/**!
ANDREAS HANDLEBARS
 @license
 handlebars v4.0.10

Copyright (C) 2011-2016 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Handlebars"] = factory();
	else
		root["Handlebars"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap ANDREAS HANDLEBARS
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _handlebarsRuntime = __webpack_require__(2);

	var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

	// Compiler imports

	var _handlebarsCompilerAst = __webpack_require__(35);

	var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

	var _handlebarsCompilerBase = __webpack_require__(36);

	var _handlebarsCompilerCompiler = __webpack_require__(41);

	var _handlebarsCompilerJavascriptCompiler = __webpack_require__(42);

	var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

	var _handlebarsCompilerVisitor = __webpack_require__(39);

	var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

	var _handlebarsNoConflict = __webpack_require__(34);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	var _create = _handlebarsRuntime2['default'].create;
	function create() {
	  var hb = _create();

	  hb.compile = function (input, options) {
	    return _handlebarsCompilerCompiler.compile(input, options, hb);
	  };
	  hb.precompile = function (input, options) {
	    return _handlebarsCompilerCompiler.precompile(input, options, hb);
	  };

	  hb.AST = _handlebarsCompilerAst2['default'];
	  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
	  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
	  hb.Parser = _handlebarsCompilerBase.parser;
	  hb.parse = _handlebarsCompilerBase.parse;

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst.Visitor = _handlebarsCompilerVisitor2['default'];

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	};

	exports.__esModule = true;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _handlebarsBase = __webpack_require__(4);

	var base = _interopRequireWildcard(_handlebarsBase);

	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)

	var _handlebarsSafeString = __webpack_require__(21);

	var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

	var _handlebarsException = __webpack_require__(6);

	var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

	var _handlebarsUtils = __webpack_require__(5);

	var Utils = _interopRequireWildcard(_handlebarsUtils);

	var _handlebarsRuntime = __webpack_require__(22);

	var runtime = _interopRequireWildcard(_handlebarsRuntime);

	var _handlebarsNoConflict = __webpack_require__(34);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base.HandlebarsEnvironment();

	  Utils.extend(hb, base);
	  hb.SafeString = _handlebarsSafeString2['default'];
	  hb.Exception = _handlebarsException2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;

	  hb.VM = runtime;
	  hb.template = function (spec) {
	    return runtime.template(spec, hb);
	  };

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};

	    if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }

	    newObj["default"] = obj;
	    return newObj;
	  }
	};

	exports.__esModule = true;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;

	var _utils = __webpack_require__(5);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _helpers = __webpack_require__(10);

	var _decorators = __webpack_require__(18);

	var _logger = __webpack_require__(20);

	var _logger2 = _interopRequireDefault(_logger);

	var VERSION = '4.0.10';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 7;

	exports.COMPILER_REVISION = COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0'
	};

	exports.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';

	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};

	  _helpers.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: _logger2['default'],
	  log: _logger2['default'].log,

	  registerHelper: function registerHelper(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple helpers');
	      }
	      _utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (_utils.toString.call(name) === objectType) {
	      _utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },

	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple decorators');
	      }
	      _utils.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  }
	};

	var log = _logger2['default'].log;

	exports.log = log;
	exports.createFrame = _utils.createFrame;
	exports.logger = _logger2['default'];

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.extend = extend;
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.createFrame = createFrame;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;
	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	var badChars = /[&<>"'`=]/g,
	    possible = /[&<>"'`=]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	exports.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};

	exports.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$defineProperty = __webpack_require__(7)['default'];

	exports.__esModule = true;

	var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      column = undefined;
	  if (loc) {
	    line = loc.start.line;
	    column = loc.start.column;

	    message += ' - ' + line + ':' + column;
	  }

	  var tmp = Error.prototype.constructor.call(this, message);

	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }

	  /* istanbul ignore else */
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }

	  try {
	    if (loc) {
	      this.lineNumber = line;

	      // Work around issue under safari where we can't directly set the column value
	      /* istanbul ignore next */
	      if (_Object$defineProperty) {
	        Object.defineProperty(this, 'column', {
	          value: column,
	          enumerable: true
	        });
	      } else {
	        this.column = column;
	      }
	    }
	  } catch (nop) {
	    /* Ignore if the browser is very particular */
	  }
	}

	Exception.prototype = new Error();

	exports['default'] = Exception;
	module.exports = exports['default'];

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(8), __esModule: true };

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(9);
	module.exports = function defineProperty(it, key, desc){
	  return $.setDesc(it, key, desc);
	};

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.registerDefaultHelpers = registerDefaultHelpers;

	var _helpersBlockHelperMissing = __webpack_require__(11);

	var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

	var _helpersEach = __webpack_require__(12);

	var _helpersEach2 = _interopRequireDefault(_helpersEach);

	var _helpersHelperMissing = __webpack_require__(13);

	var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

	var _helpersIf = __webpack_require__(14);

	var _helpersIf2 = _interopRequireDefault(_helpersIf);

	var _helpersLog = __webpack_require__(15);

	var _helpersLog2 = _interopRequireDefault(_helpersLog);

	var _helpersLookup = __webpack_require__(16);

	var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

	var _helpersWith = __webpack_require__(17);

	var _helpersWith2 = _interopRequireDefault(_helpersWith);

	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;

	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (_utils.isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }

	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }

	      return fn(context, options);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _exception2['default']('Must pass iterator to #each');
	    }

	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;

	    if (options.data && options.ids) {
	      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }

	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    if (options.data) {
	      data = _utils.createFrame(options.data);
	    }

	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;

	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }

	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }

	    if (context && typeof context === 'object') {
	      if (_utils.isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          if (i in context) {
	            execIteration(i, i, i === context.length - 1);
	          }
	        }
	      } else {
	        var priorKey = undefined;

	        for (var key in context) {
	          if (context.hasOwnProperty(key)) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey !== undefined) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          }
	        }
	        if (priorKey !== undefined) {
	          execIteration(priorKey, i - 1, true);
	        }
	      }
	    }

	    if (i === 0) {
	      ret = inverse(this);
	    }

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} construct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('if', function (conditional, options) {
	    if (_utils.isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }

	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });

	  instance.registerHelper('unless', function (conditional, options) {
	    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('log', function () /* message, options */{
	    var args = [undefined],
	        options = arguments[arguments.length - 1];
	    for (var i = 0; i < arguments.length - 1; i++) {
	      args.push(arguments[i]);
	    }

	    var level = 1;
	    if (options.hash.level != null) {
	      level = options.hash.level;
	    } else if (options.data && options.data.level != null) {
	      level = options.data.level;
	    }
	    args[0] = level;

	    instance.log.apply(instance, args);
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('lookup', function (obj, field) {
	    return obj && obj[field];
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('with', function (context, options) {
	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    var fn = options.fn;

	    if (!_utils.isEmpty(context)) {
	      var data = options.data;
	      if (options.data && options.ids) {
	        data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
	      }

	      return fn(context, {
	        data: data,
	        blockParams: _utils.blockParams([context], [data && data.contextPath])
	      });
	    } else {
	      return options.inverse(this);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.registerDefaultDecorators = registerDefaultDecorators;

	var _decoratorsInline = __webpack_require__(19);

	var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerDecorator('inline', function (fn, props, container, options) {
	    var ret = fn;
	    if (!props.partials) {
	      props.partials = {};
	      ret = function (context, options) {
	        // Create a new partials stack frame prior to exec.
	        var original = container.partials;
	        container.partials = _utils.extend({}, original, props.partials);
	        var ret = fn(context, options);
	        container.partials = original;
	        return ret;
	      };
	    }

	    props.partials[options.args[0]] = options.fn;

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var logger = {
	  methodMap: ['debug', 'info', 'warn', 'error'],
	  level: 'info',

	  // Maps a given level value to the `methodMap` indexes above.
	  lookupLevel: function lookupLevel(level) {
	    if (typeof level === 'string') {
	      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
	      if (levelMap >= 0) {
	        level = levelMap;
	      } else {
	        level = parseInt(level, 10);
	      }
	    }

	    return level;
	  },

	  // Can be overridden in the host environment
	  log: function log(level) {
	    level = logger.lookupLevel(level);

	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	      var method = logger.methodMap[level];
	      if (!console[method]) {
	        // eslint-disable-line no-console
	        method = 'log';
	      }

	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        message[_key - 1] = arguments[_key];
	      }

	      console[method].apply(console, message); // eslint-disable-line no-console
	    }
	  }
	};

	exports['default'] = logger;
	module.exports = exports['default'];

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	// Build out our basic SafeString type
	'use strict';

	exports.__esModule = true;
	function SafeString(string) {
	  this.string = string;
	}

	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};

	exports['default'] = SafeString;
	module.exports = exports['default'];

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$seal = __webpack_require__(23)['default'];

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.checkRevision = checkRevision;
	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;

	var _utils = __webpack_require__(5);

	var Utils = _interopRequireWildcard(_utils);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _base = __webpack_require__(4);

	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _base.COMPILER_REVISION;

	  if (compilerRevision !== currentRevision) {
	    if (compilerRevision < currentRevision) {
	      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	    } else {
	      // Use the embedded version info since the runtime doesn't know about this revision yet
	      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	    }
	  }
	}

	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
	  }

	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as psuedo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }

	    partial = env.VM.resolvePartial.call(this, partial, context, options);
	    var result = env.VM.invokePartial.call(this, partial, context, options);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, options);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name) {
	      if (!(name in obj)) {
	        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    merge: function merge(param, common) {
	      var obj = param || common;

	      if (param && common && param !== common) {
	        obj = Utils.extend({}, common, param);
	      }

	      return obj;
	    },
	    // An empty object to use as replacement for null-contexts
	    nullContext: _Object$seal({}),

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }

	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }
	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }
	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = container.merge(options.helpers, env.helpers);

	      if (templateSpec.usePartial) {
	        container.partials = container.merge(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = container.merge(options.decorators, env.decorators);
	      }
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var currentDepths = depths;
	    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
	      currentDepths = [context].concat(depths);
	    }

	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }

	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  // Use the current closure context to save the partial-block if this partial
	  var currentPartialBlock = options.data && options.data['partial-block'];
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }

	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    (function () {
	      options.data = _base.createFrame(options.data);
	      // Wrapper function to get access to currentPartialBlock from the closure
	      var fn = options.fn;
	      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        // Restore the partial-block from the closure for the execution of the block
	        // i.e. the part inside the block of the partial call.
	        options.data = _base.createFrame(options.data);
	        options.data['partial-block'] = currentPartialBlock;
	        return fn(context, options);
	      };
	      if (fn.partials) {
	        options.partials = Utils.extend({}, options.partials, fn.partials);
	      }
	    })();
	  }

	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }

	  if (partial === undefined) {
	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils.extend(prog, props);
	  }
	  return prog;
	}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(24), __esModule: true };

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(25);
	module.exports = __webpack_require__(30).Object.seal;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(26);

	__webpack_require__(27)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(it) : it;
	  };
	});

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(28)
	  , core    = __webpack_require__(30)
	  , fails   = __webpack_require__(33);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(29)
	  , core      = __webpack_require__(30)
	  , ctx       = __webpack_require__(31)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$export.F = 1;  // forced
	$export.G = 2;  // global
	$export.S = 4;  // static
	$export.P = 8;  // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	module.exports = $export;

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	var core = module.exports = {version: '1.2.6'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(32);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';

	exports.__esModule = true;

	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof global !== 'undefined' ? global : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	    return Handlebars;
	  };
	};

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var AST = {
	  // Public API used to evaluate derived attributes regarding AST nodes
	  helpers: {
	    // a mustache is definitely a helper if:
	    // * it is an eligible helper, and
	    // * it has at least one parameter or hash segment
	    helperExpression: function helperExpression(node) {
	      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
	    },

	    scopedId: function scopedId(path) {
	      return (/^\.|this\b/.test(path.original)
	      );
	    },

	    // an ID is simple if it only has one part, and that part is not
	    // `..` or `this`.
	    simpleId: function simpleId(path) {
	      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
	    }
	  }
	};

	// Must be exported as an object rather than the root of the module as the jison lexer
	// must modify the object to operate properly.
	exports['default'] = AST;
	module.exports = exports['default'];

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	exports.__esModule = true;
	exports.parse = parse;

	var _parser = __webpack_require__(37);

	var _parser2 = _interopRequireDefault(_parser);

	var _whitespaceControl = __webpack_require__(38);

	var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

	var _helpers = __webpack_require__(40);

	var Helpers = _interopRequireWildcard(_helpers);

	var _utils = __webpack_require__(5);

	exports.parser = _parser2['default'];

	var yy = {};
	_utils.extend(yy, Helpers);

	function parse(input, options) {
	  // Just return if an already-compiled AST was passed in.
	  if (input.type === 'Program') {
	    return input;
	  }

	  _parser2['default'].yy = yy;

	  // Altering the shared object here, but this is ok as parser is a sync operation
	  yy.locInfo = function (locInfo) {
	    return new yy.SourceLocation(options && options.srcName, locInfo);
	  };

	  var strip = new _whitespaceControl2['default'](options);
	  return strip.accept(_parser2['default'].parse(input));
	}

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	// File ignored in coverage tests via setting in .istanbul.yml
	/* Jison generated parser */
	"use strict";

	exports.__esModule = true;
	var handlebars = (function () {
	    var parser = { trace: function trace() {},
	        yy: {},
	        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
	        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
	        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
	        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
	        /**/) {

	            var $0 = $$.length - 1;
	            switch (yystate) {
	                case 1:
	                    return $$[$0 - 1];
	                    break;
	                case 2:
	                    this.$ = yy.prepareProgram($$[$0]);
	                    break;
	                case 3:
	                    this.$ = $$[$0];
	                    break;
	                case 4:
	                    this.$ = $$[$0];
	                    break;
	                case 5:
	                    this.$ = $$[$0];
	                    break;
	                case 6:
	                    this.$ = $$[$0];
	                    break;
	                case 7:
	                    this.$ = $$[$0];
	                    break;
	                case 8:
	                    this.$ = $$[$0];
	                    break;
	                case 9:
	                    this.$ = {
	                        type: 'CommentStatement',
	                        value: yy.stripComment($$[$0]),
	                        strip: yy.stripFlags($$[$0], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 10:
	                    this.$ = {
	                        type: 'ContentStatement',
	                        original: $$[$0],
	                        value: $$[$0],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 11:
	                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 12:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
	                    break;
	                case 13:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
	                    break;
	                case 14:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
	                    break;
	                case 15:
	                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 16:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 17:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 18:
	                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
	                    break;
	                case 19:
	                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
	                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
	                    program.chained = true;

	                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

	                    break;
	                case 20:
	                    this.$ = $$[$0];
	                    break;
	                case 21:
	                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
	                    break;
	                case 22:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 23:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 24:
	                    this.$ = {
	                        type: 'PartialStatement',
	                        name: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        indent: '',
	                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 25:
	                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 26:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
	                    break;
	                case 27:
	                    this.$ = $$[$0];
	                    break;
	                case 28:
	                    this.$ = $$[$0];
	                    break;
	                case 29:
	                    this.$ = {
	                        type: 'SubExpression',
	                        path: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 30:
	                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 31:
	                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 32:
	                    this.$ = yy.id($$[$0 - 1]);
	                    break;
	                case 33:
	                    this.$ = $$[$0];
	                    break;
	                case 34:
	                    this.$ = $$[$0];
	                    break;
	                case 35:
	                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 36:
	                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
	                    break;
	                case 37:
	                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
	                    break;
	                case 38:
	                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
	                    break;
	                case 39:
	                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
	                    break;
	                case 40:
	                    this.$ = $$[$0];
	                    break;
	                case 41:
	                    this.$ = $$[$0];
	                    break;
	                case 42:
	                    this.$ = yy.preparePath(true, $$[$0], this._$);
	                    break;
	                case 43:
	                    this.$ = yy.preparePath(false, $$[$0], this._$);
	                    break;
	                case 44:
	                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
	                    break;
	                case 45:
	                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
	                    break;
	                case 46:
	                    this.$ = [];
	                    break;
	                case 47:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 48:
	                    this.$ = [$$[$0]];
	                    break;
	                case 49:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 50:
	                    this.$ = [];
	                    break;
	                case 51:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 58:
	                    this.$ = [];
	                    break;
	                case 59:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 64:
	                    this.$ = [];
	                    break;
	                case 65:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 70:
	                    this.$ = [];
	                    break;
	                case 71:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 78:
	                    this.$ = [];
	                    break;
	                case 79:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 82:
	                    this.$ = [];
	                    break;
	                case 83:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 86:
	                    this.$ = [];
	                    break;
	                case 87:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 90:
	                    this.$ = [];
	                    break;
	                case 91:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 94:
	                    this.$ = [];
	                    break;
	                case 95:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 98:
	                    this.$ = [$$[$0]];
	                    break;
	                case 99:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 100:
	                    this.$ = [$$[$0]];
	                    break;
	                case 101:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	            }
	        },
	        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
	        defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
	        parseError: function parseError(str, hash) {
	            throw new Error(str);
	        },
	        parse: function parse(input) {
	            var self = this,
	                stack = [0],
	                vstack = [null],
	                lstack = [],
	                table = this.table,
	                yytext = "",
	                yylineno = 0,
	                yyleng = 0,
	                recovering = 0,
	                TERROR = 2,
	                EOF = 1;
	            this.lexer.setInput(input);
	            this.lexer.yy = this.yy;
	            this.yy.lexer = this.lexer;
	            this.yy.parser = this;
	            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
	            var yyloc = this.lexer.yylloc;
	            lstack.push(yyloc);
	            var ranges = this.lexer.options && this.lexer.options.ranges;
	            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
	            function popStack(n) {
	                stack.length = stack.length - 2 * n;
	                vstack.length = vstack.length - n;
	                lstack.length = lstack.length - n;
	            }
	            function lex() {
	                var token;
	                token = self.lexer.lex() || 1;
	                if (typeof token !== "number") {
	                    token = self.symbols_[token] || token;
	                }
	                return token;
	            }
	            var symbol,
	                preErrorSymbol,
	                state,
	                action,
	                a,
	                r,
	                yyval = {},
	                p,
	                len,
	                newState,
	                expected;
	            while (true) {
	                state = stack[stack.length - 1];
	                if (this.defaultActions[state]) {
	                    action = this.defaultActions[state];
	                } else {
	                    if (symbol === null || typeof symbol == "undefined") {
	                        symbol = lex();
	                    }
	                    action = table[state] && table[state][symbol];
	                }
	                if (typeof action === "undefined" || !action.length || !action[0]) {
	                    var errStr = "";
	                    if (!recovering) {
	                        expected = [];
	                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
	                            expected.push("'" + this.terminals_[p] + "'");
	                        }
	                        if (this.lexer.showPosition) {
	                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
	                        } else {
	                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
	                        }
	                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
	                    }
	                }
	                if (action[0] instanceof Array && action.length > 1) {
	                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
	                }
	                switch (action[0]) {
	                    case 1:
	                        stack.push(symbol);
	                        vstack.push(this.lexer.yytext);
	                        lstack.push(this.lexer.yylloc);
	                        stack.push(action[1]);
	                        symbol = null;
	                        if (!preErrorSymbol) {
	                            yyleng = this.lexer.yyleng;
	                            yytext = this.lexer.yytext;
	                            yylineno = this.lexer.yylineno;
	                            yyloc = this.lexer.yylloc;
	                            if (recovering > 0) recovering--;
	                        } else {
	                            symbol = preErrorSymbol;
	                            preErrorSymbol = null;
	                        }
	                        break;
	                    case 2:
	                        len = this.productions_[action[1]][1];
	                        yyval.$ = vstack[vstack.length - len];
	                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
	                        if (ranges) {
	                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
	                        }
	                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
	                        if (typeof r !== "undefined") {
	                            return r;
	                        }
	                        if (len) {
	                            stack = stack.slice(0, -1 * len * 2);
	                            vstack = vstack.slice(0, -1 * len);
	                            lstack = lstack.slice(0, -1 * len);
	                        }
	                        stack.push(this.productions_[action[1]][0]);
	                        vstack.push(yyval.$);
	                        lstack.push(yyval._$);
	                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	                        stack.push(newState);
	                        break;
	                    case 3:
	                        return true;
	                }
	            }
	            return true;
	        }
	    };
	    /* Jison generated lexer */
	    var lexer = (function () {
	        var lexer = { EOF: 1,
	            parseError: function parseError(str, hash) {
	                if (this.yy.parser) {
	                    this.yy.parser.parseError(str, hash);
	                } else {
	                    throw new Error(str);
	                }
	            },
	            setInput: function setInput(input) {
	                this._input = input;
	                this._more = this._less = this.done = false;
	                this.yylineno = this.yyleng = 0;
	                this.yytext = this.matched = this.match = '';
	                this.conditionStack = ['INITIAL'];
	                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
	                if (this.options.ranges) this.yylloc.range = [0, 0];
	                this.offset = 0;
	                return this;
	            },
	            input: function input() {
	                var ch = this._input[0];
	                this.yytext += ch;
	                this.yyleng++;
	                this.offset++;
	                this.match += ch;
	                this.matched += ch;
	                var lines = ch.match(/(?:\r\n?|\n).*/g);
	                if (lines) {
	                    this.yylineno++;
	                    this.yylloc.last_line++;
	                } else {
	                    this.yylloc.last_column++;
	                }
	                if (this.options.ranges) this.yylloc.range[1]++;

	                this._input = this._input.slice(1);
	                return ch;
	            },
	            unput: function unput(ch) {
	                var len = ch.length;
	                var lines = ch.split(/(?:\r\n?|\n)/g);

	                this._input = ch + this._input;
	                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
	                //this.yyleng -= len;
	                this.offset -= len;
	                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	                this.match = this.match.substr(0, this.match.length - 1);
	                this.matched = this.matched.substr(0, this.matched.length - 1);

	                if (lines.length - 1) this.yylineno -= lines.length - 1;
	                var r = this.yylloc.range;

	                this.yylloc = { first_line: this.yylloc.first_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.first_column,
	                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
	                };

	                if (this.options.ranges) {
	                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	                }
	                return this;
	            },
	            more: function more() {
	                this._more = true;
	                return this;
	            },
	            less: function less(n) {
	                this.unput(this.match.slice(n));
	            },
	            pastInput: function pastInput() {
	                var past = this.matched.substr(0, this.matched.length - this.match.length);
	                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
	            },
	            upcomingInput: function upcomingInput() {
	                var next = this.match;
	                if (next.length < 20) {
	                    next += this._input.substr(0, 20 - next.length);
	                }
	                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	            },
	            showPosition: function showPosition() {
	                var pre = this.pastInput();
	                var c = new Array(pre.length + 1).join("-");
	                return pre + this.upcomingInput() + "\n" + c + "^";
	            },
	            next: function next() {
	                if (this.done) {
	                    return this.EOF;
	                }
	                if (!this._input) this.done = true;

	                var token, match, tempMatch, index, col, lines;
	                if (!this._more) {
	                    this.yytext = '';
	                    this.match = '';
	                }
	                var rules = this._currentRules();
	                for (var i = 0; i < rules.length; i++) {
	                    tempMatch = this._input.match(this.rules[rules[i]]);
	                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                        match = tempMatch;
	                        index = i;
	                        if (!this.options.flex) break;
	                    }
	                }
	                if (match) {
	                    lines = match[0].match(/(?:\r\n?|\n).*/g);
	                    if (lines) this.yylineno += lines.length;
	                    this.yylloc = { first_line: this.yylloc.last_line,
	                        last_line: this.yylineno + 1,
	                        first_column: this.yylloc.last_column,
	                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
	                    this.yytext += match[0];
	                    this.match += match[0];
	                    this.matches = match;
	                    this.yyleng = this.yytext.length;
	                    if (this.options.ranges) {
	                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
	                    }
	                    this._more = false;
	                    this._input = this._input.slice(match[0].length);
	                    this.matched += match[0];
	                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
	                    if (this.done && this._input) this.done = false;
	                    if (token) return token;else return;
	                }
	                if (this._input === "") {
	                    return this.EOF;
	                } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
	                }
	            },
	            lex: function lex() {
	                var r = this.next();
	                if (typeof r !== 'undefined') {
	                    return r;
	                } else {
	                    return this.lex();
	                }
	            },
	            begin: function begin(condition) {
	                this.conditionStack.push(condition);
	            },
	            popState: function popState() {
	                return this.conditionStack.pop();
	            },
	            _currentRules: function _currentRules() {
	                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	            },
	            topState: function topState() {
	                return this.conditionStack[this.conditionStack.length - 2];
	            },
	            pushState: function begin(condition) {
	                this.begin(condition);
	            } };
	        lexer.options = {};
	        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
	        /**/) {

	            function strip(start, end) {
	                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
	            }

	            var YYSTATE = YY_START;
	            switch ($avoiding_name_collisions) {
	                case 0:
	                    if (yy_.yytext.slice(-2) === "\\\\") {
	                        strip(0, 1);
	                        this.begin("mu");
	                    } else if (yy_.yytext.slice(-1) === "\\") {
	                        strip(0, 1);
	                        this.begin("emu");
	                    } else {
	                        this.begin("mu");
	                    }
	                    if (yy_.yytext) return 15;

	                    break;
	                case 1:
	                    return 15;
	                    break;
	                case 2:
	                    this.popState();
	                    return 15;

	                    break;
	                case 3:
	                    this.begin('raw');return 15;
	                    break;
	                case 4:
	                    this.popState();
	                    // Should be using `this.topState()` below, but it currently
	                    // returns the second top instead of the first top. Opened an
	                    // issue about it at https://github.com/zaach/jison/issues/291
	                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
	                        return 15;
	                    } else {
	                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
	                        return 'END_RAW_BLOCK';
	                    }

	                    break;
	                case 5:
	                    return 15;
	                    break;
	                case 6:
	                    this.popState();
	                    return 14;

	                    break;
	                case 7:
	                    return 65;
	                    break;
	                case 8:
	                    return 68;
	                    break;
	                case 9:
	                    return 19;
	                    break;
	                case 10:
	                    this.popState();
	                    this.begin('raw');
	                    return 23;

	                    break;
	                case 11:
	                    return 55;
	                    break;
	                case 12:
	                    return 60;
	                    break;
	                case 13:
	                    return 29;
	                    break;
	                case 14:
	                    return 47;
	                    break;
	                case 15:
	                    this.popState();return 44;
	                    break;
	                case 16:
	                    this.popState();return 44;
	                    break;
	                case 17:
	                    return 34;
	                    break;
	                case 18:
	                    return 39;
	                    break;
	                case 19:
	                    return 51;
	                    break;
	                case 20:
	                    return 48;
	                    break;
	                case 21:
	                    this.unput(yy_.yytext);
	                    this.popState();
	                    this.begin('com');

	                    break;
	                case 22:
	                    this.popState();
	                    return 14;

	                    break;
	                case 23:
	                    return 48;
	                    break;
	                case 24:
	                    return 73;
	                    break;
	                case 25:
	                    return 72;
	                    break;
	                case 26:
	                    return 72;
	                    break;
	                case 27:
	                    return 87;
	                    break;
	                case 28:
	                    // ignore whitespace
	                    break;
	                case 29:
	                    this.popState();return 54;
	                    break;
	                case 30:
	                    this.popState();return 33;
	                    break;
	                case 31:
	                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
	                    break;
	                case 32:
	                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
	                    break;
	                case 33:
	                    return 85;
	                    break;
	                case 34:
	                    return 82;
	                    break;
	                case 35:
	                    return 82;
	                    break;
	                case 36:
	                    return 83;
	                    break;
	                case 37:
	                    return 84;
	                    break;
	                case 38:
	                    return 81;
	                    break;
	                case 39:
	                    return 75;
	                    break;
	                case 40:
	                    return 77;
	                    break;
	                case 41:
	                    return 72;
	                    break;
	                case 42:
	                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
	                    break;
	                case 43:
	                    return 'INVALID';
	                    break;
	                case 44:
	                    return 5;
	                    break;
	            }
	        };
	        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
	        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
	        return lexer;
	    })();
	    parser.lexer = lexer;
	    function Parser() {
	        this.yy = {};
	    }Parser.prototype = parser;parser.Parser = Parser;
	    return new Parser();
	})();exports["default"] = handlebars;
	module.exports = exports["default"];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _visitor = __webpack_require__(39);

	var _visitor2 = _interopRequireDefault(_visitor);

	function WhitespaceControl() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  this.options = options;
	}
	WhitespaceControl.prototype = new _visitor2['default']();

	WhitespaceControl.prototype.Program = function (program) {
	  var doStandalone = !this.options.ignoreStandalone;

	  var isRoot = !this.isRootSeen;
	  this.isRootSeen = true;

	  var body = program.body;
	  for (var i = 0, l = body.length; i < l; i++) {
	    var current = body[i],
	        strip = this.accept(current);

	    if (!strip) {
	      continue;
	    }

	    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
	        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
	        openStandalone = strip.openStandalone && _isPrevWhitespace,
	        closeStandalone = strip.closeStandalone && _isNextWhitespace,
	        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

	    if (strip.close) {
	      omitRight(body, i, true);
	    }
	    if (strip.open) {
	      omitLeft(body, i, true);
	    }

	    if (doStandalone && inlineStandalone) {
	      omitRight(body, i);

	      if (omitLeft(body, i)) {
	        // If we are on a standalone node, save the indent info for partials
	        if (current.type === 'PartialStatement') {
	          // Pull out the whitespace from the final line
	          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
	        }
	      }
	    }
	    if (doStandalone && openStandalone) {
	      omitRight((current.program || current.inverse).body);

	      // Strip out the previous content node if it's whitespace only
	      omitLeft(body, i);
	    }
	    if (doStandalone && closeStandalone) {
	      // Always strip the next node
	      omitRight(body, i);

	      omitLeft((current.inverse || current.program).body);
	    }
	  }

	  return program;
	};

	WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
	  this.accept(block.program);
	  this.accept(block.inverse);

	  // Find the inverse program that is involed with whitespace stripping.
	  var program = block.program || block.inverse,
	      inverse = block.program && block.inverse,
	      firstInverse = inverse,
	      lastInverse = inverse;

	  if (inverse && inverse.chained) {
	    firstInverse = inverse.body[0].program;

	    // Walk the inverse chain to find the last inverse that is actually in the chain.
	    while (lastInverse.chained) {
	      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
	    }
	  }

	  var strip = {
	    open: block.openStrip.open,
	    close: block.closeStrip.close,

	    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
	    // so our parent can determine if we actually are standalone
	    openStandalone: isNextWhitespace(program.body),
	    closeStandalone: isPrevWhitespace((firstInverse || program).body)
	  };

	  if (block.openStrip.close) {
	    omitRight(program.body, null, true);
	  }

	  if (inverse) {
	    var inverseStrip = block.inverseStrip;

	    if (inverseStrip.open) {
	      omitLeft(program.body, null, true);
	    }

	    if (inverseStrip.close) {
	      omitRight(firstInverse.body, null, true);
	    }
	    if (block.closeStrip.open) {
	      omitLeft(lastInverse.body, null, true);
	    }

	    // Find standalone else statments
	    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
	      omitLeft(program.body);
	      omitRight(firstInverse.body);
	    }
	  } else if (block.closeStrip.open) {
	    omitLeft(program.body, null, true);
	  }

	  return strip;
	};

	WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
	  return mustache.strip;
	};

	WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
	  /* istanbul ignore next */
	  var strip = node.strip || {};
	  return {
	    inlineStandalone: true,
	    open: strip.open,
	    close: strip.close
	  };
	};

	function isPrevWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = body.length;
	  }

	  // Nodes that end with newlines are considered whitespace (but are special
	  // cased for strip operations)
	  var prev = body[i - 1],
	      sibling = body[i - 2];
	  if (!prev) {
	    return isRoot;
	  }

	  if (prev.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
	  }
	}
	function isNextWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = -1;
	  }

	  var next = body[i + 1],
	      sibling = body[i + 2];
	  if (!next) {
	    return isRoot;
	  }

	  if (next.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
	  }
	}

	// Marks the node to the right of the position as omitted.
	// I.e. {{foo}}' ' will mark the ' ' node as omitted.
	//
	// If i is undefined, then the first child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitRight(body, i, multiple) {
	  var current = body[i == null ? 0 : i + 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
	    return;
	  }

	  var original = current.value;
	  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
	  current.rightStripped = current.value !== original;
	}

	// Marks the node to the left of the position as omitted.
	// I.e. ' '{{foo}} will mark the ' ' node as omitted.
	//
	// If i is undefined then the last child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitLeft(body, i, multiple) {
	  var current = body[i == null ? body.length - 1 : i - 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
	    return;
	  }

	  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
	  var original = current.value;
	  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
	  current.leftStripped = current.value !== original;
	  return current.leftStripped;
	}

	exports['default'] = WhitespaceControl;
	module.exports = exports['default'];

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	function Visitor() {
	  this.parents = [];
	}

	Visitor.prototype = {
	  constructor: Visitor,
	  mutating: false,

	  // Visits a given value. If mutating, will replace the value if necessary.
	  acceptKey: function acceptKey(node, name) {
	    var value = this.accept(node[name]);
	    if (this.mutating) {
	      // Hacky sanity check: This may have a few false positives for type for the helper
	      // methods but will generally do the right thing without a lot of overhead.
	      if (value && !Visitor.prototype[value.type]) {
	        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
	      }
	      node[name] = value;
	    }
	  },

	  // Performs an accept operation with added sanity check to ensure
	  // required keys are not removed.
	  acceptRequired: function acceptRequired(node, name) {
	    this.acceptKey(node, name);

	    if (!node[name]) {
	      throw new _exception2['default'](node.type + ' requires ' + name);
	    }
	  },

	  // Traverses a given array. If mutating, empty respnses will be removed
	  // for child elements.
	  acceptArray: function acceptArray(array) {
	    for (var i = 0, l = array.length; i < l; i++) {
	      this.acceptKey(array, i);

	      if (!array[i]) {
	        array.splice(i, 1);
	        i--;
	        l--;
	      }
	    }
	  },

	  accept: function accept(object) {
	    if (!object) {
	      return;
	    }

	    /* istanbul ignore next: Sanity code */
	    if (!this[object.type]) {
	      throw new _exception2['default']('Unknown type: ' + object.type, object);
	    }

	    if (this.current) {
	      this.parents.unshift(this.current);
	    }
	    this.current = object;

	    var ret = this[object.type](object);

	    this.current = this.parents.shift();

	    if (!this.mutating || ret) {
	      return ret;
	    } else if (ret !== false) {
	      return object;
	    }
	  },

	  Program: function Program(program) {
	    this.acceptArray(program.body);
	  },

	  MustacheStatement: visitSubExpression,
	  Decorator: visitSubExpression,

	  BlockStatement: visitBlock,
	  DecoratorBlock: visitBlock,

	  PartialStatement: visitPartial,
	  PartialBlockStatement: function PartialBlockStatement(partial) {
	    visitPartial.call(this, partial);

	    this.acceptKey(partial, 'program');
	  },

	  ContentStatement: function ContentStatement() /* content */{},
	  CommentStatement: function CommentStatement() /* comment */{},

	  SubExpression: visitSubExpression,

	  PathExpression: function PathExpression() /* path */{},

	  StringLiteral: function StringLiteral() /* string */{},
	  NumberLiteral: function NumberLiteral() /* number */{},
	  BooleanLiteral: function BooleanLiteral() /* bool */{},
	  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
	  NullLiteral: function NullLiteral() /* literal */{},

	  Hash: function Hash(hash) {
	    this.acceptArray(hash.pairs);
	  },
	  HashPair: function HashPair(pair) {
	    this.acceptRequired(pair, 'value');
	  }
	};

	function visitSubExpression(mustache) {
	  this.acceptRequired(mustache, 'path');
	  this.acceptArray(mustache.params);
	  this.acceptKey(mustache, 'hash');
	}
	function visitBlock(block) {
	  visitSubExpression.call(this, block);

	  this.acceptKey(block, 'program');
	  this.acceptKey(block, 'inverse');
	}
	function visitPartial(partial) {
	  this.acceptRequired(partial, 'name');
	  this.acceptArray(partial.params);
	  this.acceptKey(partial, 'hash');
	}

	exports['default'] = Visitor;
	module.exports = exports['default'];

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.SourceLocation = SourceLocation;
	exports.id = id;
	exports.stripFlags = stripFlags;
	exports.stripComment = stripComment;
	exports.preparePath = preparePath;
	exports.prepareMustache = prepareMustache;
	exports.prepareRawBlock = prepareRawBlock;
	exports.prepareBlock = prepareBlock;
	exports.prepareProgram = prepareProgram;
	exports.preparePartialBlock = preparePartialBlock;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	function validateClose(open, close) {
	  close = close.path ? close.path.original : close;

	  if (open.path.original !== close) {
	    var errorNode = { loc: open.path.loc };

	    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
	  }
	}

	function SourceLocation(source, locInfo) {
	  this.source = source;
	  this.start = {
	    line: locInfo.first_line,
	    column: locInfo.first_column
	  };
	  this.end = {
	    line: locInfo.last_line,
	    column: locInfo.last_column
	  };
	}

	function id(token) {
	  if (/^\[.*\]$/.test(token)) {
	    return token.substr(1, token.length - 2);
	  } else {
	    return token;
	  }
	}

	function stripFlags(open, close) {
	  return {
	    open: open.charAt(2) === '~',
	    close: close.charAt(close.length - 3) === '~'
	  };
	}

	function stripComment(comment) {
	  return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
	}

	function preparePath(data, parts, loc) {
	  loc = this.locInfo(loc);

	  var original = data ? '@' : '',
	      dig = [],
	      depth = 0,
	      depthString = '';

	  for (var i = 0, l = parts.length; i < l; i++) {
	    var part = parts[i].part,

	    // If we have [] syntax then we do not treat path references as operators,
	    // i.e. foo.[this] resolves to approximately context.foo['this']
	    isLiteral = parts[i].original !== part;
	    original += (parts[i].separator || '') + part;

	    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
	      if (dig.length > 0) {
	        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
	      } else if (part === '..') {
	        depth++;
	        depthString += '../';
	      }
	    } else {
	      dig.push(part);
	    }
	  }

	  return {
	    type: 'PathExpression',
	    data: data,
	    depth: depth,
	    parts: dig,
	    original: original,
	    loc: loc
	  };
	}

	function prepareMustache(path, params, hash, open, strip, locInfo) {
	  // Must use charAt to support IE pre-10
	  var escapeFlag = open.charAt(3) || open.charAt(2),
	      escaped = escapeFlag !== '{' && escapeFlag !== '&';

	  var decorator = /\*/.test(open);
	  return {
	    type: decorator ? 'Decorator' : 'MustacheStatement',
	    path: path,
	    params: params,
	    hash: hash,
	    escaped: escaped,
	    strip: strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareRawBlock(openRawBlock, contents, close, locInfo) {
	  validateClose(openRawBlock, close);

	  locInfo = this.locInfo(locInfo);
	  var program = {
	    type: 'Program',
	    body: contents,
	    strip: {},
	    loc: locInfo
	  };

	  return {
	    type: 'BlockStatement',
	    path: openRawBlock.path,
	    params: openRawBlock.params,
	    hash: openRawBlock.hash,
	    program: program,
	    openStrip: {},
	    inverseStrip: {},
	    closeStrip: {},
	    loc: locInfo
	  };
	}

	function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
	  if (close && close.path) {
	    validateClose(openBlock, close);
	  }

	  var decorator = /\*/.test(openBlock.open);

	  program.blockParams = openBlock.blockParams;

	  var inverse = undefined,
	      inverseStrip = undefined;

	  if (inverseAndProgram) {
	    if (decorator) {
	      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
	    }

	    if (inverseAndProgram.chain) {
	      inverseAndProgram.program.body[0].closeStrip = close.strip;
	    }

	    inverseStrip = inverseAndProgram.strip;
	    inverse = inverseAndProgram.program;
	  }

	  if (inverted) {
	    inverted = inverse;
	    inverse = program;
	    program = inverted;
	  }

	  return {
	    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
	    path: openBlock.path,
	    params: openBlock.params,
	    hash: openBlock.hash,
	    program: program,
	    inverse: inverse,
	    openStrip: openBlock.strip,
	    inverseStrip: inverseStrip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareProgram(statements, loc) {
	  if (!loc && statements.length) {
	    var firstLoc = statements[0].loc,
	        lastLoc = statements[statements.length - 1].loc;

	    /* istanbul ignore else */
	    if (firstLoc && lastLoc) {
	      loc = {
	        source: firstLoc.source,
	        start: {
	          line: firstLoc.start.line,
	          column: firstLoc.start.column
	        },
	        end: {
	          line: lastLoc.end.line,
	          column: lastLoc.end.column
	        }
	      };
	    }
	  }

	  return {
	    type: 'Program',
	    body: statements,
	    strip: {},
	    loc: loc
	  };
	}

	function preparePartialBlock(open, program, close, locInfo) {
	  validateClose(open, close);

	  return {
	    type: 'PartialBlockStatement',
	    name: open.path,
	    params: open.params,
	    hash: open.hash,
	    program: program,
	    openStrip: open.strip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint-disable new-cap */

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.Compiler = Compiler;
	exports.precompile = precompile;
	exports.compile = compile;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = __webpack_require__(5);

	var _ast = __webpack_require__(35);

	var _ast2 = _interopRequireDefault(_ast);

	var slice = [].slice;

	function Compiler() {}

	// the foundHelper register will disambiguate helper lookup from finding a
	// function in a context. This is necessary for mustache compatibility, which
	// requires that context functions in blocks are evaluated by blockHelperMissing,
	// and then proceed as if the resulting value was provided to blockHelperMissing.

	Compiler.prototype = {
	  compiler: Compiler,

	  equals: function equals(other) {
	    var len = this.opcodes.length;
	    if (other.opcodes.length !== len) {
	      return false;
	    }

	    for (var i = 0; i < len; i++) {
	      var opcode = this.opcodes[i],
	          otherOpcode = other.opcodes[i];
	      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
	        return false;
	      }
	    }

	    // We know that length is the same between the two arrays because they are directly tied
	    // to the opcode behavior above.
	    len = this.children.length;
	    for (var i = 0; i < len; i++) {
	      if (!this.children[i].equals(other.children[i])) {
	        return false;
	      }
	    }

	    return true;
	  },

	  guid: 0,

	  compile: function compile(program, options) {
	    this.sourceNode = [];
	    this.opcodes = [];
	    this.children = [];
	    this.options = options;
	    this.stringParams = options.stringParams;
	    this.trackIds = options.trackIds;

	    options.blockParams = options.blockParams || [];

	    // These changes will propagate to the other compiler components
	    var knownHelpers = options.knownHelpers;
	    options.knownHelpers = {
	      'helperMissing': true,
	      'blockHelperMissing': true,
	      'each': true,
	      'if': true,
	      'unless': true,
	      'with': true,
	      'log': true,
	      'lookup': true
	    };
	    if (knownHelpers) {
	      for (var _name in knownHelpers) {
	        /* istanbul ignore else */
	        if (_name in knownHelpers) {
	          this.options.knownHelpers[_name] = knownHelpers[_name];
	        }
	      }
	    }

	    return this.accept(program);
	  },

	  compileProgram: function compileProgram(program) {
	    var childCompiler = new this.compiler(),
	        // eslint-disable-line new-cap
	    result = childCompiler.compile(program, this.options),
	        guid = this.guid++;

	    this.usePartial = this.usePartial || result.usePartial;

	    this.children[guid] = result;
	    this.useDepths = this.useDepths || result.useDepths;

	    return guid;
	  },

	  accept: function accept(node) {
	    /* istanbul ignore next: Sanity code */
	    if (!this[node.type]) {
	      throw new _exception2['default']('Unknown type: ' + node.type, node);
	    }

	    this.sourceNode.unshift(node);
	    var ret = this[node.type](node);
	    this.sourceNode.shift();
	    return ret;
	  },

	  Program: function Program(program) {
	    this.options.blockParams.unshift(program.blockParams);

	    var body = program.body,
	        bodyLength = body.length;
	    for (var i = 0; i < bodyLength; i++) {
	      this.accept(body[i]);
	    }

	    this.options.blockParams.shift();

	    this.isSimple = bodyLength === 1;
	    this.blockParams = program.blockParams ? program.blockParams.length : 0;

	    return this;
	  },

	  BlockStatement: function BlockStatement(block) {
	    transformLiteralToPath(block);

	    var program = block.program,
	        inverse = block.inverse;

	    program = program && this.compileProgram(program);
	    inverse = inverse && this.compileProgram(inverse);

	    var type = this.classifySexpr(block);

	    if (type === 'helper') {
	      this.helperSexpr(block, program, inverse);
	    } else if (type === 'simple') {
	      this.simpleSexpr(block);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('blockValue', block.path.original);
	    } else {
	      this.ambiguousSexpr(block, program, inverse);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('ambiguousBlockValue');
	    }

	    this.opcode('append');
	  },

	  DecoratorBlock: function DecoratorBlock(decorator) {
	    var program = decorator.program && this.compileProgram(decorator.program);
	    var params = this.setupFullMustacheParams(decorator, program, undefined),
	        path = decorator.path;

	    this.useDecorators = true;
	    this.opcode('registerDecorator', params.length, path.original);
	  },

	  PartialStatement: function PartialStatement(partial) {
	    this.usePartial = true;

	    var program = partial.program;
	    if (program) {
	      program = this.compileProgram(partial.program);
	    }

	    var params = partial.params;
	    if (params.length > 1) {
	      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
	    } else if (!params.length) {
	      if (this.options.explicitPartialContext) {
	        this.opcode('pushLiteral', 'undefined');
	      } else {
	        params.push({ type: 'PathExpression', parts: [], depth: 0 });
	      }
	    }

	    var partialName = partial.name.original,
	        isDynamic = partial.name.type === 'SubExpression';
	    if (isDynamic) {
	      this.accept(partial.name);
	    }

	    this.setupFullMustacheParams(partial, program, undefined, true);

	    var indent = partial.indent || '';
	    if (this.options.preventIndent && indent) {
	      this.opcode('appendContent', indent);
	      indent = '';
	    }

	    this.opcode('invokePartial', isDynamic, partialName, indent);
	    this.opcode('append');
	  },
	  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
	    this.PartialStatement(partialBlock);
	  },

	  MustacheStatement: function MustacheStatement(mustache) {
	    this.SubExpression(mustache);

	    if (mustache.escaped && !this.options.noEscape) {
	      this.opcode('appendEscaped');
	    } else {
	      this.opcode('append');
	    }
	  },
	  Decorator: function Decorator(decorator) {
	    this.DecoratorBlock(decorator);
	  },

	  ContentStatement: function ContentStatement(content) {
	    if (content.value) {
	      this.opcode('appendContent', content.value);
	    }
	  },

	  CommentStatement: function CommentStatement() {},

	  SubExpression: function SubExpression(sexpr) {
	    transformLiteralToPath(sexpr);
	    var type = this.classifySexpr(sexpr);

	    if (type === 'simple') {
	      this.simpleSexpr(sexpr);
	    } else if (type === 'helper') {
	      this.helperSexpr(sexpr);
	    } else {
	      this.ambiguousSexpr(sexpr);
	    }
	  },
	  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
	    var path = sexpr.path,
	        name = path.parts[0],
	        isBlock = program != null || inverse != null;

	    this.opcode('getContext', path.depth);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    path.strict = true;
	    this.accept(path);

	    this.opcode('invokeAmbiguous', name, isBlock);
	  },

	  simpleSexpr: function simpleSexpr(sexpr) {
	    var path = sexpr.path;
	    path.strict = true;
	    this.accept(path);
	    this.opcode('resolvePossibleLambda');
	  },

	  helperSexpr: function helperSexpr(sexpr, program, inverse) {
	    var params = this.setupFullMustacheParams(sexpr, program, inverse),
	        path = sexpr.path,
	        name = path.parts[0];

	    if (this.options.knownHelpers[name]) {
	      this.opcode('invokeKnownHelper', params.length, name);
	    } else if (this.options.knownHelpersOnly) {
	      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
	    } else {
	      path.strict = true;
	      path.falsy = true;

	      this.accept(path);
	      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
	    }
	  },

	  PathExpression: function PathExpression(path) {
	    this.addDepth(path.depth);
	    this.opcode('getContext', path.depth);

	    var name = path.parts[0],
	        scoped = _ast2['default'].helpers.scopedId(path),
	        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

	    if (blockParamId) {
	      this.opcode('lookupBlockParam', blockParamId, path.parts);
	    } else if (!name) {
	      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
	      this.opcode('pushContext');
	    } else if (path.data) {
	      this.options.data = true;
	      this.opcode('lookupData', path.depth, path.parts, path.strict);
	    } else {
	      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
	    }
	  },

	  StringLiteral: function StringLiteral(string) {
	    this.opcode('pushString', string.value);
	  },

	  NumberLiteral: function NumberLiteral(number) {
	    this.opcode('pushLiteral', number.value);
	  },

	  BooleanLiteral: function BooleanLiteral(bool) {
	    this.opcode('pushLiteral', bool.value);
	  },

	  UndefinedLiteral: function UndefinedLiteral() {
	    this.opcode('pushLiteral', 'undefined');
	  },

	  NullLiteral: function NullLiteral() {
	    this.opcode('pushLiteral', 'null');
	  },

	  Hash: function Hash(hash) {
	    var pairs = hash.pairs,
	        i = 0,
	        l = pairs.length;

	    this.opcode('pushHash');

	    for (; i < l; i++) {
	      this.pushParam(pairs[i].value);
	    }
	    while (i--) {
	      this.opcode('assignToHash', pairs[i].key);
	    }
	    this.opcode('popHash');
	  },

	  // HELPERS
	  opcode: function opcode(name) {
	    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
	  },

	  addDepth: function addDepth(depth) {
	    if (!depth) {
	      return;
	    }

	    this.useDepths = true;
	  },

	  classifySexpr: function classifySexpr(sexpr) {
	    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

	    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

	    // a mustache is an eligible helper if:
	    // * its id is simple (a single part, not `this` or `..`)
	    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

	    // if a mustache is an eligible helper but not a definite
	    // helper, it is ambiguous, and will be resolved in a later
	    // pass or at runtime.
	    var isEligible = !isBlockParam && (isHelper || isSimple);

	    // if ambiguous, we can possibly resolve the ambiguity now
	    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
	    if (isEligible && !isHelper) {
	      var _name2 = sexpr.path.parts[0],
	          options = this.options;

	      if (options.knownHelpers[_name2]) {
	        isHelper = true;
	      } else if (options.knownHelpersOnly) {
	        isEligible = false;
	      }
	    }

	    if (isHelper) {
	      return 'helper';
	    } else if (isEligible) {
	      return 'ambiguous';
	    } else {
	      return 'simple';
	    }
	  },

	  pushParams: function pushParams(params) {
	    for (var i = 0, l = params.length; i < l; i++) {
	      this.pushParam(params[i]);
	    }
	  },

	  pushParam: function pushParam(val) {
	    var value = val.value != null ? val.value : val.original || '';

	    if (this.stringParams) {
	      if (value.replace) {
	        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
	      }

	      if (val.depth) {
	        this.addDepth(val.depth);
	      }
	      this.opcode('getContext', val.depth || 0);
	      this.opcode('pushStringParam', value, val.type);

	      if (val.type === 'SubExpression') {
	        // SubExpressions get evaluated and passed in
	        // in string params mode.
	        this.accept(val);
	      }
	    } else {
	      if (this.trackIds) {
	        var blockParamIndex = undefined;
	        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
	          blockParamIndex = this.blockParamIndex(val.parts[0]);
	        }
	        if (blockParamIndex) {
	          var blockParamChild = val.parts.slice(1).join('.');
	          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
	        } else {
	          value = val.original || value;
	          if (value.replace) {
	            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
	          }

	          this.opcode('pushId', val.type, value);
	        }
	      }
	      this.accept(val);
	    }
	  },

	  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
	    var params = sexpr.params;
	    this.pushParams(params);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    if (sexpr.hash) {
	      this.accept(sexpr.hash);
	    } else {
	      this.opcode('emptyHash', omitEmpty);
	    }

	    return params;
	  },

	  blockParamIndex: function blockParamIndex(name) {
	    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
	      var blockParams = this.options.blockParams[depth],
	          param = blockParams && _utils.indexOf(blockParams, name);
	      if (blockParams && param >= 0) {
	        return [depth, param];
	      }
	    }
	  }
	};

	function precompile(input, options, env) {
	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
	  }

	  options = options || {};
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var ast = env.parse(input, options),
	      environment = new env.Compiler().compile(ast, options);
	  return new env.JavaScriptCompiler().compile(environment, options);
	}

	function compile(input, options, env) {
	  if (options === undefined) options = {};

	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
	  }

	  options = _utils.extend({}, options);
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var compiled = undefined;

	  function compileInput() {
	    var ast = env.parse(input, options),
	        environment = new env.Compiler().compile(ast, options),
	        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
	    return env.template(templateSpec);
	  }

	  // Template is only compiled on first use and cached after that point.
	  function ret(context, execOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled.call(this, context, execOptions);
	  }
	  ret._setup = function (setupOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._setup(setupOptions);
	  };
	  ret._child = function (i, data, blockParams, depths) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._child(i, data, blockParams, depths);
	  };
	  return ret;
	}

	function argEquals(a, b) {
	  if (a === b) {
	    return true;
	  }

	  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
	    for (var i = 0; i < a.length; i++) {
	      if (!argEquals(a[i], b[i])) {
	        return false;
	      }
	    }
	    return true;
	  }
	}

	function transformLiteralToPath(sexpr) {
	  if (!sexpr.path.parts) {
	    var literal = sexpr.path;
	    // Casting to string here to make false and 0 literal values play nicely with the rest
	    // of the system.
	    sexpr.path = {
	      type: 'PathExpression',
	      data: false,
	      depth: 0,
	      parts: [literal.original + ''],
	      original: literal.original + '',
	      loc: literal.loc
	    };
	  }
	}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _base = __webpack_require__(4);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = __webpack_require__(5);

	var _codeGen = __webpack_require__(43);

	var _codeGen2 = _interopRequireDefault(_codeGen);

	function Literal(value) {
	  this.value = value;
	}

	function JavaScriptCompiler() {}

	JavaScriptCompiler.prototype = {
	  // PUBLIC API: You can override these methods in a subclass to provide
	  // alternative compiled forms for name lookup and buffering semantics
	  nameLookup: function nameLookup(parent, name /* , type*/) {
	    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
	      return [parent, '.', name];
	    } else {
	      return [parent, '[', JSON.stringify(name), ']'];
	    }
	  },
	  depthedLookup: function depthedLookup(name) {
	    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
	  },

	  compilerInfo: function compilerInfo() {
	    var revision = _base.COMPILER_REVISION,
	        versions = _base.REVISION_CHANGES[revision];
	    return [revision, versions];
	  },

	  appendToBuffer: function appendToBuffer(source, location, explicit) {
	    // Force a source as this simplifies the merge logic.
	    if (!_utils.isArray(source)) {
	      source = [source];
	    }
	    source = this.source.wrap(source, location);

	    if (this.environment.isSimple) {
	      return ['return ', source, ';'];
	    } else if (explicit) {
	      // This is a case where the buffer operation occurs as a child of another
	      // construct, generally braces. We have to explicitly output these buffer
	      // operations to ensure that the emitted code goes in the correct location.
	      return ['buffer += ', source, ';'];
	    } else {
	      source.appendToBuffer = true;
	      return source;
	    }
	  },

	  initializeBuffer: function initializeBuffer() {
	    return this.quotedString('');
	  },
	  // END PUBLIC API

	  compile: function compile(environment, options, context, asObject) {
	    this.environment = environment;
	    this.options = options;
	    this.stringParams = this.options.stringParams;
	    this.trackIds = this.options.trackIds;
	    this.precompile = !asObject;

	    this.name = this.environment.name;
	    this.isChild = !!context;
	    this.context = context || {
	      decorators: [],
	      programs: [],
	      environments: []
	    };

	    this.preamble();

	    this.stackSlot = 0;
	    this.stackVars = [];
	    this.aliases = {};
	    this.registers = { list: [] };
	    this.hashes = [];
	    this.compileStack = [];
	    this.inlineStack = [];
	    this.blockParams = [];

	    this.compileChildren(environment, options);

	    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
	    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

	    var opcodes = environment.opcodes,
	        opcode = undefined,
	        firstLoc = undefined,
	        i = undefined,
	        l = undefined;

	    for (i = 0, l = opcodes.length; i < l; i++) {
	      opcode = opcodes[i];

	      this.source.currentLocation = opcode.loc;
	      firstLoc = firstLoc || opcode.loc;
	      this[opcode.opcode].apply(this, opcode.args);
	    }

	    // Flush any trailing content that might be pending.
	    this.source.currentLocation = firstLoc;
	    this.pushSource('');

	    /* istanbul ignore next */
	    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
	      throw new _exception2['default']('Compile completed with content left on stack');
	    }

	    if (!this.decorators.isEmpty()) {
	      this.useDecorators = true;

	      this.decorators.prepend('var decorators = container.decorators;\n');
	      this.decorators.push('return fn;');

	      if (asObject) {
	        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
	      } else {
	        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
	        this.decorators.push('}\n');
	        this.decorators = this.decorators.merge();
	      }
	    } else {
	      this.decorators = undefined;
	    }

	    var fn = this.createFunctionContext(asObject);
	    if (!this.isChild) {
	      var ret = {
	        compiler: this.compilerInfo(),
	        main: fn
	      };

	      if (this.decorators) {
	        ret.main_d = this.decorators; // eslint-disable-line camelcase
	        ret.useDecorators = true;
	      }

	      var _context = this.context;
	      var programs = _context.programs;
	      var decorators = _context.decorators;

	      for (i = 0, l = programs.length; i < l; i++) {
	        if (programs[i]) {
	          ret[i] = programs[i];
	          if (decorators[i]) {
	            ret[i + '_d'] = decorators[i];
	            ret.useDecorators = true;
	          }
	        }
	      }

	      if (this.environment.usePartial) {
	        ret.usePartial = true;
	      }
	      if (this.options.data) {
	        ret.useData = true;
	      }
	      if (this.useDepths) {
	        ret.useDepths = true;
	      }
	      if (this.useBlockParams) {
	        ret.useBlockParams = true;
	      }
	      if (this.options.compat) {
	        ret.compat = true;
	      }

	      if (!asObject) {
	        ret.compiler = JSON.stringify(ret.compiler);

	        this.source.currentLocation = { start: { line: 1, column: 0 } };
	        ret = this.objectLiteral(ret);

	        if (options.srcName) {
	          ret = ret.toStringWithSourceMap({ file: options.destName });
	          ret.map = ret.map && ret.map.toString();
	        } else {
	          ret = ret.toString();
	        }
	      } else {
	        ret.compilerOptions = this.options;
	      }

	      return ret;
	    } else {
	      return fn;
	    }
	  },

	  preamble: function preamble() {
	    // track the last context pushed into place to allow skipping the
	    // getContext opcode when it would be a noop
	    this.lastContext = 0;
	    this.source = new _codeGen2['default'](this.options.srcName);
	    this.decorators = new _codeGen2['default'](this.options.srcName);
	  },

	  createFunctionContext: function createFunctionContext(asObject) {
	    var varDeclarations = '';

	    var locals = this.stackVars.concat(this.registers.list);
	    if (locals.length > 0) {
	      varDeclarations += ', ' + locals.join(', ');
	    }

	    // Generate minimizer alias mappings
	    //
	    // When using true SourceNodes, this will update all references to the given alias
	    // as the source nodes are reused in situ. For the non-source node compilation mode,
	    // aliases will not be used, but this case is already being run on the client and
	    // we aren't concern about minimizing the template size.
	    var aliasCount = 0;
	    for (var alias in this.aliases) {
	      // eslint-disable-line guard-for-in
	      var node = this.aliases[alias];

	      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
	        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
	        node.children[0] = 'alias' + aliasCount;
	      }
	    }

	    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

	    if (this.useBlockParams || this.useDepths) {
	      params.push('blockParams');
	    }
	    if (this.useDepths) {
	      params.push('depths');
	    }

	    // Perform a second pass over the output to merge content when possible
	    var source = this.mergeSource(varDeclarations);

	    if (asObject) {
	      params.push(source);

	      return Function.apply(this, params);
	    } else {
	      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
	    }
	  },
	  mergeSource: function mergeSource(varDeclarations) {
	    var isSimple = this.environment.isSimple,
	        appendOnly = !this.forceBuffer,
	        appendFirst = undefined,
	        sourceSeen = undefined,
	        bufferStart = undefined,
	        bufferEnd = undefined;
	    this.source.each(function (line) {
	      if (line.appendToBuffer) {
	        if (bufferStart) {
	          line.prepend('  + ');
	        } else {
	          bufferStart = line;
	        }
	        bufferEnd = line;
	      } else {
	        if (bufferStart) {
	          if (!sourceSeen) {
	            appendFirst = true;
	          } else {
	            bufferStart.prepend('buffer += ');
	          }
	          bufferEnd.add(';');
	          bufferStart = bufferEnd = undefined;
	        }

	        sourceSeen = true;
	        if (!isSimple) {
	          appendOnly = false;
	        }
	      }
	    });

	    if (appendOnly) {
	      if (bufferStart) {
	        bufferStart.prepend('return ');
	        bufferEnd.add(';');
	      } else if (!sourceSeen) {
	        this.source.push('return "";');
	      }
	    } else {
	      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

	      if (bufferStart) {
	        bufferStart.prepend('return buffer + ');
	        bufferEnd.add(';');
	      } else {
	        this.source.push('return buffer;');
	      }
	    }

	    if (varDeclarations) {
	      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
	    }

	    return this.source.merge();
	  },

	  // [blockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // On stack, after: return value of blockHelperMissing
	  //
	  // The purpose of this opcode is to take a block of the form
	  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
	  // replace it on the stack with the result of properly
	  // invoking blockHelperMissing.
	  blockValue: function blockValue(name) {
	    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs(name, 0, params);

	    var blockName = this.popStack();
	    params.splice(1, 0, blockName);

	    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
	  },

	  // [ambiguousBlockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // Compiler value, before: lastHelper=value of last found helper, if any
	  // On stack, after, if no lastHelper: same as [blockValue]
	  // On stack, after, if lastHelper: value
	  ambiguousBlockValue: function ambiguousBlockValue() {
	    // We're being a bit cheeky and reusing the options value from the prior exec
	    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs('', 0, params, true);

	    this.flushInline();

	    var current = this.topStack();
	    params.splice(1, 0, current);

	    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
	  },

	  // [appendContent]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  //
	  // Appends the string value of `content` to the current buffer
	  appendContent: function appendContent(content) {
	    if (this.pendingContent) {
	      content = this.pendingContent + content;
	    } else {
	      this.pendingLocation = this.source.currentLocation;
	    }

	    this.pendingContent = content;
	  },

	  // [append]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Coerces `value` to a String and appends it to the current buffer.
	  //
	  // If `value` is truthy, or 0, it is coerced into a string and appended
	  // Otherwise, the empty string is appended
	  append: function append() {
	    if (this.isInline()) {
	      this.replaceStack(function (current) {
	        return [' != null ? ', current, ' : ""'];
	      });

	      this.pushSource(this.appendToBuffer(this.popStack()));
	    } else {
	      var local = this.popStack();
	      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
	      if (this.environment.isSimple) {
	        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
	      }
	    }
	  },

	  // [appendEscaped]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Escape `value` and append it to the buffer
	  appendEscaped: function appendEscaped() {
	    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
	  },

	  // [getContext]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  // Compiler value, after: lastContext=depth
	  //
	  // Set the value of the `lastContext` compiler value to the depth
	  getContext: function getContext(depth) {
	    this.lastContext = depth;
	  },

	  // [pushContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext, ...
	  //
	  // Pushes the value of the current context onto the stack.
	  pushContext: function pushContext() {
	    this.pushStackLiteral(this.contextName(this.lastContext));
	  },

	  // [lookupOnContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext[name], ...
	  //
	  // Looks up the value of `name` on the current context and pushes
	  // it onto the stack.
	  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
	    var i = 0;

	    if (!scoped && this.options.compat && !this.lastContext) {
	      // The depthed query is expected to handle the undefined logic for the root level that
	      // is implemented below, so we evaluate that directly in compat mode
	      this.push(this.depthedLookup(parts[i++]));
	    } else {
	      this.pushContext();
	    }

	    this.resolvePath('context', parts, i, falsy, strict);
	  },

	  // [lookupBlockParam]
	  //
	  // On stack, before: ...
	  // On stack, after: blockParam[name], ...
	  //
	  // Looks up the value of `parts` on the given block param and pushes
	  // it onto the stack.
	  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
	    this.useBlockParams = true;

	    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
	    this.resolvePath('context', parts, 1);
	  },

	  // [lookupData]
	  //
	  // On stack, before: ...
	  // On stack, after: data, ...
	  //
	  // Push the data lookup operator
	  lookupData: function lookupData(depth, parts, strict) {
	    if (!depth) {
	      this.pushStackLiteral('data');
	    } else {
	      this.pushStackLiteral('container.data(data, ' + depth + ')');
	    }

	    this.resolvePath('data', parts, 0, true, strict);
	  },

	  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
	    // istanbul ignore next

	    var _this = this;

	    if (this.options.strict || this.options.assumeObjects) {
	      this.push(strictLookup(this.options.strict && strict, this, parts, type));
	      return;
	    }

	    var len = parts.length;
	    for (; i < len; i++) {
	      /* eslint-disable no-loop-func */
	      this.replaceStack(function (current) {
	        var lookup = _this.nameLookup(current, parts[i], type);
	        // We want to ensure that zero and false are handled properly if the context (falsy flag)
	        // needs to have the special handling for these values.
	        if (!falsy) {
	          return [' != null ? ', lookup, ' : ', current];
	        } else {
	          // Otherwise we can use generic falsy handling
	          return [' && ', lookup];
	        }
	      });
	      /* eslint-enable no-loop-func */
	    }
	  },

	  // [resolvePossibleLambda]
	  //
	  // On stack, before: value, ...
	  // On stack, after: resolved value, ...
	  //
	  // If the `value` is a lambda, replace it on the stack by
	  // the return value of the lambda
	  resolvePossibleLambda: function resolvePossibleLambda() {
	    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
	  },

	  // [pushStringParam]
	  //
	  // On stack, before: ...
	  // On stack, after: string, currentContext, ...
	  //
	  // This opcode is designed for use in string mode, which
	  // provides the string value of a parameter along with its
	  // depth rather than resolving it immediately.
	  pushStringParam: function pushStringParam(string, type) {
	    this.pushContext();
	    this.pushString(type);

	    // If it's a subexpression, the string result
	    // will be pushed after this opcode.
	    if (type !== 'SubExpression') {
	      if (typeof string === 'string') {
	        this.pushString(string);
	      } else {
	        this.pushStackLiteral(string);
	      }
	    }
	  },

	  emptyHash: function emptyHash(omitEmpty) {
	    if (this.trackIds) {
	      this.push('{}'); // hashIds
	    }
	    if (this.stringParams) {
	      this.push('{}'); // hashContexts
	      this.push('{}'); // hashTypes
	    }
	    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
	  },
	  pushHash: function pushHash() {
	    if (this.hash) {
	      this.hashes.push(this.hash);
	    }
	    this.hash = { values: [], types: [], contexts: [], ids: [] };
	  },
	  popHash: function popHash() {
	    var hash = this.hash;
	    this.hash = this.hashes.pop();

	    if (this.trackIds) {
	      this.push(this.objectLiteral(hash.ids));
	    }
	    if (this.stringParams) {
	      this.push(this.objectLiteral(hash.contexts));
	      this.push(this.objectLiteral(hash.types));
	    }

	    this.push(this.objectLiteral(hash.values));
	  },

	  // [pushString]
	  //
	  // On stack, before: ...
	  // On stack, after: quotedString(string), ...
	  //
	  // Push a quoted version of `string` onto the stack
	  pushString: function pushString(string) {
	    this.pushStackLiteral(this.quotedString(string));
	  },

	  // [pushLiteral]
	  //
	  // On stack, before: ...
	  // On stack, after: value, ...
	  //
	  // Pushes a value onto the stack. This operation prevents
	  // the compiler from creating a temporary variable to hold
	  // it.
	  pushLiteral: function pushLiteral(value) {
	    this.pushStackLiteral(value);
	  },

	  // [pushProgram]
	  //
	  // On stack, before: ...
	  // On stack, after: program(guid), ...
	  //
	  // Push a program expression onto the stack. This takes
	  // a compile-time guid and converts it into a runtime-accessible
	  // expression.
	  pushProgram: function pushProgram(guid) {
	    if (guid != null) {
	      this.pushStackLiteral(this.programExpression(guid));
	    } else {
	      this.pushStackLiteral(null);
	    }
	  },

	  // [registerDecorator]
	  //
	  // On stack, before: hash, program, params..., ...
	  // On stack, after: ...
	  //
	  // Pops off the decorator's parameters, invokes the decorator,
	  // and inserts the decorator into the decorators list.
	  registerDecorator: function registerDecorator(paramSize, name) {
	    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
	        options = this.setupHelperArgs(name, paramSize);

	    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
	  },

	  // [invokeHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // Pops off the helper's parameters, invokes the helper,
	  // and pushes the helper's return value onto the stack.
	  //
	  // If the helper is not found, `helperMissing` is called.
	  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
	    var nonHelper = this.popStack(),
	        helper = this.setupHelper(paramSize, name),
	        simple = isSimple ? [helper.name, ' || '] : '';

	    var lookup = ['('].concat(simple, nonHelper);
	    if (!this.options.strict) {
	      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
	    }
	    lookup.push(')');

	    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
	  },

	  // [invokeKnownHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // This operation is used when the helper is known to exist,
	  // so a `helperMissing` fallback is not required.
	  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
	    var helper = this.setupHelper(paramSize, name);
	    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
	  },

	  // [invokeAmbiguous]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of disambiguation
	  //
	  // This operation is used when an expression like `{{foo}}`
	  // is provided, but we don't know at compile-time whether it
	  // is a helper or a path.
	  //
	  // This operation emits more code than the other options,
	  // and can be avoided by passing the `knownHelpers` and
	  // `knownHelpersOnly` flags at compile-time.
	  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
	    this.useRegister('helper');

	    var nonHelper = this.popStack();

	    this.emptyHash();
	    var helper = this.setupHelper(0, name, helperCall);

	    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

	    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
	    if (!this.options.strict) {
	      lookup[0] = '(helper = ';
	      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
	    }

	    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
	  },

	  // [invokePartial]
	  //
	  // On stack, before: context, ...
	  // On stack after: result of partial invocation
	  //
	  // This operation pops off a context, invokes a partial with that context,
	  // and pushes the result of the invocation back.
	  invokePartial: function invokePartial(isDynamic, name, indent) {
	    var params = [],
	        options = this.setupParams(name, 1, params);

	    if (isDynamic) {
	      name = this.popStack();
	      delete options.name;
	    }

	    if (indent) {
	      options.indent = JSON.stringify(indent);
	    }
	    options.helpers = 'helpers';
	    options.partials = 'partials';
	    options.decorators = 'container.decorators';

	    if (!isDynamic) {
	      params.unshift(this.nameLookup('partials', name, 'partial'));
	    } else {
	      params.unshift(name);
	    }

	    if (this.options.compat) {
	      options.depths = 'depths';
	    }
	    options = this.objectLiteral(options);
	    params.push(options);

	    this.push(this.source.functionCall('container.invokePartial', '', params));
	  },

	  // [assignToHash]
	  //
	  // On stack, before: value, ..., hash, ...
	  // On stack, after: ..., hash, ...
	  //
	  // Pops a value off the stack and assigns it to the current hash
	  assignToHash: function assignToHash(key) {
	    var value = this.popStack(),
	        context = undefined,
	        type = undefined,
	        id = undefined;

	    if (this.trackIds) {
	      id = this.popStack();
	    }
	    if (this.stringParams) {
	      type = this.popStack();
	      context = this.popStack();
	    }

	    var hash = this.hash;
	    if (context) {
	      hash.contexts[key] = context;
	    }
	    if (type) {
	      hash.types[key] = type;
	    }
	    if (id) {
	      hash.ids[key] = id;
	    }
	    hash.values[key] = value;
	  },

	  pushId: function pushId(type, name, child) {
	    if (type === 'BlockParam') {
	      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
	    } else if (type === 'PathExpression') {
	      this.pushString(name);
	    } else if (type === 'SubExpression') {
	      this.pushStackLiteral('true');
	    } else {
	      this.pushStackLiteral('null');
	    }
	  },

	  // HELPERS

	  compiler: JavaScriptCompiler,

	  compileChildren: function compileChildren(environment, options) {
	    var children = environment.children,
	        child = undefined,
	        compiler = undefined;

	    for (var i = 0, l = children.length; i < l; i++) {
	      child = children[i];
	      compiler = new this.compiler(); // eslint-disable-line new-cap

	      var existing = this.matchExistingProgram(child);

	      if (existing == null) {
	        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
	        var index = this.context.programs.length;
	        child.index = index;
	        child.name = 'program' + index;
	        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
	        this.context.decorators[index] = compiler.decorators;
	        this.context.environments[index] = child;

	        this.useDepths = this.useDepths || compiler.useDepths;
	        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
	        child.useDepths = this.useDepths;
	        child.useBlockParams = this.useBlockParams;
	      } else {
	        child.index = existing.index;
	        child.name = 'program' + existing.index;

	        this.useDepths = this.useDepths || existing.useDepths;
	        this.useBlockParams = this.useBlockParams || existing.useBlockParams;
	      }
	    }
	  },
	  matchExistingProgram: function matchExistingProgram(child) {
	    for (var i = 0, len = this.context.environments.length; i < len; i++) {
	      var environment = this.context.environments[i];
	      if (environment && environment.equals(child)) {
	        return environment;
	      }
	    }
	  },

	  programExpression: function programExpression(guid) {
	    var child = this.environment.children[guid],
	        programParams = [child.index, 'data', child.blockParams];

	    if (this.useBlockParams || this.useDepths) {
	      programParams.push('blockParams');
	    }
	    if (this.useDepths) {
	      programParams.push('depths');
	    }

	    return 'container.program(' + programParams.join(', ') + ')';
	  },

	  useRegister: function useRegister(name) {
	    if (!this.registers[name]) {
	      this.registers[name] = true;
	      this.registers.list.push(name);
	    }
	  },

	  push: function push(expr) {
	    if (!(expr instanceof Literal)) {
	      expr = this.source.wrap(expr);
	    }

	    this.inlineStack.push(expr);
	    return expr;
	  },

	  pushStackLiteral: function pushStackLiteral(item) {
	    this.push(new Literal(item));
	  },

	  pushSource: function pushSource(source) {
	    if (this.pendingContent) {
	      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
	      this.pendingContent = undefined;
	    }

	    if (source) {
	      this.source.push(source);
	    }
	  },

	  replaceStack: function replaceStack(callback) {
	    var prefix = ['('],
	        stack = undefined,
	        createdStack = undefined,
	        usedLiteral = undefined;

	    /* istanbul ignore next */
	    if (!this.isInline()) {
	      throw new _exception2['default']('replaceStack on non-inline');
	    }

	    // We want to merge the inline statement into the replacement statement via ','
	    var top = this.popStack(true);

	    if (top instanceof Literal) {
	      // Literals do not need to be inlined
	      stack = [top.value];
	      prefix = ['(', stack];
	      usedLiteral = true;
	    } else {
	      // Get or create the current stack name for use by the inline
	      createdStack = true;
	      var _name = this.incrStack();

	      prefix = ['((', this.push(_name), ' = ', top, ')'];
	      stack = this.topStack();
	    }

	    var item = callback.call(this, stack);

	    if (!usedLiteral) {
	      this.popStack();
	    }
	    if (createdStack) {
	      this.stackSlot--;
	    }
	    this.push(prefix.concat(item, ')'));
	  },

	  incrStack: function incrStack() {
	    this.stackSlot++;
	    if (this.stackSlot > this.stackVars.length) {
	      this.stackVars.push('stack' + this.stackSlot);
	    }
	    return this.topStackName();
	  },
	  topStackName: function topStackName() {
	    return 'stack' + this.stackSlot;
	  },
	  flushInline: function flushInline() {
	    var inlineStack = this.inlineStack;
	    this.inlineStack = [];
	    for (var i = 0, len = inlineStack.length; i < len; i++) {
	      var entry = inlineStack[i];
	      /* istanbul ignore if */
	      if (entry instanceof Literal) {
	        this.compileStack.push(entry);
	      } else {
	        var stack = this.incrStack();
	        this.pushSource([stack, ' = ', entry, ';']);
	        this.compileStack.push(stack);
	      }
	    }
	  },
	  isInline: function isInline() {
	    return this.inlineStack.length;
	  },

	  popStack: function popStack(wrapped) {
	    var inline = this.isInline(),
	        item = (inline ? this.inlineStack : this.compileStack).pop();

	    if (!wrapped && item instanceof Literal) {
	      return item.value;
	    } else {
	      if (!inline) {
	        /* istanbul ignore next */
	        if (!this.stackSlot) {
	          throw new _exception2['default']('Invalid stack pop');
	        }
	        this.stackSlot--;
	      }
	      return item;
	    }
	  },

	  topStack: function topStack() {
	    var stack = this.isInline() ? this.inlineStack : this.compileStack,
	        item = stack[stack.length - 1];

	    /* istanbul ignore if */
	    if (item instanceof Literal) {
	      return item.value;
	    } else {
	      return item;
	    }
	  },

	  contextName: function contextName(context) {
	    if (this.useDepths && context) {
	      return 'depths[' + context + ']';
	    } else {
	      return 'depth' + context;
	    }
	  },

	  quotedString: function quotedString(str) {
	    return this.source.quotedString(str);
	  },

	  objectLiteral: function objectLiteral(obj) {
	    return this.source.objectLiteral(obj);
	  },

	  aliasable: function aliasable(name) {
	    var ret = this.aliases[name];
	    if (ret) {
	      ret.referenceCount++;
	      return ret;
	    }

	    ret = this.aliases[name] = this.source.wrap(name);
	    ret.aliasable = true;
	    ret.referenceCount = 1;

	    return ret;
	  },

	  setupHelper: function setupHelper(paramSize, name, blockHelper) {
	    var params = [],
	        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
	    var foundHelper = this.nameLookup('helpers', name, 'helper'),
	        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

	    return {
	      params: params,
	      paramsInit: paramsInit,
	      name: foundHelper,
	      callParams: [callContext].concat(params)
	    };
	  },

	  setupParams: function setupParams(helper, paramSize, params) {
	    var options = {},
	        contexts = [],
	        types = [],
	        ids = [],
	        objectArgs = !params,
	        param = undefined;

	    if (objectArgs) {
	      params = [];
	    }

	    options.name = this.quotedString(helper);
	    options.hash = this.popStack();

	    if (this.trackIds) {
	      options.hashIds = this.popStack();
	    }
	    if (this.stringParams) {
	      options.hashTypes = this.popStack();
	      options.hashContexts = this.popStack();
	    }

	    var inverse = this.popStack(),
	        program = this.popStack();

	    // Avoid setting fn and inverse if neither are set. This allows
	    // helpers to do a check for `if (options.fn)`
	    if (program || inverse) {
	      options.fn = program || 'container.noop';
	      options.inverse = inverse || 'container.noop';
	    }

	    // The parameters go on to the stack in order (making sure that they are evaluated in order)
	    // so we need to pop them off the stack in reverse order
	    var i = paramSize;
	    while (i--) {
	      param = this.popStack();
	      params[i] = param;

	      if (this.trackIds) {
	        ids[i] = this.popStack();
	      }
	      if (this.stringParams) {
	        types[i] = this.popStack();
	        contexts[i] = this.popStack();
	      }
	    }

	    if (objectArgs) {
	      options.args = this.source.generateArray(params);
	    }

	    if (this.trackIds) {
	      options.ids = this.source.generateArray(ids);
	    }
	    if (this.stringParams) {
	      options.types = this.source.generateArray(types);
	      options.contexts = this.source.generateArray(contexts);
	    }

	    if (this.options.data) {
	      options.data = 'data';
	    }
	    if (this.useBlockParams) {
	      options.blockParams = 'blockParams';
	    }
	    return options;
	  },

	  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
	    var options = this.setupParams(helper, paramSize, params);
	    options = this.objectLiteral(options);
	    if (useRegister) {
	      this.useRegister('options');
	      params.push('options');
	      return ['options=', options];
	    } else if (params) {
	      params.push(options);
	      return '';
	    } else {
	      return options;
	    }
	  }
	};

	(function () {
	  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

	  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

	  for (var i = 0, l = reservedWords.length; i < l; i++) {
	    compilerWords[reservedWords[i]] = true;
	  }
	})();

	JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
	  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
	};

	function strictLookup(requireTerminal, compiler, parts, type) {
	  var stack = compiler.popStack(),
	      i = 0,
	      len = parts.length;
	  if (requireTerminal) {
	    len--;
	  }

	  for (; i < len; i++) {
	    stack = compiler.nameLookup(stack, parts[i], type);
	  }

	  if (requireTerminal) {
	    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
	  } else {
	    return stack;
	  }
	}

	exports['default'] = JavaScriptCompiler;
	module.exports = exports['default'];

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/* global define */
	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var SourceNode = undefined;

	try {
	  /* istanbul ignore next */
	  if (false) {
	    // We don't support this in AMD environments. For these environments, we asusme that
	    // they are running on the browser and thus have no need for the source-map library.
	    var SourceMap = require('source-map');
	    SourceNode = SourceMap.SourceNode;
	  }
	} catch (err) {}
	/* NOP */

	/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
	if (!SourceNode) {
	  SourceNode = function (line, column, srcFile, chunks) {
	    this.src = '';
	    if (chunks) {
	      this.add(chunks);
	    }
	  };
	  /* istanbul ignore next */
	  SourceNode.prototype = {
	    add: function add(chunks) {
	      if (_utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src += chunks;
	    },
	    prepend: function prepend(chunks) {
	      if (_utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src = chunks + this.src;
	    },
	    toStringWithSourceMap: function toStringWithSourceMap() {
	      return { code: this.toString() };
	    },
	    toString: function toString() {
	      return this.src;
	    }
	  };
	}

	function castChunk(chunk, codeGen, loc) {
	  if (_utils.isArray(chunk)) {
	    var ret = [];

	    for (var i = 0, len = chunk.length; i < len; i++) {
	      ret.push(codeGen.wrap(chunk[i], loc));
	    }
	    return ret;
	  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
	    // Handle primitives that the SourceNode will throw up on
	    return chunk + '';
	  }
	  return chunk;
	}

	function CodeGen(srcFile) {
	  this.srcFile = srcFile;
	  this.source = [];
	}

	CodeGen.prototype = {
	  isEmpty: function isEmpty() {
	    return !this.source.length;
	  },
	  prepend: function prepend(source, loc) {
	    this.source.unshift(this.wrap(source, loc));
	  },
	  push: function push(source, loc) {
	    this.source.push(this.wrap(source, loc));
	  },

	  merge: function merge() {
	    var source = this.empty();
	    this.each(function (line) {
	      source.add(['  ', line, '\n']);
	    });
	    return source;
	  },

	  each: function each(iter) {
	    for (var i = 0, len = this.source.length; i < len; i++) {
	      iter(this.source[i]);
	    }
	  },

	  empty: function empty() {
	    var loc = this.currentLocation || { start: {} };
	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
	  },
	  wrap: function wrap(chunk) {
	    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

	    if (chunk instanceof SourceNode) {
	      return chunk;
	    }

	    chunk = castChunk(chunk, this, loc);

	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
	  },

	  functionCall: function functionCall(fn, type, params) {
	    params = this.generateList(params);
	    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
	  },

	  quotedString: function quotedString(str) {
	    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
	    .replace(/\u2029/g, '\\u2029') + '"';
	  },

	  objectLiteral: function objectLiteral(obj) {
	    var pairs = [];

	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        var value = castChunk(obj[key], this);
	        if (value !== 'undefined') {
	          pairs.push([this.quotedString(key), ':', value]);
	        }
	      }
	    }

	    var ret = this.generateList(pairs);
	    ret.prepend('{');
	    ret.add('}');
	    return ret;
	  },

	  generateList: function generateList(entries) {
	    var ret = this.empty();

	    for (var i = 0, len = entries.length; i < len; i++) {
	      if (i) {
	        ret.add(',');
	      }

	      ret.add(castChunk(entries[i], this));
	    }

	    return ret;
	  },

	  generateArray: function generateArray(entries) {
	    var ret = this.generateList(entries);
	    ret.prepend('[');
	    ret.add(']');

	    return ret;
	  }
	};

	exports['default'] = CodeGen;
	module.exports = exports['default'];

/***/ })
/******/ ])
});
;
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	var dt = __webpack_require__(1);
	var $ = __webpack_require__(2);
	   
	$(function () {

	    let init = function () {
	       
	        dt.init();
	    }

	    init();      
	   
	    
	});


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	let $ = __webpack_require__(2);
	let _dt = __webpack_require__(3);
	let _dtEvent = __webpack_require__(4);
	let _hh = __webpack_require__(6)
	let _hh_helper = __webpack_require__(12);
	let _service = __webpack_require__(11);
	let servicecall = __webpack_require__(9);
	let appsettingsobject = __webpack_require__(8);
	let appsettings = appsettingsobject.config;

	module.exports = {
	    init: function () {
	        this.cacheDom();
	        this.bindEvent();
	        this.EventHandler();
	        this.render();
	    },
	    cacheDom: function () {
	        this.$body = $('body');
	        this.$bb_aj_listatoApprove = $("#bb_aj_listatoApprove");
	        this.$bb_aj_listaAlla = $("#bb_aj_listaAlla");
	        this.$bb_aj_boktipsAdminList = $("#bb_aj_boktipsAdminList");
	        this.$bb_aj_boktipsAdminALLList = $("#bb_aj_boktipsAdminALLList");
	    },
	    bindEvent: function (userid) {
	        let that = this;
	                
	        this.$body.on('click', '#bb_aj_listaAlla', function (e) {
	            $(this).addClass("not-active");
	            that.$bb_aj_listatoApprove.removeClass("not-active");

	            that.$bb_aj_boktipsAdminList.hide();
	            let datatables = that.$bb_aj_boktipsAdminList.DataTable();
	            datatables.destroy();
	                        
	            that.serviceHandler("#bb_aj_boktipsAdminALLList", appsettings.api.boktipslistor.getboktipslistAll(), function(){
	                that.$bb_aj_boktipsAdminALLList.show();
	            });
	                       
	            return false;
	        });

	        this.$body.on('click', '#bb_aj_listatoApprove', function (e) {        
	            $(this).addClass("not-active");
	            that.$bb_aj_listaAlla.removeClass("not-active");
	            that.$bb_aj_boktipsAdminALLList.hide();

	            let datatables = that.$bb_aj_boktipsAdminALLList.DataTable();
	            datatables.destroy();            
	            
	            that.serviceHandler("#bb_aj_boktipsAdminList", appsettings.api.boktipslistor.getboktipslistToApprove(), function () {
	                that.$bb_aj_boktipsAdminList.show();
	            });           
	         
	            return false;
	        });

	        this.$body.on('click', '#bb_aj_Deleteboktips', function (e) {
	            let id = $(this).attr('data-tipid');

	            servicecall.deletetip(id, function (isok) {
	                that.updatetable();
	            });

	            $("#bb_aj_modalContainer").hide();
	            return false;
	        });

	        this.$body.on('click', '#bb_aj_Saveboktips', function (e) {
	            let id = $(this).attr('data-tipid');
	            let rub = $("#bb_aj_saveBoktipRubrik").html();
	            let content = tinyMCE.activeEditor.getContent();

	            servicecall.savetip(id, rub, content, function () {              
	                that.updatetable();                          
	            });

	            $("#bb_aj_modalContainer").hide();
	            return false;
	        });
	    },
	    EventHandler: function () {
	        _dtEvent.init();
	        _hh_helper.init();
	    },
	    updatetable: function () {

	        let valdlist, urlen, cssdiv;
	        if (this.$bb_aj_boktipsAdminList.is(':visible')) {
	            valdlist = this.$bb_aj_boktipsAdminList;
	            urlen = appsettings.api.boktipslistor.getboktipslistToApprove();
	            cssdiv = "#bb_aj_boktipsAdminList"
	        }
	        else {
	            if (this.$bb_aj_boktipsAdminALLList.is(':visible')) {
	                valdlist = this.$bb_aj_boktipsAdminALLList
	                urlen = appsettings.api.boktipslistor.getboktipslistAll();
	                cssdiv = "#bb_aj_boktipsAdminALLList"
	            };
	        };      
	        
	        let datatables = valdlist.DataTable();
	        datatables.destroy();

	        this.serviceHandler(cssdiv, urlen, function () { });
	    },
	    serviceHandler: function (cssSelector,url, callback) {
	        //let jsondatapromise = _service.getjsondata('https://www2.barnensbibliotek.se/Api_v3.1/boktips/typ/ByUserId/val/7017/txtval/0/devkey/alf/?type=json');
	        let jsondatapromise = _service.getjsondata(url);

	        jsondatapromise.then(jsondata => {

	            appsettings.dataset.currentdatalist = jsondata;

	            _hh.injecthtmltemplate(cssSelector, appsettings.handlebartemplate.hb_booktipList_tmp, jsondata, function () {
	                console.log("funkar1:" + appsettings.dataset.currentdatalist);
	                _dt.RunDataTable(cssSelector);
	                console.log("funkar2:" + appsettings.dataset.currentdatalist);
	                callback();
	            });
	        });    
	    },
	    render: function () {
	        
	        this.serviceHandler("#bb_aj_boktipsAdminList", appsettings.api.boktipslistor.getboktipslistToApprove(), function () { });
	        //this.serviceHandler("#bb_aj_boktipsAdminALLList", appsettings.api.boktipslistor.getboktipslistAll());
	    }
	}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.3.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2018-01-20T17:24Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};

	var isFunction = function isFunction( obj ) {

	      // Support: Chrome <=57, Firefox <=52
	      // In some browsers, typeof returns "function" for HTML <object> elements
	      // (i.e., `typeof document.createElement( "object" ) === "function"`).
	      // We don't want to classify *any* DOM node as a function.
	      return typeof obj === "function" && typeof obj.nodeType !== "number";
	  };


	var isWindow = function isWindow( obj ) {
			return obj != null && obj === obj.window;
		};




		var preservedScriptAttributes = {
			type: true,
			src: true,
			noModule: true
		};

		function DOMEval( code, doc, node ) {
			doc = doc || document;

			var i,
				script = doc.createElement( "script" );

			script.text = code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
					if ( node[ i ] ) {
						script[ i ] = node[ i ];
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}


	function toType( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.3.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = toType( obj );

		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( toType( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};


	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase );
				} else {
					key = camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Support: Firefox <=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;

			}

			initialInUnit = initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( toType( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
				"margin-top:1px;padding:0;border:0";
			div.style.cssText =
				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
				"margin:auto;border:1px;padding:1px;" +
				"width:60%;top:1%";
			documentElement.appendChild( container ).appendChild( div );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn't
			div.style.right = "60%";
			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			div.style.position = "absolute";
			scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}

		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;

		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? "border" : "content" ) ) {
			return 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin
			if ( box === "margin" ) {
				delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if ( !isBorderBox ) {

				// Add padding
				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// For "border" or "margin", add border
				if ( box !== "padding" ) {
					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

				// But still keep track of it otherwise
				} else {
					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}

			// If we get here with a border-box (content + padding + border), we're seeking "content" or
			// "padding" or "margin"
			} else {

				// For "content", subtract padding
				if ( box === "content" ) {
					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// For "content" or "padding", subtract border
				if ( box !== "margin" ) {
					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox && computedVal >= 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
			) );
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles = getStyles( elem ),
			val = curCSS( elem, dimension, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
			valueIsBorderBox = isBorderBox;

		// Support: Firefox <=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = "auto";
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = valueIsBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ dimension ] );

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		if ( val === "auto" ||
			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

			val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

			// offsetWidth/offsetHeight provide border-box values
			valueIsBorderBox = true;
		}

		// Normalize "" and auto
		val = parseFloat( val ) || 0;

		// Adjust for the element's box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, dimension ) {
		jQuery.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),
					isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					subtract = extra && boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					);

				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox && support.scrollboxSize() === styles.position ) {
					subtract -= Math.ceil(
						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, "border", false, styles ) -
						0.5
					);
				}

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ dimension ] = value;
					value = jQuery.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !== "margin" ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = Date.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === "string" ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray( value );

			if ( typeof stateVal === "boolean" && isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = classesToArray( value );

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			valueIsFunction = isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	support.focusin = "onfocusin" in window;


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = lastElement = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = Date.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && toType( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction = isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
										xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {

		// offset() relates an element's border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();

			} else {
				offset = this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &&
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
					jQuery.css( offsetParent, "position" ) === "static" ) {

					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery( offsetParent ).offset();
					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	};

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;

	jQuery.now = Date.now;

	jQuery.isNumeric = function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.7
	 * 2008-2014 SpryMedia Ltd - datatables.net/license
	 */
	var $ = __webpack_require__(2);
	/**
	 * @summary     DataTables
	 * @description Paginate, search and order HTML tables
	 * @version     1.10.7
	 * @file        jquery.dataTables.js
	 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
	 * @contact     www.sprymedia.co.uk/contact
	 * @copyright   Copyright 2008-2014 SpryMedia Ltd.
	 *
	 * This source file is free software, available under the following license:
	 *   MIT license - http://datatables.net/license
	 *
	 * This source file is distributed in the hope that it will be useful, but
	 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
	 *
	 * For details please refer to: http://www.datatables.net
	 */

	/*jslint evil: true, undef: true, browser: true */
	/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
	module.exports = {
	    jqueryTableInit: function () {
	        (/** @lends <global> */function (window, document, undefined) {

	            (function (factory) {
	                "use strict";

	                if (true) {
	                    // Define as an AMD module if possible
	                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	                }
	                else if (typeof exports === 'object') {
	                    // Node/CommonJS
	                    module.exports = factory(require('jquery'));
	                }
	                else if (jQuery && !jQuery.fn.dataTable) {
	                    // Define using browser globals otherwise
	                    // Prevent multiple instantiations if the script is loaded twice
	                    factory(jQuery);
	                }
	            }
	            (/** @lends <global> */function ($) {
	                "use strict";

	                /**
	                 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
	                 * flexible tool, based upon the foundations of progressive enhancement,
	                 * which will add advanced interaction controls to any HTML table. For a
	                 * full list of features please refer to
	                 * [DataTables.net](href="http://datatables.net).
	                 *
	                 * Note that the `DataTable` object is not a global variable but is aliased
	                 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
	                 * be  accessed.
	                 *
	                 *  @class
	                 *  @param {object} [init={}] Configuration object for DataTables. Options
	                 *    are defined by {@link DataTable.defaults}
	                 *  @requires jQuery 1.7+
	                 *
	                 *  @example
	                 *    // Basic initialisation
	                 *    $(document).ready( function {
	                 *      $('#example').dataTable();
	                 *    } );
	                 *
	                 *  @example
	                 *    // Initialisation with configuration options - in this case, disable
	                 *    // pagination and sorting.
	                 *    $(document).ready( function {
	                 *      $('#example').dataTable( {
	                 *        "paginate": false,
	                 *        "sort": false
	                 *      } );
	                 *    } );
	                 */
	                var DataTable;


	                /*
	                 * It is useful to have variables which are scoped locally so only the
	                 * DataTables functions can access them and they don't leak into global space.
	                 * At the same time these functions are often useful over multiple files in the
	                 * core and API, so we list, or at least document, all variables which are used
	                 * by DataTables as private variables here. This also ensures that there is no
	                 * clashing of variable names and that they can easily referenced for reuse.
	                 */


	                // Defined else where
	                //  _selector_run
	                //  _selector_opts
	                //  _selector_first
	                //  _selector_row_indexes

	                var _ext; // DataTable.ext
	                var _Api; // DataTable.Api
	                var _api_register; // DataTable.Api.register
	                var _api_registerPlural; // DataTable.Api.registerPlural

	                var _re_dic = {};
	                var _re_new_lines = /[\r\n]/g;
	                var _re_html = /<.*?>/g;
	                var _re_date_start = /^[\w\+\-]/;
	                var _re_date_end = /[\w\+\-]$/;

	                // Escape regular expression special characters
	                var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g');

	                // http://en.wikipedia.org/wiki/Foreign_exchange_market
	                // - \u20BD - Russian ruble.
	                // - \u20a9 - South Korean Won
	                // - \u20BA - Turkish Lira
	                // - \u20B9 - Indian Rupee
	                // - R - Brazil (R$) and South Africa
	                // - fr - Swiss Franc
	                // - kr - Swedish krona, Norwegian krone and Danish krone
	                // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
	                //   standards as thousands separators.
	                var _re_formatted_numeric = /[',$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;


	                var _empty = function (d) {
	                    return !d || d === true || d === '-' ? true : false;
	                };


	                var _intVal = function (s) {
	                    var integer = parseInt(s, 10);
	                    return !isNaN(integer) && isFinite(s) ? integer : null;
	                };

	                // Convert from a formatted number with characters other than `.` as the
	                // decimal place, to a Javascript number
	                var _numToDecimal = function (num, decimalPoint) {
	                    // Cache created regular expressions for speed as this function is called often
	                    if (!_re_dic[decimalPoint]) {
	                        _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
	                    }
	                    return typeof num === 'string' && decimalPoint !== '.' ?
	                        num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') :
	                        num;
	                };


	                var _isNumber = function (d, decimalPoint, formatted) {
	                    var strType = typeof d === 'string';

	                    // If empty return immediately so there must be a number if it is a
	                    // formatted string (this stops the string "k", or "kr", etc being detected
	                    // as a formatted number for currency
	                    if (_empty(d)) {
	                        return true;
	                    }

	                    if (decimalPoint && strType) {
	                        d = _numToDecimal(d, decimalPoint);
	                    }

	                    if (formatted && strType) {
	                        d = d.replace(_re_formatted_numeric, '');
	                    }

	                    return !isNaN(parseFloat(d)) && isFinite(d);
	                };


	                // A string without HTML in it can be considered to be HTML still
	                var _isHtml = function (d) {
	                    return _empty(d) || typeof d === 'string';
	                };


	                var _htmlNumeric = function (d, decimalPoint, formatted) {
	                    if (_empty(d)) {
	                        return true;
	                    }

	                    var html = _isHtml(d);
	                    return !html ?
	                        null :
	                        _isNumber(_stripHtml(d), decimalPoint, formatted) ?
	                            true :
	                            null;
	                };


	                var _pluck = function (a, prop, prop2) {
	                    var out = [];
	                    var i = 0, ien = a.length;

	                    // Could have the test in the loop for slightly smaller code, but speed
	                    // is essential here
	                    if (prop2 !== undefined) {
	                        for (; i < ien ; i++) {
	                            if (a[i] && a[i][prop]) {
	                                out.push(a[i][prop][prop2]);
	                            }
	                        }
	                    }
	                    else {
	                        for (; i < ien ; i++) {
	                            if (a[i]) {
	                                out.push(a[i][prop]);
	                            }
	                        }
	                    }

	                    return out;
	                };


	                // Basically the same as _pluck, but rather than looping over `a` we use `order`
	                // as the indexes to pick from `a`
	                var _pluck_order = function (a, order, prop, prop2) {
	                    var out = [];
	                    var i = 0, ien = order.length;

	                    // Could have the test in the loop for slightly smaller code, but speed
	                    // is essential here
	                    if (prop2 !== undefined) {
	                        for (; i < ien ; i++) {
	                            if (a[order[i]][prop]) {
	                                out.push(a[order[i]][prop][prop2]);
	                            }
	                        }
	                    }
	                    else {
	                        for (; i < ien ; i++) {
	                            out.push(a[order[i]][prop]);
	                        }
	                    }

	                    return out;
	                };


	                var _range = function (len, start) {
	                    var out = [];
	                    var end;

	                    if (start === undefined) {
	                        start = 0;
	                        end = len;
	                    }
	                    else {
	                        end = start;
	                        start = len;
	                    }

	                    for (var i = start ; i < end ; i++) {
	                        out.push(i);
	                    }

	                    return out;
	                };


	                var _removeEmpty = function (a) {
	                    var out = [];

	                    for (var i = 0, ien = a.length ; i < ien ; i++) {
	                        if (a[i]) { // careful - will remove all falsy values!
	                            out.push(a[i]);
	                        }
	                    }

	                    return out;
	                };


	                var _stripHtml = function (d) {
	                    return d.replace(_re_html, '');
	                };


	                /**
	                 * Find the unique elements in a source array.
	                 *
	                 * @param  {array} src Source array
	                 * @return {array} Array of unique items
	                 * @ignore
	                 */
	                var _unique = function (src) {
	                    // A faster unique method is to use object keys to identify used values,
	                    // but this doesn't work with arrays or objects, which we must also
	                    // consider. See jsperf.com/compare-array-unique-versions/4 for more
	                    // information.
	                    var
	                        out = [],
	                        val,
	                        i, ien = src.length,
	                        j, k = 0;

	                    again: for (i = 0 ; i < ien ; i++) {
	                        val = src[i];

	                        for (j = 0 ; j < k ; j++) {
	                            if (out[j] === val) {
	                                continue again;
	                            }
	                        }

	                        out.push(val);
	                        k++;
	                    }

	                    return out;
	                };



	                /**
	                 * Create a mapping object that allows camel case parameters to be looked up
	                 * for their Hungarian counterparts. The mapping is stored in a private
	                 * parameter called `_hungarianMap` which can be accessed on the source object.
	                 *  @param {object} o
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnHungarianMap(o) {
	                    var
	                        hungarian = 'a aa ai ao as b fn i m o s ',
	                        match,
	                        newKey,
	                        map = {};

	                    $.each(o, function (key, val) {
	                        match = key.match(/^([^A-Z]+?)([A-Z])/);

	                        if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
	                            newKey = key.replace(match[0], match[2].toLowerCase());
	                            map[newKey] = key;

	                            if (match[1] === 'o') {
	                                _fnHungarianMap(o[key]);
	                            }
	                        }
	                    });

	                    o._hungarianMap = map;
	                }


	                /**
	                 * Convert from camel case parameters to Hungarian, based on a Hungarian map
	                 * created by _fnHungarianMap.
	                 *  @param {object} src The model object which holds all parameters that can be
	                 *    mapped.
	                 *  @param {object} user The object to convert from camel case to Hungarian.
	                 *  @param {boolean} force When set to `true`, properties which already have a
	                 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	                 *    won't be.
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCamelToHungarian(src, user, force) {
	                    if (!src._hungarianMap) {
	                        _fnHungarianMap(src);
	                    }

	                    var hungarianKey;

	                    $.each(user, function (key, val) {
	                        hungarianKey = src._hungarianMap[key];

	                        if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
	                            // For objects, we need to buzz down into the object to copy parameters
	                            if (hungarianKey.charAt(0) === 'o') {
	                                // Copy the camelCase options over to the hungarian
	                                if (!user[hungarianKey]) {
	                                    user[hungarianKey] = {};
	                                }
	                                $.extend(true, user[hungarianKey], user[key]);

	                                _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
	                            }
	                            else {
	                                user[hungarianKey] = user[key];
	                            }
	                        }
	                    });
	                }


	                /**
	                 * Language compatibility - when certain options are given, and others aren't, we
	                 * need to duplicate the values over, in order to provide backwards compatibility
	                 * with older language files.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnLanguageCompat(lang) {
	                    var defaults = DataTable.defaults.oLanguage;
	                    var zeroRecords = lang.sZeroRecords;

	                    /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
	                     * sZeroRecords - assuming that is given.
	                     */
	                    if (!lang.sEmptyTable && zeroRecords &&
	                        defaults.sEmptyTable === "No data available in table") {
	                        _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
	                    }

	                    /* Likewise with loading records */
	                    if (!lang.sLoadingRecords && zeroRecords &&
	                        defaults.sLoadingRecords === "Loading...") {
	                        _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
	                    }

	                    // Old parameter name of the thousands separator mapped onto the new
	                    if (lang.sInfoThousands) {
	                        lang.sThousands = lang.sInfoThousands;
	                    }

	                    var decimal = lang.sDecimal;
	                    if (decimal) {
	                        _addNumericSort(decimal);
	                    }
	                }


	                /**
	                 * Map one parameter onto another
	                 *  @param {object} o Object to map
	                 *  @param {*} knew The new parameter name
	                 *  @param {*} old The old parameter name
	                 */
	                var _fnCompatMap = function (o, knew, old) {
	                    if (o[knew] !== undefined) {
	                        o[old] = o[knew];
	                    }
	                };


	                /**
	                 * Provide backwards compatibility for the main DT options. Note that the new
	                 * options are mapped onto the old parameters, so this is an external interface
	                 * change only.
	                 *  @param {object} init Object to map
	                 */
	                function _fnCompatOpts(init) {
	                    _fnCompatMap(init, 'ordering', 'bSort');
	                    _fnCompatMap(init, 'orderMulti', 'bSortMulti');
	                    _fnCompatMap(init, 'orderClasses', 'bSortClasses');
	                    _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');
	                    _fnCompatMap(init, 'order', 'aaSorting');
	                    _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');
	                    _fnCompatMap(init, 'paging', 'bPaginate');
	                    _fnCompatMap(init, 'pagingType', 'sPaginationType');
	                    _fnCompatMap(init, 'pageLength', 'iDisplayLength');
	                    _fnCompatMap(init, 'searching', 'bFilter');

	                    // Column search objects are in an array, so it needs to be converted
	                    // element by element
	                    var searchCols = init.aoSearchCols;

	                    if (searchCols) {
	                        for (var i = 0, ien = searchCols.length ; i < ien ; i++) {
	                            if (searchCols[i]) {
	                                _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Provide backwards compatibility for column options. Note that the new options
	                 * are mapped onto the old parameters, so this is an external interface change
	                 * only.
	                 *  @param {object} init Object to map
	                 */
	                function _fnCompatCols(init) {
	                    _fnCompatMap(init, 'orderable', 'bSortable');
	                    _fnCompatMap(init, 'orderData', 'aDataSort');
	                    _fnCompatMap(init, 'orderSequence', 'asSorting');
	                    _fnCompatMap(init, 'orderDataType', 'sortDataType');

	                    // orderData can be given as an integer
	                    var dataSort = init.aDataSort;
	                    if (dataSort && !$.isArray(dataSort)) {
	                        init.aDataSort = [dataSort];
	                    }
	                }


	                /**
	                 * Browser feature detection for capabilities, quirks
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnBrowserDetect(settings) {
	                    var browser = settings.oBrowser;

	                    // Scrolling feature / quirks detection
	                    var n = $('<div/>')
	                        .css({
	                            position: 'absolute',
	                            top: 0,
	                            left: 0,
	                            height: 1,
	                            width: 1,
	                            overflow: 'hidden'
	                        })
	                        .append(
	                            $('<div/>')
	                                .css({
	                                    position: 'absolute',
	                                    top: 1,
	                                    left: 1,
	                                    width: 100,
	                                    overflow: 'scroll'
	                                })
	                                .append(
	                                    $('<div class="test"/>')
	                                        .css({
	                                            width: '100%',
	                                            height: 10
	                                        })
	                                )
	                        )
	                        .appendTo('body');

	                    var test = n.find('.test');

	                    // IE6/7 will oversize a width 100% element inside a scrolling element, to
	                    // include the width of the scrollbar, while other browsers ensure the inner
	                    // element is contained without forcing scrolling
	                    browser.bScrollOversize = test[0].offsetWidth === 100;

	                    // In rtl text layout, some browsers (most, but not all) will place the
	                    // scrollbar on the left, rather than the right.
	                    browser.bScrollbarLeft = Math.round(test.offset().left) !== 1;

	                    n.remove();
	                }


	                /**
	                 * Array.prototype reduce[Right] method, used for browsers which don't support
	                 * JS 1.6. Done this way to reduce code size, since we iterate either way
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnReduce(that, fn, init, start, end, inc) {
	                    var
	                        i = start,
	                        value,
	                        isSet = false;

	                    if (init !== undefined) {
	                        value = init;
	                        isSet = true;
	                    }

	                    while (i !== end) {
	                        if (!that.hasOwnProperty(i)) {
	                            continue;
	                        }

	                        value = isSet ?
	                            fn(value, that[i], i, that) :
	                            that[i];

	                        isSet = true;
	                        i += inc;
	                    }

	                    return value;
	                }

	                /**
	                 * Add a column to the list used for the table with default values
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {node} nTh The th element for this column
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAddColumn(oSettings, nTh) {
	                    // Add column to aoColumns array
	                    var oDefaults = DataTable.defaults.column;
	                    var iCol = oSettings.aoColumns.length;
	                    var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
	                        "nTh": nTh ? nTh : document.createElement('th'),
	                        "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
	                        "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
	                        "mData": oDefaults.mData ? oDefaults.mData : iCol,
	                        idx: iCol
	                    });
	                    oSettings.aoColumns.push(oCol);

	                    // Add search object for column specific search. Note that the `searchCols[ iCol ]`
	                    // passed into extend can be undefined. This allows the user to give a default
	                    // with only some of the parameters defined, and also not give a default
	                    var searchCols = oSettings.aoPreSearchCols;
	                    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);

	                    // Use the default column options function to initialise classes etc
	                    _fnColumnOptions(oSettings, iCol, $(nTh).data());
	                }


	                /**
	                 * Apply options for a column
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {int} iCol column index to consider
	                 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnColumnOptions(oSettings, iCol, oOptions) {
	                    var oCol = oSettings.aoColumns[iCol];
	                    var oClasses = oSettings.oClasses;
	                    var th = $(oCol.nTh);

	                    // Try to get width information from the DOM. We can't get it from CSS
	                    // as we'd need to parse the CSS stylesheet. `width` option can override
	                    if (!oCol.sWidthOrig) {
	                        // Width attribute
	                        oCol.sWidthOrig = th.attr('width') || null;

	                        // Style attribute
	                        var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
	                        if (t) {
	                            oCol.sWidthOrig = t[1];
	                        }
	                    }

	                    /* User specified column options */
	                    if (oOptions !== undefined && oOptions !== null) {
	                        // Backwards compatibility
	                        _fnCompatCols(oOptions);

	                        // Map camel case parameters to their Hungarian counterparts
	                        _fnCamelToHungarian(DataTable.defaults.column, oOptions);

	                        /* Backwards compatibility for mDataProp */
	                        if (oOptions.mDataProp !== undefined && !oOptions.mData) {
	                            oOptions.mData = oOptions.mDataProp;
	                        }

	                        if (oOptions.sType) {
	                            oCol._sManualType = oOptions.sType;
	                        }

	                        // `class` is a reserved word in Javascript, so we need to provide
	                        // the ability to use a valid name for the camel case input
	                        if (oOptions.className && !oOptions.sClass) {
	                            oOptions.sClass = oOptions.className;
	                        }

	                        $.extend(oCol, oOptions);
	                        _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");

	                        /* iDataSort to be applied (backwards compatibility), but aDataSort will take
	                         * priority if defined
	                         */
	                        if (oOptions.iDataSort !== undefined) {
	                            oCol.aDataSort = [oOptions.iDataSort];
	                        }
	                        _fnMap(oCol, oOptions, "aDataSort");
	                    }

	                    /* Cache the data get and set functions for speed */
	                    var mDataSrc = oCol.mData;
	                    var mData = _fnGetObjectDataFn(mDataSrc);
	                    var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

	                    var attrTest = function (src) {
	                        return typeof src === 'string' && src.indexOf('@') !== -1;
	                    };
	                    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (
	                        attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
	                    );

	                    oCol.fnGetData = function (rowData, type, meta) {
	                        var innerData = mData(rowData, type, undefined, meta);

	                        return mRender && type ?
	                            mRender(innerData, type, rowData, meta) :
	                            innerData;
	                    };
	                    oCol.fnSetData = function (rowData, val, meta) {
	                        return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
	                    };

	                    // Indicate if DataTables should read DOM data as an object or array
	                    // Used in _fnGetRowElements
	                    if (typeof mDataSrc !== 'number') {
	                        oSettings._rowReadObject = true;
	                    }

	                    /* Feature sorting overrides column specific when off */
	                    if (!oSettings.oFeatures.bSort) {
	                        oCol.bSortable = false;
	                        th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
	                    }

	                    /* Check that the class assignment is correct for sorting */
	                    var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
	                    var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
	                    if (!oCol.bSortable || (!bAsc && !bDesc)) {
	                        oCol.sSortingClass = oClasses.sSortableNone;
	                        oCol.sSortingClassJUI = "";
	                    }
	                    else if (bAsc && !bDesc) {
	                        oCol.sSortingClass = oClasses.sSortableAsc;
	                        oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
	                    }
	                    else if (!bAsc && bDesc) {
	                        oCol.sSortingClass = oClasses.sSortableDesc;
	                        oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
	                    }
	                    else {
	                        oCol.sSortingClass = oClasses.sSortable;
	                        oCol.sSortingClassJUI = oClasses.sSortJUI;
	                    }
	                }


	                /**
	                 * Adjust the table column widths for new data. Note: you would probably want to
	                 * do a redraw after calling this function!
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAdjustColumnSizing(settings) {
	                    /* Not interested in doing column width calculation if auto-width is disabled */
	                    if (settings.oFeatures.bAutoWidth !== false) {
	                        var columns = settings.aoColumns;

	                        _fnCalculateColumnWidths(settings);
	                        for (var i = 0, iLen = columns.length ; i < iLen ; i++) {
	                            columns[i].nTh.style.width = columns[i].sWidth;
	                        }
	                    }

	                    var scroll = settings.oScroll;
	                    if (scroll.sY !== '' || scroll.sX !== '') {
	                        _fnScrollDraw(settings);
	                    }

	                    _fnCallbackFire(settings, null, 'column-sizing', [settings]);
	                }


	                /**
	                 * Covert the index of a visible column to the index in the data array (take account
	                 * of hidden columns)
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {int} iMatch Visible column index to lookup
	                 *  @returns {int} i the data index
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnVisibleToColumnIndex(oSettings, iMatch) {
	                    var aiVis = _fnGetColumns(oSettings, 'bVisible');

	                    return typeof aiVis[iMatch] === 'number' ?
	                        aiVis[iMatch] :
	                        null;
	                }


	                /**
	                 * Covert the index of an index in the data array and convert it to the visible
	                 *   column index (take account of hidden columns)
	                 *  @param {int} iMatch Column index to lookup
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {int} i the data index
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnColumnIndexToVisible(oSettings, iMatch) {
	                    var aiVis = _fnGetColumns(oSettings, 'bVisible');
	                    var iPos = $.inArray(iMatch, aiVis);

	                    return iPos !== -1 ? iPos : null;
	                }


	                /**
	                 * Get the number of visible columns
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {int} i the number of visible columns
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnVisbleColumns(oSettings) {
	                    return _fnGetColumns(oSettings, 'bVisible').length;
	                }


	                /**
	                 * Get an array of column indexes that match a given property
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {string} sParam Parameter in aoColumns to look for - typically
	                 *    bVisible or bSearchable
	                 *  @returns {array} Array of indexes with matched properties
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetColumns(oSettings, sParam) {
	                    var a = [];

	                    $.map(oSettings.aoColumns, function (val, i) {
	                        if (val[sParam]) {
	                            a.push(i);
	                        }
	                    });

	                    return a;
	                }


	                /**
	                 * Calculate the 'type' of a column
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnColumnTypes(settings) {
	                    var columns = settings.aoColumns;
	                    var data = settings.aoData;
	                    var types = DataTable.ext.type.detect;
	                    var i, ien, j, jen, k, ken;
	                    var col, cell, detectedType, cache;

	                    // For each column, spin over the 
	                    for (i = 0, ien = columns.length ; i < ien ; i++) {
	                        col = columns[i];
	                        cache = [];

	                        if (!col.sType && col._sManualType) {
	                            col.sType = col._sManualType;
	                        }
	                        else if (!col.sType) {
	                            for (j = 0, jen = types.length ; j < jen ; j++) {
	                                for (k = 0, ken = data.length ; k < ken ; k++) {
	                                    // Use a cache array so we only need to get the type data
	                                    // from the formatter once (when using multiple detectors)
	                                    if (cache[k] === undefined) {
	                                        cache[k] = _fnGetCellData(settings, k, i, 'type');
	                                    }

	                                    detectedType = types[j](cache[k], settings);

	                                    // If null, then this type can't apply to this column, so
	                                    // rather than testing all cells, break out. There is an
	                                    // exception for the last type which is `html`. We need to
	                                    // scan all rows since it is possible to mix string and HTML
	                                    // types
	                                    if (!detectedType && j !== types.length - 1) {
	                                        break;
	                                    }

	                                    // Only a single match is needed for html type since it is
	                                    // bottom of the pile and very similar to string
	                                    if (detectedType === 'html') {
	                                        break;
	                                    }
	                                }

	                                // Type is valid for all data points in the column - use this
	                                // type
	                                if (detectedType) {
	                                    col.sType = detectedType;
	                                    break;
	                                }
	                            }

	                            // Fall back - if no type was detected, always use string
	                            if (!col.sType) {
	                                col.sType = 'string';
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Take the column definitions and static columns arrays and calculate how
	                 * they relate to column indexes. The callback function will then apply the
	                 * definition found for a column to a suitable configuration object.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
	                 *  @param {array} aoCols The aoColumns array that defines columns individually
	                 *  @param {function} fn Callback function - takes two parameters, the calculated
	                 *    column index and the definition for that column.
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
	                    var i, iLen, j, jLen, k, kLen, def;
	                    var columns = oSettings.aoColumns;

	                    // Column definitions with aTargets
	                    if (aoColDefs) {
	                        /* Loop over the definitions array - loop in reverse so first instance has priority */
	                        for (i = aoColDefs.length - 1 ; i >= 0 ; i--) {
	                            def = aoColDefs[i];

	                            /* Each definition can target multiple columns, as it is an array */
	                            var aTargets = def.targets !== undefined ?
	                                def.targets :
	                                def.aTargets;

	                            if (!$.isArray(aTargets)) {
	                                aTargets = [aTargets];
	                            }

	                            for (j = 0, jLen = aTargets.length ; j < jLen ; j++) {
	                                if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
	                                    /* Add columns that we don't yet know about */
	                                    while (columns.length <= aTargets[j]) {
	                                        _fnAddColumn(oSettings);
	                                    }

	                                    /* Integer, basic index */
	                                    fn(aTargets[j], def);
	                                }
	                                else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
	                                    /* Negative integer, right to left column counting */
	                                    fn(columns.length + aTargets[j], def);
	                                }
	                                else if (typeof aTargets[j] === 'string') {
	                                    /* Class name matching on TH element */
	                                    for (k = 0, kLen = columns.length ; k < kLen ; k++) {
	                                        if (aTargets[j] == "_all" ||
	                                             $(columns[k].nTh).hasClass(aTargets[j])) {
	                                            fn(k, def);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }

	                    // Statically defined columns array
	                    if (aoCols) {
	                        for (i = 0, iLen = aoCols.length ; i < iLen ; i++) {
	                            fn(i, aoCols[i]);
	                        }
	                    }
	                }

	                /**
	                 * Add a data array to the table, creating DOM node etc. This is the parallel to
	                 * _fnGatherData, but for adding rows from a Javascript source, rather than a
	                 * DOM source.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {array} aData data array to be added
	                 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
	                 *    DataTables will create a row automatically
	                 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	                 *    if nTr is.
	                 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAddData(oSettings, aDataIn, nTr, anTds) {
	                    /* Create the object for storing information about this new row */
	                    var iRow = oSettings.aoData.length;
	                    var oData = $.extend(true, {}, DataTable.models.oRow, {
	                        src: nTr ? 'dom' : 'data'
	                    });

	                    oData._aData = aDataIn;
	                    oSettings.aoData.push(oData);

	                    /* Create the cells */
	                    var nTd, sThisType;
	                    var columns = oSettings.aoColumns;
	                    for (var i = 0, iLen = columns.length ; i < iLen ; i++) {
	                        // When working with a row, the data source object must be populated. In
	                        // all other cases, the data source object is already populated, so we
	                        // don't overwrite it, which might break bindings etc
	                        if (nTr) {
	                            _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i));
	                        }
	                        columns[i].sType = null;
	                    }

	                    /* Add to the display array */
	                    oSettings.aiDisplayMaster.push(iRow);

	                    /* Create the DOM information, or register it if already present */
	                    if (nTr || !oSettings.oFeatures.bDeferRender) {
	                        _fnCreateTr(oSettings, iRow, nTr, anTds);
	                    }

	                    return iRow;
	                }


	                /**
	                 * Add one or more TR elements to the table. Generally we'd expect to
	                 * use this for reading data from a DOM sourced table, but it could be
	                 * used for an TR element. Note that if a TR is given, it is used (i.e.
	                 * it is not cloned).
	                 *  @param {object} settings dataTables settings object
	                 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
	                 *  @returns {array} Array of indexes for the added rows
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAddTr(settings, trs) {
	                    var row;

	                    // Allow an individual node to be passed in
	                    if (!(trs instanceof $)) {
	                        trs = $(trs);
	                    }

	                    return trs.map(function (i, el) {
	                        row = _fnGetRowElements(settings, el);
	                        return _fnAddData(settings, row.data, el, row.cells);
	                    });
	                }


	                /**
	                 * Take a TR element and convert it to an index in aoData
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {node} n the TR element to find
	                 *  @returns {int} index if the node is found, null if not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnNodeToDataIndex(oSettings, n) {
	                    return (n._DT_RowIndex !== undefined) ? n._DT_RowIndex : null;
	                }


	                /**
	                 * Take a TD element and convert it into a column data index (not the visible index)
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {int} iRow The row number the TD/TH can be found in
	                 *  @param {node} n The TD/TH element to find
	                 *  @returns {int} index if the node is found, -1 if not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnNodeToColumnIndex(oSettings, iRow, n) {
	                    return $.inArray(n, oSettings.aoData[iRow].anCells);
	                }


	                /**
	                 * Get the data for a given cell from the internal cache, taking into account data mapping
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} rowIdx aoData row id
	                 *  @param {int} colIdx Column index
	                 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
	                 *  @returns {*} Cell data
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetCellData(settings, rowIdx, colIdx, type) {
	                    var draw = settings.iDraw;
	                    var col = settings.aoColumns[colIdx];
	                    var rowData = settings.aoData[rowIdx]._aData;
	                    var defaultContent = col.sDefaultContent;
	                    var cellData = col.fnGetData(rowData, type, {
	                        settings: settings,
	                        row: rowIdx,
	                        col: colIdx
	                    });

	                    if (cellData === undefined) {
	                        if (settings.iDrawError != draw && defaultContent === null) {
	                            _fnLog(settings, 0, "Requested unknown parameter " +
	                                (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") +
	                                " for row " + rowIdx, 4);
	                            settings.iDrawError = draw;
	                        }
	                        return defaultContent;
	                    }

	                    /* When the data source is null, we can use default column data */
	                    if ((cellData === rowData || cellData === null) && defaultContent !== null) {
	                        cellData = defaultContent;
	                    }
	                    else if (typeof cellData === 'function') {
	                        // If the data source is a function, then we run it and use the return,
	                        // executing in the scope of the data object (for instances)
	                        return cellData.call(rowData);
	                    }

	                    if (cellData === null && type == 'display') {
	                        return '';
	                    }
	                    return cellData;
	                }


	                /**
	                 * Set the value for a specific cell, into the internal data cache
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} rowIdx aoData row id
	                 *  @param {int} colIdx Column index
	                 *  @param {*} val Value to set
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSetCellData(settings, rowIdx, colIdx, val) {
	                    var col = settings.aoColumns[colIdx];
	                    var rowData = settings.aoData[rowIdx]._aData;

	                    col.fnSetData(rowData, val, {
	                        settings: settings,
	                        row: rowIdx,
	                        col: colIdx
	                    });
	                }


	                // Private variable that is used to match action syntax in the data property object
	                var __reArray = /\[.*?\]$/;
	                var __reFn = /\(\)$/;

	                /**
	                 * Split string on periods, taking into account escaped periods
	                 * @param  {string} str String to split
	                 * @return {array} Split string
	                 */
	                function _fnSplitObjNotation(str) {
	                    return $.map(str.match(/(\\.|[^\.])+/g), function (s) {
	                        return s.replace(/\\./g, '.');
	                    });
	                }


	                /**
	                 * Return a function that can be used to get data from a source object, taking
	                 * into account the ability to use nested objects as a source
	                 *  @param {string|int|function} mSource The data source for the object
	                 *  @returns {function} Data get function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetObjectDataFn(mSource) {
	                    if ($.isPlainObject(mSource)) {
	                        /* Build an object of get functions, and wrap them in a single call */
	                        var o = {};
	                        $.each(mSource, function (key, val) {
	                            if (val) {
	                                o[key] = _fnGetObjectDataFn(val);
	                            }
	                        });

	                        return function (data, type, row, meta) {
	                            var t = o[type] || o._;
	                            return t !== undefined ?
	                                t(data, type, row, meta) :
	                                data;
	                        };
	                    }
	                    else if (mSource === null) {
	                        /* Give an empty string for rendering / sorting etc */
	                        return function (data) { // type, row and meta also passed, but not used
	                            return data;
	                        };
	                    }
	                    else if (typeof mSource === 'function') {
	                        return function (data, type, row, meta) {
	                            return mSource(data, type, row, meta);
	                        };
	                    }
	                    else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
	                              mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
	                        /* If there is a . in the source string then the data source is in a
	                         * nested object so we loop over the data for each level to get the next
	                         * level down. On each loop we test for undefined, and if found immediately
	                         * return. This allows entire objects to be missing and sDefaultContent to
	                         * be used if defined, rather than throwing an error
	                         */
	                        var fetchData = function (data, type, src) {
	                            var arrayNotation, funcNotation, out, innerSrc;

	                            if (src !== "") {
	                                var a = _fnSplitObjNotation(src);

	                                for (var i = 0, iLen = a.length ; i < iLen ; i++) {
	                                    // Check if we are dealing with special notation
	                                    arrayNotation = a[i].match(__reArray);
	                                    funcNotation = a[i].match(__reFn);

	                                    if (arrayNotation) {
	                                        // Array notation
	                                        a[i] = a[i].replace(__reArray, '');

	                                        // Condition allows simply [] to be passed in
	                                        if (a[i] !== "") {
	                                            data = data[a[i]];
	                                        }
	                                        out = [];

	                                        // Get the remainder of the nested object to get
	                                        a.splice(0, i + 1);
	                                        innerSrc = a.join('.');

	                                        // Traverse each entry in the array getting the properties requested
	                                        for (var j = 0, jLen = data.length ; j < jLen ; j++) {
	                                            out.push(fetchData(data[j], type, innerSrc));
	                                        }

	                                        // If a string is given in between the array notation indicators, that
	                                        // is used to join the strings together, otherwise an array is returned
	                                        var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
	                                        data = (join === "") ? out : out.join(join);

	                                        // The inner call to fetchData has already traversed through the remainder
	                                        // of the source requested, so we exit from the loop
	                                        break;
	                                    }
	                                    else if (funcNotation) {
	                                        // Function call
	                                        a[i] = a[i].replace(__reFn, '');
	                                        data = data[a[i]]();
	                                        continue;
	                                    }

	                                    if (data === null || data[a[i]] === undefined) {
	                                        return undefined;
	                                    }
	                                    data = data[a[i]];
	                                }
	                            }

	                            return data;
	                        };

	                        return function (data, type) { // row and meta also passed, but not used
	                            return fetchData(data, type, mSource);
	                        };
	                    }
	                    else {
	                        /* Array or flat object mapping */
	                        return function (data, type) { // row and meta also passed, but not used
	                            return data[mSource];
	                        };
	                    }
	                }


	                /**
	                 * Return a function that can be used to set data from a source object, taking
	                 * into account the ability to use nested objects as a source
	                 *  @param {string|int|function} mSource The data source for the object
	                 *  @returns {function} Data set function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSetObjectDataFn(mSource) {
	                    if ($.isPlainObject(mSource)) {
	                        /* Unlike get, only the underscore (global) option is used for for
	                         * setting data since we don't know the type here. This is why an object
	                         * option is not documented for `mData` (which is read/write), but it is
	                         * for `mRender` which is read only.
	                         */
	                        return _fnSetObjectDataFn(mSource._);
	                    }
	                    else if (mSource === null) {
	                        /* Nothing to do when the data source is null */
	                        return function () { };
	                    }
	                    else if (typeof mSource === 'function') {
	                        return function (data, val, meta) {
	                            mSource(data, 'set', val, meta);
	                        };
	                    }
	                    else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
	                              mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
	                        /* Like the get, we need to get data from a nested object */
	                        var setData = function (data, val, src) {
	                            var a = _fnSplitObjNotation(src), b;
	                            var aLast = a[a.length - 1];
	                            var arrayNotation, funcNotation, o, innerSrc;

	                            for (var i = 0, iLen = a.length - 1 ; i < iLen ; i++) {
	                                // Check if we are dealing with an array notation request
	                                arrayNotation = a[i].match(__reArray);
	                                funcNotation = a[i].match(__reFn);

	                                if (arrayNotation) {
	                                    a[i] = a[i].replace(__reArray, '');
	                                    data[a[i]] = [];

	                                    // Get the remainder of the nested object to set so we can recurse
	                                    b = a.slice();
	                                    b.splice(0, i + 1);
	                                    innerSrc = b.join('.');

	                                    // Traverse each entry in the array setting the properties requested
	                                    for (var j = 0, jLen = val.length ; j < jLen ; j++) {
	                                        o = {};
	                                        setData(o, val[j], innerSrc);
	                                        data[a[i]].push(o);
	                                    }

	                                    // The inner call to setData has already traversed through the remainder
	                                    // of the source and has set the data, thus we can exit here
	                                    return;
	                                }
	                                else if (funcNotation) {
	                                    // Function call
	                                    a[i] = a[i].replace(__reFn, '');
	                                    data = data[a[i]](val);
	                                }

	                                // If the nested object doesn't currently exist - since we are
	                                // trying to set the value - create it
	                                if (data[a[i]] === null || data[a[i]] === undefined) {
	                                    data[a[i]] = {};
	                                }
	                                data = data[a[i]];
	                            }

	                            // Last item in the input - i.e, the actual set
	                            if (aLast.match(__reFn)) {
	                                // Function call
	                                data = data[aLast.replace(__reFn, '')](val);
	                            }
	                            else {
	                                // If array notation is used, we just want to strip it and use the property name
	                                // and assign the value. If it isn't used, then we get the result we want anyway
	                                data[aLast.replace(__reArray, '')] = val;
	                            }
	                        };

	                        return function (data, val) { // meta is also passed in, but not used
	                            return setData(data, val, mSource);
	                        };
	                    }
	                    else {
	                        /* Array or flat object mapping */
	                        return function (data, val) { // meta is also passed in, but not used
	                            data[mSource] = val;
	                        };
	                    }
	                }


	                /**
	                 * Return an array with the full table data
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns array {array} aData Master data array
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetDataMaster(settings) {
	                    return _pluck(settings.aoData, '_aData');
	                }


	                /**
	                 * Nuke the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnClearTable(settings) {
	                    settings.aoData.length = 0;
	                    settings.aiDisplayMaster.length = 0;
	                    settings.aiDisplay.length = 0;
	                }


	                /**
	                * Take an array of integers (index array) and remove a target integer (value - not
	                * the key!)
	                *  @param {array} a Index array to target
	                *  @param {int} iTarget value to find
	                *  @memberof DataTable#oApi
	                */
	                function _fnDeleteIndex(a, iTarget, splice) {
	                    var iTargetIndex = -1;

	                    for (var i = 0, iLen = a.length ; i < iLen ; i++) {
	                        if (a[i] == iTarget) {
	                            iTargetIndex = i;
	                        }
	                        else if (a[i] > iTarget) {
	                            a[i]--;
	                        }
	                    }

	                    if (iTargetIndex != -1 && splice === undefined) {
	                        a.splice(iTargetIndex, 1);
	                    }
	                }


	                /**
	                 * Mark cached data as invalid such that a re-read of the data will occur when
	                 * the cached data is next requested. Also update from the data source object.
	                 *
	                 * @param {object} settings DataTables settings object
	                 * @param {int}    rowIdx   Row index to invalidate
	                 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
	                 *     or 'data'
	                 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
	                 *     row will be invalidated
	                 * @memberof DataTable#oApi
	                 *
	                 * @todo For the modularisation of v1.11 this will need to become a callback, so
	                 *   the sort and filter methods can subscribe to it. That will required
	                 *   initialisation options for sorting, which is why it is not already baked in
	                 */
	                function _fnInvalidate(settings, rowIdx, src, colIdx) {
	                    var row = settings.aoData[rowIdx];
	                    var i, ien;
	                    var cellWrite = function (cell, col) {
	                        // This is very frustrating, but in IE if you just write directly
	                        // to innerHTML, and elements that are overwritten are GC'ed,
	                        // even if there is a reference to them elsewhere
	                        while (cell.childNodes.length) {
	                            cell.removeChild(cell.firstChild);
	                        }

	                        cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
	                    };

	                    // Are we reading last data from DOM or the data object?
	                    if (src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {
	                        // Read the data from the DOM
	                        row._aData = _fnGetRowElements(
	                                settings, row, colIdx, colIdx === undefined ? undefined : row._aData
	                            )
	                            .data;
	                    }
	                    else {
	                        // Reading from data object, update the DOM
	                        var cells = row.anCells;

	                        if (cells) {
	                            if (colIdx !== undefined) {
	                                cellWrite(cells[colIdx], colIdx);
	                            }
	                            else {
	                                for (i = 0, ien = cells.length ; i < ien ; i++) {
	                                    cellWrite(cells[i], i);
	                                }
	                            }
	                        }
	                    }

	                    // For both row and cell invalidation, the cached data for sorting and
	                    // filtering is nulled out
	                    row._aSortData = null;
	                    row._aFilterData = null;

	                    // Invalidate the type for a specific column (if given) or all columns since
	                    // the data might have changed
	                    var cols = settings.aoColumns;
	                    if (colIdx !== undefined) {
	                        cols[colIdx].sType = null;
	                    }
	                    else {
	                        for (i = 0, ien = cols.length ; i < ien ; i++) {
	                            cols[i].sType = null;
	                        }

	                        // Update DataTables special `DT_*` attributes for the row
	                        _fnRowAttributes(row);
	                    }
	                }


	                /**
	                 * Build a data source object from an HTML row, reading the contents of the
	                 * cells that are in the row.
	                 *
	                 * @param {object} settings DataTables settings object
	                 * @param {node|object} TR element from which to read data or existing row
	                 *   object from which to re-read the data from the cells
	                 * @param {int} [colIdx] Optional column index
	                 * @param {array|object} [d] Data source object. If `colIdx` is given then this
	                 *   parameter should also be given and will be used to write the data into.
	                 *   Only the column in question will be written
	                 * @returns {object} Object with two parameters: `data` the data read, in
	                 *   document order, and `cells` and array of nodes (they can be useful to the
	                 *   caller, so rather than needing a second traversal to get them, just return
	                 *   them from here).
	                 * @memberof DataTable#oApi
	                 */
	                function _fnGetRowElements(settings, row, colIdx, d) {
	                    var
	                        tds = [],
	                        td = row.firstChild,
	                        name, col, o, i = 0, contents,
	                        columns = settings.aoColumns,
	                        objectRead = settings._rowReadObject;

	                    // Allow the data object to be passed in, or construct
	                    d = d || objectRead ? {} : [];

	                    var attr = function (str, td) {
	                        if (typeof str === 'string') {
	                            var idx = str.indexOf('@');

	                            if (idx !== -1) {
	                                var attr = str.substring(idx + 1);
	                                var setter = _fnSetObjectDataFn(str);
	                                setter(d, td.getAttribute(attr));
	                            }
	                        }
	                    };

	                    // Read data from a cell and store into the data object
	                    var cellProcess = function (cell) {
	                        if (colIdx === undefined || colIdx === i) {
	                            col = columns[i];
	                            contents = $.trim(cell.innerHTML);

	                            if (col && col._bAttrSrc) {
	                                var setter = _fnSetObjectDataFn(col.mData._);
	                                setter(d, contents);

	                                attr(col.mData.sort, cell);
	                                attr(col.mData.type, cell);
	                                attr(col.mData.filter, cell);
	                            }
	                            else {
	                                // Depending on the `data` option for the columns the data can
	                                // be read to either an object or an array.
	                                if (objectRead) {
	                                    if (!col._setter) {
	                                        // Cache the setter function
	                                        col._setter = _fnSetObjectDataFn(col.mData);
	                                    }
	                                    col._setter(d, contents);
	                                }
	                                else {
	                                    d[i] = contents;
	                                }
	                            }
	                        }

	                        i++;
	                    };

	                    if (td) {
	                        // `tr` element was passed in
	                        while (td) {
	                            name = td.nodeName.toUpperCase();

	                            if (name == "TD" || name == "TH") {
	                                cellProcess(td);
	                                tds.push(td);
	                            }

	                            td = td.nextSibling;
	                        }
	                    }
	                    else {
	                        // Existing row object passed in
	                        tds = row.anCells;

	                        for (var j = 0, jen = tds.length ; j < jen ; j++) {
	                            cellProcess(tds[j]);
	                        }
	                    }

	                    return {
	                        data: d,
	                        cells: tds
	                    };
	                }
	                /**
	                 * Create a new TR element (and it's TD children) for a row
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {int} iRow Row to consider
	                 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
	                 *    DataTables will create a row automatically
	                 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	                 *    if nTr is.
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
	                    var
	                        row = oSettings.aoData[iRow],
	                        rowData = row._aData,
	                        cells = [],
	                        nTr, nTd, oCol,
	                        i, iLen;

	                    if (row.nTr === null) {
	                        nTr = nTrIn || document.createElement('tr');

	                        row.nTr = nTr;
	                        row.anCells = cells;

	                        /* Use a private property on the node to allow reserve mapping from the node
	                         * to the aoData array for fast look up
	                         */
	                        nTr._DT_RowIndex = iRow;

	                        /* Special parameters can be given by the data source to be used on the row */
	                        _fnRowAttributes(row);

	                        /* Process each column */
	                        for (i = 0, iLen = oSettings.aoColumns.length ; i < iLen ; i++) {
	                            oCol = oSettings.aoColumns[i];

	                            nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
	                            cells.push(nTd);

	                            // Need to create the HTML if new, or if a rendering function is defined
	                            if (!nTrIn || oCol.mRender || oCol.mData !== i) {
	                                nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
	                            }

	                            /* Add user defined class */
	                            if (oCol.sClass) {
	                                nTd.className += ' ' + oCol.sClass;
	                            }

	                            // Visibility - add or remove as required
	                            if (oCol.bVisible && !nTrIn) {
	                                nTr.appendChild(nTd);
	                            }
	                            else if (!oCol.bVisible && nTrIn) {
	                                nTd.parentNode.removeChild(nTd);
	                            }

	                            if (oCol.fnCreatedCell) {
	                                oCol.fnCreatedCell.call(oSettings.oInstance,
	                                    nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i
	                                );
	                            }
	                        }

	                        _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow]);
	                    }

	                    // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
	                    // and deployed
	                    row.nTr.setAttribute('role', 'row');
	                }


	                /**
	                 * Add attributes to a row based on the special `DT_*` parameters in a data
	                 * source object.
	                 *  @param {object} DataTables row object for the row to be modified
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnRowAttributes(row) {
	                    var tr = row.nTr;
	                    var data = row._aData;

	                    if (tr) {
	                        if (data.DT_RowId) {
	                            tr.id = data.DT_RowId;
	                        }

	                        if (data.DT_RowClass) {
	                            // Remove any classes added by DT_RowClass before
	                            var a = data.DT_RowClass.split(' ');
	                            row.__rowc = row.__rowc ?
	                                _unique(row.__rowc.concat(a)) :
	                                a;

	                            $(tr)
	                                .removeClass(row.__rowc.join(' '))
	                                .addClass(data.DT_RowClass);
	                        }

	                        if (data.DT_RowAttr) {
	                            $(tr).attr(data.DT_RowAttr);
	                        }

	                        if (data.DT_RowData) {
	                            $(tr).data(data.DT_RowData);
	                        }
	                    }
	                }


	                /**
	                 * Create the HTML header for the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnBuildHead(oSettings) {
	                    var i, ien, cell, row, column;
	                    var thead = oSettings.nTHead;
	                    var tfoot = oSettings.nTFoot;
	                    var createHeader = $('th, td', thead).length === 0;
	                    var classes = oSettings.oClasses;
	                    var columns = oSettings.aoColumns;

	                    if (createHeader) {
	                        row = $('<tr/>').appendTo(thead);
	                    }

	                    for (i = 0, ien = columns.length ; i < ien ; i++) {
	                        column = columns[i];
	                        cell = $(column.nTh).addClass(column.sClass);

	                        if (createHeader) {
	                            cell.appendTo(row);
	                        }

	                        // 1.11 move into sorting
	                        if (oSettings.oFeatures.bSort) {
	                            cell.addClass(column.sSortingClass);

	                            if (column.bSortable !== false) {
	                                cell
	                                    .attr('tabindex', oSettings.iTabIndex)
	                                    .attr('aria-controls', oSettings.sTableId);

	                                _fnSortAttachListener(oSettings, column.nTh, i);
	                            }
	                        }

	                        if (column.sTitle != cell.html()) {
	                            cell.html(column.sTitle);
	                        }

	                        _fnRenderer(oSettings, 'header')(
	                            oSettings, cell, column, classes
	                        );
	                    }

	                    if (createHeader) {
	                        _fnDetectHeader(oSettings.aoHeader, thead);
	                    }

	                    /* ARIA role for the rows */
	                    $(thead).find('>tr').attr('role', 'row');

	                    /* Deal with the footer - add classes if required */
	                    $(thead).find('>tr>th, >tr>td').addClass(classes.sHeaderTH);
	                    $(tfoot).find('>tr>th, >tr>td').addClass(classes.sFooterTH);

	                    // Cache the footer cells. Note that we only take the cells from the first
	                    // row in the footer. If there is more than one row the user wants to
	                    // interact with, they need to use the table().foot() method. Note also this
	                    // allows cells to be used for multiple columns using colspan
	                    if (tfoot !== null) {
	                        var cells = oSettings.aoFooter[0];

	                        for (i = 0, ien = cells.length ; i < ien ; i++) {
	                            column = columns[i];
	                            column.nTf = cells[i].cell;

	                            if (column.sClass) {
	                                $(column.nTf).addClass(column.sClass);
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Draw the header (or footer) element based on the column visibility states. The
	                 * methodology here is to use the layout array from _fnDetectHeader, modified for
	                 * the instantaneous column visibility, to construct the new layout. The grid is
	                 * traversed over cell at a time in a rows x columns grid fashion, although each
	                 * cell insert can cover multiple elements in the grid - which is tracks using the
	                 * aApplied array. Cell inserts in the grid will only occur where there isn't
	                 * already a cell in that position.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param array {objects} aoSource Layout array from _fnDetectHeader
	                 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
	                    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
	                    var aoLocal = [];
	                    var aApplied = [];
	                    var iColumns = oSettings.aoColumns.length;
	                    var iRowspan, iColspan;

	                    if (!aoSource) {
	                        return;
	                    }

	                    if (bIncludeHidden === undefined) {
	                        bIncludeHidden = false;
	                    }

	                    /* Make a copy of the master layout array, but without the visible columns in it */
	                    for (i = 0, iLen = aoSource.length ; i < iLen ; i++) {
	                        aoLocal[i] = aoSource[i].slice();
	                        aoLocal[i].nTr = aoSource[i].nTr;

	                        /* Remove any columns which are currently hidden */
	                        for (j = iColumns - 1 ; j >= 0 ; j--) {
	                            if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
	                                aoLocal[i].splice(j, 1);
	                            }
	                        }

	                        /* Prep the applied array - it needs an element for each row */
	                        aApplied.push([]);
	                    }

	                    for (i = 0, iLen = aoLocal.length ; i < iLen ; i++) {
	                        nLocalTr = aoLocal[i].nTr;

	                        /* All cells are going to be replaced, so empty out the row */
	                        if (nLocalTr) {
	                            while ((n = nLocalTr.firstChild)) {
	                                nLocalTr.removeChild(n);
	                            }
	                        }

	                        for (j = 0, jLen = aoLocal[i].length ; j < jLen ; j++) {
	                            iRowspan = 1;
	                            iColspan = 1;

	                            /* Check to see if there is already a cell (row/colspan) covering our target
	                             * insert point. If there is, then there is nothing to do.
	                             */
	                            if (aApplied[i][j] === undefined) {
	                                nLocalTr.appendChild(aoLocal[i][j].cell);
	                                aApplied[i][j] = 1;

	                                /* Expand the cell to cover as many rows as needed */
	                                while (aoLocal[i + iRowspan] !== undefined &&
	                                        aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
	                                    aApplied[i + iRowspan][j] = 1;
	                                    iRowspan++;
	                                }

	                                /* Expand the cell to cover as many columns as needed */
	                                while (aoLocal[i][j + iColspan] !== undefined &&
	                                        aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
	                                    /* Must update the applied array over the rows for the columns */
	                                    for (k = 0 ; k < iRowspan ; k++) {
	                                        aApplied[i + k][j + iColspan] = 1;
	                                    }
	                                    iColspan++;
	                                }

	                                /* Do the actual expansion in the DOM */
	                                $(aoLocal[i][j].cell)
	                                    .attr('rowspan', iRowspan)
	                                    .attr('colspan', iColspan);
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Insert the required TR nodes into the table for display
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnDraw(oSettings) {
	                    /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
	                    var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);
	                    if ($.inArray(false, aPreDraw) !== -1) {
	                        _fnProcessingDisplay(oSettings, false);
	                        return;
	                    }

	                    var i, iLen, n;
	                    var anRows = [];
	                    var iRowCount = 0;
	                    var asStripeClasses = oSettings.asStripeClasses;
	                    var iStripes = asStripeClasses.length;
	                    var iOpenRows = oSettings.aoOpenRows.length;
	                    var oLang = oSettings.oLanguage;
	                    var iInitDisplayStart = oSettings.iInitDisplayStart;
	                    var bServerSide = _fnDataSource(oSettings) == 'ssp';
	                    var aiDisplay = oSettings.aiDisplay;

	                    oSettings.bDrawing = true;

	                    /* Check and see if we have an initial draw position from state saving */
	                    if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
	                        oSettings._iDisplayStart = bServerSide ?
	                            iInitDisplayStart :
	                            iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
	                                0 :
	                                iInitDisplayStart;

	                        oSettings.iInitDisplayStart = -1;
	                    }

	                    var iDisplayStart = oSettings._iDisplayStart;
	                    var iDisplayEnd = oSettings.fnDisplayEnd();

	                    /* Server-side processing draw intercept */
	                    if (oSettings.bDeferLoading) {
	                        oSettings.bDeferLoading = false;
	                        oSettings.iDraw++;
	                        _fnProcessingDisplay(oSettings, false);
	                    }
	                    else if (!bServerSide) {
	                        oSettings.iDraw++;
	                    }
	                    else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
	                        return;
	                    }

	                    if (aiDisplay.length !== 0) {
	                        var iStart = bServerSide ? 0 : iDisplayStart;
	                        var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

	                        for (var j = iStart ; j < iEnd ; j++) {
	                            var iDataIndex = aiDisplay[j];
	                            var aoData = oSettings.aoData[iDataIndex];
	                            if (aoData.nTr === null) {
	                                _fnCreateTr(oSettings, iDataIndex);
	                            }

	                            var nRow = aoData.nTr;

	                            /* Remove the old striping classes and then add the new one */
	                            if (iStripes !== 0) {
	                                var sStripe = asStripeClasses[iRowCount % iStripes];
	                                if (aoData._sRowStripe != sStripe) {
	                                    $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
	                                    aoData._sRowStripe = sStripe;
	                                }
	                            }

	                            // Row callback functions - might want to manipulate the row
	                            // iRowCount and j are not currently documented. Are they at all
	                            // useful?
	                            _fnCallbackFire(oSettings, 'aoRowCallback', null,
	                                [nRow, aoData._aData, iRowCount, j]);

	                            anRows.push(nRow);
	                            iRowCount++;
	                        }
	                    }
	                    else {
	                        /* Table is empty - create a row with an empty message in it */
	                        var sZero = oLang.sZeroRecords;
	                        if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
	                            sZero = oLang.sLoadingRecords;
	                        }
	                        else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
	                            sZero = oLang.sEmptyTable;
	                        }

	                        anRows[0] = $('<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' })
	                            .append($('<td />', {
	                                'valign': 'top',
	                                'colSpan': _fnVisbleColumns(oSettings),
	                                'class': oSettings.oClasses.sRowEmpty
	                            }).html(sZero))[0];
	                    }

	                    /* Header and footer callbacks */
	                    _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0],
	                        _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

	                    _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0],
	                        _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

	                    var body = $(oSettings.nTBody);

	                    body.children().detach();
	                    body.append($(anRows));

	                    /* Call all required callback functions for the end of a draw */
	                    _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);

	                    /* Draw is complete, sorting and filtering must be as well */
	                    oSettings.bSorted = false;
	                    oSettings.bFiltered = false;
	                    oSettings.bDrawing = false;
	                }


	                /**
	                 * Redraw the table - taking account of the various features which are enabled
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {boolean} [holdPosition] Keep the current paging position. By default
	                 *    the paging is reset to the first page
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnReDraw(settings, holdPosition) {
	                    var
	                        features = settings.oFeatures,
	                        sort = features.bSort,
	                        filter = features.bFilter;

	                    if (sort) {
	                        _fnSort(settings);
	                    }

	                    if (filter) {
	                        _fnFilterComplete(settings, settings.oPreviousSearch);
	                    }
	                    else {
	                        // No filtering, so we want to just use the display master
	                        settings.aiDisplay = settings.aiDisplayMaster.slice();
	                    }

	                    if (holdPosition !== true) {
	                        settings._iDisplayStart = 0;
	                    }

	                    // Let any modules know about the draw hold position state (used by
	                    // scrolling internally)
	                    settings._drawHold = holdPosition;

	                    _fnDraw(settings);

	                    settings._drawHold = false;
	                }


	                /**
	                 * Add the options to the page HTML for the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAddOptionsHtml(oSettings) {
	                    var classes = oSettings.oClasses;
	                    var table = $(oSettings.nTable);
	                    var holding = $('<div/>').insertBefore(table); // Holding element for speed
	                    var features = oSettings.oFeatures;

	                    // All DataTables are wrapped in a div
	                    var insert = $('<div/>', {
	                        id: oSettings.sTableId + '_wrapper',
	                        'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
	                    });

	                    oSettings.nHolding = holding[0];
	                    oSettings.nTableWrapper = insert[0];
	                    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

	                    /* Loop over the user set positioning and place the elements as needed */
	                    var aDom = oSettings.sDom.split('');
	                    var featureNode, cOption, nNewNode, cNext, sAttr, j;
	                    for (var i = 0 ; i < aDom.length ; i++) {
	                        featureNode = null;
	                        cOption = aDom[i];

	                        if (cOption == '<') {
	                            /* New container div */
	                            nNewNode = $('<div/>')[0];

	                            /* Check to see if we should append an id and/or a class name to the container */
	                            cNext = aDom[i + 1];
	                            if (cNext == "'" || cNext == '"') {
	                                sAttr = "";
	                                j = 2;
	                                while (aDom[i + j] != cNext) {
	                                    sAttr += aDom[i + j];
	                                    j++;
	                                }

	                                /* Replace jQuery UI constants @todo depreciated */
	                                if (sAttr == "H") {
	                                    sAttr = classes.sJUIHeader;
	                                }
	                                else if (sAttr == "F") {
	                                    sAttr = classes.sJUIFooter;
	                                }

	                                /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
	                                 * breaks the string into parts and applies them as needed
	                                 */
	                                if (sAttr.indexOf('.') != -1) {
	                                    var aSplit = sAttr.split('.');
	                                    nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
	                                    nNewNode.className = aSplit[1];
	                                }
	                                else if (sAttr.charAt(0) == "#") {
	                                    nNewNode.id = sAttr.substr(1, sAttr.length - 1);
	                                }
	                                else {
	                                    nNewNode.className = sAttr;
	                                }

	                                i += j; /* Move along the position array */
	                            }

	                            insert.append(nNewNode);
	                            insert = $(nNewNode);
	                        }
	                        else if (cOption == '>') {
	                            /* End container div */
	                            insert = insert.parent();
	                        }
	                            // @todo Move options into their own plugins?
	                        else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
	                            /* Length */
	                            featureNode = _fnFeatureHtmlLength(oSettings);
	                        }
	                        else if (cOption == 'f' && features.bFilter) {
	                            /* Filter */
	                            featureNode = _fnFeatureHtmlFilter(oSettings);
	                        }
	                        else if (cOption == 'r' && features.bProcessing) {
	                            /* pRocessing */
	                            featureNode = _fnFeatureHtmlProcessing(oSettings);
	                        }
	                        else if (cOption == 't') {
	                            /* Table */
	                            featureNode = _fnFeatureHtmlTable(oSettings);
	                        }
	                        else if (cOption == 'i' && features.bInfo) {
	                            /* Info */
	                            featureNode = _fnFeatureHtmlInfo(oSettings);
	                        }
	                        else if (cOption == 'p' && features.bPaginate) {
	                            /* Pagination */
	                            featureNode = _fnFeatureHtmlPaginate(oSettings);
	                        }
	                        else if (DataTable.ext.feature.length !== 0) {
	                            /* Plug-in features */
	                            var aoFeatures = DataTable.ext.feature;
	                            for (var k = 0, kLen = aoFeatures.length ; k < kLen ; k++) {
	                                if (cOption == aoFeatures[k].cFeature) {
	                                    featureNode = aoFeatures[k].fnInit(oSettings);
	                                    break;
	                                }
	                            }
	                        }

	                        /* Add to the 2D features array */
	                        if (featureNode) {
	                            var aanFeatures = oSettings.aanFeatures;

	                            if (!aanFeatures[cOption]) {
	                                aanFeatures[cOption] = [];
	                            }

	                            aanFeatures[cOption].push(featureNode);
	                            insert.append(featureNode);
	                        }
	                    }

	                    /* Built our DOM structure - replace the holding div with what we want */
	                    holding.replaceWith(insert);
	                }


	                /**
	                 * Use the DOM source to create up an array of header cells. The idea here is to
	                 * create a layout grid (array) of rows x columns, which contains a reference
	                 * to the cell that that point in the grid (regardless of col/rowspan), such that
	                 * any column / row could be removed and the new grid constructed
	                 *  @param array {object} aLayout Array to store the calculated layout in
	                 *  @param {node} nThead The header/footer element for the table
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnDetectHeader(aLayout, nThead) {
	                    var nTrs = $(nThead).children('tr');
	                    var nTr, nCell;
	                    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
	                    var bUnique;
	                    var fnShiftCol = function (a, i, j) {
	                        var k = a[i];
	                        while (k[j]) {
	                            j++;
	                        }
	                        return j;
	                    };

	                    aLayout.splice(0, aLayout.length);

	                    /* We know how many rows there are in the layout - so prep it */
	                    for (i = 0, iLen = nTrs.length ; i < iLen ; i++) {
	                        aLayout.push([]);
	                    }

	                    /* Calculate a layout array */
	                    for (i = 0, iLen = nTrs.length ; i < iLen ; i++) {
	                        nTr = nTrs[i];
	                        iColumn = 0;

	                        /* For every cell in the row... */
	                        nCell = nTr.firstChild;
	                        while (nCell) {
	                            if (nCell.nodeName.toUpperCase() == "TD" ||
	                                 nCell.nodeName.toUpperCase() == "TH") {
	                                /* Get the col and rowspan attributes from the DOM and sanitise them */
	                                iColspan = nCell.getAttribute('colspan') * 1;
	                                iRowspan = nCell.getAttribute('rowspan') * 1;
	                                iColspan = (!iColspan || iColspan === 0 || iColspan === 1) ? 1 : iColspan;
	                                iRowspan = (!iRowspan || iRowspan === 0 || iRowspan === 1) ? 1 : iRowspan;

	                                /* There might be colspan cells already in this row, so shift our target
	                                 * accordingly
	                                 */
	                                iColShifted = fnShiftCol(aLayout, i, iColumn);

	                                /* Cache calculation for unique columns */
	                                bUnique = iColspan === 1 ? true : false;

	                                /* If there is col / rowspan, copy the information into the layout grid */
	                                for (l = 0 ; l < iColspan ; l++) {
	                                    for (k = 0 ; k < iRowspan ; k++) {
	                                        aLayout[i + k][iColShifted + l] = {
	                                            "cell": nCell,
	                                            "unique": bUnique
	                                        };
	                                        aLayout[i + k].nTr = nTr;
	                                    }
	                                }
	                            }
	                            nCell = nCell.nextSibling;
	                        }
	                    }
	                }


	                /**
	                 * Get an array of unique th elements, one for each column
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {node} nHeader automatically detect the layout from this node - optional
	                 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
	                 *  @returns array {node} aReturn list of unique th's
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
	                    var aReturn = [];
	                    if (!aLayout) {
	                        aLayout = oSettings.aoHeader;
	                        if (nHeader) {
	                            aLayout = [];
	                            _fnDetectHeader(aLayout, nHeader);
	                        }
	                    }

	                    for (var i = 0, iLen = aLayout.length ; i < iLen ; i++) {
	                        for (var j = 0, jLen = aLayout[i].length ; j < jLen ; j++) {
	                            if (aLayout[i][j].unique &&
	                                 (!aReturn[j] || !oSettings.bSortCellsTop)) {
	                                aReturn[j] = aLayout[i][j].cell;
	                            }
	                        }
	                    }

	                    return aReturn;
	                }

	                /**
	                 * Create an Ajax call based on the table's settings, taking into account that
	                 * parameters can have multiple forms, and backwards compatibility.
	                 *
	                 * @param {object} oSettings dataTables settings object
	                 * @param {array} data Data to send to the server, required by
	                 *     DataTables - may be augmented by developer callbacks
	                 * @param {function} fn Callback function to run when data is obtained
	                 */
	                function _fnBuildAjax(oSettings, data, fn) {
	                    // Compatibility with 1.9-, allow fnServerData and event to manipulate
	                    _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]);

	                    // Convert to object based for 1.10+ if using the old array scheme which can
	                    // come from server-side processing or serverParams
	                    if (data && $.isArray(data)) {
	                        var tmp = {};
	                        var rbracket = /(.*?)\[\]$/;

	                        $.each(data, function (key, val) {
	                            var match = val.name.match(rbracket);

	                            if (match) {
	                                // Support for arrays
	                                var name = match[0];

	                                if (!tmp[name]) {
	                                    tmp[name] = [];
	                                }
	                                tmp[name].push(val.value);
	                            }
	                            else {
	                                tmp[val.name] = val.value;
	                            }
	                        });
	                        data = tmp;
	                    }

	                    var ajaxData;
	                    var ajax = oSettings.ajax;
	                    var instance = oSettings.oInstance;
	                    var callback = function (json) {
	                        _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);
	                        fn(json);
	                    };

	                    if ($.isPlainObject(ajax) && ajax.data) {
	                        ajaxData = ajax.data;

	                        var newData = $.isFunction(ajaxData) ?
	                            ajaxData(data, oSettings) :  // fn can manipulate data or return
	                            ajaxData;                      // an object object or array to merge

	                        // If the function returned something, use that alone
	                        data = $.isFunction(ajaxData) && newData ?
	                            newData :
	                            $.extend(true, data, newData);

	                        // Remove the data property as we've resolved it already and don't want
	                        // jQuery to do it again (it is restored at the end of the function)
	                        delete ajax.data;
	                    }

	                    var baseAjax = {
	                        "data": data,
	                        "success": function (json) {
	                            var error = json.error || json.sError;
	                            if (error) {
	                                _fnLog(oSettings, 0, error);
	                            }

	                            oSettings.json = json;
	                            callback(json);
	                        },
	                        "dataType": "json",
	                        "cache": false,
	                        "type": oSettings.sServerMethod,
	                        "error": function (xhr, error, thrown) {
	                            var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

	                            if ($.inArray(true, ret) === -1) {
	                                if (error == "parsererror") {
	                                    _fnLog(oSettings, 0, 'Invalid JSON response', 1);
	                                }
	                                else if (xhr.readyState === 4) {
	                                    _fnLog(oSettings, 0, 'Ajax error', 7);
	                                }
	                            }

	                            _fnProcessingDisplay(oSettings, false);
	                        }
	                    };

	                    // Store the data submitted for the API
	                    oSettings.oAjaxData = data;

	                    // Allow plug-ins and external processes to modify the data
	                    _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

	                    if (oSettings.fnServerData) {
	                        // DataTables 1.9- compatibility
	                        oSettings.fnServerData.call(instance,
	                            oSettings.sAjaxSource,
	                            $.map(data, function (val, key) { // Need to convert back to 1.9 trad format
	                                return { name: key, value: val };
	                            }),
	                            callback,
	                            oSettings
	                        );
	                    }
	                    else if (oSettings.sAjaxSource || typeof ajax === 'string') {
	                        // DataTables 1.9- compatibility
	                        oSettings.jqXHR = $.ajax($.extend(baseAjax, {
	                            url: ajax || oSettings.sAjaxSource
	                        }));
	                    }
	                    else if ($.isFunction(ajax)) {
	                        // Is a function - let the caller define what needs to be done
	                        oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
	                    }
	                    else {
	                        // Object to extend the base settings
	                        oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax));

	                        // Restore for next time around
	                        ajax.data = ajaxData;
	                    }
	                }


	                /**
	                 * Update the table using an Ajax call
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {boolean} Block the table drawing or not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAjaxUpdate(settings) {
	                    if (settings.bAjaxDataGet) {
	                        settings.iDraw++;
	                        _fnProcessingDisplay(settings, true);

	                        _fnBuildAjax(
	                            settings,
	                            _fnAjaxParameters(settings),
	                            function (json) {
	                                _fnAjaxUpdateDraw(settings, json);
	                            }
	                        );

	                        return false;
	                    }
	                    return true;
	                }


	                /**
	                 * Build up the parameters in an object needed for a server-side processing
	                 * request. Note that this is basically done twice, is different ways - a modern
	                 * method which is used by default in DataTables 1.10 which uses objects and
	                 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
	                 * the sAjaxSource option is used in the initialisation, or the legacyAjax
	                 * option is set.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {bool} block the table drawing or not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAjaxParameters(settings) {
	                    var
	                        columns = settings.aoColumns,
	                        columnCount = columns.length,
	                        features = settings.oFeatures,
	                        preSearch = settings.oPreviousSearch,
	                        preColSearch = settings.aoPreSearchCols,
	                        i, data = [], dataProp, column, columnSearch,
	                        sort = _fnSortFlatten(settings),
	                        displayStart = settings._iDisplayStart,
	                        displayLength = features.bPaginate !== false ?
	                            settings._iDisplayLength :
	                            -1;

	                    var param = function (name, value) {
	                        data.push({ 'name': name, 'value': value });
	                    };

	                    // DataTables 1.9- compatible method
	                    param('sEcho', settings.iDraw);
	                    param('iColumns', columnCount);
	                    param('sColumns', _pluck(columns, 'sName').join(','));
	                    param('iDisplayStart', displayStart);
	                    param('iDisplayLength', displayLength);

	                    // DataTables 1.10+ method
	                    var d = {
	                        draw: settings.iDraw,
	                        columns: [],
	                        order: [],
	                        start: displayStart,
	                        length: displayLength,
	                        search: {
	                            value: preSearch.sSearch,
	                            regex: preSearch.bRegex
	                        }
	                    };

	                    for (i = 0 ; i < columnCount ; i++) {
	                        column = columns[i];
	                        columnSearch = preColSearch[i];
	                        dataProp = typeof column.mData == "function" ? 'function' : column.mData;

	                        d.columns.push({
	                            data: dataProp,
	                            name: column.sName,
	                            searchable: column.bSearchable,
	                            orderable: column.bSortable,
	                            search: {
	                                value: columnSearch.sSearch,
	                                regex: columnSearch.bRegex
	                            }
	                        });

	                        param("mDataProp_" + i, dataProp);

	                        if (features.bFilter) {
	                            param('sSearch_' + i, columnSearch.sSearch);
	                            param('bRegex_' + i, columnSearch.bRegex);
	                            param('bSearchable_' + i, column.bSearchable);
	                        }

	                        if (features.bSort) {
	                            param('bSortable_' + i, column.bSortable);
	                        }
	                    }

	                    if (features.bFilter) {
	                        param('sSearch', preSearch.sSearch);
	                        param('bRegex', preSearch.bRegex);
	                    }

	                    if (features.bSort) {
	                        $.each(sort, function (i, val) {
	                            d.order.push({ column: val.col, dir: val.dir });

	                            param('iSortCol_' + i, val.col);
	                            param('sSortDir_' + i, val.dir);
	                        });

	                        param('iSortingCols', sort.length);
	                    }

	                    // If the legacy.ajax parameter is null, then we automatically decide which
	                    // form to use, based on sAjaxSource
	                    var legacy = DataTable.ext.legacy.ajax;
	                    if (legacy === null) {
	                        return settings.sAjaxSource ? data : d;
	                    }

	                    // Otherwise, if legacy has been specified then we use that to decide on the
	                    // form
	                    return legacy ? data : d;
	                }


	                /**
	                 * Data the data from the server (nuking the old) and redraw the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {object} json json data return from the server.
	                 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
	                 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
	                 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
	                 *  @param {array} json.aaData The data to display on this page
	                 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAjaxUpdateDraw(settings, json) {
	                    // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
	                    // Support both
	                    var compat = function (old, modern) {
	                        return json[old] !== undefined ? json[old] : json[modern];
	                    };

	                    var data = _fnAjaxDataSrc(settings, json);
	                    var draw = compat('sEcho', 'draw');
	                    var recordsTotal = compat('iTotalRecords', 'recordsTotal');
	                    var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

	                    if (draw) {
	                        // Protect against out of sequence returns
	                        if (draw * 1 < settings.iDraw) {
	                            return;
	                        }
	                        settings.iDraw = draw * 1;
	                    }

	                    _fnClearTable(settings);
	                    settings._iRecordsTotal = parseInt(recordsTotal, 10);
	                    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

	                    for (var i = 0, ien = data.length ; i < ien ; i++) {
	                        _fnAddData(settings, data[i]);
	                    }
	                    settings.aiDisplay = settings.aiDisplayMaster.slice();

	                    settings.bAjaxDataGet = false;
	                    _fnDraw(settings);

	                    if (!settings._bInitComplete) {
	                        _fnInitComplete(settings, json);
	                    }

	                    settings.bAjaxDataGet = true;
	                    _fnProcessingDisplay(settings, false);
	                }


	                /**
	                 * Get the data from the JSON data source to use for drawing a table. Using
	                 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
	                 * source object, or from a processing function.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param  {object} json Data source object / array from the server
	                 *  @return {array} Array of data to use
	                 */
	                function _fnAjaxDataSrc(oSettings, json) {
	                    var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ?
	                        oSettings.ajax.dataSrc :
	                        oSettings.sAjaxDataProp; // Compatibility with 1.9-.

	                    // Compatibility with 1.9-. In order to read from aaData, check if the
	                    // default has been changed, if not, check for aaData
	                    if (dataSrc === 'data') {
	                        return json.aaData || json[dataSrc];
	                    }

	                    return dataSrc !== "" ?
	                        _fnGetObjectDataFn(dataSrc)(json) :
	                        json;
	                }

	                /**
	                 * Generate the node required for filtering text
	                 *  @returns {node} Filter control element
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlFilter(settings) {
	                    var classes = settings.oClasses;
	                    var tableId = settings.sTableId;
	                    var language = settings.oLanguage;
	                    var previousSearch = settings.oPreviousSearch;
	                    var features = settings.aanFeatures;
	                    var input = '<input type="search" class="' + classes.sFilterInput + '"/>';

	                    var str = language.sSearch;
	                    str = str.match(/_INPUT_/) ?
	                        str.replace('_INPUT_', input) :
	                        str + input;

	                    var filter = $('<div/>', {
	                        'id': !features.f ? tableId + '_filter' : null,
	                        'class': classes.sFilter
	                    })
	                        .append($('<label/>').append(str));

	                    var searchFn = function () {
	                        /* Update all other filter input elements for the new display */
	                        var n = features.f;
	                        var val = !this.value ? "" : this.value; // mental IE8 fix :-(

	                        /* Now do the filter */
	                        if (val != previousSearch.sSearch) {
	                            _fnFilterComplete(settings, {
	                                "sSearch": val,
	                                "bRegex": previousSearch.bRegex,
	                                "bSmart": previousSearch.bSmart,
	                                "bCaseInsensitive": previousSearch.bCaseInsensitive
	                            });

	                            // Need to redraw, without resorting
	                            settings._iDisplayStart = 0;
	                            _fnDraw(settings);
	                        }
	                    };

	                    var searchDelay = settings.searchDelay !== null ?
	                        settings.searchDelay :
	                        _fnDataSource(settings) === 'ssp' ?
	                            400 :
	                            0;

	                    var jqFilter = $('input', filter)
	                        .val(previousSearch.sSearch)
	                        .attr('placeholder', language.sSearchPlaceholder)
	                        .bind(
	                            'keyup.DT search.DT input.DT paste.DT cut.DT',
	                            searchDelay ?
	                                _fnThrottle(searchFn, searchDelay) :
	                                searchFn
	                        )
	                        .bind('keypress.DT', function (e) {
	                            /* Prevent form submission */
	                            if (e.keyCode == 13) {
	                                return false;
	                            }
	                        })
	                        .attr('aria-controls', tableId);

	                    // Update the input elements whenever the table is filtered
	                    $(settings.nTable).on('search.dt.DT', function (ev, s) {
	                        if (settings === s) {
	                            // IE9 throws an 'unknown error' if document.activeElement is used
	                            // inside an iframe or frame...
	                            try {
	                                if (jqFilter[0] !== document.activeElement) {
	                                    jqFilter.val(previousSearch.sSearch);
	                                }
	                            }
	                            catch (e) { }
	                        }
	                    });

	                    return filter[0];
	                }


	                /**
	                 * Filter the table using both the global filter and column based filtering
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {object} oSearch search information
	                 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilterComplete(oSettings, oInput, iForce) {
	                    var oPrevSearch = oSettings.oPreviousSearch;
	                    var aoPrevSearch = oSettings.aoPreSearchCols;
	                    var fnSaveFilter = function (oFilter) {
	                        /* Save the filtering values */
	                        oPrevSearch.sSearch = oFilter.sSearch;
	                        oPrevSearch.bRegex = oFilter.bRegex;
	                        oPrevSearch.bSmart = oFilter.bSmart;
	                        oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
	                    };
	                    var fnRegex = function (o) {
	                        // Backwards compatibility with the bEscapeRegex option
	                        return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
	                    };

	                    // Resolve any column types that are unknown due to addition or invalidation
	                    // @todo As per sort - can this be moved into an event handler?
	                    _fnColumnTypes(oSettings);

	                    /* In server-side processing all filtering is done by the server, so no point hanging around here */
	                    if (_fnDataSource(oSettings) != 'ssp') {
	                        /* Global filter */
	                        _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
	                        fnSaveFilter(oInput);

	                        /* Now do the individual column filter */
	                        for (var i = 0 ; i < aoPrevSearch.length ; i++) {
	                            _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
	                                aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
	                        }

	                        /* Custom filtering */
	                        _fnFilterCustom(oSettings);
	                    }
	                    else {
	                        fnSaveFilter(oInput);
	                    }

	                    /* Tell the draw function we have been filtering */
	                    oSettings.bFiltered = true;
	                    _fnCallbackFire(oSettings, null, 'search', [oSettings]);
	                }


	                /**
	                 * Apply custom filtering functions
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilterCustom(settings) {
	                    var filters = DataTable.ext.search;
	                    var displayRows = settings.aiDisplay;
	                    var row, rowIdx;

	                    for (var i = 0, ien = filters.length ; i < ien ; i++) {
	                        var rows = [];

	                        // Loop over each row and see if it should be included
	                        for (var j = 0, jen = displayRows.length ; j < jen ; j++) {
	                            rowIdx = displayRows[j];
	                            row = settings.aoData[rowIdx];

	                            if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
	                                rows.push(rowIdx);
	                            }
	                        }

	                        // So the array reference doesn't break set the results into the
	                        // existing array
	                        displayRows.length = 0;
	                        displayRows.push.apply(displayRows, rows);
	                    }
	                }


	                /**
	                 * Filter the table on a per-column basis
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {string} sInput string to filter on
	                 *  @param {int} iColumn column to filter
	                 *  @param {bool} bRegex treat search string as a regular expression or not
	                 *  @param {bool} bSmart use smart filtering or not
	                 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
	                    if (searchStr === '') {
	                        return;
	                    }

	                    var data;
	                    var display = settings.aiDisplay;
	                    var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

	                    for (var i = display.length - 1 ; i >= 0 ; i--) {
	                        data = settings.aoData[display[i]]._aFilterData[colIdx];

	                        if (!rpSearch.test(data)) {
	                            display.splice(i, 1);
	                        }
	                    }
	                }


	                /**
	                 * Filter the data table based on user input and draw the table
	                 *  @param {object} settings dataTables settings object
	                 *  @param {string} input string to filter on
	                 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
	                 *  @param {bool} regex treat as a regular expression or not
	                 *  @param {bool} smart perform smart filtering or not
	                 *  @param {bool} caseInsensitive Do case insenstive matching or not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
	                    var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
	                    var prevSearch = settings.oPreviousSearch.sSearch;
	                    var displayMaster = settings.aiDisplayMaster;
	                    var display, invalidated, i;

	                    // Need to take account of custom filtering functions - always filter
	                    if (DataTable.ext.search.length !== 0) {
	                        force = true;
	                    }

	                    // Check if any of the rows were invalidated
	                    invalidated = _fnFilterData(settings);

	                    // If the input is blank - we just want the full data set
	                    if (input.length <= 0) {
	                        settings.aiDisplay = displayMaster.slice();
	                    }
	                    else {
	                        // New search - start from the master array
	                        if (invalidated ||
	                             force ||
	                             prevSearch.length > input.length ||
	                             input.indexOf(prevSearch) !== 0 ||
	                             settings.bSorted // On resort, the display master needs to be
	                            // re-filtered since indexes will have changed
	                        ) {
	                            settings.aiDisplay = displayMaster.slice();
	                        }

	                        // Search the display array
	                        display = settings.aiDisplay;

	                        for (i = display.length - 1 ; i >= 0 ; i--) {
	                            if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
	                                display.splice(i, 1);
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Build a regular expression object suitable for searching a table
	                 *  @param {string} sSearch string to search for
	                 *  @param {bool} bRegex treat as a regular expression or not
	                 *  @param {bool} bSmart perform smart filtering or not
	                 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	                 *  @returns {RegExp} constructed object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
	                    search = regex ?
	                        search :
	                        _fnEscapeRegex(search);

	                    if (smart) {
	                        /* For smart filtering we want to allow the search to work regardless of
	                         * word order. We also want double quoted text to be preserved, so word
	                         * order is important - a la google. So this is what we want to
	                         * generate:
	                         * 
	                         * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
	                         */
	                        var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
	                            if (word.charAt(0) === '"') {
	                                var m = word.match(/^"(.*)"$/);
	                                word = m ? m[1] : word;
	                            }

	                            return word.replace('"', '');
	                        });

	                        search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
	                    }

	                    return new RegExp(search, caseInsensitive ? 'i' : '');
	                }


	                /**
	                 * Escape a string such that it can be used in a regular expression
	                 *  @param {string} sVal string to escape
	                 *  @returns {string} escaped string
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnEscapeRegex(sVal) {
	                    return sVal.replace(_re_escape_regex, '\\$1');
	                }



	                var __filter_div = $('<div>')[0];
	                var __filter_div_textContent = __filter_div.textContent !== undefined;

	                // Update the filtering data for each row if needed (by invalidation or first run)
	                function _fnFilterData(settings) {
	                    var columns = settings.aoColumns;
	                    var column;
	                    var i, j, ien, jen, filterData, cellData, row;
	                    var fomatters = DataTable.ext.type.search;
	                    var wasInvalidated = false;

	                    for (i = 0, ien = settings.aoData.length ; i < ien ; i++) {
	                        row = settings.aoData[i];

	                        if (!row._aFilterData) {
	                            filterData = [];

	                            for (j = 0, jen = columns.length ; j < jen ; j++) {
	                                column = columns[j];

	                                if (column.bSearchable) {
	                                    cellData = _fnGetCellData(settings, i, j, 'filter');

	                                    if (fomatters[column.sType]) {
	                                        cellData = fomatters[column.sType](cellData);
	                                    }

	                                    // Search in DataTables 1.10 is string based. In 1.11 this
	                                    // should be altered to also allow strict type checking.
	                                    if (cellData === null) {
	                                        cellData = '';
	                                    }

	                                    if (typeof cellData !== 'string' && cellData.toString) {
	                                        cellData = cellData.toString();
	                                    }
	                                }
	                                else {
	                                    cellData = '';
	                                }

	                                // If it looks like there is an HTML entity in the string,
	                                // attempt to decode it so sorting works as expected. Note that
	                                // we could use a single line of jQuery to do this, but the DOM
	                                // method used here is much faster http://jsperf.com/html-decode
	                                if (cellData.indexOf && cellData.indexOf('&') !== -1) {
	                                    __filter_div.innerHTML = cellData;
	                                    cellData = __filter_div_textContent ?
	                                        __filter_div.textContent :
	                                        __filter_div.innerText;
	                                }

	                                if (cellData.replace) {
	                                    cellData = cellData.replace(/[\r\n]/g, '');
	                                }

	                                filterData.push(cellData);
	                            }

	                            row._aFilterData = filterData;
	                            row._sFilterRow = filterData.join('  ');
	                            wasInvalidated = true;
	                        }
	                    }

	                    return wasInvalidated;
	                }


	                /**
	                 * Convert from the internal Hungarian notation to camelCase for external
	                 * interaction
	                 *  @param {object} obj Object to convert
	                 *  @returns {object} Inverted object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSearchToCamel(obj) {
	                    return {
	                        search: obj.sSearch,
	                        smart: obj.bSmart,
	                        regex: obj.bRegex,
	                        caseInsensitive: obj.bCaseInsensitive
	                    };
	                }



	                /**
	                 * Convert from camelCase notation to the internal Hungarian. We could use the
	                 * Hungarian convert function here, but this is cleaner
	                 *  @param {object} obj Object to convert
	                 *  @returns {object} Inverted object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSearchToHung(obj) {
	                    return {
	                        sSearch: obj.search,
	                        bSmart: obj.smart,
	                        bRegex: obj.regex,
	                        bCaseInsensitive: obj.caseInsensitive
	                    };
	                }

	                /**
	                 * Generate the node required for the info display
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {node} Information element
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlInfo(settings) {
	                    var
	                        tid = settings.sTableId,
	                        nodes = settings.aanFeatures.i,
	                        n = $('<div/>', {
	                            'class': settings.oClasses.sInfo,
	                            'id': !nodes ? tid + '_info' : null
	                        });

	                    if (!nodes) {
	                        // Update display on each draw
	                        settings.aoDrawCallback.push({
	                            "fn": _fnUpdateInfo,
	                            "sName": "information"
	                        });

	                        n
	                            .attr('role', 'status')
	                            .attr('aria-live', 'polite');

	                        // Table is described by our info div
	                        $(settings.nTable).attr('aria-describedby', tid + '_info');
	                    }

	                    return n[0];
	                }


	                /**
	                 * Update the information elements in the display
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnUpdateInfo(settings) {
	                    /* Show information about the table */
	                    var nodes = settings.aanFeatures.i;
	                    if (nodes.length === 0) {
	                        return;
	                    }

	                    var
	                        lang = settings.oLanguage,
	                        start = settings._iDisplayStart + 1,
	                        end = settings.fnDisplayEnd(),
	                        max = settings.fnRecordsTotal(),
	                        total = settings.fnRecordsDisplay(),
	                        out = total ?
	                            lang.sInfo :
	                            lang.sInfoEmpty;

	                    if (total !== max) {
	                        /* Record set after filtering */
	                        out += ' ' + lang.sInfoFiltered;
	                    }

	                    // Convert the macros
	                    out += lang.sInfoPostFix;
	                    out = _fnInfoMacros(settings, out);

	                    var callback = lang.fnInfoCallback;
	                    if (callback !== null) {
	                        out = callback.call(settings.oInstance,
	                            settings, start, end, max, total, out
	                        );
	                    }

	                    $(nodes).html(out);
	                }


	                function _fnInfoMacros(settings, str) {
	                    // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
	                    // internally
	                    var
	                        formatter = settings.fnFormatNumber,
	                        start = settings._iDisplayStart + 1,
	                        len = settings._iDisplayLength,
	                        vis = settings.fnRecordsDisplay(),
	                        all = len === -1;

	                    return str.
	                        replace(/_START_/g, formatter.call(settings, start)).
	                        replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).
	                        replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).
	                        replace(/_TOTAL_/g, formatter.call(settings, vis)).
	                        replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).
	                        replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
	                }



	                /**
	                 * Draw the table for the first time, adding all required features
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnInitialise(settings) {
	                    var i, iLen, iAjaxStart = settings.iInitDisplayStart;
	                    var columns = settings.aoColumns, column;
	                    var features = settings.oFeatures;

	                    /* Ensure that the table data is fully initialised */
	                    if (!settings.bInitialised) {
	                        setTimeout(function () { _fnInitialise(settings); }, 200);
	                        return;
	                    }

	                    /* Show the display HTML options */
	                    _fnAddOptionsHtml(settings);

	                    /* Build and draw the header / footer for the table */
	                    _fnBuildHead(settings);
	                    _fnDrawHead(settings, settings.aoHeader);
	                    _fnDrawHead(settings, settings.aoFooter);

	                    /* Okay to show that something is going on now */
	                    _fnProcessingDisplay(settings, true);

	                    /* Calculate sizes for columns */
	                    if (features.bAutoWidth) {
	                        _fnCalculateColumnWidths(settings);
	                    }

	                    for (i = 0, iLen = columns.length ; i < iLen ; i++) {
	                        column = columns[i];

	                        if (column.sWidth) {
	                            column.nTh.style.width = _fnStringToCss(column.sWidth);
	                        }
	                    }

	                    // If there is default sorting required - let's do it. The sort function
	                    // will do the drawing for us. Otherwise we draw the table regardless of the
	                    // Ajax source - this allows the table to look initialised for Ajax sourcing
	                    // data (show 'loading' message possibly)
	                    _fnReDraw(settings);

	                    // Server-side processing init complete is done by _fnAjaxUpdateDraw
	                    var dataSrc = _fnDataSource(settings);
	                    if (dataSrc != 'ssp') {
	                        // if there is an ajax source load the data
	                        if (dataSrc == 'ajax') {
	                            _fnBuildAjax(settings, [], function (json) {
	                                var aData = _fnAjaxDataSrc(settings, json);

	                                // Got the data - add it to the table
	                                for (i = 0 ; i < aData.length ; i++) {
	                                    _fnAddData(settings, aData[i]);
	                                }

	                                // Reset the init display for cookie saving. We've already done
	                                // a filter, and therefore cleared it before. So we need to make
	                                // it appear 'fresh'
	                                settings.iInitDisplayStart = iAjaxStart;

	                                _fnReDraw(settings);

	                                _fnProcessingDisplay(settings, false);
	                                _fnInitComplete(settings, json);
	                            }, settings);
	                        }
	                        else {
	                            _fnProcessingDisplay(settings, false);
	                            _fnInitComplete(settings);
	                        }
	                    }
	                }


	                /**
	                 * Draw the table for the first time, adding all required features
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
	                 *    with client-side processing (optional)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnInitComplete(settings, json) {
	                    settings._bInitComplete = true;

	                    // On an Ajax load we now have data and therefore want to apply the column
	                    // sizing
	                    if (json) {
	                        _fnAdjustColumnSizing(settings);
	                    }

	                    _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
	                }


	                function _fnLengthChange(settings, val) {
	                    var len = parseInt(val, 10);
	                    settings._iDisplayLength = len;

	                    _fnLengthOverflow(settings);

	                    // Fire length change event
	                    _fnCallbackFire(settings, null, 'length', [settings, len]);
	                }


	                /**
	                 * Generate the node required for user display length changing
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {node} Display length feature node
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlLength(settings) {
	                    var
	                        classes = settings.oClasses,
	                        tableId = settings.sTableId,
	                        menu = settings.aLengthMenu,
	                        d2 = $.isArray(menu[0]),
	                        lengths = d2 ? menu[0] : menu,
	                        language = d2 ? menu[1] : menu;

	                    var select = $('<select/>', {
	                        'name': tableId + '_length',
	                        'aria-controls': tableId,
	                        'class': classes.sLengthSelect
	                    });

	                    for (var i = 0, ien = lengths.length ; i < ien ; i++) {
	                        select[0][i] = new Option(language[i], lengths[i]);
	                    }

	                    var div = $('<div><label/></div>').addClass(classes.sLength);
	                    if (!settings.aanFeatures.l) {
	                        div[0].id = tableId + '_length';
	                    }

	                    div.children().append(
	                        settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)
	                    );

	                    // Can't use `select` variable as user might provide their own and the
	                    // reference is broken by the use of outerHTML
	                    $('select', div)
	                        .val(settings._iDisplayLength)
	                        .bind('change.DT', function (e) {
	                            _fnLengthChange(settings, $(this).val());
	                            _fnDraw(settings);
	                        });

	                    // Update node value whenever anything changes the table's length
	                    $(settings.nTable).bind('length.dt.DT', function (e, s, len) {
	                        if (settings === s) {
	                            $('select', div).val(len);
	                        }
	                    });

	                    return div[0];
	                }



	                /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	                 * Note that most of the paging logic is done in
	                 * DataTable.ext.pager
	                 */

	                /**
	                 * Generate the node required for default pagination
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {node} Pagination feature node
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlPaginate(settings) {
	                    var
	                        type = settings.sPaginationType,
	                        plugin = DataTable.ext.pager[type],
	                        modern = typeof plugin === 'function',
	                        redraw = function (settings) {
	                            _fnDraw(settings);
	                        },
	                        node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
	                        features = settings.aanFeatures;

	                    if (!modern) {
	                        plugin.fnInit(settings, node, redraw);
	                    }

	                    /* Add a draw callback for the pagination on first instance, to update the paging display */
	                    if (!features.p) {
	                        node.id = settings.sTableId + '_paginate';

	                        settings.aoDrawCallback.push({
	                            "fn": function (settings) {
	                                if (modern) {
	                                    var
	                                        start = settings._iDisplayStart,
	                                        len = settings._iDisplayLength,
	                                        visRecords = settings.fnRecordsDisplay(),
	                                        all = len === -1,
	                                        page = all ? 0 : Math.ceil(start / len),
	                                        pages = all ? 1 : Math.ceil(visRecords / len),
	                                        buttons = plugin(page, pages),
	                                        i, ien;

	                                    for (i = 0, ien = features.p.length ; i < ien ; i++) {
	                                        _fnRenderer(settings, 'pageButton')(
	                                            settings, features.p[i], i, buttons, page, pages
	                                        );
	                                    }
	                                }
	                                else {
	                                    plugin.fnUpdate(settings, redraw);
	                                }
	                            },
	                            "sName": "pagination"
	                        });
	                    }

	                    return node;
	                }


	                /**
	                 * Alter the display settings to change the page
	                 *  @param {object} settings DataTables settings object
	                 *  @param {string|int} action Paging action to take: "first", "previous",
	                 *    "next" or "last" or page number to jump to (integer)
	                 *  @param [bool] redraw Automatically draw the update or not
	                 *  @returns {bool} true page has changed, false - no change
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnPageChange(settings, action, redraw) {
	                    var
	                        start = settings._iDisplayStart,
	                        len = settings._iDisplayLength,
	                        records = settings.fnRecordsDisplay();

	                    if (records === 0 || len === -1) {
	                        start = 0;
	                    }
	                    else if (typeof action === "number") {
	                        start = action * len;

	                        if (start > records) {
	                            start = 0;
	                        }
	                    }
	                    else if (action == "first") {
	                        start = 0;
	                    }
	                    else if (action == "previous") {
	                        start = len >= 0 ?
	                            start - len :
	                            0;

	                        if (start < 0) {
	                            start = 0;
	                        }
	                    }
	                    else if (action == "next") {
	                        if (start + len < records) {
	                            start += len;
	                        }
	                    }
	                    else if (action == "last") {
	                        start = Math.floor((records - 1) / len) * len;
	                    }
	                    else {
	                        _fnLog(settings, 0, "Unknown paging action: " + action, 5);
	                    }

	                    var changed = settings._iDisplayStart !== start;
	                    settings._iDisplayStart = start;

	                    if (changed) {
	                        _fnCallbackFire(settings, null, 'page', [settings]);

	                        if (redraw) {
	                            _fnDraw(settings);
	                        }
	                    }

	                    return changed;
	                }



	                /**
	                 * Generate the node required for the processing node
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {node} Processing element
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlProcessing(settings) {
	                    return $('<div/>', {
	                        'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
	                        'class': settings.oClasses.sProcessing
	                    })
	                        .html(settings.oLanguage.sProcessing)
	                        .insertBefore(settings.nTable)[0];
	                }


	                /**
	                 * Display or hide the processing indicator
	                 *  @param {object} settings dataTables settings object
	                 *  @param {bool} show Show the processing indicator (true) or not (false)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnProcessingDisplay(settings, show) {
	                    if (settings.oFeatures.bProcessing) {
	                        $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
	                    }

	                    _fnCallbackFire(settings, null, 'processing', [settings, show]);
	                }

	                /**
	                 * Add any control elements for the table - specifically scrolling
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {node} Node to add to the DOM
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlTable(settings) {
	                    var table = $(settings.nTable);

	                    // Add the ARIA grid role to the table
	                    table.attr('role', 'grid');

	                    // Scrolling from here on in
	                    var scroll = settings.oScroll;

	                    if (scroll.sX === '' && scroll.sY === '') {
	                        return settings.nTable;
	                    }

	                    var scrollX = scroll.sX;
	                    var scrollY = scroll.sY;
	                    var classes = settings.oClasses;
	                    var caption = table.children('caption');
	                    var captionSide = caption.length ? caption[0]._captionSide : null;
	                    var headerClone = $(table[0].cloneNode(false));
	                    var footerClone = $(table[0].cloneNode(false));
	                    var footer = table.children('tfoot');
	                    var _div = '<div/>';
	                    var size = function (s) {
	                        return !s ? null : _fnStringToCss(s);
	                    };

	                    // This is fairly messy, but with x scrolling enabled, if the table has a
	                    // width attribute, regardless of any width applied using the column width
	                    // options, the browser will shrink or grow the table as needed to fit into
	                    // that 100%. That would make the width options useless. So we remove it.
	                    // This is okay, under the assumption that width:100% is applied to the
	                    // table in CSS (it is in the default stylesheet) which will set the table
	                    // width as appropriate (the attribute and css behave differently...)
	                    if (scroll.sX && table.attr('width') === '100%') {
	                        table.removeAttr('width');
	                    }

	                    if (!footer.length) {
	                        footer = null;
	                    }

	                    /*
	                     * The HTML structure that we want to generate in this function is:
	                     *  div - scroller
	                     *    div - scroll head
	                     *      div - scroll head inner
	                     *        table - scroll head table
	                     *          thead - thead
	                     *    div - scroll body
	                     *      table - table (master table)
	                     *        thead - thead clone for sizing
	                     *        tbody - tbody
	                     *    div - scroll foot
	                     *      div - scroll foot inner
	                     *        table - scroll foot table
	                     *          tfoot - tfoot
	                     */
	                    var scroller = $(_div, { 'class': classes.sScrollWrapper })
	                        .append(
	                            $(_div, { 'class': classes.sScrollHead })
	                                .css({
	                                    overflow: 'hidden',
	                                    position: 'relative',
	                                    border: 0,
	                                    width: scrollX ? size(scrollX) : '100%'
	                                })
	                                .append(
	                                    $(_div, { 'class': classes.sScrollHeadInner })
	                                        .css({
	                                            'box-sizing': 'content-box',
	                                            width: scroll.sXInner || '100%'
	                                        })
	                                        .append(
	                                            headerClone
	                                                .removeAttr('id')
	                                                .css('margin-left', 0)
	                                                .append(captionSide === 'top' ? caption : null)
	                                                .append(
	                                                    table.children('thead')
	                                                )
	                                        )
	                                )
	                        )
	                        .append(
	                            $(_div, { 'class': classes.sScrollBody })
	                                .css({
	                                    overflow: 'auto',
	                                    height: size(scrollY),
	                                    width: size(scrollX)
	                                })
	                                .append(table)
	                        );

	                    if (footer) {
	                        scroller.append(
	                            $(_div, { 'class': classes.sScrollFoot })
	                                .css({
	                                    overflow: 'hidden',
	                                    border: 0,
	                                    width: scrollX ? size(scrollX) : '100%'
	                                })
	                                .append(
	                                    $(_div, { 'class': classes.sScrollFootInner })
	                                        .append(
	                                            footerClone
	                                                .removeAttr('id')
	                                                .css('margin-left', 0)
	                                                .append(captionSide === 'bottom' ? caption : null)
	                                                .append(
	                                                    table.children('tfoot')
	                                                )
	                                        )
	                                )
	                        );
	                    }

	                    var children = scroller.children();
	                    var scrollHead = children[0];
	                    var scrollBody = children[1];
	                    var scrollFoot = footer ? children[2] : null;

	                    // When the body is scrolled, then we also want to scroll the headers
	                    if (scrollX) {
	                        $(scrollBody).on('scroll.DT', function (e) {
	                            var scrollLeft = this.scrollLeft;

	                            scrollHead.scrollLeft = scrollLeft;

	                            if (footer) {
	                                scrollFoot.scrollLeft = scrollLeft;
	                            }
	                        });
	                    }

	                    settings.nScrollHead = scrollHead;
	                    settings.nScrollBody = scrollBody;
	                    settings.nScrollFoot = scrollFoot;

	                    // On redraw - align columns
	                    settings.aoDrawCallback.push({
	                        "fn": _fnScrollDraw,
	                        "sName": "scrolling"
	                    });

	                    return scroller[0];
	                }



	                /**
	                 * Update the header, footer and body tables for resizing - i.e. column
	                 * alignment.
	                 *
	                 * Welcome to the most horrible function DataTables. The process that this
	                 * function follows is basically:
	                 *   1. Re-create the table inside the scrolling div
	                 *   2. Take live measurements from the DOM
	                 *   3. Apply the measurements to align the columns
	                 *   4. Clean up
	                 *
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnScrollDraw(settings) {
	                    // Given that this is such a monster function, a lot of variables are use
	                    // to try and keep the minimised size as small as possible
	                    var
	                        scroll = settings.oScroll,
	                        scrollX = scroll.sX,
	                        scrollXInner = scroll.sXInner,
	                        scrollY = scroll.sY,
	                        barWidth = scroll.iBarWidth,
	                        divHeader = $(settings.nScrollHead),
	                        divHeaderStyle = divHeader[0].style,
	                        divHeaderInner = divHeader.children('div'),
	                        divHeaderInnerStyle = divHeaderInner[0].style,
	                        divHeaderTable = divHeaderInner.children('table'),
	                        divBodyEl = settings.nScrollBody,
	                        divBody = $(divBodyEl),
	                        divBodyStyle = divBodyEl.style,
	                        divFooter = $(settings.nScrollFoot),
	                        divFooterInner = divFooter.children('div'),
	                        divFooterTable = divFooterInner.children('table'),
	                        header = $(settings.nTHead),
	                        table = $(settings.nTable),
	                        tableEl = table[0],
	                        tableStyle = tableEl.style,
	                        footer = settings.nTFoot ? $(settings.nTFoot) : null,
	                        browser = settings.oBrowser,
	                        ie67 = browser.bScrollOversize,
	                        headerTrgEls, footerTrgEls,
	                        headerSrcEls, footerSrcEls,
	                        headerCopy, footerCopy,
	                        headerWidths = [], footerWidths = [],
	                        headerContent = [],
	                        idx, correction, sanityWidth,
	                        zeroOut = function (nSizer) {
	                            var style = nSizer.style;
	                            style.paddingTop = "0";
	                            style.paddingBottom = "0";
	                            style.borderTopWidth = "0";
	                            style.borderBottomWidth = "0";
	                            style.height = 0;
	                        };

	                    /*
	                     * 1. Re-create the table inside the scrolling div
	                     */

	                    // Remove the old minimised thead and tfoot elements in the inner table
	                    table.children('thead, tfoot').remove();

	                    // Clone the current header and footer elements and then place it into the inner table
	                    headerCopy = header.clone().prependTo(table);
	                    headerTrgEls = header.find('tr'); // original header is in its own table
	                    headerSrcEls = headerCopy.find('tr');
	                    headerCopy.find('th, td').removeAttr('tabindex');

	                    if (footer) {
	                        footerCopy = footer.clone().prependTo(table);
	                        footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
	                        footerSrcEls = footerCopy.find('tr');
	                    }


	                    /*
	                     * 2. Take live measurements from the DOM - do not alter the DOM itself!
	                     */

	                    // Remove old sizing and apply the calculated column widths
	                    // Get the unique column headers in the newly created (cloned) header. We want to apply the
	                    // calculated sizes to this header
	                    if (!scrollX) {
	                        divBodyStyle.width = '100%';
	                        divHeader[0].style.width = '100%';
	                    }

	                    $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
	                        idx = _fnVisibleToColumnIndex(settings, i);
	                        el.style.width = settings.aoColumns[idx].sWidth;
	                    });

	                    if (footer) {
	                        _fnApplyToChildren(function (n) {
	                            n.style.width = "";
	                        }, footerSrcEls);
	                    }

	                    // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
	                    // will end up forcing the scrollbar to appear, making our measurements wrong for when we
	                    // then hide it (end of this function), so add the header height to the body scroller.
	                    if (scroll.bCollapse && scrollY !== "") {
	                        divBodyStyle.height = (divBody[0].offsetHeight + header[0].offsetHeight) + "px";
	                    }

	                    // Size the table as a whole
	                    sanityWidth = table.outerWidth();
	                    if (scrollX === "") {
	                        // No x scrolling
	                        tableStyle.width = "100%";

	                        // IE7 will make the width of the table when 100% include the scrollbar
	                        // - which is shouldn't. When there is a scrollbar we need to take this
	                        // into account.
	                        if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
	                            divBody.css('overflow-y') == "scroll")
	                        ) {
	                            tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
	                        }
	                    }
	                    else {
	                        // x scrolling
	                        if (scrollXInner !== "") {
	                            // x scroll inner has been given - use it
	                            tableStyle.width = _fnStringToCss(scrollXInner);
	                        }
	                        else if (sanityWidth == divBody.width() && divBody.height() < table.height()) {
	                            // There is y-scrolling - try to take account of the y scroll bar
	                            tableStyle.width = _fnStringToCss(sanityWidth - barWidth);
	                            if (table.outerWidth() > sanityWidth - barWidth) {
	                                // Not possible to take account of it
	                                tableStyle.width = _fnStringToCss(sanityWidth);
	                            }
	                        }
	                        else {
	                            // When all else fails
	                            tableStyle.width = _fnStringToCss(sanityWidth);
	                        }
	                    }

	                    // Recalculate the sanity width - now that we've applied the required width,
	                    // before it was a temporary variable. This is required because the column
	                    // width calculation is done before this table DOM is created.
	                    sanityWidth = table.outerWidth();

	                    // Hidden header should have zero height, so remove padding and borders. Then
	                    // set the width based on the real headers

	                    // Apply all styles in one pass
	                    _fnApplyToChildren(zeroOut, headerSrcEls);

	                    // Read all widths in next pass
	                    _fnApplyToChildren(function (nSizer) {
	                        headerContent.push(nSizer.innerHTML);
	                        headerWidths.push(_fnStringToCss($(nSizer).css('width')));
	                    }, headerSrcEls);

	                    // Apply all widths in final pass
	                    _fnApplyToChildren(function (nToSize, i) {
	                        nToSize.style.width = headerWidths[i];
	                    }, headerTrgEls);

	                    $(headerSrcEls).height(0);

	                    /* Same again with the footer if we have one */
	                    if (footer) {
	                        _fnApplyToChildren(zeroOut, footerSrcEls);

	                        _fnApplyToChildren(function (nSizer) {
	                            footerWidths.push(_fnStringToCss($(nSizer).css('width')));
	                        }, footerSrcEls);

	                        _fnApplyToChildren(function (nToSize, i) {
	                            nToSize.style.width = footerWidths[i];
	                        }, footerTrgEls);

	                        $(footerSrcEls).height(0);
	                    }


	                    /*
	                     * 3. Apply the measurements
	                     */

	                    // "Hide" the header and footer that we used for the sizing. We need to keep
	                    // the content of the cell so that the width applied to the header and body
	                    // both match, but we want to hide it completely. We want to also fix their
	                    // width to what they currently are
	                    _fnApplyToChildren(function (nSizer, i) {
	                        nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + headerContent[i] + '</div>';
	                        nSizer.style.width = headerWidths[i];
	                    }, headerSrcEls);

	                    if (footer) {
	                        _fnApplyToChildren(function (nSizer, i) {
	                            nSizer.innerHTML = "";
	                            nSizer.style.width = footerWidths[i];
	                        }, footerSrcEls);
	                    }

	                    // Sanity check that the table is of a sensible width. If not then we are going to get
	                    // misalignment - try to prevent this by not allowing the table to shrink below its min width
	                    if (table.outerWidth() < sanityWidth) {
	                        // The min width depends upon if we have a vertical scrollbar visible or not */
	                        correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
	                            divBody.css('overflow-y') == "scroll")) ?
	                                sanityWidth + barWidth :
	                                sanityWidth;

	                        // IE6/7 are a law unto themselves...
	                        if (ie67 && (divBodyEl.scrollHeight >
	                            divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
	                        ) {
	                            tableStyle.width = _fnStringToCss(correction - barWidth);
	                        }

	                        // And give the user a warning that we've stopped the table getting too small
	                        if (scrollX === "" || scrollXInner !== "") {
	                            _fnLog(settings, 1, 'Possible column misalignment', 6);
	                        }
	                    }
	                    else {
	                        correction = '100%';
	                    }

	                    // Apply to the container elements
	                    divBodyStyle.width = _fnStringToCss(correction);
	                    divHeaderStyle.width = _fnStringToCss(correction);

	                    if (footer) {
	                        settings.nScrollFoot.style.width = _fnStringToCss(correction);
	                    }


	                    /*
	                     * 4. Clean up
	                     */
	                    if (!scrollY) {
	                        /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
	                         * the scrollbar height from the visible display, rather than adding it on. We need to
	                         * set the height in order to sort this. Don't want to do it in any other browsers.
	                         */
	                        if (ie67) {
	                            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
	                        }
	                    }

	                    if (scrollY && scroll.bCollapse) {
	                        divBodyStyle.height = _fnStringToCss(scrollY);

	                        var iExtra = (scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth) ?
	                            barWidth :
	                            0;

	                        if (tableEl.offsetHeight < divBodyEl.offsetHeight) {
	                            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + iExtra);
	                        }
	                    }

	                    /* Finally set the width's of the header and footer tables */
	                    var iOuterWidth = table.outerWidth();
	                    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
	                    divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);

	                    // Figure out if there are scrollbar present - if so then we need a the header and footer to
	                    // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
	                    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
	                    var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
	                    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

	                    if (footer) {
	                        divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
	                        divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
	                        divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
	                    }

	                    /* Adjust the position of the header in case we loose the y-scrollbar */
	                    divBody.scroll();

	                    // If sorting or filtering has occurred, jump the scrolling back to the top
	                    // only if we aren't holding the position
	                    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
	                        divBodyEl.scrollTop = 0;
	                    }
	                }



	                /**
	                 * Apply a given function to the display child nodes of an element array (typically
	                 * TD children of TR rows
	                 *  @param {function} fn Method to apply to the objects
	                 *  @param array {nodes} an1 List of elements to look through for display children
	                 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnApplyToChildren(fn, an1, an2) {
	                    var index = 0, i = 0, iLen = an1.length;
	                    var nNode1, nNode2;

	                    while (i < iLen) {
	                        nNode1 = an1[i].firstChild;
	                        nNode2 = an2 ? an2[i].firstChild : null;

	                        while (nNode1) {
	                            if (nNode1.nodeType === 1) {
	                                if (an2) {
	                                    fn(nNode1, nNode2, index);
	                                }
	                                else {
	                                    fn(nNode1, index);
	                                }

	                                index++;
	                            }

	                            nNode1 = nNode1.nextSibling;
	                            nNode2 = an2 ? nNode2.nextSibling : null;
	                        }

	                        i++;
	                    }
	                }



	                var __re_html_remove = /<.*?>/g;


	                /**
	                 * Calculate the width of columns for the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCalculateColumnWidths(oSettings) {
	                    var
	                        table = oSettings.nTable,
	                        columns = oSettings.aoColumns,
	                        scroll = oSettings.oScroll,
	                        scrollY = scroll.sY,
	                        scrollX = scroll.sX,
	                        scrollXInner = scroll.sXInner,
	                        columnCount = columns.length,
	                        visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
	                        headerCells = $('th', oSettings.nTHead),
	                        tableWidthAttr = table.getAttribute('width'), // from DOM element
	                        tableContainer = table.parentNode,
	                        userInputs = false,
	                        i, column, columnIdx, width, outerWidth;

	                    var styleWidth = table.style.width;
	                    if (styleWidth && styleWidth.indexOf('%') !== -1) {
	                        tableWidthAttr = styleWidth;
	                    }

	                    /* Convert any user input sizes into pixel sizes */
	                    for (i = 0 ; i < visibleColumns.length ; i++) {
	                        column = columns[visibleColumns[i]];

	                        if (column.sWidth !== null) {
	                            column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);

	                            userInputs = true;
	                        }
	                    }

	                    /* If the number of columns in the DOM equals the number that we have to
	                     * process in DataTables, then we can use the offsets that are created by
	                     * the web- browser. No custom sizes can be set in order for this to happen,
	                     * nor scrolling used
	                     */
	                    if (!userInputs && !scrollX && !scrollY &&
	                        columnCount == _fnVisbleColumns(oSettings) &&
	                        columnCount == headerCells.length
	                    ) {
	                        for (i = 0 ; i < columnCount ; i++) {
	                            columns[i].sWidth = _fnStringToCss(headerCells.eq(i).width());
	                        }
	                    }
	                    else {
	                        // Otherwise construct a single row, worst case, table with the widest
	                        // node in the data, assign any user defined widths, then insert it into
	                        // the DOM and allow the browser to do all the hard work of calculating
	                        // table widths
	                        var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
	                            .css('visibility', 'hidden')
	                            .removeAttr('id');

	                        // Clean up the table body
	                        tmpTable.find('tbody tr').remove();
	                        var tr = $('<tr/>').appendTo(tmpTable.find('tbody'));

	                        // Remove any assigned widths from the footer (from scrolling)
	                        tmpTable.find('tfoot th, tfoot td').css('width', '');

	                        // Apply custom sizing to the cloned header
	                        headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

	                        for (i = 0 ; i < visibleColumns.length ; i++) {
	                            column = columns[visibleColumns[i]];

	                            headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
	                                _fnStringToCss(column.sWidthOrig) :
	                                '';
	                        }

	                        // Find the widest cell for each column and put it into the table
	                        if (oSettings.aoData.length) {
	                            for (i = 0 ; i < visibleColumns.length ; i++) {
	                                columnIdx = visibleColumns[i];
	                                column = columns[columnIdx];

	                                $(_fnGetWidestNode(oSettings, columnIdx))
	                                    .clone(false)
	                                    .append(column.sContentPadding)
	                                    .appendTo(tr);
	                            }
	                        }

	                        // Table has been built, attach to the document so we can work with it
	                        tmpTable.appendTo(tableContainer);

	                        // When scrolling (X or Y) we want to set the width of the table as 
	                        // appropriate. However, when not scrolling leave the table width as it
	                        // is. This results in slightly different, but I think correct behaviour
	                        if (scrollX && scrollXInner) {
	                            tmpTable.width(scrollXInner);
	                        }
	                        else if (scrollX) {
	                            tmpTable.css('width', 'auto');

	                            if (tmpTable.width() < tableContainer.offsetWidth) {
	                                tmpTable.width(tableContainer.offsetWidth);
	                            }
	                        }
	                        else if (scrollY) {
	                            tmpTable.width(tableContainer.offsetWidth);
	                        }
	                        else if (tableWidthAttr) {
	                            tmpTable.width(tableWidthAttr);
	                        }

	                        // Take into account the y scrollbar
	                        _fnScrollingWidthAdjust(oSettings, tmpTable[0]);

	                        // Browsers need a bit of a hand when a width is assigned to any columns
	                        // when x-scrolling as they tend to collapse the table to the min-width,
	                        // even if we sent the column widths. So we need to keep track of what
	                        // the table width should be by summing the user given values, and the
	                        // automatic values
	                        if (scrollX) {
	                            var total = 0;

	                            for (i = 0 ; i < visibleColumns.length ; i++) {
	                                column = columns[visibleColumns[i]];
	                                outerWidth = $(headerCells[i]).outerWidth();

	                                total += column.sWidthOrig === null ?
	                                    outerWidth :
	                                    parseInt(column.sWidth, 10) + outerWidth - $(headerCells[i]).width();
	                            }

	                            tmpTable.width(_fnStringToCss(total));
	                            table.style.width = _fnStringToCss(total);
	                        }

	                        // Get the width of each column in the constructed table
	                        for (i = 0 ; i < visibleColumns.length ; i++) {
	                            column = columns[visibleColumns[i]];
	                            width = $(headerCells[i]).width();

	                            if (width) {
	                                column.sWidth = _fnStringToCss(width);
	                            }
	                        }

	                        table.style.width = _fnStringToCss(tmpTable.css('width'));

	                        // Finished with the table - ditch it
	                        tmpTable.remove();
	                    }

	                    // If there is a width attr, we want to attach an event listener which
	                    // allows the table sizing to automatically adjust when the window is
	                    // resized. Use the width attr rather than CSS, since we can't know if the
	                    // CSS is a relative value or absolute - DOM read is always px.
	                    if (tableWidthAttr) {
	                        table.style.width = _fnStringToCss(tableWidthAttr);
	                    }

	                    if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
	                        var bindResize = function () {
	                            $(window).bind('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
	                                _fnAdjustColumnSizing(oSettings);
	                            }));
	                        };

	                        // IE6/7 will crash if we bind a resize event handler on page load.
	                        // To be removed in 1.11 which drops IE6/7 support
	                        if (oSettings.oBrowser.bScrollOversize) {
	                            setTimeout(bindResize, 1000);
	                        }
	                        else {
	                            bindResize();
	                        }

	                        oSettings._reszEvt = true;
	                    }
	                }


	                /**
	                 * Throttle the calls to a function. Arguments and context are maintained for
	                 * the throttled function
	                 *  @param {function} fn Function to be called
	                 *  @param {int} [freq=200] call frequency in mS
	                 *  @returns {function} wrapped function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnThrottle(fn, freq) {
	                    var
	                        frequency = freq !== undefined ? freq : 200,
	                        last,
	                        timer;

	                    return function () {
	                        var
	                            that = this,
	                            now = +new Date(),
	                            args = arguments;

	                        if (last && now < last + frequency) {
	                            clearTimeout(timer);

	                            timer = setTimeout(function () {
	                                last = undefined;
	                                fn.apply(that, args);
	                            }, frequency);
	                        }
	                        else {
	                            last = now;
	                            fn.apply(that, args);
	                        }
	                    };
	                }


	                /**
	                 * Convert a CSS unit width to pixels (e.g. 2em)
	                 *  @param {string} width width to be converted
	                 *  @param {node} parent parent to get the with for (required for relative widths) - optional
	                 *  @returns {int} width in pixels
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnConvertToWidth(width, parent) {
	                    if (!width) {
	                        return 0;
	                    }

	                    var n = $('<div/>')
	                        .css('width', _fnStringToCss(width))
	                        .appendTo(parent || document.body);

	                    var val = n[0].offsetWidth;
	                    n.remove();

	                    return val;
	                }


	                /**
	                 * Adjust a table's width to take account of vertical scroll bar
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {node} n table node
	                 *  @memberof DataTable#oApi
	                 */

	                function _fnScrollingWidthAdjust(settings, n) {
	                    var scroll = settings.oScroll;

	                    if (scroll.sX || scroll.sY) {
	                        // When y-scrolling only, we want to remove the width of the scroll bar
	                        // so the table + scroll bar will fit into the area available, otherwise
	                        // we fix the table at its current size with no adjustment
	                        var correction = !scroll.sX ? scroll.iBarWidth : 0;
	                        n.style.width = _fnStringToCss($(n).outerWidth() - correction);
	                    }
	                }


	                /**
	                 * Get the widest node
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} colIdx column of interest
	                 *  @returns {node} widest table node
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetWidestNode(settings, colIdx) {
	                    var idx = _fnGetMaxLenString(settings, colIdx);
	                    if (idx < 0) {
	                        return null;
	                    }

	                    var data = settings.aoData[idx];
	                    return !data.nTr ? // Might not have been created when deferred rendering
	                        $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] :
	                        data.anCells[colIdx];
	                }


	                /**
	                 * Get the maximum strlen for each data column
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} colIdx column of interest
	                 *  @returns {string} max string length for each column
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetMaxLenString(settings, colIdx) {
	                    var s, max = -1, maxIdx = -1;

	                    for (var i = 0, ien = settings.aoData.length ; i < ien ; i++) {
	                        s = _fnGetCellData(settings, i, colIdx, 'display') + '';
	                        s = s.replace(__re_html_remove, '');

	                        if (s.length > max) {
	                            max = s.length;
	                            maxIdx = i;
	                        }
	                    }

	                    return maxIdx;
	                }


	                /**
	                 * Append a CSS unit (only if required) to a string
	                 *  @param {string} value to css-ify
	                 *  @returns {string} value with css unit
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnStringToCss(s) {
	                    if (s === null) {
	                        return '0px';
	                    }

	                    if (typeof s == 'number') {
	                        return s < 0 ?
	                            '0px' :
	                            s + 'px';
	                    }

	                    // Check it has a unit character already
	                    return s.match(/\d$/) ?
	                        s + 'px' :
	                        s;
	                }


	                /**
	                 * Get the width of a scroll bar in this browser being used
	                 *  @returns {int} width in pixels
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnScrollBarWidth() {
	                    // On first run a static variable is set, since this is only needed once.
	                    // Subsequent runs will just use the previously calculated value
	                    var width = DataTable.__scrollbarWidth;

	                    if (width === undefined) {
	                        var sizer = $('<p/>').css({
	                            position: 'absolute',
	                            top: 0,
	                            left: 0,
	                            width: '100%',
	                            height: 150,
	                            padding: 0,
	                            overflow: 'scroll',
	                            visibility: 'hidden'
	                        })
	                            .appendTo('body');

	                        width = sizer[0].offsetWidth - sizer[0].clientWidth;
	                        DataTable.__scrollbarWidth = width;

	                        sizer.remove();
	                    }

	                    return width;
	                }



	                function _fnSortFlatten(settings) {
	                    var
	                        i, iLen, k, kLen,
	                        aSort = [],
	                        aiOrig = [],
	                        aoColumns = settings.aoColumns,
	                        aDataSort, iCol, sType, srcCol,
	                        fixed = settings.aaSortingFixed,
	                        fixedObj = $.isPlainObject(fixed),
	                        nestedSort = [],
	                        add = function (a) {
	                            if (a.length && !$.isArray(a[0])) {
	                                // 1D array
	                                nestedSort.push(a);
	                            }
	                            else {
	                                // 2D array
	                                nestedSort.push.apply(nestedSort, a);
	                            }
	                        };

	                    // Build the sort array, with pre-fix and post-fix options if they have been
	                    // specified
	                    if ($.isArray(fixed)) {
	                        add(fixed);
	                    }

	                    if (fixedObj && fixed.pre) {
	                        add(fixed.pre);
	                    }

	                    add(settings.aaSorting);

	                    if (fixedObj && fixed.post) {
	                        add(fixed.post);
	                    }

	                    for (i = 0 ; i < nestedSort.length ; i++) {
	                        srcCol = nestedSort[i][0];
	                        aDataSort = aoColumns[srcCol].aDataSort;

	                        for (k = 0, kLen = aDataSort.length ; k < kLen ; k++) {
	                            iCol = aDataSort[k];
	                            sType = aoColumns[iCol].sType || 'string';

	                            if (nestedSort[i]._idx === undefined) {
	                                nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
	                            }

	                            aSort.push({
	                                src: srcCol,
	                                col: iCol,
	                                dir: nestedSort[i][1],
	                                index: nestedSort[i]._idx,
	                                type: sType,
	                                formatter: DataTable.ext.type.order[sType + "-pre"]
	                            });
	                        }
	                    }

	                    return aSort;
	                }

	                /**
	                 * Change the order of the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 *  @todo This really needs split up!
	                 */
	                function _fnSort(oSettings) {
	                    var
	                        i, ien, iLen, j, jLen, k, kLen,
	                        sDataType, nTh,
	                        aiOrig = [],
	                        oExtSort = DataTable.ext.type.order,
	                        aoData = oSettings.aoData,
	                        aoColumns = oSettings.aoColumns,
	                        aDataSort, data, iCol, sType, oSort,
	                        formatters = 0,
	                        sortCol,
	                        displayMaster = oSettings.aiDisplayMaster,
	                        aSort;

	                    // Resolve any column types that are unknown due to addition or invalidation
	                    // @todo Can this be moved into a 'data-ready' handler which is called when
	                    //   data is going to be used in the table?
	                    _fnColumnTypes(oSettings);

	                    aSort = _fnSortFlatten(oSettings);

	                    for (i = 0, ien = aSort.length ; i < ien ; i++) {
	                        sortCol = aSort[i];

	                        // Track if we can use the fast sort algorithm
	                        if (sortCol.formatter) {
	                            formatters++;
	                        }

	                        // Load the data needed for the sort, for each cell
	                        _fnSortData(oSettings, sortCol.col);
	                    }

	                    /* No sorting required if server-side or no sorting array */
	                    if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
	                        // Create a value - key array of the current row positions such that we can use their
	                        // current position during the sort, if values match, in order to perform stable sorting
	                        for (i = 0, iLen = displayMaster.length ; i < iLen ; i++) {
	                            aiOrig[displayMaster[i]] = i;
	                        }

	                        /* Do the sort - here we want multi-column sorting based on a given data source (column)
	                         * and sorting function (from oSort) in a certain direction. It's reasonably complex to
	                         * follow on it's own, but this is what we want (example two column sorting):
	                         *  fnLocalSorting = function(a,b){
	                         *    var iTest;
	                         *    iTest = oSort['string-asc']('data11', 'data12');
	                         *      if (iTest !== 0)
	                         *        return iTest;
	                         *    iTest = oSort['numeric-desc']('data21', 'data22');
	                         *    if (iTest !== 0)
	                         *      return iTest;
	                         *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
	                         *  }
	                         * Basically we have a test for each sorting column, if the data in that column is equal,
	                         * test the next column. If all columns match, then we use a numeric sort on the row
	                         * positions in the original data array to provide a stable sort.
	                         *
	                         * Note - I know it seems excessive to have two sorting methods, but the first is around
	                         * 15% faster, so the second is only maintained for backwards compatibility with sorting
	                         * methods which do not have a pre-sort formatting function.
	                         */
	                        if (formatters === aSort.length) {
	                            // All sort types have formatting functions
	                            displayMaster.sort(function (a, b) {
	                                var
	                                    x, y, k, test, sort,
	                                    len = aSort.length,
	                                    dataA = aoData[a]._aSortData,
	                                    dataB = aoData[b]._aSortData;

	                                for (k = 0 ; k < len ; k++) {
	                                    sort = aSort[k];

	                                    x = dataA[sort.col];
	                                    y = dataB[sort.col];

	                                    test = x < y ? -1 : x > y ? 1 : 0;
	                                    if (test !== 0) {
	                                        return sort.dir === 'asc' ? test : -test;
	                                    }
	                                }

	                                x = aiOrig[a];
	                                y = aiOrig[b];
	                                return x < y ? -1 : x > y ? 1 : 0;
	                            });
	                        }
	                        else {
	                            // Depreciated - remove in 1.11 (providing a plug-in option)
	                            // Not all sort types have formatting methods, so we have to call their sorting
	                            // methods.
	                            displayMaster.sort(function (a, b) {
	                                var
	                                    x, y, k, l, test, sort, fn,
	                                    len = aSort.length,
	                                    dataA = aoData[a]._aSortData,
	                                    dataB = aoData[b]._aSortData;

	                                for (k = 0 ; k < len ; k++) {
	                                    sort = aSort[k];

	                                    x = dataA[sort.col];
	                                    y = dataB[sort.col];

	                                    fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
	                                    test = fn(x, y);
	                                    if (test !== 0) {
	                                        return test;
	                                    }
	                                }

	                                x = aiOrig[a];
	                                y = aiOrig[b];
	                                return x < y ? -1 : x > y ? 1 : 0;
	                            });
	                        }
	                    }

	                    /* Tell the draw function that we have sorted the data */
	                    oSettings.bSorted = true;
	                }


	                function _fnSortAria(settings) {
	                    var label;
	                    var nextSort;
	                    var columns = settings.aoColumns;
	                    var aSort = _fnSortFlatten(settings);
	                    var oAria = settings.oLanguage.oAria;

	                    // ARIA attributes - need to loop all columns, to update all (removing old
	                    // attributes as needed)
	                    for (var i = 0, iLen = columns.length ; i < iLen ; i++) {
	                        var col = columns[i];
	                        var asSorting = col.asSorting;
	                        var sTitle = col.sTitle.replace(/<.*?>/g, "");
	                        var th = col.nTh;

	                        // IE7 is throwing an error when setting these properties with jQuery's
	                        // attr() and removeAttr() methods...
	                        th.removeAttribute('aria-sort');

	                        /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
	                        if (col.bSortable) {
	                            if (aSort.length > 0 && aSort[0].col == i) {
	                                th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
	                                nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
	                            }
	                            else {
	                                nextSort = asSorting[0];
	                            }

	                            label = sTitle + (nextSort === "asc" ?
	                                oAria.sSortAscending :
	                                oAria.sSortDescending
	                            );
	                        }
	                        else {
	                            label = sTitle;
	                        }

	                        th.setAttribute('aria-label', label);
	                    }
	                }


	                /**
	                 * Function to run on user sort request
	                 *  @param {object} settings dataTables settings object
	                 *  @param {node} attachTo node to attach the handler to
	                 *  @param {int} colIdx column sorting index
	                 *  @param {boolean} [append=false] Append the requested sort to the existing
	                 *    sort if true (i.e. multi-column sort)
	                 *  @param {function} [callback] callback function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSortListener(settings, colIdx, append, callback) {
	                    var col = settings.aoColumns[colIdx];
	                    var sorting = settings.aaSorting;
	                    var asSorting = col.asSorting;
	                    var nextSortIdx;
	                    var next = function (a, overflow) {
	                        var idx = a._idx;
	                        if (idx === undefined) {
	                            idx = $.inArray(a[1], asSorting);
	                        }

	                        return idx + 1 < asSorting.length ?
	                            idx + 1 :
	                            overflow ?
	                                null :
	                                0;
	                    };

	                    // Convert to 2D array if needed
	                    if (typeof sorting[0] === 'number') {
	                        sorting = settings.aaSorting = [sorting];
	                    }

	                    // If appending the sort then we are multi-column sorting
	                    if (append && settings.oFeatures.bSortMulti) {
	                        // Are we already doing some kind of sort on this column?
	                        var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

	                        if (sortIdx !== -1) {
	                            // Yes, modify the sort
	                            nextSortIdx = next(sorting[sortIdx], true);

	                            if (nextSortIdx === null && sorting.length === 1) {
	                                nextSortIdx = 0; // can't remove sorting completely
	                            }

	                            if (nextSortIdx === null) {
	                                sorting.splice(sortIdx, 1);
	                            }
	                            else {
	                                sorting[sortIdx][1] = asSorting[nextSortIdx];
	                                sorting[sortIdx]._idx = nextSortIdx;
	                            }
	                        }
	                        else {
	                            // No sort on this column yet
	                            sorting.push([colIdx, asSorting[0], 0]);
	                            sorting[sorting.length - 1]._idx = 0;
	                        }
	                    }
	                    else if (sorting.length && sorting[0][0] == colIdx) {
	                        // Single column - already sorting on this column, modify the sort
	                        nextSortIdx = next(sorting[0]);

	                        sorting.length = 1;
	                        sorting[0][1] = asSorting[nextSortIdx];
	                        sorting[0]._idx = nextSortIdx;
	                    }
	                    else {
	                        // Single column - sort only on this column
	                        sorting.length = 0;
	                        sorting.push([colIdx, asSorting[0]]);
	                        sorting[0]._idx = 0;
	                    }

	                    // Run the sort by calling a full redraw
	                    _fnReDraw(settings);

	                    // callback used for async user interaction
	                    if (typeof callback == 'function') {
	                        callback(settings);
	                    }
	                }


	                /**
	                 * Attach a sort handler (click) to a node
	                 *  @param {object} settings dataTables settings object
	                 *  @param {node} attachTo node to attach the handler to
	                 *  @param {int} colIdx column sorting index
	                 *  @param {function} [callback] callback function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
	                    var col = settings.aoColumns[colIdx];

	                    _fnBindAction(attachTo, {}, function (e) {
	                        /* If the column is not sortable - don't to anything */
	                        if (col.bSortable === false) {
	                            return;
	                        }

	                        // If processing is enabled use a timeout to allow the processing
	                        // display to be shown - otherwise to it synchronously
	                        if (settings.oFeatures.bProcessing) {
	                            _fnProcessingDisplay(settings, true);

	                            setTimeout(function () {
	                                _fnSortListener(settings, colIdx, e.shiftKey, callback);

	                                // In server-side processing, the draw callback will remove the
	                                // processing display
	                                if (_fnDataSource(settings) !== 'ssp') {
	                                    _fnProcessingDisplay(settings, false);
	                                }
	                            }, 0);
	                        }
	                        else {
	                            _fnSortListener(settings, colIdx, e.shiftKey, callback);
	                        }
	                    });
	                }


	                /**
	                 * Set the sorting classes on table's body, Note: it is safe to call this function
	                 * when bSort and bSortClasses are false
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSortingClasses(settings) {
	                    var oldSort = settings.aLastSort;
	                    var sortClass = settings.oClasses.sSortColumn;
	                    var sort = _fnSortFlatten(settings);
	                    var features = settings.oFeatures;
	                    var i, ien, colIdx;

	                    if (features.bSort && features.bSortClasses) {
	                        // Remove old sorting classes
	                        for (i = 0, ien = oldSort.length ; i < ien ; i++) {
	                            colIdx = oldSort[i].src;

	                            // Remove column sorting
	                            $(_pluck(settings.aoData, 'anCells', colIdx))
	                                .removeClass(sortClass + (i < 2 ? i + 1 : 3));
	                        }

	                        // Add new column sorting
	                        for (i = 0, ien = sort.length ; i < ien ; i++) {
	                            colIdx = sort[i].src;

	                            $(_pluck(settings.aoData, 'anCells', colIdx))
	                                .addClass(sortClass + (i < 2 ? i + 1 : 3));
	                        }
	                    }

	                    settings.aLastSort = sort;
	                }


	                // Get the data to sort a column, be it from cache, fresh (populating the
	                // cache), or from a sort formatter
	                function _fnSortData(settings, idx) {
	                    // Custom sorting function - provided by the sort data type
	                    var column = settings.aoColumns[idx];
	                    var customSort = DataTable.ext.order[column.sSortDataType];
	                    var customData;

	                    if (customSort) {
	                        customData = customSort.call(settings.oInstance, settings, idx,
	                            _fnColumnIndexToVisible(settings, idx)
	                        );
	                    }

	                    // Use / populate cache
	                    var row, cellData;
	                    var formatter = DataTable.ext.type.order[column.sType + "-pre"];

	                    for (var i = 0, ien = settings.aoData.length ; i < ien ; i++) {
	                        row = settings.aoData[i];

	                        if (!row._aSortData) {
	                            row._aSortData = [];
	                        }

	                        if (!row._aSortData[idx] || customSort) {
	                            cellData = customSort ?
	                                customData[i] : // If there was a custom sort function, use data from there
	                                _fnGetCellData(settings, i, idx, 'sort');

	                            row._aSortData[idx] = formatter ?
	                                formatter(cellData) :
	                                cellData;
	                        }
	                    }
	                }



	                /**
	                 * Save the state of a table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSaveState(settings) {
	                    if (!settings.oFeatures.bStateSave || settings.bDestroying) {
	                        return;
	                    }

	                    /* Store the interesting variables */
	                    var state = {
	                        time: +new Date(),
	                        start: settings._iDisplayStart,
	                        length: settings._iDisplayLength,
	                        order: $.extend(true, [], settings.aaSorting),
	                        search: _fnSearchToCamel(settings.oPreviousSearch),
	                        columns: $.map(settings.aoColumns, function (col, i) {
	                            return {
	                                visible: col.bVisible,
	                                search: _fnSearchToCamel(settings.aoPreSearchCols[i])
	                            };
	                        })
	                    };

	                    _fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

	                    settings.oSavedState = state;
	                    settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
	                }


	                /**
	                 * Attempt to load a saved table state
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {object} oInit DataTables init object so we can override settings
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnLoadState(settings, oInit) {
	                    var i, ien;
	                    var columns = settings.aoColumns;

	                    if (!settings.oFeatures.bStateSave) {
	                        return;
	                    }

	                    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings);
	                    if (!state || !state.time) {
	                        return;
	                    }

	                    /* Allow custom and plug-in manipulation functions to alter the saved data set and
	                     * cancelling of loading by returning false
	                     */
	                    var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state]);
	                    if ($.inArray(false, abStateLoad) !== -1) {
	                        return;
	                    }

	                    /* Reject old data */
	                    var duration = settings.iStateDuration;
	                    if (duration > 0 && state.time < +new Date() - (duration * 1000)) {
	                        return;
	                    }

	                    // Number of columns have changed - all bets are off, no restore of settings
	                    if (columns.length !== state.columns.length) {
	                        return;
	                    }

	                    // Store the saved state so it might be accessed at any time
	                    settings.oLoadedState = $.extend(true, {}, state);

	                    // Restore key features - todo - for 1.11 this needs to be done by
	                    // subscribed events
	                    if (state.start !== undefined) {
	                        settings._iDisplayStart = state.start;
	                        settings.iInitDisplayStart = state.start;
	                    }
	                    if (state.length !== undefined) {
	                        settings._iDisplayLength = state.length;
	                    }

	                    // Order
	                    if (state.order !== undefined) {
	                        settings.aaSorting = [];
	                        $.each(state.order, function (i, col) {
	                            settings.aaSorting.push(col[0] >= columns.length ?
	                                [0, col[1]] :
	                                col
	                            );
	                        });
	                    }

	                    // Search
	                    if (state.search !== undefined) {
	                        $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search));
	                    }

	                    // Columns
	                    for (i = 0, ien = state.columns.length ; i < ien ; i++) {
	                        var col = state.columns[i];

	                        // Visibility
	                        if (col.visible !== undefined) {
	                            columns[i].bVisible = col.visible;
	                        }

	                        // Search
	                        if (col.search !== undefined) {
	                            $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
	                        }
	                    }

	                    _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, state]);
	                }


	                /**
	                 * Return the settings object for a particular table
	                 *  @param {node} table table we are using as a dataTable
	                 *  @returns {object} Settings object - or null if not found
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSettingsFromNode(table) {
	                    var settings = DataTable.settings;
	                    var idx = $.inArray(table, _pluck(settings, 'nTable'));

	                    return idx !== -1 ?
	                        settings[idx] :
	                        null;
	                }


	                /**
	                 * Log an error message
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} level log error messages, or display them to the user
	                 *  @param {string} msg error message
	                 *  @param {int} tn Technical note id to get more information about the error.
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnLog(settings, level, msg, tn) {
	                    msg = 'DataTables warning: ' +
	                        (settings !== null ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

	                    if (tn) {
	                        msg += '. For more information about this error, please see ' +
	                        'http://datatables.net/tn/' + tn;
	                    }

	                    if (!level) {
	                        // Backwards compatibility pre 1.10
	                        var ext = DataTable.ext;
	                        var type = ext.sErrMode || ext.errMode;

	                        _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);

	                        if (type == 'alert') {
	                            alert(msg);
	                        }
	                        else if (type == 'throw') {
	                            throw new Error(msg);
	                        }
	                        else if (typeof type == 'function') {
	                            type(settings, tn, msg);
	                        }
	                    }
	                    else if (window.console && console.log) {
	                        console.log(msg);
	                    }
	                }


	                /**
	                 * See if a property is defined on one object, if so assign it to the other object
	                 *  @param {object} ret target object
	                 *  @param {object} src source object
	                 *  @param {string} name property
	                 *  @param {string} [mappedName] name to map too - optional, name used if not given
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnMap(ret, src, name, mappedName) {
	                    if ($.isArray(name)) {
	                        $.each(name, function (i, val) {
	                            if ($.isArray(val)) {
	                                _fnMap(ret, src, val[0], val[1]);
	                            }
	                            else {
	                                _fnMap(ret, src, val);
	                            }
	                        });

	                        return;
	                    }

	                    if (mappedName === undefined) {
	                        mappedName = name;
	                    }

	                    if (src[name] !== undefined) {
	                        ret[mappedName] = src[name];
	                    }
	                }


	                /**
	                 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
	                 * shallow copy arrays. The reason we need to do this, is that we don't want to
	                 * deep copy array init values (such as aaSorting) since the dev wouldn't be
	                 * able to override them, but we do want to deep copy arrays.
	                 *  @param {object} out Object to extend
	                 *  @param {object} extender Object from which the properties will be applied to
	                 *      out
	                 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
	                 *      independent copy with the exception of the `data` or `aaData` parameters
	                 *      if they are present. This is so you can pass in a collection to
	                 *      DataTables and have that used as your data source without breaking the
	                 *      references
	                 *  @returns {object} out Reference, just for convenience - out === the return.
	                 *  @memberof DataTable#oApi
	                 *  @todo This doesn't take account of arrays inside the deep copied objects.
	                 */
	                function _fnExtend(out, extender, breakRefs) {
	                    var val;

	                    for (var prop in extender) {
	                        if (extender.hasOwnProperty(prop)) {
	                            val = extender[prop];

	                            if ($.isPlainObject(val)) {
	                                if (!$.isPlainObject(out[prop])) {
	                                    out[prop] = {};
	                                }
	                                $.extend(true, out[prop], val);
	                            }
	                            else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {
	                                out[prop] = val.slice();
	                            }
	                            else {
	                                out[prop] = val;
	                            }
	                        }
	                    }

	                    return out;
	                }


	                /**
	                 * Bind an event handers to allow a click or return key to activate the callback.
	                 * This is good for accessibility since a return on the keyboard will have the
	                 * same effect as a click, if the element has focus.
	                 *  @param {element} n Element to bind the action to
	                 *  @param {object} oData Data object to pass to the triggered function
	                 *  @param {function} fn Callback function for when the event is triggered
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnBindAction(n, oData, fn) {
	                    $(n)
	                        .bind('click.DT', oData, function (e) {
	                            n.blur(); // Remove focus outline for mouse users
	                            fn(e);
	                        })
	                        .bind('keypress.DT', oData, function (e) {
	                            if (e.which === 13) {
	                                e.preventDefault();
	                                fn(e);
	                            }
	                        })
	                        .bind('selectstart.DT', function () {
	                            /* Take the brutal approach to cancelling text selection */
	                            return false;
	                        });
	                }


	                /**
	                 * Register a callback function. Easily allows a callback function to be added to
	                 * an array store of callback functions that can then all be called together.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
	                 *  @param {function} fn Function to be called back
	                 *  @param {string} sName Identifying name for the callback (i.e. a label)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCallbackReg(oSettings, sStore, fn, sName) {
	                    if (fn) {
	                        oSettings[sStore].push({
	                            "fn": fn,
	                            "sName": sName
	                        });
	                    }
	                }


	                /**
	                 * Fire callback functions and trigger events. Note that the loop over the
	                 * callback array store is done backwards! Further note that you do not want to
	                 * fire off triggers in time sensitive applications (for example cell creation)
	                 * as its slow.
	                 *  @param {object} settings dataTables settings object
	                 *  @param {string} callbackArr Name of the array storage for the callbacks in
	                 *      oSettings
	                 *  @param {string} eventName Name of the jQuery custom event to trigger. If
	                 *      null no trigger is fired
	                 *  @param {array} args Array of arguments to pass to the callback function /
	                 *      trigger
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCallbackFire(settings, callbackArr, eventName, args) {
	                    var ret = [];

	                    if (callbackArr) {
	                        ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
	                            return val.fn.apply(settings.oInstance, args);
	                        });
	                    }

	                    if (eventName !== null) {
	                        var e = $.Event(eventName + '.dt');

	                        $(settings.nTable).trigger(e, args);

	                        ret.push(e.result);
	                    }

	                    return ret;
	                }


	                function _fnLengthOverflow(settings) {
	                    var
	                        start = settings._iDisplayStart,
	                        end = settings.fnDisplayEnd(),
	                        len = settings._iDisplayLength;

	                    /* If we have space to show extra rows (backing up from the end point - then do so */
	                    if (start >= end) {
	                        start = end - len;
	                    }

	                    // Keep the start record on the current page
	                    start -= (start % len);

	                    if (len === -1 || start < 0) {
	                        start = 0;
	                    }

	                    settings._iDisplayStart = start;
	                }


	                function _fnRenderer(settings, type) {
	                    var renderer = settings.renderer;
	                    var host = DataTable.ext.renderer[type];

	                    if ($.isPlainObject(renderer) && renderer[type]) {
	                        // Specific renderer for this type. If available use it, otherwise use
	                        // the default.
	                        return host[renderer[type]] || host._;
	                    }
	                    else if (typeof renderer === 'string') {
	                        // Common renderer - if there is one available for this type use it,
	                        // otherwise use the default
	                        return host[renderer] || host._;
	                    }

	                    // Use the default
	                    return host._;
	                }


	                /**
	                 * Detect the data source being used for the table. Used to simplify the code
	                 * a little (ajax) and to make it compress a little smaller.
	                 *
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {string} Data source
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnDataSource(settings) {
	                    if (settings.oFeatures.bServerSide) {
	                        return 'ssp';
	                    }
	                    else if (settings.ajax || settings.sAjaxSource) {
	                        return 'ajax';
	                    }
	                    return 'dom';
	                }


	                DataTable = function (options) {
	                    /**
	                     * Perform a jQuery selector action on the table's TR elements (from the tbody) and
	                     * return the resulting jQuery object.
	                     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
	                     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
	                     *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
	                     *    criterion ("applied") or all TR elements (i.e. no filter).
	                     *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
	                     *    Can be either 'current', whereby the current sorting of the table is used, or
	                     *    'original' whereby the original order the data was read into the table is used.
	                     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
	                     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
	                     *    'current' and filter is 'applied', regardless of what they might be given as.
	                     *  @returns {object} jQuery object, filtered by the given selector.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Highlight every second row
	                     *      oTable.$('tr:odd').css('backgroundColor', 'blue');
	                     *    } );
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Filter to rows with 'Webkit' in them, add a background colour and then
	                     *      // remove the filter, thus highlighting the 'Webkit' rows only.
	                     *      oTable.fnFilter('Webkit');
	                     *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
	                     *      oTable.fnFilter('');
	                     *    } );
	                     */
	                    this.$ = function (sSelector, oOpts) {
	                        return this.api(true).$(sSelector, oOpts);
	                    };


	                    /**
	                     * Almost identical to $ in operation, but in this case returns the data for the matched
	                     * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
	                     * rather than any descendants, so the data can be obtained for the row/cell. If matching
	                     * rows are found, the data returned is the original data array/object that was used to
	                     * create the row (or a generated array if from a DOM source).
	                     *
	                     * This method is often useful in-combination with $ where both functions are given the
	                     * same parameters and the array indexes will match identically.
	                     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
	                     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
	                     *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
	                     *    criterion ("applied") or all elements (i.e. no filter).
	                     *  @param {string} [oOpts.order=current] Order of the data in the processed array.
	                     *    Can be either 'current', whereby the current sorting of the table is used, or
	                     *    'original' whereby the original order the data was read into the table is used.
	                     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
	                     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
	                     *    'current' and filter is 'applied', regardless of what they might be given as.
	                     *  @returns {array} Data for the matched elements. If any elements, as a result of the
	                     *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
	                     *    entry in the array.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Get the data from the first row in the table
	                     *      var data = oTable._('tr:first');
	                     *
	                     *      // Do something useful with the data
	                     *      alert( "First cell is: "+data[0] );
	                     *    } );
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Filter to 'Webkit' and get all data for
	                     *      oTable.fnFilter('Webkit');
	                     *      var data = oTable._('tr', {"search": "applied"});
	                     *
	                     *      // Do something with the data
	                     *      alert( data.length+" rows matched the search" );
	                     *    } );
	                     */
	                    this._ = function (sSelector, oOpts) {
	                        return this.api(true).rows(sSelector, oOpts).data();
	                    };


	                    /**
	                     * Create a DataTables Api instance, with the currently selected tables for
	                     * the Api's context.
	                     * @param {boolean} [traditional=false] Set the API instance's context to be
	                     *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
	                     *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
	                     *   or if all tables captured in the jQuery object should be used.
	                     * @return {DataTables.Api}
	                     */
	                    this.api = function (traditional) {
	                        return traditional ?
	                            new _Api(
	                                _fnSettingsFromNode(this[_ext.iApiIndex])
	                            ) :
	                            new _Api(this);
	                    };


	                    /**
	                     * Add a single new row or multiple rows of data to the table. Please note
	                     * that this is suitable for client-side processing only - if you are using
	                     * server-side processing (i.e. "bServerSide": true), then to add data, you
	                     * must add it to the data source, i.e. the server-side, through an Ajax call.
	                     *  @param {array|object} data The data to be added to the table. This can be:
	                     *    <ul>
	                     *      <li>1D array of data - add a single row with the data provided</li>
	                     *      <li>2D array of arrays - add multiple rows in a single call</li>
	                     *      <li>object - data object when using <i>mData</i></li>
	                     *      <li>array of objects - multiple data objects when using <i>mData</i></li>
	                     *    </ul>
	                     *  @param {bool} [redraw=true] redraw the table or not
	                     *  @returns {array} An array of integers, representing the list of indexes in
	                     *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
	                     *    the table.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    // Global var for counter
	                     *    var giCount = 2;
	                     *
	                     *    $(document).ready(function() {
	                     *      $('#example').dataTable();
	                     *    } );
	                     *
	                     *    function fnClickAddRow() {
	                     *      $('#example').dataTable().fnAddData( [
	                     *        giCount+".1",
	                     *        giCount+".2",
	                     *        giCount+".3",
	                     *        giCount+".4" ]
	                     *      );
	                     *
	                     *      giCount++;
	                     *    }
	                     */
	                    this.fnAddData = function (data, redraw) {
	                        var api = this.api(true);

	                        /* Check if we want to add multiple rows or not */
	                        var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ?
	                            api.rows.add(data) :
	                            api.row.add(data);

	                        if (redraw === undefined || redraw) {
	                            api.draw();
	                        }

	                        return rows.flatten().toArray();
	                    };


	                    /**
	                     * This function will make DataTables recalculate the column sizes, based on the data
	                     * contained in the table and the sizes applied to the columns (in the DOM, CSS or
	                     * through the sWidth parameter). This can be useful when the width of the table's
	                     * parent element changes (for example a window resize).
	                     *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable( {
	                     *        "sScrollY": "200px",
	                     *        "bPaginate": false
	                     *      } );
	                     *
	                     *      $(window).bind('resize', function () {
	                     *        oTable.fnAdjustColumnSizing();
	                     *      } );
	                     *    } );
	                     */
	                    this.fnAdjustColumnSizing = function (bRedraw) {
	                        var api = this.api(true).columns.adjust();
	                        var settings = api.settings()[0];
	                        var scroll = settings.oScroll;

	                        if (bRedraw === undefined || bRedraw) {
	                            api.draw(false);
	                        }
	                        else if (scroll.sX !== "" || scroll.sY !== "") {
	                            /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
	                            _fnScrollDraw(settings);
	                        }
	                    };


	                    /**
	                     * Quickly and simply clear a table
	                     *  @param {bool} [bRedraw=true] redraw the table or not
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
	                     *      oTable.fnClearTable();
	                     *    } );
	                     */
	                    this.fnClearTable = function (bRedraw) {
	                        var api = this.api(true).clear();

	                        if (bRedraw === undefined || bRedraw) {
	                            api.draw();
	                        }
	                    };


	                    /**
	                     * The exact opposite of 'opening' a row, this function will close any rows which
	                     * are currently 'open'.
	                     *  @param {node} nTr the table row to 'close'
	                     *  @returns {int} 0 on success, or 1 if failed (can't find the row)
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable;
	                     *
	                     *      // 'open' an information row when a row is clicked on
	                     *      $('#example tbody tr').click( function () {
	                     *        if ( oTable.fnIsOpen(this) ) {
	                     *          oTable.fnClose( this );
	                     *        } else {
	                     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
	                     *        }
	                     *      } );
	                     *
	                     *      oTable = $('#example').dataTable();
	                     *    } );
	                     */
	                    this.fnClose = function (nTr) {
	                        this.api(true).row(nTr).child.hide();
	                    };


	                    /**
	                     * Remove a row for the table
	                     *  @param {mixed} target The index of the row from aoData to be deleted, or
	                     *    the TR element you want to delete
	                     *  @param {function|null} [callBack] Callback function
	                     *  @param {bool} [redraw=true] Redraw the table or not
	                     *  @returns {array} The row that was deleted
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Immediately remove the first row
	                     *      oTable.fnDeleteRow( 0 );
	                     *    } );
	                     */
	                    this.fnDeleteRow = function (target, callback, redraw) {
	                        var api = this.api(true);
	                        var rows = api.rows(target);
	                        var settings = rows.settings()[0];
	                        var data = settings.aoData[rows[0][0]];

	                        rows.remove();

	                        if (callback) {
	                            callback.call(this, settings, data);
	                        }

	                        if (redraw === undefined || redraw) {
	                            api.draw();
	                        }

	                        return data;
	                    };


	                    /**
	                     * Restore the table to it's original state in the DOM by removing all of DataTables
	                     * enhancements, alterations to the DOM structure of the table and event listeners.
	                     *  @param {boolean} [remove=false] Completely remove the table from the DOM
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
	                     *      var oTable = $('#example').dataTable();
	                     *      oTable.fnDestroy();
	                     *    } );
	                     */
	                    this.fnDestroy = function (remove) {
	                        this.api(true).destroy(remove);
	                    };


	                    /**
	                     * Redraw the table
	                     *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
	                     *      oTable.fnDraw();
	                     *    } );
	                     */
	                    this.fnDraw = function (complete) {
	                        // Note that this isn't an exact match to the old call to _fnDraw - it takes
	                        // into account the new data, but can hold position.
	                        this.api(true).draw(complete);
	                    };


	                    /**
	                     * Filter the input based on data
	                     *  @param {string} sInput String to filter the table on
	                     *  @param {int|null} [iColumn] Column to limit filtering to
	                     *  @param {bool} [bRegex=false] Treat as regular expression or not
	                     *  @param {bool} [bSmart=true] Perform smart filtering or not
	                     *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
	                     *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Sometime later - filter...
	                     *      oTable.fnFilter( 'test string' );
	                     *    } );
	                     */
	                    this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
	                        var api = this.api(true);

	                        if (iColumn === null || iColumn === undefined) {
	                            api.search(sInput, bRegex, bSmart, bCaseInsensitive);
	                        }
	                        else {
	                            api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
	                        }

	                        api.draw();
	                    };


	                    /**
	                     * Get the data for the whole table, an individual row or an individual cell based on the
	                     * provided parameters.
	                     *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
	                     *    a TR node then the data source for the whole row will be returned. If given as a
	                     *    TD/TH cell node then iCol will be automatically calculated and the data for the
	                     *    cell returned. If given as an integer, then this is treated as the aoData internal
	                     *    data index for the row (see fnGetPosition) and the data for that row used.
	                     *  @param {int} [col] Optional column index that you want the data of.
	                     *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
	                     *    returned. If mRow is defined, just data for that row, and is iCol is
	                     *    defined, only data for the designated cell is returned.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    // Row data
	                     *    $(document).ready(function() {
	                     *      oTable = $('#example').dataTable();
	                     *
	                     *      oTable.$('tr').click( function () {
	                     *        var data = oTable.fnGetData( this );
	                     *        // ... do something with the array / object of data for the row
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Individual cell data
	                     *    $(document).ready(function() {
	                     *      oTable = $('#example').dataTable();
	                     *
	                     *      oTable.$('td').click( function () {
	                     *        var sData = oTable.fnGetData( this );
	                     *        alert( 'The cell clicked on had the value of '+sData );
	                     *      } );
	                     *    } );
	                     */
	                    this.fnGetData = function (src, col) {
	                        var api = this.api(true);

	                        if (src !== undefined) {
	                            var type = src.nodeName ? src.nodeName.toLowerCase() : '';

	                            return col !== undefined || type == 'td' || type == 'th' ?
	                                api.cell(src, col).data() :
	                                api.row(src).data() || null;
	                        }

	                        return api.data().toArray();
	                    };


	                    /**
	                     * Get an array of the TR nodes that are used in the table's body. Note that you will
	                     * typically want to use the '$' API method in preference to this as it is more
	                     * flexible.
	                     *  @param {int} [iRow] Optional row index for the TR element you want
	                     *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
	                     *    in the table's body, or iRow is defined, just the TR element requested.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Get the nodes from the table
	                     *      var nNodes = oTable.fnGetNodes( );
	                     *    } );
	                     */
	                    this.fnGetNodes = function (iRow) {
	                        var api = this.api(true);

	                        return iRow !== undefined ?
	                            api.row(iRow).node() :
	                            api.rows().nodes().flatten().toArray();
	                    };


	                    /**
	                     * Get the array indexes of a particular cell from it's DOM element
	                     * and column index including hidden columns
	                     *  @param {node} node this can either be a TR, TD or TH in the table's body
	                     *  @returns {int} If nNode is given as a TR, then a single index is returned, or
	                     *    if given as a cell, an array of [row index, column index (visible),
	                     *    column index (all)] is given.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      $('#example tbody td').click( function () {
	                     *        // Get the position of the current data from the node
	                     *        var aPos = oTable.fnGetPosition( this );
	                     *
	                     *        // Get the data array for this row
	                     *        var aData = oTable.fnGetData( aPos[0] );
	                     *
	                     *        // Update the data array and return the value
	                     *        aData[ aPos[1] ] = 'clicked';
	                     *        this.innerHTML = 'clicked';
	                     *      } );
	                     *
	                     *      // Init DataTables
	                     *      oTable = $('#example').dataTable();
	                     *    } );
	                     */
	                    this.fnGetPosition = function (node) {
	                        var api = this.api(true);
	                        var nodeName = node.nodeName.toUpperCase();

	                        if (nodeName == 'TR') {
	                            return api.row(node).index();
	                        }
	                        else if (nodeName == 'TD' || nodeName == 'TH') {
	                            var cell = api.cell(node).index();

	                            return [
	                                cell.row,
	                                cell.columnVisible,
	                                cell.column
	                            ];
	                        }
	                        return null;
	                    };


	                    /**
	                     * Check to see if a row is 'open' or not.
	                     *  @param {node} nTr the table row to check
	                     *  @returns {boolean} true if the row is currently open, false otherwise
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable;
	                     *
	                     *      // 'open' an information row when a row is clicked on
	                     *      $('#example tbody tr').click( function () {
	                     *        if ( oTable.fnIsOpen(this) ) {
	                     *          oTable.fnClose( this );
	                     *        } else {
	                     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
	                     *        }
	                     *      } );
	                     *
	                     *      oTable = $('#example').dataTable();
	                     *    } );
	                     */
	                    this.fnIsOpen = function (nTr) {
	                        return this.api(true).row(nTr).child.isShown();
	                    };


	                    /**
	                     * This function will place a new row directly after a row which is currently
	                     * on display on the page, with the HTML contents that is passed into the
	                     * function. This can be used, for example, to ask for confirmation that a
	                     * particular record should be deleted.
	                     *  @param {node} nTr The table row to 'open'
	                     *  @param {string|node|jQuery} mHtml The HTML to put into the row
	                     *  @param {string} sClass Class to give the new TD cell
	                     *  @returns {node} The row opened. Note that if the table row passed in as the
	                     *    first parameter, is not found in the table, this method will silently
	                     *    return.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable;
	                     *
	                     *      // 'open' an information row when a row is clicked on
	                     *      $('#example tbody tr').click( function () {
	                     *        if ( oTable.fnIsOpen(this) ) {
	                     *          oTable.fnClose( this );
	                     *        } else {
	                     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
	                     *        }
	                     *      } );
	                     *
	                     *      oTable = $('#example').dataTable();
	                     *    } );
	                     */
	                    this.fnOpen = function (nTr, mHtml, sClass) {
	                        return this.api(true)
	                            .row(nTr)
	                            .child(mHtml, sClass)
	                            .show()
	                            .child()[0];
	                    };


	                    /**
	                     * Change the pagination - provides the internal logic for pagination in a simple API
	                     * function. With this function you can have a DataTables table go to the next,
	                     * previous, first or last pages.
	                     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
	                     *    or page number to jump to (integer), note that page 0 is the first page.
	                     *  @param {bool} [bRedraw=true] Redraw the table or not
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *      oTable.fnPageChange( 'next' );
	                     *    } );
	                     */
	                    this.fnPageChange = function (mAction, bRedraw) {
	                        var api = this.api(true).page(mAction);

	                        if (bRedraw === undefined || bRedraw) {
	                            api.draw(false);
	                        }
	                    };


	                    /**
	                     * Show a particular column
	                     *  @param {int} iCol The column whose display should be changed
	                     *  @param {bool} bShow Show (true) or hide (false) the column
	                     *  @param {bool} [bRedraw=true] Redraw the table or not
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Hide the second column after initialisation
	                     *      oTable.fnSetColumnVis( 1, false );
	                     *    } );
	                     */
	                    this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
	                        var api = this.api(true).column(iCol).visible(bShow);

	                        if (bRedraw === undefined || bRedraw) {
	                            api.columns.adjust().draw();
	                        }
	                    };


	                    /**
	                     * Get the settings for a particular table for external manipulation
	                     *  @returns {object} DataTables settings object. See
	                     *    {@link DataTable.models.oSettings}
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *      var oSettings = oTable.fnSettings();
	                     *
	                     *      // Show an example parameter from the settings
	                     *      alert( oSettings._iDisplayStart );
	                     *    } );
	                     */
	                    this.fnSettings = function () {
	                        return _fnSettingsFromNode(this[_ext.iApiIndex]);
	                    };


	                    /**
	                     * Sort the table by a particular column
	                     *  @param {int} iCol the data index to sort on. Note that this will not match the
	                     *    'display index' if you have hidden data entries
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Sort immediately with columns 0 and 1
	                     *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
	                     *    } );
	                     */
	                    this.fnSort = function (aaSort) {
	                        this.api(true).order(aaSort).draw();
	                    };


	                    /**
	                     * Attach a sort listener to an element for a given column
	                     *  @param {node} nNode the element to attach the sort listener to
	                     *  @param {int} iColumn the column that a click on this node will sort on
	                     *  @param {function} [fnCallback] callback function when sort is run
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Sort on column 1, when 'sorter' is clicked on
	                     *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
	                     *    } );
	                     */
	                    this.fnSortListener = function (nNode, iColumn, fnCallback) {
	                        this.api(true).order.listener(nNode, iColumn, fnCallback);
	                    };


	                    /**
	                     * Update a table cell or row - this method will accept either a single value to
	                     * update the cell with, an array of values with one element for each column or
	                     * an object in the same format as the original data source. The function is
	                     * self-referencing in order to make the multi column updates easier.
	                     *  @param {object|array|string} mData Data to update the cell/row with
	                     *  @param {node|int} mRow TR element you want to update or the aoData index
	                     *  @param {int} [iColumn] The column to update, give as null or undefined to
	                     *    update a whole row.
	                     *  @param {bool} [bRedraw=true] Redraw the table or not
	                     *  @param {bool} [bAction=true] Perform pre-draw actions or not
	                     *  @returns {int} 0 on success, 1 on error
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
	                     *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
	                     *    } );
	                     */
	                    this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
	                        var api = this.api(true);

	                        if (iColumn === undefined || iColumn === null) {
	                            api.row(mRow).data(mData);
	                        }
	                        else {
	                            api.cell(mRow, iColumn).data(mData);
	                        }

	                        if (bAction === undefined || bAction) {
	                            api.columns.adjust();
	                        }

	                        if (bRedraw === undefined || bRedraw) {
	                            api.draw();
	                        }
	                        return 0;
	                    };


	                    /**
	                     * Provide a common method for plug-ins to check the version of DataTables being used, in order
	                     * to ensure compatibility.
	                     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
	                     *    formats "X" and "X.Y" are also acceptable.
	                     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
	                     *    version, or false if this version of DataTales is not suitable
	                     *  @method
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *      alert( oTable.fnVersionCheck( '1.9.0' ) );
	                     *    } );
	                     */
	                    this.fnVersionCheck = _ext.fnVersionCheck;


	                    var _that = this;
	                    var emptyInit = options === undefined;
	                    var len = this.length;

	                    if (emptyInit) {
	                        options = {};
	                    }

	                    this.oApi = this.internal = _ext.internal;

	                    // Extend with old style plug-in API methods
	                    for (var fn in DataTable.ext.internal) {
	                        if (fn) {
	                            this[fn] = _fnExternApiFunc(fn);
	                        }
	                    }

	                    this.each(function () {
	                        // For each initialisation we want to give it a clean initialisation
	                        // object that can be bashed around
	                        var o = {};
	                        var oInit = len > 1 ? // optimisation for single table case
	                            _fnExtend(o, options, true) :
	                            options;

	                        /*global oInit,_that,emptyInit*/
	                        var i = 0, iLen, j, jLen, k, kLen;
	                        var sId = this.getAttribute('id');
	                        var bInitHandedOff = false;
	                        var defaults = DataTable.defaults;
	                        var $this = $(this);


	                        /* Sanity check */
	                        if (this.nodeName.toLowerCase() != 'table') {
	                            _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);
	                            return;
	                        }

	                        /* Backwards compatibility for the defaults */
	                        _fnCompatOpts(defaults);
	                        _fnCompatCols(defaults.column);

	                        /* Convert the camel-case defaults to Hungarian */
	                        _fnCamelToHungarian(defaults, defaults, true);
	                        _fnCamelToHungarian(defaults.column, defaults.column, true);

	                        /* Setting up the initialisation object */
	                        _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));



	                        /* Check to see if we are re-initialising a table */
	                        var allSettings = DataTable.settings;
	                        for (i = 0, iLen = allSettings.length ; i < iLen ; i++) {
	                            var s = allSettings[i];

	                            /* Base check on table node */
	                            if (s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot && s.nTFoot.parentNode == this)) {
	                                var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
	                                var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

	                                if (emptyInit || bRetrieve) {
	                                    return s.oInstance;
	                                }
	                                else if (bDestroy) {
	                                    s.oInstance.fnDestroy();
	                                    break;
	                                }
	                                else {
	                                    _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);
	                                    return;
	                                }
	                            }

	                            /* If the element we are initialising has the same ID as a table which was previously
	                             * initialised, but the table nodes don't match (from before) then we destroy the old
	                             * instance by simply deleting it. This is under the assumption that the table has been
	                             * destroyed by other methods. Anyone using non-id selectors will need to do this manually
	                             */
	                            if (s.sTableId == this.id) {
	                                allSettings.splice(i, 1);
	                                break;
	                            }
	                        }

	                        /* Ensure the table has an ID - required for accessibility */
	                        if (sId === null || sId === "") {
	                            sId = "DataTables_Table_" + (DataTable.ext._unique++);
	                            this.id = sId;
	                        }

	                        /* Create the settings object for this table and set some of the default parameters */
	                        var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
	                            "sDestroyWidth": $this[0].style.width,
	                            "sInstance": sId,
	                            "sTableId": sId
	                        });
	                        oSettings.nTable = this;
	                        oSettings.oApi = _that.internal;
	                        oSettings.oInit = oInit;

	                        allSettings.push(oSettings);

	                        // Need to add the instance after the instance after the settings object has been added
	                        // to the settings array, so we can self reference the table instance if more than one
	                        oSettings.oInstance = (_that.length === 1) ? _that : $this.dataTable();

	                        // Backwards compatibility, before we apply all the defaults
	                        _fnCompatOpts(oInit);

	                        if (oInit.oLanguage) {
	                            _fnLanguageCompat(oInit.oLanguage);
	                        }

	                        // If the length menu is given, but the init display length is not, use the length menu
	                        if (oInit.aLengthMenu && !oInit.iDisplayLength) {
	                            oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ?
	                                oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
	                        }

	                        // Apply the defaults and init options to make a single init object will all
	                        // options defined from defaults and instance options.
	                        oInit = _fnExtend($.extend(true, {}, defaults), oInit);


	                        // Map the initialisation options onto the settings object
	                        _fnMap(oSettings.oFeatures, oInit, [
	                            "bPaginate",
	                            "bLengthChange",
	                            "bFilter",
	                            "bSort",
	                            "bSortMulti",
	                            "bInfo",
	                            "bProcessing",
	                            "bAutoWidth",
	                            "bSortClasses",
	                            "bServerSide",
	                            "bDeferRender"
	                        ]);
	                        _fnMap(oSettings, oInit, [
	                            "asStripeClasses",
	                            "ajax",
	                            "fnServerData",
	                            "fnFormatNumber",
	                            "sServerMethod",
	                            "aaSorting",
	                            "aaSortingFixed",
	                            "aLengthMenu",
	                            "sPaginationType",
	                            "sAjaxSource",
	                            "sAjaxDataProp",
	                            "iStateDuration",
	                            "sDom",
	                            "bSortCellsTop",
	                            "iTabIndex",
	                            "fnStateLoadCallback",
	                            "fnStateSaveCallback",
	                            "renderer",
	                            "searchDelay",
	                            ["iCookieDuration", "iStateDuration"], // backwards compat
	                            ["oSearch", "oPreviousSearch"],
	                            ["aoSearchCols", "aoPreSearchCols"],
	                            ["iDisplayLength", "_iDisplayLength"],
	                            ["bJQueryUI", "bJUI"]
	                        ]);
	                        _fnMap(oSettings.oScroll, oInit, [
	                            ["sScrollX", "sX"],
	                            ["sScrollXInner", "sXInner"],
	                            ["sScrollY", "sY"],
	                            ["bScrollCollapse", "bCollapse"]
	                        ]);
	                        _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");

	                        /* Callback functions which are array driven */
	                        _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');
	                        _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');
	                        _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');
	                        _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');
	                        _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');
	                        _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');
	                        _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');
	                        _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');
	                        _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');
	                        _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');
	                        _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

	                        var oClasses = oSettings.oClasses;

	                        // @todo Remove in 1.11
	                        if (oInit.bJQueryUI) {
	                            /* Use the JUI classes object for display. You could clone the oStdClasses object if
	                             * you want to have multiple tables with multiple independent classes
	                             */
	                            $.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses);

	                            if (oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip") {
	                                /* Set the DOM to use a layout suitable for jQuery UI's theming */
	                                oSettings.sDom = '<"H"lfr>t<"F"ip>';
	                            }

	                            if (!oSettings.renderer) {
	                                oSettings.renderer = 'jqueryui';
	                            }
	                            else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {
	                                oSettings.renderer.header = 'jqueryui';
	                            }
	                        }
	                        else {
	                            $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
	                        }
	                        $this.addClass(oClasses.sTable);

	                        /* Calculate the scroll bar width and cache it for use later on */
	                        if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
	                            oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
	                        }
	                        if (oSettings.oScroll.sX === true) { // Easy initialisation of x-scrolling
	                            oSettings.oScroll.sX = '100%';
	                        }

	                        if (oSettings.iInitDisplayStart === undefined) {
	                            /* Display start point, taking into account the save saving */
	                            oSettings.iInitDisplayStart = oInit.iDisplayStart;
	                            oSettings._iDisplayStart = oInit.iDisplayStart;
	                        }

	                        if (oInit.iDeferLoading !== null) {
	                            oSettings.bDeferLoading = true;
	                            var tmp = $.isArray(oInit.iDeferLoading);
	                            oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
	                            oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
	                        }

	                        /* Language definitions */
	                        var oLanguage = oSettings.oLanguage;
	                        $.extend(true, oLanguage, oInit.oLanguage);

	                        if (oLanguage.sUrl !== "") {
	                            /* Get the language definitions from a file - because this Ajax call makes the language
	                             * get async to the remainder of this function we use bInitHandedOff to indicate that
	                             * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
	                             */
	                            $.ajax({
	                                dataType: 'json',
	                                url: oLanguage.sUrl,
	                                success: function (json) {
	                                    _fnLanguageCompat(json);
	                                    _fnCamelToHungarian(defaults.oLanguage, json);
	                                    $.extend(true, oLanguage, json);
	                                    _fnInitialise(oSettings);
	                                },
	                                error: function () {
	                                    // Error occurred loading language file, continue on as best we can
	                                    _fnInitialise(oSettings);
	                                }
	                            });
	                            bInitHandedOff = true;
	                        }

	                        /*
	                         * Stripes
	                         */
	                        if (oInit.asStripeClasses === null) {
	                            oSettings.asStripeClasses = [
	                                oClasses.sStripeOdd,
	                                oClasses.sStripeEven
	                            ];
	                        }

	                        /* Remove row stripe classes if they are already on the table row */
	                        var stripeClasses = oSettings.asStripeClasses;
	                        var rowOne = $this.children('tbody').find('tr').eq(0);
	                        if ($.inArray(true, $.map(stripeClasses, function (el, i) {
	                            return rowOne.hasClass(el);
	                        })) !== -1) {
	                            $('tbody tr', this).removeClass(stripeClasses.join(' '));
	                            oSettings.asDestroyStripes = stripeClasses.slice();
	                        }

	                        /*
	                         * Columns
	                         * See if we should load columns automatically or use defined ones
	                         */
	                        var anThs = [];
	                        var aoColumnsInit;
	                        var nThead = this.getElementsByTagName('thead');
	                        if (nThead.length !== 0) {
	                            _fnDetectHeader(oSettings.aoHeader, nThead[0]);
	                            anThs = _fnGetUniqueThs(oSettings);
	                        }

	                        /* If not given a column array, generate one with nulls */
	                        if (oInit.aoColumns === null) {
	                            aoColumnsInit = [];
	                            for (i = 0, iLen = anThs.length ; i < iLen ; i++) {
	                                aoColumnsInit.push(null);
	                            }
	                        }
	                        else {
	                            aoColumnsInit = oInit.aoColumns;
	                        }

	                        /* Add the columns */
	                        for (i = 0, iLen = aoColumnsInit.length ; i < iLen ; i++) {
	                            _fnAddColumn(oSettings, anThs ? anThs[i] : null);
	                        }

	                        /* Apply the column definitions */
	                        _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
	                            _fnColumnOptions(oSettings, iCol, oDef);
	                        });

	                        /* HTML5 attribute detection - build an mData object automatically if the
	                         * attributes are found
	                         */
	                        if (rowOne.length) {
	                            var a = function (cell, name) {
	                                return cell.getAttribute('data-' + name) !== null ? name : null;
	                            };

	                            $.each(_fnGetRowElements(oSettings, rowOne[0]).cells, function (i, cell) {
	                                var col = oSettings.aoColumns[i];

	                                if (col.mData === i) {
	                                    var sort = a(cell, 'sort') || a(cell, 'order');
	                                    var filter = a(cell, 'filter') || a(cell, 'search');

	                                    if (sort !== null || filter !== null) {
	                                        col.mData = {
	                                            _: i + '.display',
	                                            sort: sort !== null ? i + '.@data-' + sort : undefined,
	                                            type: sort !== null ? i + '.@data-' + sort : undefined,
	                                            filter: filter !== null ? i + '.@data-' + filter : undefined
	                                        };

	                                        _fnColumnOptions(oSettings, i);
	                                    }
	                                }
	                            });
	                        }

	                        var features = oSettings.oFeatures;

	                        /* Must be done after everything which can be overridden by the state saving! */
	                        if (oInit.bStateSave) {
	                            features.bStateSave = true;
	                            _fnLoadState(oSettings, oInit);
	                            _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
	                        }


	                        /*
	                         * Sorting
	                         * @todo For modularisation (1.11) this needs to do into a sort start up handler
	                         */

	                        // If aaSorting is not defined, then we use the first indicator in asSorting
	                        // in case that has been altered, so the default sort reflects that option
	                        if (oInit.aaSorting === undefined) {
	                            var sorting = oSettings.aaSorting;
	                            for (i = 0, iLen = sorting.length ; i < iLen ; i++) {
	                                sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
	                            }
	                        }

	                        /* Do a first pass on the sorting classes (allows any size changes to be taken into
	                         * account, and also will apply sorting disabled classes if disabled
	                         */
	                        _fnSortingClasses(oSettings);

	                        if (features.bSort) {
	                            _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
	                                if (oSettings.bSorted) {
	                                    var aSort = _fnSortFlatten(oSettings);
	                                    var sortedColumns = {};

	                                    $.each(aSort, function (i, val) {
	                                        sortedColumns[val.src] = val.dir;
	                                    });

	                                    _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);
	                                    _fnSortAria(oSettings);
	                                }
	                            });
	                        }

	                        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
	                            if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
	                                _fnSortingClasses(oSettings);
	                            }
	                        }, 'sc');


	                        /*
	                         * Final init
	                         * Cache the header, body and footer as required, creating them if needed
	                         */

	                        /* Browser support detection */
	                        _fnBrowserDetect(oSettings);

	                        // Work around for Webkit bug 83867 - store the caption-side before removing from doc
	                        var captions = $this.children('caption').each(function () {
	                            this._captionSide = $this.css('caption-side');
	                        });

	                        var thead = $this.children('thead');
	                        if (thead.length === 0) {
	                            thead = $('<thead/>').appendTo(this);
	                        }
	                        oSettings.nTHead = thead[0];

	                        var tbody = $this.children('tbody');
	                        if (tbody.length === 0) {
	                            tbody = $('<tbody/>').appendTo(this);
	                        }
	                        oSettings.nTBody = tbody[0];

	                        var tfoot = $this.children('tfoot');
	                        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
	                            // If we are a scrolling table, and no footer has been given, then we need to create
	                            // a tfoot element for the caption element to be appended to
	                            tfoot = $('<tfoot/>').appendTo(this);
	                        }

	                        if (tfoot.length === 0 || tfoot.children().length === 0) {
	                            $this.addClass(oClasses.sNoFooter);
	                        }
	                        else if (tfoot.length > 0) {
	                            oSettings.nTFoot = tfoot[0];
	                            _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
	                        }

	                        /* Check if there is data passing into the constructor */
	                        if (oInit.aaData) {
	                            for (i = 0 ; i < oInit.aaData.length ; i++) {
	                                _fnAddData(oSettings, oInit.aaData[i]);
	                            }
	                        }
	                        else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
	                            /* Grab the data from the page - only do this when deferred loading or no Ajax
	                             * source since there is no point in reading the DOM data if we are then going
	                             * to replace it with Ajax data
	                             */
	                            _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
	                        }

	                        /* Copy the data index array */
	                        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

	                        /* Initialisation complete - table can be drawn */
	                        oSettings.bInitialised = true;

	                        /* Check if we need to initialise the table (it might not have been handed off to the
	                         * language processor)
	                         */
	                        if (bInitHandedOff === false) {
	                            _fnInitialise(oSettings);
	                        }
	                    });
	                    _that = null;
	                    return this;
	                };



	                /**
	                 * Computed structure of the DataTables API, defined by the options passed to
	                 * `DataTable.Api.register()` when building the API.
	                 *
	                 * The structure is built in order to speed creation and extension of the Api
	                 * objects since the extensions are effectively pre-parsed.
	                 *
	                 * The array is an array of objects with the following structure, where this
	                 * base array represents the Api prototype base:
	                 *
	                 *     [
	                 *       {
	                 *         name:      'data'                -- string   - Property name
	                 *         val:       function () {},       -- function - Api method (or undefined if just an object
	                 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	                 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	                 *       },
	                 *       {
	                 *         name:     'row'
	                 *         val:       {},
	                 *         methodExt: [ ... ],
	                 *         propExt:   [
	                 *           {
	                 *             name:      'data'
	                 *             val:       function () {},
	                 *             methodExt: [ ... ],
	                 *             propExt:   [ ... ]
	                 *           },
	                 *           ...
	                 *         ]
	                 *       }
	                 *     ]
	                 *
	                 * @type {Array}
	                 * @ignore
	                 */
	                var __apiStruct = [];


	                /**
	                 * `Array.prototype` reference.
	                 *
	                 * @type object
	                 * @ignore
	                 */
	                var __arrayProto = Array.prototype;


	                /**
	                 * Abstraction for `context` parameter of the `Api` constructor to allow it to
	                 * take several different forms for ease of use.
	                 *
	                 * Each of the input parameter types will be converted to a DataTables settings
	                 * object where possible.
	                 *
	                 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
	                 *   of:
	                 *
	                 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	                 *     with be found and used.
	                 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	                 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	                 *   * `object` - DataTables settings object
	                 *   * `DataTables.Api` - API instance
	                 * @return {array|null} Matching DataTables settings objects. `null` or
	                 *   `undefined` is returned if no matching DataTable is found.
	                 * @ignore
	                 */
	                var _toSettings = function (mixed) {
	                    var idx, jq;
	                    var settings = DataTable.settings;
	                    var tables = $.map(settings, function (el, i) {
	                        return el.nTable;
	                    });

	                    if (!mixed) {
	                        return [];
	                    }
	                    else if (mixed.nTable && mixed.oApi) {
	                        // DataTables settings object
	                        return [mixed];
	                    }
	                    else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
	                        // Table node
	                        idx = $.inArray(mixed, tables);
	                        return idx !== -1 ? [settings[idx]] : null;
	                    }
	                    else if (mixed && typeof mixed.settings === 'function') {
	                        return mixed.settings().toArray();
	                    }
	                    else if (typeof mixed === 'string') {
	                        // jQuery selector
	                        jq = $(mixed);
	                    }
	                    else if (mixed instanceof $) {
	                        // jQuery object (also DataTables instance)
	                        jq = mixed;
	                    }

	                    if (jq) {
	                        return jq.map(function (i) {
	                            idx = $.inArray(this, tables);
	                            return idx !== -1 ? settings[idx] : null;
	                        }).toArray();
	                    }
	                };


	                /**
	                 * DataTables API class - used to control and interface with  one or more
	                 * DataTables enhanced tables.
	                 *
	                 * The API class is heavily based on jQuery, presenting a chainable interface
	                 * that you can use to interact with tables. Each instance of the API class has
	                 * a "context" - i.e. the tables that it will operate on. This could be a single
	                 * table, all tables on a page or a sub-set thereof.
	                 *
	                 * Additionally the API is designed to allow you to easily work with the data in
	                 * the tables, retrieving and manipulating it as required. This is done by
	                 * presenting the API class as an array like interface. The contents of the
	                 * array depend upon the actions requested by each method (for example
	                 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
	                 * return an array of objects or arrays depending upon your table's
	                 * configuration). The API object has a number of array like methods (`push`,
	                 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
	                 * `unique` etc) to assist your working with the data held in a table.
	                 *
	                 * Most methods (those which return an Api instance) are chainable, which means
	                 * the return from a method call also has all of the methods available that the
	                 * top level object had. For example, these two calls are equivalent:
	                 *
	                 *     // Not chained
	                 *     api.row.add( {...} );
	                 *     api.draw();
	                 *
	                 *     // Chained
	                 *     api.row.add( {...} ).draw();
	                 *
	                 * @class DataTable.Api
	                 * @param {array|object|string|jQuery} context DataTable identifier. This is
	                 *   used to define which DataTables enhanced tables this API will operate on.
	                 *   Can be one of:
	                 *
	                 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	                 *     with be found and used.
	                 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	                 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	                 *   * `object` - DataTables settings object
	                 * @param {array} [data] Data to initialise the Api instance with.
	                 *
	                 * @example
	                 *   // Direct initialisation during DataTables construction
	                 *   var api = $('#example').DataTable();
	                 *
	                 * @example
	                 *   // Initialisation using a DataTables jQuery object
	                 *   var api = $('#example').dataTable().api();
	                 *
	                 * @example
	                 *   // Initialisation as a constructor
	                 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
	                 */
	                _Api = function (context, data) {
	                    if (!(this instanceof _Api)) {
	                        return new _Api(context, data);
	                    }

	                    var settings = [];
	                    var ctxSettings = function (o) {
	                        var a = _toSettings(o);
	                        if (a) {
	                            settings.push.apply(settings, a);
	                        }
	                    };

	                    if ($.isArray(context)) {
	                        for (var i = 0, ien = context.length ; i < ien ; i++) {
	                            ctxSettings(context[i]);
	                        }
	                    }
	                    else {
	                        ctxSettings(context);
	                    }

	                    // Remove duplicates
	                    this.context = _unique(settings);

	                    // Initial data
	                    if (data) {
	                        this.push.apply(this, data.toArray ? data.toArray() : data);
	                    }

	                    // selector
	                    this.selector = {
	                        rows: null,
	                        cols: null,
	                        opts: null
	                    };

	                    _Api.extend(this, this, __apiStruct);
	                };

	                DataTable.Api = _Api;

	                _Api.prototype = /** @lends DataTables.Api */{
	                    any: function () {
	                        return this.flatten().length !== 0;
	                    },


	                    concat: __arrayProto.concat,


	                    context: [], // array of table settings objects


	                    each: function (fn) {
	                        for (var i = 0, ien = this.length ; i < ien; i++) {
	                            fn.call(this, this[i], i, this);
	                        }

	                        return this;
	                    },


	                    eq: function (idx) {
	                        var ctx = this.context;

	                        return ctx.length > idx ?
	                            new _Api(ctx[idx], this[idx]) :
	                            null;
	                    },


	                    filter: function (fn) {
	                        var a = [];

	                        if (__arrayProto.filter) {
	                            a = __arrayProto.filter.call(this, fn, this);
	                        }
	                        else {
	                            // Compatibility for browsers without EMCA-252-5 (JS 1.6)
	                            for (var i = 0, ien = this.length ; i < ien ; i++) {
	                                if (fn.call(this, this[i], i, this)) {
	                                    a.push(this[i]);
	                                }
	                            }
	                        }

	                        return new _Api(this.context, a);
	                    },


	                    flatten: function () {
	                        var a = [];
	                        return new _Api(this.context, a.concat.apply(a, this.toArray()));
	                    },


	                    join: __arrayProto.join,


	                    indexOf: __arrayProto.indexOf || function (obj, start) {
	                        for (var i = (start || 0), ien = this.length ; i < ien ; i++) {
	                            if (this[i] === obj) {
	                                return i;
	                            }
	                        }
	                        return -1;
	                    },

	                    iterator: function (flatten, type, fn, alwaysNew) {
	                        var
	                            a = [], ret,
	                            i, ien, j, jen,
	                            context = this.context,
	                            rows, items, item,
	                            selector = this.selector;

	                        // Argument shifting
	                        if (typeof flatten === 'string') {
	                            alwaysNew = fn;
	                            fn = type;
	                            type = flatten;
	                            flatten = false;
	                        }

	                        for (i = 0, ien = context.length ; i < ien ; i++) {
	                            var apiInst = new _Api(context[i]);

	                            if (type === 'table') {
	                                ret = fn.call(apiInst, context[i], i);

	                                if (ret !== undefined) {
	                                    a.push(ret);
	                                }
	                            }
	                            else if (type === 'columns' || type === 'rows') {
	                                // this has same length as context - one entry for each table
	                                ret = fn.call(apiInst, context[i], this[i], i);

	                                if (ret !== undefined) {
	                                    a.push(ret);
	                                }
	                            }
	                            else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
	                                // columns and rows share the same structure.
	                                // 'this' is an array of column indexes for each context
	                                items = this[i];

	                                if (type === 'column-rows') {
	                                    rows = _selector_row_indexes(context[i], selector.opts);
	                                }

	                                for (j = 0, jen = items.length ; j < jen ; j++) {
	                                    item = items[j];

	                                    if (type === 'cell') {
	                                        ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
	                                    }
	                                    else {
	                                        ret = fn.call(apiInst, context[i], item, i, j, rows);
	                                    }

	                                    if (ret !== undefined) {
	                                        a.push(ret);
	                                    }
	                                }
	                            }
	                        }

	                        if (a.length || alwaysNew) {
	                            var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
	                            var apiSelector = api.selector;
	                            apiSelector.rows = selector.rows;
	                            apiSelector.cols = selector.cols;
	                            apiSelector.opts = selector.opts;
	                            return api;
	                        }
	                        return this;
	                    },


	                    lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
	                        // Bit cheeky...
	                        return this.indexOf.apply(this.toArray.reverse(), arguments);
	                    },


	                    length: 0,


	                    map: function (fn) {
	                        var a = [];

	                        if (__arrayProto.map) {
	                            a = __arrayProto.map.call(this, fn, this);
	                        }
	                        else {
	                            // Compatibility for browsers without EMCA-252-5 (JS 1.6)
	                            for (var i = 0, ien = this.length ; i < ien ; i++) {
	                                a.push(fn.call(this, this[i], i));
	                            }
	                        }

	                        return new _Api(this.context, a);
	                    },


	                    pluck: function (prop) {
	                        return this.map(function (el) {
	                            return el[prop];
	                        });
	                    },

	                    pop: __arrayProto.pop,


	                    push: __arrayProto.push,


	                    // Does not return an API instance
	                    reduce: __arrayProto.reduce || function (fn, init) {
	                        return _fnReduce(this, fn, init, 0, this.length, 1);
	                    },


	                    reduceRight: __arrayProto.reduceRight || function (fn, init) {
	                        return _fnReduce(this, fn, init, this.length - 1, -1, -1);
	                    },


	                    reverse: __arrayProto.reverse,


	                    // Object with rows, columns and opts
	                    selector: null,


	                    shift: __arrayProto.shift,


	                    sort: __arrayProto.sort, // ? name - order?


	                    splice: __arrayProto.splice,


	                    toArray: function () {
	                        return __arrayProto.slice.call(this);
	                    },


	                    to$: function () {
	                        return $(this);
	                    },


	                    toJQuery: function () {
	                        return $(this);
	                    },


	                    unique: function () {
	                        return new _Api(this.context, _unique(this));
	                    },


	                    unshift: __arrayProto.unshift
	                };


	                _Api.extend = function (scope, obj, ext) {
	                    // Only extend API instances and static properties of the API
	                    if (!ext.length || !obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {
	                        return;
	                    }

	                    var
	                        i, ien,
	                        j, jen,
	                        struct, inner,
	                        methodScoping = function (scope, fn, struc) {
	                            return function () {
	                                var ret = fn.apply(scope, arguments);

	                                // Method extension
	                                _Api.extend(ret, ret, struc.methodExt);
	                                return ret;
	                            };
	                        };

	                    for (i = 0, ien = ext.length ; i < ien ; i++) {
	                        struct = ext[i];

	                        // Value
	                        obj[struct.name] = typeof struct.val === 'function' ?
	                            methodScoping(scope, struct.val, struct) :
	                            $.isPlainObject(struct.val) ?
						{} :
	                                struct.val;

	                        obj[struct.name].__dt_wrapper = true;

	                        // Property extension
	                        _Api.extend(scope, obj[struct.name], struct.propExt);
	                    }
	                };


	                // @todo - Is there need for an augment function?
	                // _Api.augment = function ( inst, name )
	                // {
	                // 	// Find src object in the structure from the name
	                // 	var parts = name.split('.');

	                // 	_Api.extend( inst, obj );
	                // };


	                //     [
	                //       {
	                //         name:      'data'                -- string   - Property name
	                //         val:       function () {},       -- function - Api method (or undefined if just an object
	                //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	                //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	                //       },
	                //       {
	                //         name:     'row'
	                //         val:       {},
	                //         methodExt: [ ... ],
	                //         propExt:   [
	                //           {
	                //             name:      'data'
	                //             val:       function () {},
	                //             methodExt: [ ... ],
	                //             propExt:   [ ... ]
	                //           },
	                //           ...
	                //         ]
	                //       }
	                //     ]

	                _Api.register = _api_register = function (name, val) {
	                    if ($.isArray(name)) {
	                        for (var j = 0, jen = name.length ; j < jen ; j++) {
	                            _Api.register(name[j], val);
	                        }
	                        return;
	                    }

	                    var
	                        i, ien,
	                        heir = name.split('.'),
	                        struct = __apiStruct,
	                        key, method;

	                    var find = function (src, name) {
	                        for (var i = 0, ien = src.length ; i < ien ; i++) {
	                            if (src[i].name === name) {
	                                return src[i];
	                            }
	                        }
	                        return null;
	                    };

	                    for (i = 0, ien = heir.length ; i < ien ; i++) {
	                        method = heir[i].indexOf('()') !== -1;
	                        key = method ?
	                            heir[i].replace('()', '') :
	                            heir[i];

	                        var src = find(struct, key);
	                        if (!src) {
	                            src = {
	                                name: key,
	                                val: {},
	                                methodExt: [],
	                                propExt: []
	                            };
	                            struct.push(src);
	                        }

	                        if (i === ien - 1) {
	                            src.val = val;
	                        }
	                        else {
	                            struct = method ?
	                                src.methodExt :
	                                src.propExt;
	                        }
	                    }
	                };


	                _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {
	                    _Api.register(pluralName, val);

	                    _Api.register(singularName, function () {
	                        var ret = val.apply(this, arguments);

	                        if (ret === this) {
	                            // Returned item is the API instance that was passed in, return it
	                            return this;
	                        }
	                        else if (ret instanceof _Api) {
	                            // New API instance returned, want the value from the first item
	                            // in the returned array for the singular result.
	                            return ret.length ?
	                                $.isArray(ret[0]) ?
	                                    new _Api(ret.context, ret[0]) : // Array results are 'enhanced'
	                                    ret[0] :
	                                undefined;
	                        }

	                        // Non-API return - just fire it back
	                        return ret;
	                    });
	                };


	                /**
	                 * Selector for HTML tables. Apply the given selector to the give array of
	                 * DataTables settings objects.
	                 *
	                 * @param {string|integer} [selector] jQuery selector string or integer
	                 * @param  {array} Array of DataTables settings objects to be filtered
	                 * @return {array}
	                 * @ignore
	                 */
	                var __table_selector = function (selector, a) {
	                    // Integer is used to pick out a table by index
	                    if (typeof selector === 'number') {
	                        return [a[selector]];
	                    }

	                    // Perform a jQuery selector on the table nodes
	                    var nodes = $.map(a, function (el, i) {
	                        return el.nTable;
	                    });

	                    return $(nodes)
	                        .filter(selector)
	                        .map(function (i) {
	                            // Need to translate back from the table node to the settings
	                            var idx = $.inArray(this, nodes);
	                            return a[idx];
	                        })
	                        .toArray();
	                };



	                /**
	                 * Context selector for the API's context (i.e. the tables the API instance
	                 * refers to.
	                 *
	                 * @name    DataTable.Api#tables
	                 * @param {string|integer} [selector] Selector to pick which tables the iterator
	                 *   should operate on. If not given, all tables in the current context are
	                 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
	                 *   select multiple tables or as an integer to select a single table.
	                 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
	                 */
	                _api_register('tables()', function (selector) {
	                    // A new instance is created if there was a selector specified
	                    return selector ?
	                        new _Api(__table_selector(selector, this.context)) :
	                        this;
	                });


	                _api_register('table()', function (selector) {
	                    var tables = this.tables(selector);
	                    var ctx = tables.context;

	                    // Truncate to the first matched table
	                    return ctx.length ?
	                        new _Api(ctx[0]) :
	                        tables;
	                });


	                _api_registerPlural('tables().nodes()', 'table().node()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTable;
	                    }, 1);
	                });


	                _api_registerPlural('tables().body()', 'table().body()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTBody;
	                    }, 1);
	                });


	                _api_registerPlural('tables().header()', 'table().header()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTHead;
	                    }, 1);
	                });


	                _api_registerPlural('tables().footer()', 'table().footer()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTFoot;
	                    }, 1);
	                });


	                _api_registerPlural('tables().containers()', 'table().container()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTableWrapper;
	                    }, 1);
	                });



	                /**
	                 * Redraw the tables in the current context.
	                 *
	                 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	                 *   position. A full re-sort and re-filter is performed when this method is
	                 *   called, which is why the pagination reset is the default action.
	                 * @returns {DataTables.Api} this
	                 */
	                _api_register('draw()', function (resetPaging) {
	                    return this.iterator('table', function (settings) {
	                        _fnReDraw(settings, resetPaging === false);
	                    });
	                });



	                /**
	                 * Get the current page index.
	                 *
	                 * @return {integer} Current page index (zero based)
	                 *//**
		 * Set the current page.
		 *
		 * Note that if you attempt to show a page which does not exist, DataTables will
		 * not throw an error, but rather reset the paging.
		 *
		 * @param {integer|string} action The paging action to take. This can be one of:
		 *  * `integer` - The page index to jump to
		 *  * `string` - An action to take:
		 *    * `first` - Jump to first page.
		 *    * `next` - Jump to the next page
		 *    * `previous` - Jump to previous page
		 *    * `last` - Jump to the last page.
		 * @returns {DataTables.Api} this
		 */
	                _api_register('page()', function (action) {
	                    if (action === undefined) {
	                        return this.page.info().page; // not an expensive call
	                    }

	                    // else, have an action to take on all tables
	                    return this.iterator('table', function (settings) {
	                        _fnPageChange(settings, action);
	                    });
	                });


	                /**
	                 * Paging information for the first table in the current context.
	                 *
	                 * If you require paging information for another table, use the `table()` method
	                 * with a suitable selector.
	                 *
	                 * @return {object} Object with the following properties set:
	                 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
	                 *  * `pages` - Total number of pages
	                 *  * `start` - Display index for the first record shown on the current page
	                 *  * `end` - Display index for the last record shown on the current page
	                 *  * `length` - Display length (number of records). Note that generally `start
	                 *    + length = end`, but this is not always true, for example if there are
	                 *    only 2 records to show on the final page, with a length of 10.
	                 *  * `recordsTotal` - Full data set length
	                 *  * `recordsDisplay` - Data set length once the current filtering criterion
	                 *    are applied.
	                 */
	                _api_register('page.info()', function (action) {
	                    if (this.context.length === 0) {
	                        return undefined;
	                    }

	                    var
	                        settings = this.context[0],
	                        start = settings._iDisplayStart,
	                        len = settings._iDisplayLength,
	                        visRecords = settings.fnRecordsDisplay(),
	                        all = len === -1;

	                    return {
	                        "page": all ? 0 : Math.floor(start / len),
	                        "pages": all ? 1 : Math.ceil(visRecords / len),
	                        "start": start,
	                        "end": settings.fnDisplayEnd(),
	                        "length": len,
	                        "recordsTotal": settings.fnRecordsTotal(),
	                        "recordsDisplay": visRecords
	                    };
	                });


	                /**
	                 * Get the current page length.
	                 *
	                 * @return {integer} Current page length. Note `-1` indicates that all records
	                 *   are to be shown.
	                 *//**
		 * Set the current page length.
		 *
		 * @param {integer} Page length to set. Use `-1` to show all records.
		 * @returns {DataTables.Api} this
		 */
	                _api_register('page.len()', function (len) {
	                    // Note that we can't call this function 'length()' because `length`
	                    // is a Javascript property of functions which defines how many arguments
	                    // the function expects.
	                    if (len === undefined) {
	                        return this.context.length !== 0 ?
	                            this.context[0]._iDisplayLength :
	                            undefined;
	                    }

	                    // else, set the page length
	                    return this.iterator('table', function (settings) {
	                        _fnLengthChange(settings, len);
	                    });
	                });



	                var __reload = function (settings, holdPosition, callback) {
	                    // Use the draw event to trigger a callback
	                    if (callback) {
	                        var api = new _Api(settings);

	                        api.one('draw', function () {
	                            callback(api.ajax.json());
	                        });
	                    }

	                    if (_fnDataSource(settings) == 'ssp') {
	                        _fnReDraw(settings, holdPosition);
	                    }
	                    else {
	                        // Trigger xhr
	                        _fnProcessingDisplay(settings, true);

	                        _fnBuildAjax(settings, [], function (json) {
	                            _fnClearTable(settings);

	                            var data = _fnAjaxDataSrc(settings, json);
	                            for (var i = 0, ien = data.length ; i < ien ; i++) {
	                                _fnAddData(settings, data[i]);
	                            }

	                            _fnReDraw(settings, holdPosition);
	                            _fnProcessingDisplay(settings, false);
	                        });
	                    }
	                };


	                /**
	                 * Get the JSON response from the last Ajax request that DataTables made to the
	                 * server. Note that this returns the JSON from the first table in the current
	                 * context.
	                 *
	                 * @return {object} JSON received from the server.
	                 */
	                _api_register('ajax.json()', function () {
	                    var ctx = this.context;

	                    if (ctx.length > 0) {
	                        return ctx[0].json;
	                    }

	                    // else return undefined;
	                });


	                /**
	                 * Get the data submitted in the last Ajax request
	                 */
	                _api_register('ajax.params()', function () {
	                    var ctx = this.context;

	                    if (ctx.length > 0) {
	                        return ctx[0].oAjaxData;
	                    }

	                    // else return undefined;
	                });


	                /**
	                 * Reload tables from the Ajax data source. Note that this function will
	                 * automatically re-draw the table when the remote data has been loaded.
	                 *
	                 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	                 *   position. A full re-sort and re-filter is performed when this method is
	                 *   called, which is why the pagination reset is the default action.
	                 * @returns {DataTables.Api} this
	                 */
	                _api_register('ajax.reload()', function (callback, resetPaging) {
	                    return this.iterator('table', function (settings) {
	                        __reload(settings, resetPaging === false, callback);
	                    });
	                });


	                /**
	                 * Get the current Ajax URL. Note that this returns the URL from the first
	                 * table in the current context.
	                 *
	                 * @return {string} Current Ajax source URL
	                 *//**
		 * Set the Ajax URL. Note that this will set the URL for all tables in the
		 * current context.
		 *
		 * @param {string} url URL to set.
		 * @returns {DataTables.Api} this
		 */
	                _api_register('ajax.url()', function (url) {
	                    var ctx = this.context;

	                    if (url === undefined) {
	                        // get
	                        if (ctx.length === 0) {
	                            return undefined;
	                        }
	                        ctx = ctx[0];

	                        return ctx.ajax ?
	                            $.isPlainObject(ctx.ajax) ?
	                                ctx.ajax.url :
	                                ctx.ajax :
	                            ctx.sAjaxSource;
	                    }

	                    // set
	                    return this.iterator('table', function (settings) {
	                        if ($.isPlainObject(settings.ajax)) {
	                            settings.ajax.url = url;
	                        }
	                        else {
	                            settings.ajax = url;
	                        }
	                        // No need to consider sAjaxSource here since DataTables gives priority
	                        // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
	                        // value of `sAjaxSource` redundant.
	                    });
	                });


	                /**
	                 * Load data from the newly set Ajax URL. Note that this method is only
	                 * available when `ajax.url()` is used to set a URL. Additionally, this method
	                 * has the same effect as calling `ajax.reload()` but is provided for
	                 * convenience when setting a new URL. Like `ajax.reload()` it will
	                 * automatically redraw the table once the remote data has been loaded.
	                 *
	                 * @returns {DataTables.Api} this
	                 */
	                _api_register('ajax.url().load()', function (callback, resetPaging) {
	                    // Same as a reload, but makes sense to present it for easy access after a
	                    // url change
	                    return this.iterator('table', function (ctx) {
	                        __reload(ctx, resetPaging === false, callback);
	                    });
	                });




	                var _selector_run = function (type, selector, selectFn, settings, opts) {
	                    var
	                        out = [], res,
	                        a, i, ien, j, jen,
	                        selectorType = typeof selector;

	                    // Can't just check for isArray here, as an API or jQuery instance might be
	                    // given with their array like look
	                    if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
	                        selector = [selector];
	                    }

	                    for (i = 0, ien = selector.length ; i < ien ; i++) {
	                        a = selector[i] && selector[i].split ?
	                            selector[i].split(',') :
	                            [selector[i]];

	                        for (j = 0, jen = a.length ; j < jen ; j++) {
	                            res = selectFn(typeof a[j] === 'string' ? $.trim(a[j]) : a[j]);

	                            if (res && res.length) {
	                                out.push.apply(out, res);
	                            }
	                        }
	                    }

	                    // selector extensions
	                    var ext = _ext.selector[type];
	                    if (ext.length) {
	                        for (i = 0, ien = ext.length ; i < ien ; i++) {
	                            out = ext[i](settings, opts, out);
	                        }
	                    }

	                    return out;
	                };


	                var _selector_opts = function (opts) {
	                    if (!opts) {
	                        opts = {};
	                    }

	                    // Backwards compatibility for 1.9- which used the terminology filter rather
	                    // than search
	                    if (opts.filter && opts.search === undefined) {
	                        opts.search = opts.filter;
	                    }

	                    return $.extend({
	                        search: 'none',
	                        order: 'current',
	                        page: 'all'
	                    }, opts);
	                };


	                var _selector_first = function (inst) {
	                    // Reduce the API instance to the first item found
	                    for (var i = 0, ien = inst.length ; i < ien ; i++) {
	                        if (inst[i].length > 0) {
	                            // Assign the first element to the first item in the instance
	                            // and truncate the instance and context
	                            inst[0] = inst[i];
	                            inst[0].length = 1;
	                            inst.length = 1;
	                            inst.context = [inst.context[i]];

	                            return inst;
	                        }
	                    }

	                    // Not found - return an empty instance
	                    inst.length = 0;
	                    return inst;
	                };


	                var _selector_row_indexes = function (settings, opts) {
	                    var
	                        i, ien, tmp, a = [],
	                        displayFiltered = settings.aiDisplay,
	                        displayMaster = settings.aiDisplayMaster;

	                    var
	                        search = opts.search,  // none, applied, removed
	                        order = opts.order,   // applied, current, index (original - compatibility with 1.9)
	                        page = opts.page;    // all, current

	                    if (_fnDataSource(settings) == 'ssp') {
	                        // In server-side processing mode, most options are irrelevant since
	                        // rows not shown don't exist and the index order is the applied order
	                        // Removed is a special case - for consistency just return an empty
	                        // array
	                        return search === 'removed' ?
	                            [] :
	                            _range(0, displayMaster.length);
	                    }
	                    else if (page == 'current') {
	                        // Current page implies that order=current and fitler=applied, since it is
	                        // fairly senseless otherwise, regardless of what order and search actually
	                        // are
	                        for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd() ; i < ien ; i++) {
	                            a.push(displayFiltered[i]);
	                        }
	                    }
	                    else if (order == 'current' || order == 'applied') {
	                        a = search == 'none' ?
	                            displayMaster.slice() :                      // no search
	                            search == 'applied' ?
	                                displayFiltered.slice() :                // applied search
	                                $.map(displayMaster, function (el, i) { // removed search
	                                    return $.inArray(el, displayFiltered) === -1 ? el : null;
	                                });
	                    }
	                    else if (order == 'index' || order == 'original') {
	                        for (i = 0, ien = settings.aoData.length ; i < ien ; i++) {
	                            if (search == 'none') {
	                                a.push(i);
	                            }
	                            else { // applied | removed
	                                tmp = $.inArray(i, displayFiltered);

	                                if ((tmp === -1 && search == 'removed') ||
	                                    (tmp >= 0 && search == 'applied')) {
	                                    a.push(i);
	                                }
	                            }
	                        }
	                    }

	                    return a;
	                };


	                /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	                 * Rows
	                 *
	                 * {}          - no selector - use all available rows
	                 * {integer}   - row aoData index
	                 * {node}      - TR node
	                 * {string}    - jQuery selector to apply to the TR elements
	                 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	                 *
	                 */


	                var __row_selector = function (settings, selector, opts) {
	                    var run = function (sel) {
	                        var selInt = _intVal(sel);
	                        var i, ien;

	                        // Short cut - selector is a number and no options provided (default is
	                        // all records, so no need to check if the index is in there, since it
	                        // must be - dev error if the index doesn't exist).
	                        if (selInt !== null && !opts) {
	                            return [selInt];
	                        }

	                        var rows = _selector_row_indexes(settings, opts);

	                        if (selInt !== null && $.inArray(selInt, rows) !== -1) {
	                            // Selector - integer
	                            return [selInt];
	                        }
	                        else if (!sel) {
	                            // Selector - none
	                            return rows;
	                        }

	                        // Selector - function
	                        if (typeof sel === 'function') {
	                            return $.map(rows, function (idx) {
	                                var row = settings.aoData[idx];
	                                return sel(idx, row._aData, row.nTr) ? idx : null;
	                            });
	                        }

	                        // Get nodes in the order from the `rows` array with null values removed
	                        var nodes = _removeEmpty(
	                            _pluck_order(settings.aoData, rows, 'nTr')
	                        );

	                        // Selector - node
	                        if (sel.nodeName) {
	                            if ($.inArray(sel, nodes) !== -1) {
	                                return [sel._DT_RowIndex]; // sel is a TR node that is in the table
	                                // and DataTables adds a prop for fast lookup
	                            }
	                        }

	                        // Selector - jQuery selector string, array of nodes or jQuery object/
	                        // As jQuery's .filter() allows jQuery objects to be passed in filter,
	                        // it also allows arrays, so this will cope with all three options
	                        return $(nodes)
	                            .filter(sel)
	                            .map(function () {
	                                return this._DT_RowIndex;
	                            })
	                            .toArray();
	                    };

	                    return _selector_run('row', selector, run, settings, opts);
	                };


	                _api_register('rows()', function (selector, opts) {
	                    // argument shifting
	                    if (selector === undefined) {
	                        selector = '';
	                    }
	                    else if ($.isPlainObject(selector)) {
	                        opts = selector;
	                        selector = '';
	                    }

	                    opts = _selector_opts(opts);

	                    var inst = this.iterator('table', function (settings) {
	                        return __row_selector(settings, selector, opts);
	                    }, 1);

	                    // Want argument shifting here and in __row_selector?
	                    inst.selector.rows = selector;
	                    inst.selector.opts = opts;

	                    return inst;
	                });

	                _api_register('rows().nodes()', function () {
	                    return this.iterator('row', function (settings, row) {
	                        return settings.aoData[row].nTr || undefined;
	                    }, 1);
	                });

	                _api_register('rows().data()', function () {
	                    return this.iterator(true, 'rows', function (settings, rows) {
	                        return _pluck_order(settings.aoData, rows, '_aData');
	                    }, 1);
	                });

	                _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
	                    return this.iterator('row', function (settings, row) {
	                        var r = settings.aoData[row];
	                        return type === 'search' ? r._aFilterData : r._aSortData;
	                    }, 1);
	                });

	                _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
	                    return this.iterator('row', function (settings, row) {
	                        _fnInvalidate(settings, row, src);
	                    });
	                });

	                _api_registerPlural('rows().indexes()', 'row().index()', function () {
	                    return this.iterator('row', function (settings, row) {
	                        return row;
	                    }, 1);
	                });

	                _api_registerPlural('rows().remove()', 'row().remove()', function () {
	                    var that = this;

	                    return this.iterator('row', function (settings, row, thatIdx) {
	                        var data = settings.aoData;

	                        data.splice(row, 1);

	                        // Update the _DT_RowIndex parameter on all rows in the table
	                        for (var i = 0, ien = data.length ; i < ien ; i++) {
	                            if (data[i].nTr !== null) {
	                                data[i].nTr._DT_RowIndex = i;
	                            }
	                        }

	                        // Remove the target row from the search array
	                        var displayIndex = $.inArray(row, settings.aiDisplay);

	                        // Delete from the display arrays
	                        _fnDeleteIndex(settings.aiDisplayMaster, row);
	                        _fnDeleteIndex(settings.aiDisplay, row);
	                        _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes

	                        // Check for an 'overflow' they case for displaying the table
	                        _fnLengthOverflow(settings);
	                    });
	                });


	                _api_register('rows.add()', function (rows) {
	                    var newRows = this.iterator('table', function (settings) {
	                        var row, i, ien;
	                        var out = [];

	                        for (i = 0, ien = rows.length ; i < ien ; i++) {
	                            row = rows[i];

	                            if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
	                                out.push(_fnAddTr(settings, row)[0]);
	                            }
	                            else {
	                                out.push(_fnAddData(settings, row));
	                            }
	                        }

	                        return out;
	                    }, 1);

	                    // Return an Api.rows() extended instance, so rows().nodes() etc can be used
	                    var modRows = this.rows(-1);
	                    modRows.pop();
	                    modRows.push.apply(modRows, newRows.toArray());

	                    return modRows;
	                });





	                /**
	                 *
	                 */
	                _api_register('row()', function (selector, opts) {
	                    return _selector_first(this.rows(selector, opts));
	                });


	                _api_register('row().data()', function (data) {
	                    var ctx = this.context;

	                    if (data === undefined) {
	                        // Get
	                        return ctx.length && this.length ?
	                            ctx[0].aoData[this[0]]._aData :
	                            undefined;
	                    }

	                    // Set
	                    ctx[0].aoData[this[0]]._aData = data;

	                    // Automatically invalidate
	                    _fnInvalidate(ctx[0], this[0], 'data');

	                    return this;
	                });


	                _api_register('row().node()', function () {
	                    var ctx = this.context;

	                    return ctx.length && this.length ?
	                        ctx[0].aoData[this[0]].nTr || null :
	                        null;
	                });


	                _api_register('row.add()', function (row) {
	                    // Allow a jQuery object to be passed in - only a single row is added from
	                    // it though - the first element in the set
	                    if (row instanceof $ && row.length) {
	                        row = row[0];
	                    }

	                    var rows = this.iterator('table', function (settings) {
	                        if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
	                            return _fnAddTr(settings, row)[0];
	                        }
	                        return _fnAddData(settings, row);
	                    });

	                    // Return an Api.rows() extended instance, with the newly added row selected
	                    return this.row(rows[0]);
	                });



	                var __details_add = function (ctx, row, data, klass) {
	                    // Convert to array of TR elements
	                    var rows = [];
	                    var addRow = function (r, k) {
	                        // Recursion to allow for arrays of jQuery objects
	                        if ($.isArray(r) || r instanceof $) {
	                            for (var i = 0, ien = r.length ; i < ien ; i++) {
	                                addRow(r[i], k);
	                            }
	                            return;
	                        }

	                        // If we get a TR element, then just add it directly - up to the dev
	                        // to add the correct number of columns etc
	                        if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
	                            rows.push(r);
	                        }
	                        else {
	                            // Otherwise create a row with a wrapper
	                            var created = $('<tr><td/></tr>').addClass(k);
	                            $('td', created)
	                                .addClass(k)
	                                .html(r)
	                                [0].colSpan = _fnVisbleColumns(ctx);

	                            rows.push(created[0]);
	                        }
	                    };

	                    addRow(data, klass);

	                    if (row._details) {
	                        row._details.remove();
	                    }

	                    row._details = $(rows);

	                    // If the children were already shown, that state should be retained
	                    if (row._detailsShow) {
	                        row._details.insertAfter(row.nTr);
	                    }
	                };


	                var __details_remove = function (api, idx) {
	                    var ctx = api.context;

	                    if (ctx.length) {
	                        var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

	                        if (row._details) {
	                            row._details.remove();

	                            row._detailsShow = undefined;
	                            row._details = undefined;
	                        }
	                    }
	                };


	                var __details_display = function (api, show) {
	                    var ctx = api.context;

	                    if (ctx.length && api.length) {
	                        var row = ctx[0].aoData[api[0]];

	                        if (row._details) {
	                            row._detailsShow = show;

	                            if (show) {
	                                row._details.insertAfter(row.nTr);
	                            }
	                            else {
	                                row._details.detach();
	                            }

	                            __details_events(ctx[0]);
	                        }
	                    }
	                };


	                var __details_events = function (settings) {
	                    var api = new _Api(settings);
	                    var namespace = '.dt.DT_details';
	                    var drawEvent = 'draw' + namespace;
	                    var colvisEvent = 'column-visibility' + namespace;
	                    var destroyEvent = 'destroy' + namespace;
	                    var data = settings.aoData;

	                    api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

	                    if (_pluck(data, '_details').length > 0) {
	                        // On each draw, insert the required elements into the document
	                        api.on(drawEvent, function (e, ctx) {
	                            if (settings !== ctx) {
	                                return;
	                            }

	                            api.rows({ page: 'current' }).eq(0).each(function (idx) {
	                                // Internal data grab
	                                var row = data[idx];

	                                if (row._detailsShow) {
	                                    row._details.insertAfter(row.nTr);
	                                }
	                            });
	                        });

	                        // Column visibility change - update the colspan
	                        api.on(colvisEvent, function (e, ctx, idx, vis) {
	                            if (settings !== ctx) {
	                                return;
	                            }

	                            // Update the colspan for the details rows (note, only if it already has
	                            // a colspan)
	                            var row, visible = _fnVisbleColumns(ctx);

	                            for (var i = 0, ien = data.length ; i < ien ; i++) {
	                                row = data[i];

	                                if (row._details) {
	                                    row._details.children('td[colspan]').attr('colspan', visible);
	                                }
	                            }
	                        });

	                        // Table destroyed - nuke any child rows
	                        api.on(destroyEvent, function (e, ctx) {
	                            if (settings !== ctx) {
	                                return;
	                            }

	                            for (var i = 0, ien = data.length ; i < ien ; i++) {
	                                if (data[i]._details) {
	                                    __details_remove(api, i);
	                                }
	                            }
	                        });
	                    }
	                };

	                // Strings for the method names to help minification
	                var _emp = '';
	                var _child_obj = _emp + 'row().child';
	                var _child_mth = _child_obj + '()';

	                // data can be:
	                //  tr
	                //  string
	                //  jQuery or array of any of the above
	                _api_register(_child_mth, function (data, klass) {
	                    var ctx = this.context;

	                    if (data === undefined) {
	                        // get
	                        return ctx.length && this.length ?
	                            ctx[0].aoData[this[0]]._details :
	                            undefined;
	                    }
	                    else if (data === true) {
	                        // show
	                        this.child.show();
	                    }
	                    else if (data === false) {
	                        // remove
	                        __details_remove(this);
	                    }
	                    else if (ctx.length && this.length) {
	                        // set
	                        __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
	                    }

	                    return this;
	                });


	                _api_register([
	                    _child_obj + '.show()',
	                    _child_mth + '.show()' // only when `child()` was called with parameters (without
	                ], function (show) {   // it returns an object and this method is not executed)
	                    __details_display(this, true);
	                    return this;
	                });


	                _api_register([
	                    _child_obj + '.hide()',
	                    _child_mth + '.hide()' // only when `child()` was called with parameters (without
	                ], function () {         // it returns an object and this method is not executed)
	                    __details_display(this, false);
	                    return this;
	                });


	                _api_register([
	                    _child_obj + '.remove()',
	                    _child_mth + '.remove()' // only when `child()` was called with parameters (without
	                ], function () {           // it returns an object and this method is not executed)
	                    __details_remove(this);
	                    return this;
	                });


	                _api_register(_child_obj + '.isShown()', function () {
	                    var ctx = this.context;

	                    if (ctx.length && this.length) {
	                        // _detailsShown as false or undefined will fall through to return false
	                        return ctx[0].aoData[this[0]]._detailsShow || false;
	                    }
	                    return false;
	                });



	                /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	                 * Columns
	                 *
	                 * {integer}           - column index (>=0 count from left, <0 count from right)
	                 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
	                 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
	                 * "{string}:name"     - column name
	                 * "{string}"          - jQuery selector on column header nodes
	                 *
	                 */

	                // can be an array of these items, comma separated list, or an array of comma
	                // separated lists

	                var __re_column_selector = /^(.+):(name|visIdx|visible)$/;


	                // r1 and r2 are redundant - but it means that the parameters match for the
	                // iterator callback in columns().data()
	                var __columnData = function (settings, column, r1, r2, rows) {
	                    var a = [];
	                    for (var row = 0, ien = rows.length ; row < ien ; row++) {
	                        a.push(_fnGetCellData(settings, rows[row], column));
	                    }
	                    return a;
	                };


	                var __column_selector = function (settings, selector, opts) {
	                    var
	                        columns = settings.aoColumns,
	                        names = _pluck(columns, 'sName'),
	                        nodes = _pluck(columns, 'nTh');

	                    var run = function (s) {
	                        var selInt = _intVal(s);

	                        // Selector - all
	                        if (s === '') {
	                            return _range(columns.length);
	                        }

	                        // Selector - index
	                        if (selInt !== null) {
	                            return [selInt >= 0 ?
	                                selInt : // Count from left
	                                columns.length + selInt // Count from right (+ because its a negative value)
	                            ];
	                        }

	                        // Selector = function
	                        if (typeof s === 'function') {
	                            var rows = _selector_row_indexes(settings, opts);

	                            return $.map(columns, function (col, idx) {
	                                return s(
	                                        idx,
	                                        __columnData(settings, idx, 0, 0, rows),
	                                        nodes[idx]
	                                    ) ? idx : null;
	                            });
	                        }

	                        // jQuery or string selector
	                        var match = typeof s === 'string' ?
	                            s.match(__re_column_selector) :
	                            '';

	                        if (match) {
	                            switch (match[2]) {
	                                case 'visIdx':
	                                case 'visible':
	                                    var idx = parseInt(match[1], 10);
	                                    // Visible index given, convert to column index
	                                    if (idx < 0) {
	                                        // Counting from the right
	                                        var visColumns = $.map(columns, function (col, i) {
	                                            return col.bVisible ? i : null;
	                                        });
	                                        return [visColumns[visColumns.length + idx]];
	                                    }
	                                    // Counting from the left
	                                    return [_fnVisibleToColumnIndex(settings, idx)];

	                                case 'name':
	                                    // match by name. `names` is column index complete and in order
	                                    return $.map(names, function (name, i) {
	                                        return name === match[1] ? i : null;
	                                    });
	                            }
	                        }
	                        else {
	                            // jQuery selector on the TH elements for the columns
	                            return $(nodes)
	                                .filter(s)
	                                .map(function () {
	                                    return $.inArray(this, nodes); // `nodes` is column index complete and in order
	                                })
	                                .toArray();
	                        }
	                    };

	                    return _selector_run('column', selector, run, settings, opts);
	                };


	                var __setColumnVis = function (settings, column, vis, recalc) {
	                    var
	                        cols = settings.aoColumns,
	                        col = cols[column],
	                        data = settings.aoData,
	                        row, cells, i, ien, tr;

	                    // Get
	                    if (vis === undefined) {
	                        return col.bVisible;
	                    }

	                    // Set
	                    // No change
	                    if (col.bVisible === vis) {
	                        return;
	                    }

	                    if (vis) {
	                        // Insert column
	                        // Need to decide if we should use appendChild or insertBefore
	                        var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

	                        for (i = 0, ien = data.length ; i < ien ; i++) {
	                            tr = data[i].nTr;
	                            cells = data[i].anCells;

	                            if (tr) {
	                                // insertBefore can act like appendChild if 2nd arg is null
	                                tr.insertBefore(cells[column], cells[insertBefore] || null);
	                            }
	                        }
	                    }
	                    else {
	                        // Remove column
	                        $(_pluck(settings.aoData, 'anCells', column)).detach();
	                    }

	                    // Common actions
	                    col.bVisible = vis;
	                    _fnDrawHead(settings, settings.aoHeader);
	                    _fnDrawHead(settings, settings.aoFooter);

	                    if (recalc === undefined || recalc) {
	                        // Automatically adjust column sizing
	                        _fnAdjustColumnSizing(settings);

	                        // Realign columns for scrolling
	                        if (settings.oScroll.sX || settings.oScroll.sY) {
	                            _fnScrollDraw(settings);
	                        }
	                    }

	                    _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis]);

	                    _fnSaveState(settings);
	                };


	                _api_register('columns()', function (selector, opts) {
	                    // argument shifting
	                    if (selector === undefined) {
	                        selector = '';
	                    }
	                    else if ($.isPlainObject(selector)) {
	                        opts = selector;
	                        selector = '';
	                    }

	                    opts = _selector_opts(opts);

	                    var inst = this.iterator('table', function (settings) {
	                        return __column_selector(settings, selector, opts);
	                    }, 1);

	                    // Want argument shifting here and in _row_selector?
	                    inst.selector.cols = selector;
	                    inst.selector.opts = opts;

	                    return inst;
	                });

	                _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
	                    return this.iterator('column', function (settings, column) {
	                        return settings.aoColumns[column].nTh;
	                    }, 1);
	                });

	                _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
	                    return this.iterator('column', function (settings, column) {
	                        return settings.aoColumns[column].nTf;
	                    }, 1);
	                });

	                _api_registerPlural('columns().data()', 'column().data()', function () {
	                    return this.iterator('column-rows', __columnData, 1);
	                });

	                _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
	                    return this.iterator('column', function (settings, column) {
	                        return settings.aoColumns[column].mData;
	                    }, 1);
	                });

	                _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
	                    return this.iterator('column-rows', function (settings, column, i, j, rows) {
	                        return _pluck_order(settings.aoData, rows,
	                            type === 'search' ? '_aFilterData' : '_aSortData', column
	                        );
	                    }, 1);
	                });

	                _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
	                    return this.iterator('column-rows', function (settings, column, i, j, rows) {
	                        return _pluck_order(settings.aoData, rows, 'anCells', column);
	                    }, 1);
	                });

	                _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
	                    return this.iterator('column', function (settings, column) {
	                        if (vis === undefined) {
	                            return settings.aoColumns[column].bVisible;
	                        } // else
	                        __setColumnVis(settings, column, vis, calc);
	                    });
	                });

	                _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
	                    return this.iterator('column', function (settings, column) {
	                        return type === 'visible' ?
	                            _fnColumnIndexToVisible(settings, column) :
	                            column;
	                    }, 1);
	                });

	                _api_register('columns.adjust()', function () {
	                    return this.iterator('table', function (settings) {
	                        _fnAdjustColumnSizing(settings);
	                    }, 1);
	                });

	                _api_register('column.index()', function (type, idx) {
	                    if (this.context.length !== 0) {
	                        var ctx = this.context[0];

	                        if (type === 'fromVisible' || type === 'toData') {
	                            return _fnVisibleToColumnIndex(ctx, idx);
	                        }
	                        else if (type === 'fromData' || type === 'toVisible') {
	                            return _fnColumnIndexToVisible(ctx, idx);
	                        }
	                    }
	                });

	                _api_register('column()', function (selector, opts) {
	                    return _selector_first(this.columns(selector, opts));
	                });




	                var __cell_selector = function (settings, selector, opts) {
	                    var data = settings.aoData;
	                    var rows = _selector_row_indexes(settings, opts);
	                    var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));
	                    var allCells = $([].concat.apply([], cells));
	                    var row;
	                    var columns = settings.aoColumns.length;
	                    var a, i, ien, j, o, host;

	                    var run = function (s) {
	                        var fnSelector = typeof s === 'function';

	                        if (s === null || s === undefined || fnSelector) {
	                            // All cells and function selectors
	                            a = [];

	                            for (i = 0, ien = rows.length ; i < ien ; i++) {
	                                row = rows[i];

	                                for (j = 0 ; j < columns ; j++) {
	                                    o = {
	                                        row: row,
	                                        column: j
	                                    };

	                                    if (fnSelector) {
	                                        // Selector - function
	                                        host = settings.aoData[row];

	                                        if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
	                                            a.push(o);
	                                        }
	                                    }
	                                    else {
	                                        // Selector - all
	                                        a.push(o);
	                                    }
	                                }
	                            }

	                            return a;
	                        }

	                        // Selector - index
	                        if ($.isPlainObject(s)) {
	                            return [s];
	                        }

	                        // Selector - jQuery filtered cells
	                        return allCells
	                            .filter(s)
	                            .map(function (i, el) {
	                                row = el.parentNode._DT_RowIndex;

	                                return {
	                                    row: row,
	                                    column: $.inArray(el, data[row].anCells)
	                                };
	                            })
	                            .toArray();
	                    };

	                    return _selector_run('cell', selector, run, settings, opts);
	                };




	                _api_register('cells()', function (rowSelector, columnSelector, opts) {
	                    // Argument shifting
	                    if ($.isPlainObject(rowSelector)) {
	                        // Indexes
	                        if (rowSelector.row === undefined) {
	                            // Selector options in first parameter
	                            opts = rowSelector;
	                            rowSelector = null;
	                        }
	                        else {
	                            // Cell index objects in first parameter
	                            opts = columnSelector;
	                            columnSelector = null;
	                        }
	                    }
	                    if ($.isPlainObject(columnSelector)) {
	                        opts = columnSelector;
	                        columnSelector = null;
	                    }

	                    // Cell selector
	                    if (columnSelector === null || columnSelector === undefined) {
	                        return this.iterator('table', function (settings) {
	                            return __cell_selector(settings, rowSelector, _selector_opts(opts));
	                        });
	                    }

	                    // Row + column selector
	                    var columns = this.columns(columnSelector, opts);
	                    var rows = this.rows(rowSelector, opts);
	                    var a, i, ien, j, jen;

	                    var cells = this.iterator('table', function (settings, idx) {
	                        a = [];

	                        for (i = 0, ien = rows[idx].length ; i < ien ; i++) {
	                            for (j = 0, jen = columns[idx].length ; j < jen ; j++) {
	                                a.push({
	                                    row: rows[idx][i],
	                                    column: columns[idx][j]
	                                });
	                            }
	                        }

	                        return a;
	                    }, 1);

	                    $.extend(cells.selector, {
	                        cols: columnSelector,
	                        rows: rowSelector,
	                        opts: opts
	                    });

	                    return cells;
	                });


	                _api_registerPlural('cells().nodes()', 'cell().node()', function () {
	                    return this.iterator('cell', function (settings, row, column) {
	                        var cells = settings.aoData[row].anCells;
	                        return cells ?
	                            cells[column] :
	                            undefined;
	                    }, 1);
	                });


	                _api_register('cells().data()', function () {
	                    return this.iterator('cell', function (settings, row, column) {
	                        return _fnGetCellData(settings, row, column);
	                    }, 1);
	                });


	                _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
	                    type = type === 'search' ? '_aFilterData' : '_aSortData';

	                    return this.iterator('cell', function (settings, row, column) {
	                        return settings.aoData[row][type][column];
	                    }, 1);
	                });


	                _api_registerPlural('cells().render()', 'cell().render()', function (type) {
	                    return this.iterator('cell', function (settings, row, column) {
	                        return _fnGetCellData(settings, row, column, type);
	                    }, 1);
	                });


	                _api_registerPlural('cells().indexes()', 'cell().index()', function () {
	                    return this.iterator('cell', function (settings, row, column) {
	                        return {
	                            row: row,
	                            column: column,
	                            columnVisible: _fnColumnIndexToVisible(settings, column)
	                        };
	                    }, 1);
	                });


	                _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
	                    return this.iterator('cell', function (settings, row, column) {
	                        _fnInvalidate(settings, row, src, column);
	                    });
	                });



	                _api_register('cell()', function (rowSelector, columnSelector, opts) {
	                    return _selector_first(this.cells(rowSelector, columnSelector, opts));
	                });


	                _api_register('cell().data()', function (data) {
	                    var ctx = this.context;
	                    var cell = this[0];

	                    if (data === undefined) {
	                        // Get
	                        return ctx.length && cell.length ?
	                            _fnGetCellData(ctx[0], cell[0].row, cell[0].column) :
	                            undefined;
	                    }

	                    // Set
	                    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
	                    _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

	                    return this;
	                });



	                /**
	                 * Get current ordering (sorting) that has been applied to the table.
	                 *
	                 * @returns {array} 2D array containing the sorting information for the first
	                 *   table in the current context. Each element in the parent array represents
	                 *   a column being sorted upon (i.e. multi-sorting with two columns would have
	                 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
	                 *   the column index that the sorting condition applies to, the second is the
	                 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
	                 *   index of the sorting order from the `column.sorting` initialisation array.
	                 *//**
		 * Set the ordering for the table.
		 *
		 * @param {integer} order Column index to sort upon.
		 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 1D array of sorting information to be applied.
		 * @param {array} [...] Optional additional sorting conditions
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 2D array of sorting information to be applied.
		 * @returns {DataTables.Api} this
		 */
	                _api_register('order()', function (order, dir) {
	                    var ctx = this.context;

	                    if (order === undefined) {
	                        // get
	                        return ctx.length !== 0 ?
	                            ctx[0].aaSorting :
	                            undefined;
	                    }

	                    // set
	                    if (typeof order === 'number') {
	                        // Simple column / direction passed in
	                        order = [[order, dir]];
	                    }
	                    else if (!$.isArray(order[0])) {
	                        // Arguments passed in (list of 1D arrays)
	                        order = Array.prototype.slice.call(arguments);
	                    }
	                    // otherwise a 2D array was passed in

	                    return this.iterator('table', function (settings) {
	                        settings.aaSorting = order.slice();
	                    });
	                });


	                /**
	                 * Attach a sort listener to an element for a given column
	                 *
	                 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
	                 *   listener to. This can take the form of a single DOM node, a jQuery
	                 *   collection of nodes or a jQuery selector which will identify the node(s).
	                 * @param {integer} column the column that a click on this node will sort on
	                 * @param {function} [callback] callback function when sort is run
	                 * @returns {DataTables.Api} this
	                 */
	                _api_register('order.listener()', function (node, column, callback) {
	                    return this.iterator('table', function (settings) {
	                        _fnSortAttachListener(settings, node, column, callback);
	                    });
	                });


	                // Order by the selected column(s)
	                _api_register([
	                    'columns().order()',
	                    'column().order()'
	                ], function (dir) {
	                    var that = this;

	                    return this.iterator('table', function (settings, i) {
	                        var sort = [];

	                        $.each(that[i], function (j, col) {
	                            sort.push([col, dir]);
	                        });

	                        settings.aaSorting = sort;
	                    });
	                });



	                _api_register('search()', function (input, regex, smart, caseInsen) {
	                    var ctx = this.context;

	                    if (input === undefined) {
	                        // get
	                        return ctx.length !== 0 ?
	                            ctx[0].oPreviousSearch.sSearch :
	                            undefined;
	                    }

	                    // set
	                    return this.iterator('table', function (settings) {
	                        if (!settings.oFeatures.bFilter) {
	                            return;
	                        }

	                        _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
	                            "sSearch": input + "",
	                            "bRegex": regex === null ? false : regex,
	                            "bSmart": smart === null ? true : smart,
	                            "bCaseInsensitive": caseInsen === null ? true : caseInsen
	                        }), 1);
	                    });
	                });


	                _api_registerPlural(
	                    'columns().search()',
	                    'column().search()',
	                    function (input, regex, smart, caseInsen) {
	                        return this.iterator('column', function (settings, column) {
	                            var preSearch = settings.aoPreSearchCols;

	                            if (input === undefined) {
	                                // get
	                                return preSearch[column].sSearch;
	                            }

	                            // set
	                            if (!settings.oFeatures.bFilter) {
	                                return;
	                            }

	                            $.extend(preSearch[column], {
	                                "sSearch": input + "",
	                                "bRegex": regex === null ? false : regex,
	                                "bSmart": smart === null ? true : smart,
	                                "bCaseInsensitive": caseInsen === null ? true : caseInsen
	                            });

	                            _fnFilterComplete(settings, settings.oPreviousSearch, 1);
	                        });
	                    }
	                );

	                /*
	                 * State API methods
	                 */

	                _api_register('state()', function () {
	                    return this.context.length ?
	                        this.context[0].oSavedState :
	                        null;
	                });


	                _api_register('state.clear()', function () {
	                    return this.iterator('table', function (settings) {
	                        // Save an empty object
	                        settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
	                    });
	                });


	                _api_register('state.loaded()', function () {
	                    return this.context.length ?
	                        this.context[0].oLoadedState :
	                        null;
	                });


	                _api_register('state.save()', function () {
	                    return this.iterator('table', function (settings) {
	                        _fnSaveState(settings);
	                    });
	                });



	                /**
	                 * Provide a common method for plug-ins to check the version of DataTables being
	                 * used, in order to ensure compatibility.
	                 *
	                 *  @param {string} version Version string to check for, in the format "X.Y.Z".
	                 *    Note that the formats "X" and "X.Y" are also acceptable.
	                 *  @returns {boolean} true if this version of DataTables is greater or equal to
	                 *    the required version, or false if this version of DataTales is not
	                 *    suitable
	                 *  @static
	                 *  @dtopt API-Static
	                 *
	                 *  @example
	                 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
	                 */
	                DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
	                    var aThis = DataTable.version.split('.');
	                    var aThat = version.split('.');
	                    var iThis, iThat;

	                    for (var i = 0, iLen = aThat.length ; i < iLen ; i++) {
	                        iThis = parseInt(aThis[i], 10) || 0;
	                        iThat = parseInt(aThat[i], 10) || 0;

	                        // Parts are the same, keep comparing
	                        if (iThis === iThat) {
	                            continue;
	                        }

	                        // Parts are different, return immediately
	                        return iThis > iThat;
	                    }

	                    return true;
	                };


	                /**
	                 * Check if a `<table>` node is a DataTable table already or not.
	                 *
	                 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
	                 *      selector for the table to test. Note that if more than more than one
	                 *      table is passed on, only the first will be checked
	                 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	                 *  @static
	                 *  @dtopt API-Static
	                 *
	                 *  @example
	                 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
	                 *      $('#example').dataTable();
	                 *    }
	                 */
	                DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
	                    var t = $(table).get(0);
	                    var is = false;

	                    $.each(DataTable.settings, function (i, o) {
	                        var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
	                        var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

	                        if (o.nTable === t || head === t || foot === t) {
	                            is = true;
	                        }
	                    });

	                    return is;
	                };


	                /**
	                 * Get all DataTable tables that have been initialised - optionally you can
	                 * select to get only currently visible tables.
	                 *
	                 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
	                 *    or visible tables only.
	                 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
	                 *    DataTables
	                 *  @static
	                 *  @dtopt API-Static
	                 *
	                 *  @example
	                 *    $.each( $.fn.dataTable.tables(true), function () {
	                 *      $(table).DataTable().columns.adjust();
	                 *    } );
	                 */
	                DataTable.tables = DataTable.fnTables = function (visible) {
	                    return $.map(DataTable.settings, function (o) {
	                        if (!visible || (visible && $(o.nTable).is(':visible'))) {
	                            return o.nTable;
	                        }
	                    });
	                };


	                /**
	                 * DataTables utility methods
	                 * 
	                 * This namespace provides helper methods that DataTables uses internally to
	                 * create a DataTable, but which are not exclusively used only for DataTables.
	                 * These methods can be used by extension authors to save the duplication of
	                 * code.
	                 *
	                 *  @namespace
	                 */
	                DataTable.util = {
	                    /**
	                     * Throttle the calls to a function. Arguments and context are maintained
	                     * for the throttled function.
	                     *
	                     * @param {function} fn Function to be called
	                     * @param {integer} freq Call frequency in mS
	                     * @return {function} Wrapped function
	                     */
	                    throttle: _fnThrottle,


	                    /**
	                     * Escape a string such that it can be used in a regular expression
	                     *
	                     *  @param {string} sVal string to escape
	                     *  @returns {string} escaped string
	                     */
	                    escapeRegex: _fnEscapeRegex
	                };


	                /**
	                 * Convert from camel case parameters to Hungarian notation. This is made public
	                 * for the extensions to provide the same ability as DataTables core to accept
	                 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
	                 * parameters.
	                 *
	                 *  @param {object} src The model object which holds all parameters that can be
	                 *    mapped.
	                 *  @param {object} user The object to convert from camel case to Hungarian.
	                 *  @param {boolean} force When set to `true`, properties which already have a
	                 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	                 *    won't be.
	                 */
	                DataTable.camelToHungarian = _fnCamelToHungarian;



	                /**
	                 *
	                 */
	                _api_register('$()', function (selector, opts) {
	                    var
	                        rows = this.rows(opts).nodes(), // Get all rows
	                        jqRows = $(rows);

	                    return $([].concat(
	                        jqRows.filter(selector).toArray(),
	                        jqRows.find(selector).toArray()
	                    ));
	                });


	                // jQuery functions to operate on the tables
	                $.each(['on', 'one', 'off'], function (i, key) {
	                    _api_register(key + '()', function ( /* event, handler */) {
	                        var args = Array.prototype.slice.call(arguments);

	                        // Add the `dt` namespace automatically if it isn't already present
	                        if (!args[0].match(/\.dt\b/)) {
	                            args[0] += '.dt';
	                        }

	                        var inst = $(this.tables().nodes());
	                        inst[key].apply(inst, args);
	                        return this;
	                    });
	                });


	                _api_register('clear()', function () {
	                    return this.iterator('table', function (settings) {
	                        _fnClearTable(settings);
	                    });
	                });


	                _api_register('settings()', function () {
	                    return new _Api(this.context, this.context);
	                });


	                _api_register('init()', function () {
	                    var ctx = this.context;
	                    return ctx.length ? ctx[0].oInit : null;
	                });


	                _api_register('data()', function () {
	                    return this.iterator('table', function (settings) {
	                        return _pluck(settings.aoData, '_aData');
	                    }).flatten();
	                });


	                _api_register('destroy()', function (remove) {
	                    remove = remove || false;

	                    return this.iterator('table', function (settings) {
	                        var orig = settings.nTableWrapper.parentNode;
	                        var classes = settings.oClasses;
	                        var table = settings.nTable;
	                        var tbody = settings.nTBody;
	                        var thead = settings.nTHead;
	                        var tfoot = settings.nTFoot;
	                        var jqTable = $(table);
	                        var jqTbody = $(tbody);
	                        var jqWrapper = $(settings.nTableWrapper);
	                        var rows = $.map(settings.aoData, function (r) { return r.nTr; });
	                        var i, ien;

	                        // Flag to note that the table is currently being destroyed - no action
	                        // should be taken
	                        settings.bDestroying = true;

	                        // Fire off the destroy callbacks for plug-ins etc
	                        _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]);

	                        // If not being removed from the document, make all columns visible
	                        if (!remove) {
	                            new _Api(settings).columns().visible(true);
	                        }

	                        // Blitz all `DT` namespaced events (these are internal events, the
	                        // lowercase, `dt` events are user subscribed and they are responsible
	                        // for removing them
	                        jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
	                        $(window).unbind('.DT-' + settings.sInstance);

	                        // When scrolling we had to break the table up - restore it
	                        if (table != thead.parentNode) {
	                            jqTable.children('thead').detach();
	                            jqTable.append(thead);
	                        }

	                        if (tfoot && table != tfoot.parentNode) {
	                            jqTable.children('tfoot').detach();
	                            jqTable.append(tfoot);
	                        }

	                        // Remove the DataTables generated nodes, events and classes
	                        jqTable.detach();
	                        jqWrapper.detach();

	                        settings.aaSorting = [];
	                        settings.aaSortingFixed = [];
	                        _fnSortingClasses(settings);

	                        $(rows).removeClass(settings.asStripeClasses.join(' '));

	                        $('th, td', thead).removeClass(classes.sSortable + ' ' +
	                            classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone
	                        );

	                        if (settings.bJUI) {
	                            $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach();
	                            $('th, td', thead).each(function () {
	                                var wrapper = $('div.' + classes.sSortJUIWrapper, this);
	                                $(this).append(wrapper.contents());
	                                wrapper.detach();
	                            });
	                        }

	                        if (!remove && orig) {
	                            // insertBefore acts like appendChild if !arg[1]
	                            orig.insertBefore(table, settings.nTableReinsertBefore);
	                        }

	                        // Add the TR elements back into the table in their original order
	                        jqTbody.children().detach();
	                        jqTbody.append(rows);

	                        // Restore the width of the original table - was read from the style property,
	                        // so we can restore directly to that
	                        jqTable
	                            .css('width', settings.sDestroyWidth)
	                            .removeClass(classes.sTable);

	                        // If the were originally stripe classes - then we add them back here.
	                        // Note this is not fool proof (for example if not all rows had stripe
	                        // classes - but it's a good effort without getting carried away
	                        ien = settings.asDestroyStripes.length;

	                        if (ien) {
	                            jqTbody.children().each(function (i) {
	                                $(this).addClass(settings.asDestroyStripes[i % ien]);
	                            });
	                        }

	                        /* Remove the settings object from the settings array */
	                        var idx = $.inArray(settings, DataTable.settings);
	                        if (idx !== -1) {
	                            DataTable.settings.splice(idx, 1);
	                        }
	                    });
	                });


	                // Add the `every()` method for rows, columns and cells in a compact form
	                $.each(['column', 'row', 'cell'], function (i, type) {
	                    _api_register(type + 's().every()', function (fn) {
	                        return this.iterator(type, function (settings, idx, idx2) {
	                            // idx2 is undefined for rows and columns.
	                            fn.call(new _Api(settings)[type](idx, idx2));
	                        });
	                    });
	                });


	                // i18n method for extensions to be able to use the language object from the
	                // DataTable
	                _api_register('i18n()', function (token, def, plural) {
	                    var ctx = this.context[0];
	                    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

	                    if (resolved === undefined) {
	                        resolved = def;
	                    }

	                    if (plural !== undefined && $.isPlainObject(resolved)) {
	                        resolved = resolved[plural] !== undefined ?
	                            resolved[plural] :
	                            resolved._;
	                    }

	                    return resolved.replace('%d', plural); // nb: plural might be undefined,
	                });

	                /**
	                 * Version string for plug-ins to check compatibility. Allowed format is
	                 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
	                 * only for non-release builds. See http://semver.org/ for more information.
	                 *  @member
	                 *  @type string
	                 *  @default Version number
	                 */
	                DataTable.version = "1.10.7";

	                /**
	                 * Private data store, containing all of the settings objects that are
	                 * created for the tables on a given page.
	                 *
	                 * Note that the `DataTable.settings` object is aliased to
	                 * `jQuery.fn.dataTableExt` through which it may be accessed and
	                 * manipulated, or `jQuery.fn.dataTable.settings`.
	                 *  @member
	                 *  @type array
	                 *  @default []
	                 *  @private
	                 */
	                DataTable.settings = [];

	                /**
	                 * Object models container, for the various models that DataTables has
	                 * available to it. These models define the objects that are used to hold
	                 * the active state and configuration of the table.
	                 *  @namespace
	                 */
	                DataTable.models = {};



	                /**
	                 * Template object for the way in which DataTables holds information about
	                 * search information for the global filter and individual column filters.
	                 *  @namespace
	                 */
	                DataTable.models.oSearch = {
	                    /**
	                     * Flag to indicate if the filtering should be case insensitive or not
	                     *  @type boolean
	                     *  @default true
	                     */
	                    "bCaseInsensitive": true,

	                    /**
	                     * Applied search term
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     */
	                    "sSearch": "",

	                    /**
	                     * Flag to indicate if the search term should be interpreted as a
	                     * regular expression (true) or not (false) and therefore and special
	                     * regex characters escaped.
	                     *  @type boolean
	                     *  @default false
	                     */
	                    "bRegex": false,

	                    /**
	                     * Flag to indicate if DataTables is to use its smart filtering or not.
	                     *  @type boolean
	                     *  @default true
	                     */
	                    "bSmart": true
	                };




	                /**
	                 * Template object for the way in which DataTables holds information about
	                 * each individual row. This is the object format used for the settings
	                 * aoData array.
	                 *  @namespace
	                 */
	                DataTable.models.oRow = {
	                    /**
	                     * TR element for the row
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTr": null,

	                    /**
	                     * Array of TD elements for each row. This is null until the row has been
	                     * created.
	                     *  @type array nodes
	                     *  @default []
	                     */
	                    "anCells": null,

	                    /**
	                     * Data object from the original data source for the row. This is either
	                     * an array if using the traditional form of DataTables, or an object if
	                     * using mData options. The exact type will depend on the passed in
	                     * data from the data source, or will be an array if using DOM a data
	                     * source.
	                     *  @type array|object
	                     *  @default []
	                     */
	                    "_aData": [],

	                    /**
	                     * Sorting data cache - this array is ostensibly the same length as the
	                     * number of columns (although each index is generated only as it is
	                     * needed), and holds the data that is used for sorting each column in the
	                     * row. We do this cache generation at the start of the sort in order that
	                     * the formatting of the sort data need be done only once for each cell
	                     * per sort. This array should not be read from or written to by anything
	                     * other than the master sorting methods.
	                     *  @type array
	                     *  @default null
	                     *  @private
	                     */
	                    "_aSortData": null,

	                    /**
	                     * Per cell filtering data cache. As per the sort data cache, used to
	                     * increase the performance of the filtering in DataTables
	                     *  @type array
	                     *  @default null
	                     *  @private
	                     */
	                    "_aFilterData": null,

	                    /**
	                     * Filtering data cache. This is the same as the cell filtering cache, but
	                     * in this case a string rather than an array. This is easily computed with
	                     * a join on `_aFilterData`, but is provided as a cache so the join isn't
	                     * needed on every search (memory traded for performance)
	                     *  @type array
	                     *  @default null
	                     *  @private
	                     */
	                    "_sFilterRow": null,

	                    /**
	                     * Cache of the class name that DataTables has applied to the row, so we
	                     * can quickly look at this variable rather than needing to do a DOM check
	                     * on className for the nTr property.
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     *  @private
	                     */
	                    "_sRowStripe": "",

	                    /**
	                     * Denote if the original data source was from the DOM, or the data source
	                     * object. This is used for invalidating data, so DataTables can
	                     * automatically read data from the original source, unless uninstructed
	                     * otherwise.
	                     *  @type string
	                     *  @default null
	                     *  @private
	                     */
	                    "src": null
	                };


	                /**
	                 * Template object for the column information object in DataTables. This object
	                 * is held in the settings aoColumns array and contains all the information that
	                 * DataTables needs about each individual column.
	                 *
	                 * Note that this object is related to {@link DataTable.defaults.column}
	                 * but this one is the internal data store for DataTables's cache of columns.
	                 * It should NOT be manipulated outside of DataTables. Any configuration should
	                 * be done through the initialisation options.
	                 *  @namespace
	                 */
	                DataTable.models.oColumn = {
	                    /**
	                     * Column index. This could be worked out on-the-fly with $.inArray, but it
	                     * is faster to just hold it as a variable
	                     *  @type integer
	                     *  @default null
	                     */
	                    "idx": null,

	                    /**
	                     * A list of the columns that sorting should occur on when this column
	                     * is sorted. That this property is an array allows multi-column sorting
	                     * to be defined for a column (for example first name / last name columns
	                     * would benefit from this). The values are integers pointing to the
	                     * columns to be sorted on (typically it will be a single integer pointing
	                     * at itself, but that doesn't need to be the case).
	                     *  @type array
	                     */
	                    "aDataSort": null,

	                    /**
	                     * Define the sorting directions that are applied to the column, in sequence
	                     * as the column is repeatedly sorted upon - i.e. the first value is used
	                     * as the sorting direction when the column if first sorted (clicked on).
	                     * Sort it again (click again) and it will move on to the next index.
	                     * Repeat until loop.
	                     *  @type array
	                     */
	                    "asSorting": null,

	                    /**
	                     * Flag to indicate if the column is searchable, and thus should be included
	                     * in the filtering or not.
	                     *  @type boolean
	                     */
	                    "bSearchable": null,

	                    /**
	                     * Flag to indicate if the column is sortable or not.
	                     *  @type boolean
	                     */
	                    "bSortable": null,

	                    /**
	                     * Flag to indicate if the column is currently visible in the table or not
	                     *  @type boolean
	                     */
	                    "bVisible": null,

	                    /**
	                     * Store for manual type assignment using the `column.type` option. This
	                     * is held in store so we can manipulate the column's `sType` property.
	                     *  @type string
	                     *  @default null
	                     *  @private
	                     */
	                    "_sManualType": null,

	                    /**
	                     * Flag to indicate if HTML5 data attributes should be used as the data
	                     * source for filtering or sorting. True is either are.
	                     *  @type boolean
	                     *  @default false
	                     *  @private
	                     */
	                    "_bAttrSrc": false,

	                    /**
	                     * Developer definable function that is called whenever a cell is created (Ajax source,
	                     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	                     * allowing you to modify the DOM element (add background colour for example) when the
	                     * element is available.
	                     *  @type function
	                     *  @param {element} nTd The TD node that has been created
	                     *  @param {*} sData The Data for the cell
	                     *  @param {array|object} oData The data for the whole row
	                     *  @param {int} iRow The row index for the aoData data store
	                     *  @default null
	                     */
	                    "fnCreatedCell": null,

	                    /**
	                     * Function to get data from a cell in a column. You should <b>never</b>
	                     * access data directly through _aData internally in DataTables - always use
	                     * the method attached to this property. It allows mData to function as
	                     * required. This function is automatically assigned by the column
	                     * initialisation method
	                     *  @type function
	                     *  @param {array|object} oData The data array/object for the array
	                     *    (i.e. aoData[]._aData)
	                     *  @param {string} sSpecific The specific data type you want to get -
	                     *    'display', 'type' 'filter' 'sort'
	                     *  @returns {*} The data for the cell from the given row's data
	                     *  @default null
	                     */
	                    "fnGetData": null,

	                    /**
	                     * Function to set data for a cell in the column. You should <b>never</b>
	                     * set the data directly to _aData internally in DataTables - always use
	                     * this method. It allows mData to function as required. This function
	                     * is automatically assigned by the column initialisation method
	                     *  @type function
	                     *  @param {array|object} oData The data array/object for the array
	                     *    (i.e. aoData[]._aData)
	                     *  @param {*} sValue Value to set
	                     *  @default null
	                     */
	                    "fnSetData": null,

	                    /**
	                     * Property to read the value for the cells in the column from the data
	                     * source array / object. If null, then the default content is used, if a
	                     * function is given then the return from the function is used.
	                     *  @type function|int|string|null
	                     *  @default null
	                     */
	                    "mData": null,

	                    /**
	                     * Partner property to mData which is used (only when defined) to get
	                     * the data - i.e. it is basically the same as mData, but without the
	                     * 'set' option, and also the data fed to it is the result from mData.
	                     * This is the rendering method to match the data method of mData.
	                     *  @type function|int|string|null
	                     *  @default null
	                     */
	                    "mRender": null,

	                    /**
	                     * Unique header TH/TD element for this column - this is what the sorting
	                     * listener is attached to (if sorting is enabled.)
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTh": null,

	                    /**
	                     * Unique footer TH/TD element for this column (if there is one). Not used
	                     * in DataTables as such, but can be used for plug-ins to reference the
	                     * footer for each column.
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTf": null,

	                    /**
	                     * The class to apply to all TD elements in the table's TBODY for the column
	                     *  @type string
	                     *  @default null
	                     */
	                    "sClass": null,

	                    /**
	                     * When DataTables calculates the column widths to assign to each column,
	                     * it finds the longest string in each column and then constructs a
	                     * temporary table and reads the widths from that. The problem with this
	                     * is that "mmm" is much wider then "iiii", but the latter is a longer
	                     * string - thus the calculation can go wrong (doing it properly and putting
	                     * it into an DOM object and measuring that is horribly(!) slow). Thus as
	                     * a "work around" we provide this option. It will append its value to the
	                     * text that is found to be the longest string for the column - i.e. padding.
	                     *  @type string
	                     */
	                    "sContentPadding": null,

	                    /**
	                     * Allows a default value to be given for a column's data, and will be used
	                     * whenever a null data source is encountered (this can be because mData
	                     * is set to null, or because the data source itself is null).
	                     *  @type string
	                     *  @default null
	                     */
	                    "sDefaultContent": null,

	                    /**
	                     * Name for the column, allowing reference to the column by name as well as
	                     * by index (needs a lookup to work by name).
	                     *  @type string
	                     */
	                    "sName": null,

	                    /**
	                     * Custom sorting data type - defines which of the available plug-ins in
	                     * afnSortData the custom sorting will use - if any is defined.
	                     *  @type string
	                     *  @default std
	                     */
	                    "sSortDataType": 'std',

	                    /**
	                     * Class to be applied to the header element when sorting on this column
	                     *  @type string
	                     *  @default null
	                     */
	                    "sSortingClass": null,

	                    /**
	                     * Class to be applied to the header element when sorting on this column -
	                     * when jQuery UI theming is used.
	                     *  @type string
	                     *  @default null
	                     */
	                    "sSortingClassJUI": null,

	                    /**
	                     * Title of the column - what is seen in the TH element (nTh).
	                     *  @type string
	                     */
	                    "sTitle": null,

	                    /**
	                     * Column sorting and filtering type
	                     *  @type string
	                     *  @default null
	                     */
	                    "sType": null,

	                    /**
	                     * Width of the column
	                     *  @type string
	                     *  @default null
	                     */
	                    "sWidth": null,

	                    /**
	                     * Width of the column when it was first "encountered"
	                     *  @type string
	                     *  @default null
	                     */
	                    "sWidthOrig": null
	                };


	                /*
	                 * Developer note: The properties of the object below are given in Hungarian
	                 * notation, that was used as the interface for DataTables prior to v1.10, however
	                 * from v1.10 onwards the primary interface is camel case. In order to avoid
	                 * breaking backwards compatibility utterly with this change, the Hungarian
	                 * version is still, internally the primary interface, but is is not documented
	                 * - hence the @name tags in each doc comment. This allows a Javascript function
	                 * to create a map from Hungarian notation to camel case (going the other direction
	                 * would require each property to be listed, which would at around 3K to the size
	                 * of DataTables, while this method is about a 0.5K hit.
	                 *
	                 * Ultimately this does pave the way for Hungarian notation to be dropped
	                 * completely, but that is a massive amount of work and will break current
	                 * installs (therefore is on-hold until v2).
	                 */

	                /**
	                 * Initialisation options that can be given to DataTables at initialisation
	                 * time.
	                 *  @namespace
	                 */
	                DataTable.defaults = {
	                    /**
	                     * An array of data to use for the table, passed in at initialisation which
	                     * will be used in preference to any data which is already in the DOM. This is
	                     * particularly useful for constructing tables purely in Javascript, for
	                     * example with a custom Ajax call.
	                     *  @type array
	                     *  @default null
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.data
	                     *
	                     *  @example
	                     *    // Using a 2D array data source
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "data": [
	                     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
	                     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
	                     *        ],
	                     *        "columns": [
	                     *          { "title": "Engine" },
	                     *          { "title": "Browser" },
	                     *          { "title": "Platform" },
	                     *          { "title": "Version" },
	                     *          { "title": "Grade" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using an array of objects as a data source (`data`)
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "data": [
	                     *          {
	                     *            "engine":   "Trident",
	                     *            "browser":  "Internet Explorer 4.0",
	                     *            "platform": "Win 95+",
	                     *            "version":  4,
	                     *            "grade":    "X"
	                     *          },
	                     *          {
	                     *            "engine":   "Trident",
	                     *            "browser":  "Internet Explorer 5.0",
	                     *            "platform": "Win 95+",
	                     *            "version":  5,
	                     *            "grade":    "C"
	                     *          }
	                     *        ],
	                     *        "columns": [
	                     *          { "title": "Engine",   "data": "engine" },
	                     *          { "title": "Browser",  "data": "browser" },
	                     *          { "title": "Platform", "data": "platform" },
	                     *          { "title": "Version",  "data": "version" },
	                     *          { "title": "Grade",    "data": "grade" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "aaData": null,


	                    /**
	                     * If ordering is enabled, then DataTables will perform a first pass sort on
	                     * initialisation. You can define which column(s) the sort is performed
	                     * upon, and the sorting direction, with this variable. The `sorting` array
	                     * should contain an array for each column to be sorted initially containing
	                     * the column's index and a direction string ('asc' or 'desc').
	                     *  @type array
	                     *  @default [[0,'asc']]
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.order
	                     *
	                     *  @example
	                     *    // Sort by 3rd column first, and then 4th column
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "order": [[2,'asc'], [3,'desc']]
	                     *      } );
	                     *    } );
	                     *
	                     *    // No initial sorting
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "order": []
	                     *      } );
	                     *    } );
	                     */
	                    "aaSorting": [[0, 'asc']],


	                    /**
	                     * This parameter is basically identical to the `sorting` parameter, but
	                     * cannot be overridden by user interaction with the table. What this means
	                     * is that you could have a column (visible or hidden) which the sorting
	                     * will always be forced on first - any sorting after that (from the user)
	                     * will then be performed as required. This can be useful for grouping rows
	                     * together.
	                     *  @type array
	                     *  @default null
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.orderFixed
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "orderFixed": [[0,'asc']]
	                     *      } );
	                     *    } )
	                     */
	                    "aaSortingFixed": [],


	                    /**
	                     * DataTables can be instructed to load data to display in the table from a
	                     * Ajax source. This option defines how that Ajax call is made and where to.
	                     *
	                     * The `ajax` property has three different modes of operation, depending on
	                     * how it is defined. These are:
	                     *
	                     * * `string` - Set the URL from where the data should be loaded from.
	                     * * `object` - Define properties for `jQuery.ajax`.
	                     * * `function` - Custom data get function
	                     *
	                     * `string`
	                     * --------
	                     *
	                     * As a string, the `ajax` property simply defines the URL from which
	                     * DataTables will load data.
	                     *
	                     * `object`
	                     * --------
	                     *
	                     * As an object, the parameters in the object are passed to
	                     * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
	                     * of the Ajax request. DataTables has a number of default parameters which
	                     * you can override using this option. Please refer to the jQuery
	                     * documentation for a full description of the options available, although
	                     * the following parameters provide additional options in DataTables or
	                     * require special consideration:
	                     *
	                     * * `data` - As with jQuery, `data` can be provided as an object, but it
	                     *   can also be used as a function to manipulate the data DataTables sends
	                     *   to the server. The function takes a single parameter, an object of
	                     *   parameters with the values that DataTables has readied for sending. An
	                     *   object may be returned which will be merged into the DataTables
	                     *   defaults, or you can add the items to the object that was passed in and
	                     *   not return anything from the function. This supersedes `fnServerParams`
	                     *   from DataTables 1.9-.
	                     *
	                     * * `dataSrc` - By default DataTables will look for the property `data` (or
	                     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
	                     *   from an Ajax source or for server-side processing - this parameter
	                     *   allows that property to be changed. You can use Javascript dotted
	                     *   object notation to get a data source for multiple levels of nesting, or
	                     *   it my be used as a function. As a function it takes a single parameter,
	                     *   the JSON returned from the server, which can be manipulated as
	                     *   required, with the returned value being that used by DataTables as the
	                     *   data source for the table. This supersedes `sAjaxDataProp` from
	                     *   DataTables 1.9-.
	                     *
	                     * * `success` - Should not be overridden it is used internally in
	                     *   DataTables. To manipulate / transform the data returned by the server
	                     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
	                     *
	                     * `function`
	                     * ----------
	                     *
	                     * As a function, making the Ajax call is left up to yourself allowing
	                     * complete control of the Ajax request. Indeed, if desired, a method other
	                     * than Ajax could be used to obtain the required data, such as Web storage
	                     * or an AIR database.
	                     *
	                     * The function is given four parameters and no return is required. The
	                     * parameters are:
	                     *
	                     * 1. _object_ - Data to send to the server
	                     * 2. _function_ - Callback function that must be executed when the required
	                     *    data has been obtained. That data should be passed into the callback
	                     *    as the only parameter
	                     * 3. _object_ - DataTables settings object for the table
	                     *
	                     * Note that this supersedes `fnServerData` from DataTables 1.9-.
	                     *
	                     *  @type string|object|function
	                     *  @default null
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.ajax
	                     *  @since 1.10.0
	                     *
	                     * @example
	                     *   // Get JSON data from a file via Ajax.
	                     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
	                     *   $('#example').dataTable( {
	                     *     "ajax": "data.json"
	                     *   } );
	                     *
	                     * @example
	                     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
	                     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "dataSrc": "tableData"
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
	                     *   // from a plain array rather than an array in an object
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "dataSrc": ""
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Manipulate the data returned from the server - add a link to data
	                     *   // (note this can, should, be done using `render` for the column - this
	                     *   // is just a simple example of how the data can be manipulated).
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "dataSrc": function ( json ) {
	                     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
	                     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
	                     *         }
	                     *         return json;
	                     *       }
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Add data to the request
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "data": function ( d ) {
	                     *         return {
	                     *           "extra_search": $('#extra').val()
	                     *         };
	                     *       }
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Send request as POST
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "type": "POST"
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Get the data from localStorage (could interface with a form for
	                     *   // adding, editing and removing rows).
	                     *   $('#example').dataTable( {
	                     *     "ajax": function (data, callback, settings) {
	                     *       callback(
	                     *         JSON.parse( localStorage.getItem('dataTablesData') )
	                     *       );
	                     *     }
	                     *   } );
	                     */
	                    "ajax": null,


	                    /**
	                     * This parameter allows you to readily specify the entries in the length drop
	                     * down menu that DataTables shows when pagination is enabled. It can be
	                     * either a 1D array of options which will be used for both the displayed
	                     * option and the value, or a 2D array which will use the array in the first
	                     * position as the value, and the array in the second position as the
	                     * displayed options (useful for language strings such as 'All').
	                     *
	                     * Note that the `pageLength` property will be automatically set to the
	                     * first value given in this array, unless `pageLength` is also provided.
	                     *  @type array
	                     *  @default [ 10, 25, 50, 100 ]
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.lengthMenu
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
	                     *      } );
	                     *    } );
	                     */
	                    "aLengthMenu": [10, 25, 50, 100],


	                    /**
	                     * The `columns` option in the initialisation parameter allows you to define
	                     * details about the way individual columns behave. For a full list of
	                     * column options that can be set, please see
	                     * {@link DataTable.defaults.column}. Note that if you use `columns` to
	                     * define your columns, you must have an entry in the array for every single
	                     * column that you have in your table (these can be null if you don't which
	                     * to specify any options).
	                     *  @member
	                     *
	                     *  @name DataTable.defaults.column
	                     */
	                    "aoColumns": null,

	                    /**
	                     * Very similar to `columns`, `columnDefs` allows you to target a specific
	                     * column, multiple columns, or all columns, using the `targets` property of
	                     * each object in the array. This allows great flexibility when creating
	                     * tables, as the `columnDefs` arrays can be of any length, targeting the
	                     * columns you specifically want. `columnDefs` may use any of the column
	                     * options available: {@link DataTable.defaults.column}, but it _must_
	                     * have `targets` defined in each object in the array. Values in the `targets`
	                     * array may be:
	                     *   <ul>
	                     *     <li>a string - class name will be matched on the TH for the column</li>
	                     *     <li>0 or a positive integer - column index counting from the left</li>
	                     *     <li>a negative integer - column index counting from the right</li>
	                     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
	                     *   </ul>
	                     *  @member
	                     *
	                     *  @name DataTable.defaults.columnDefs
	                     */
	                    "aoColumnDefs": null,


	                    /**
	                     * Basically the same as `search`, this parameter defines the individual column
	                     * filtering state at initialisation time. The array must be of the same size
	                     * as the number of columns, and each element be an object with the parameters
	                     * `search` and `escapeRegex` (the latter is optional). 'null' is also
	                     * accepted and the default will be used.
	                     *  @type array
	                     *  @default []
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.searchCols
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "searchCols": [
	                     *          null,
	                     *          { "search": "My filter" },
	                     *          null,
	                     *          { "search": "^[0-9]", "escapeRegex": false }
	                     *        ]
	                     *      } );
	                     *    } )
	                     */
	                    "aoSearchCols": [],


	                    /**
	                     * An array of CSS classes that should be applied to displayed rows. This
	                     * array may be of any length, and DataTables will apply each class
	                     * sequentially, looping when required.
	                     *  @type array
	                     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
	                     *    options</i>
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.stripeClasses
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
	                     *      } );
	                     *    } )
	                     */
	                    "asStripeClasses": null,


	                    /**
	                     * Enable or disable automatic column width calculation. This can be disabled
	                     * as an optimisation (it takes some time to calculate the widths) if the
	                     * tables widths are passed in using `columns`.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.autoWidth
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "autoWidth": false
	                     *      } );
	                     *    } );
	                     */
	                    "bAutoWidth": true,


	                    /**
	                     * Deferred rendering can provide DataTables with a huge speed boost when you
	                     * are using an Ajax or JS data source for the table. This option, when set to
	                     * true, will cause DataTables to defer the creation of the table elements for
	                     * each row until they are needed for a draw - saving a significant amount of
	                     * time.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.deferRender
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "ajax": "sources/arrays.txt",
	                     *        "deferRender": true
	                     *      } );
	                     *    } );
	                     */
	                    "bDeferRender": false,


	                    /**
	                     * Replace a DataTable which matches the given selector and replace it with
	                     * one which has the properties of the new initialisation object passed. If no
	                     * table matches the selector, then the new DataTable will be constructed as
	                     * per normal.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.destroy
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "srollY": "200px",
	                     *        "paginate": false
	                     *      } );
	                     *
	                     *      // Some time later....
	                     *      $('#example').dataTable( {
	                     *        "filter": false,
	                     *        "destroy": true
	                     *      } );
	                     *    } );
	                     */
	                    "bDestroy": false,


	                    /**
	                     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
	                     * that it allows the end user to input multiple words (space separated) and
	                     * will match a row containing those words, even if not in the order that was
	                     * specified (this allow matching across multiple columns). Note that if you
	                     * wish to use filtering in DataTables this must remain 'true' - to remove the
	                     * default filtering input box and retain filtering abilities, please use
	                     * {@link DataTable.defaults.dom}.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.searching
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "searching": false
	                     *      } );
	                     *    } );
	                     */
	                    "bFilter": true,


	                    /**
	                     * Enable or disable the table information display. This shows information
	                     * about the data that is currently visible on the page, including information
	                     * about filtered data if that action is being performed.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.info
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "info": false
	                     *      } );
	                     *    } );
	                     */
	                    "bInfo": true,


	                    /**
	                     * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
	                     * slightly different and additional mark-up from what DataTables has
	                     * traditionally used).
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.jQueryUI
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "jQueryUI": true
	                     *      } );
	                     *    } );
	                     */
	                    "bJQueryUI": false,


	                    /**
	                     * Allows the end user to select the size of a formatted page from a select
	                     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.lengthChange
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "lengthChange": false
	                     *      } );
	                     *    } );
	                     */
	                    "bLengthChange": true,


	                    /**
	                     * Enable or disable pagination.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.paging
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "paging": false
	                     *      } );
	                     *    } );
	                     */
	                    "bPaginate": true,


	                    /**
	                     * Enable or disable the display of a 'processing' indicator when the table is
	                     * being processed (e.g. a sort). This is particularly useful for tables with
	                     * large amounts of data where it can take a noticeable amount of time to sort
	                     * the entries.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.processing
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "processing": true
	                     *      } );
	                     *    } );
	                     */
	                    "bProcessing": false,


	                    /**
	                     * Retrieve the DataTables object for the given selector. Note that if the
	                     * table has already been initialised, this parameter will cause DataTables
	                     * to simply return the object that has already been set up - it will not take
	                     * account of any changes you might have made to the initialisation object
	                     * passed to DataTables (setting this parameter to true is an acknowledgement
	                     * that you understand this). `destroy` can be used to reinitialise a table if
	                     * you need.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.retrieve
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      initTable();
	                     *      tableActions();
	                     *    } );
	                     *
	                     *    function initTable ()
	                     *    {
	                     *      return $('#example').dataTable( {
	                     *        "scrollY": "200px",
	                     *        "paginate": false,
	                     *        "retrieve": true
	                     *      } );
	                     *    }
	                     *
	                     *    function tableActions ()
	                     *    {
	                     *      var table = initTable();
	                     *      // perform API operations with oTable
	                     *    }
	                     */
	                    "bRetrieve": false,


	                    /**
	                     * When vertical (y) scrolling is enabled, DataTables will force the height of
	                     * the table's viewport to the given height at all times (useful for layout).
	                     * However, this can look odd when filtering data down to a small data set,
	                     * and the footer is left "floating" further down. This parameter (when
	                     * enabled) will cause DataTables to collapse the table's viewport down when
	                     * the result set will fit within the given Y height.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.scrollCollapse
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "scrollY": "200",
	                     *        "scrollCollapse": true
	                     *      } );
	                     *    } );
	                     */
	                    "bScrollCollapse": false,


	                    /**
	                     * Configure DataTables to use server-side processing. Note that the
	                     * `ajax` parameter must also be given in order to give DataTables a
	                     * source to obtain the required data for each draw.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.serverSide
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "serverSide": true,
	                     *        "ajax": "xhr.php"
	                     *      } );
	                     *    } );
	                     */
	                    "bServerSide": false,


	                    /**
	                     * Enable or disable sorting of columns. Sorting of individual columns can be
	                     * disabled by the `sortable` option for each column.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.ordering
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "ordering": false
	                     *      } );
	                     *    } );
	                     */
	                    "bSort": true,


	                    /**
	                     * Enable or display DataTables' ability to sort multiple columns at the
	                     * same time (activated by shift-click by the user).
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.orderMulti
	                     *
	                     *  @example
	                     *    // Disable multiple column sorting ability
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "orderMulti": false
	                     *      } );
	                     *    } );
	                     */
	                    "bSortMulti": true,


	                    /**
	                     * Allows control over whether DataTables should use the top (true) unique
	                     * cell that is found for a single column, or the bottom (false - default).
	                     * This is useful when using complex headers.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.orderCellsTop
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "orderCellsTop": true
	                     *      } );
	                     *    } );
	                     */
	                    "bSortCellsTop": false,


	                    /**
	                     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
	                     * `sorting\_3` to the columns which are currently being sorted on. This is
	                     * presented as a feature switch as it can increase processing time (while
	                     * classes are removed and added) so for large data sets you might want to
	                     * turn this off.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.orderClasses
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "orderClasses": false
	                     *      } );
	                     *    } );
	                     */
	                    "bSortClasses": true,


	                    /**
	                     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
	                     * used to save table display information such as pagination information,
	                     * display length, filtering and sorting. As such when the end user reloads
	                     * the page the display display will match what thy had previously set up.
	                     *
	                     * Due to the use of `localStorage` the default state saving is not supported
	                     * in IE6 or 7. If state saving is required in those browsers, use
	                     * `stateSaveCallback` to provide a storage solution such as cookies.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.stateSave
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true
	                     *      } );
	                     *    } );
	                     */
	                    "bStateSave": false,


	                    /**
	                     * This function is called when a TR element is created (and all TD child
	                     * elements have been inserted), or registered if using a DOM source, allowing
	                     * manipulation of the TR element (adding classes etc).
	                     *  @type function
	                     *  @param {node} row "TR" element for the current row
	                     *  @param {array} data Raw data array for this row
	                     *  @param {int} dataIndex The index of this row in the internal aoData array
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.createdRow
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "createdRow": function( row, data, dataIndex ) {
	                     *          // Bold the grade for all 'A' grade browsers
	                     *          if ( data[4] == "A" )
	                     *          {
	                     *            $('td:eq(4)', row).html( '<b>A</b>' );
	                     *          }
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnCreatedRow": null,


	                    /**
	                     * This function is called on every 'draw' event, and allows you to
	                     * dynamically modify any aspect you want about the created DOM.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.drawCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "drawCallback": function( settings ) {
	                     *          alert( 'DataTables has redrawn the table' );
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnDrawCallback": null,


	                    /**
	                     * Identical to fnHeaderCallback() but for the table footer this function
	                     * allows you to modify the table footer on every 'draw' event.
	                     *  @type function
	                     *  @param {node} foot "TR" element for the footer
	                     *  @param {array} data Full table data (as derived from the original HTML)
	                     *  @param {int} start Index for the current display starting point in the
	                     *    display array
	                     *  @param {int} end Index for the current display ending point in the
	                     *    display array
	                     *  @param {array int} display Index array to translate the visual position
	                     *    to the full data array
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.footerCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "footerCallback": function( tfoot, data, start, end, display ) {
	                     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
	                     *        }
	                     *      } );
	                     *    } )
	                     */
	                    "fnFooterCallback": null,


	                    /**
	                     * When rendering large numbers in the information element for the table
	                     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
	                     * to have a comma separator for the 'thousands' units (e.g. 1 million is
	                     * rendered as "1,000,000") to help readability for the end user. This
	                     * function will override the default method DataTables uses.
	                     *  @type function
	                     *  @member
	                     *  @param {int} toFormat number to be formatted
	                     *  @returns {string} formatted string for DataTables to show the number
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.formatNumber
	                     *
	                     *  @example
	                     *    // Format a number using a single quote for the separator (note that
	                     *    // this can also be done with the language.thousands option)
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "formatNumber": function ( toFormat ) {
	                     *          return toFormat.toString().replace(
	                     *            /\B(?=(\d{3})+(?!\d))/g, "'"
	                     *          );
	                     *        };
	                     *      } );
	                     *    } );
	                     */
	                    "fnFormatNumber": function (toFormat) {
	                        return toFormat.toString().replace(
	                            /\B(?=(\d{3})+(?!\d))/g,
	                            this.oLanguage.sThousands
	                        );
	                    },


	                    /**
	                     * This function is called on every 'draw' event, and allows you to
	                     * dynamically modify the header row. This can be used to calculate and
	                     * display useful information about the table.
	                     *  @type function
	                     *  @param {node} head "TR" element for the header
	                     *  @param {array} data Full table data (as derived from the original HTML)
	                     *  @param {int} start Index for the current display starting point in the
	                     *    display array
	                     *  @param {int} end Index for the current display ending point in the
	                     *    display array
	                     *  @param {array int} display Index array to translate the visual position
	                     *    to the full data array
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.headerCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "fheaderCallback": function( head, data, start, end, display ) {
	                     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
	                     *        }
	                     *      } );
	                     *    } )
	                     */
	                    "fnHeaderCallback": null,


	                    /**
	                     * The information element can be used to convey information about the current
	                     * state of the table. Although the internationalisation options presented by
	                     * DataTables are quite capable of dealing with most customisations, there may
	                     * be times where you wish to customise the string further. This callback
	                     * allows you to do exactly that.
	                     *  @type function
	                     *  @param {object} oSettings DataTables settings object
	                     *  @param {int} start Starting position in data for the draw
	                     *  @param {int} end End position in data for the draw
	                     *  @param {int} max Total number of rows in the table (regardless of
	                     *    filtering)
	                     *  @param {int} total Total number of rows in the data set, after filtering
	                     *  @param {string} pre The string that DataTables has formatted using it's
	                     *    own rules
	                     *  @returns {string} The string to be displayed in the information element.
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.infoCallback
	                     *
	                     *  @example
	                     *    $('#example').dataTable( {
	                     *      "infoCallback": function( settings, start, end, max, total, pre ) {
	                     *        return start +" to "+ end;
	                     *      }
	                     *    } );
	                     */
	                    "fnInfoCallback": null,


	                    /**
	                     * Called when the table has been initialised. Normally DataTables will
	                     * initialise sequentially and there will be no need for this function,
	                     * however, this does not hold true when using external language information
	                     * since that is obtained using an async XHR call.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} json The JSON object request from the server - only
	                     *    present if client-side Ajax sourced data is used
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.initComplete
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "initComplete": function(settings, json) {
	                     *          alert( 'DataTables has finished its initialisation.' );
	                     *        }
	                     *      } );
	                     *    } )
	                     */
	                    "fnInitComplete": null,


	                    /**
	                     * Called at the very start of each table draw and can be used to cancel the
	                     * draw by returning false, any other return (including undefined) results in
	                     * the full draw occurring).
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @returns {boolean} False will cancel the draw, anything else (including no
	                     *    return) will allow it to complete.
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.preDrawCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "preDrawCallback": function( settings ) {
	                     *          if ( $('#test').val() == 1 ) {
	                     *            return false;
	                     *          }
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnPreDrawCallback": null,


	                    /**
	                     * This function allows you to 'post process' each row after it have been
	                     * generated for each table draw, but before it is rendered on screen. This
	                     * function might be used for setting the row class name etc.
	                     *  @type function
	                     *  @param {node} row "TR" element for the current row
	                     *  @param {array} data Raw data array for this row
	                     *  @param {int} displayIndex The display index for the current table draw
	                     *  @param {int} displayIndexFull The index of the data in the full list of
	                     *    rows (after filtering)
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.rowCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
	                     *          // Bold the grade for all 'A' grade browsers
	                     *          if ( data[4] == "A" ) {
	                     *            $('td:eq(4)', row).html( '<b>A</b>' );
	                     *          }
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnRowCallback": null,


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     * This parameter allows you to override the default function which obtains
	                     * the data from the server so something more suitable for your application.
	                     * For example you could use POST data, or pull information from a Gears or
	                     * AIR database.
	                     *  @type function
	                     *  @member
	                     *  @param {string} source HTTP source to obtain the data from (`ajax`)
	                     *  @param {array} data A key/value pair object containing the data to send
	                     *    to the server
	                     *  @param {function} callback to be called on completion of the data get
	                     *    process that will draw the data on the page.
	                     *  @param {object} settings DataTables settings object
	                     *
	                     *  @dtopt Callbacks
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.serverData
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "fnServerData": null,


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     *  It is often useful to send extra data to the server when making an Ajax
	                     * request - for example custom filtering information, and this callback
	                     * function makes it trivial to send extra information to the server. The
	                     * passed in parameter is the data set that has been constructed by
	                     * DataTables, and you can add to this or modify it as you require.
	                     *  @type function
	                     *  @param {array} data Data array (array of objects which are name/value
	                     *    pairs) that has been constructed by DataTables and will be sent to the
	                     *    server. In the case of Ajax sourced data with server-side processing
	                     *    this will be an empty array, for server-side processing there will be a
	                     *    significant number of parameters!
	                     *  @returns {undefined} Ensure that you modify the data array passed in,
	                     *    as this is passed by reference.
	                     *
	                     *  @dtopt Callbacks
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.serverParams
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "fnServerParams": null,


	                    /**
	                     * Load the table state. With this function you can define from where, and how, the
	                     * state of a table is loaded. By default DataTables will load from `localStorage`
	                     * but you might wish to use a server-side database or cookies.
	                     *  @type function
	                     *  @member
	                     *  @param {object} settings DataTables settings object
	                     *  @return {object} The DataTables state object to be loaded
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateLoadCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateLoadCallback": function (settings) {
	                     *          var o;
	                     *
	                     *          // Send an Ajax request to the server to get the data. Note that
	                     *          // this is a synchronous request.
	                     *          $.ajax( {
	                     *            "url": "/state_load",
	                     *            "async": false,
	                     *            "dataType": "json",
	                     *            "success": function (json) {
	                     *              o = json;
	                     *            }
	                     *          } );
	                     *
	                     *          return o;
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateLoadCallback": function (settings) {
	                        try {
	                            return JSON.parse(
	                                (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
	                                    'DataTables_' + settings.sInstance + '_' + location.pathname
	                                )
	                            );
	                        } catch (e) { }
	                    },


	                    /**
	                     * Callback which allows modification of the saved state prior to loading that state.
	                     * This callback is called when the table is loading state from the stored data, but
	                     * prior to the settings object being modified by the saved state. Note that for
	                     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
	                     * a plug-in.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} data The state object that is to be loaded
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateLoadParams
	                     *
	                     *  @example
	                     *    // Remove a saved filter, so filtering is never loaded
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateLoadParams": function (settings, data) {
	                     *          data.oSearch.sSearch = "";
	                     *        }
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Disallow state loading by returning false
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateLoadParams": function (settings, data) {
	                     *          return false;
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateLoadParams": null,


	                    /**
	                     * Callback that is called when the state has been loaded from the state saving method
	                     * and the DataTables settings object has been modified as a result of the loaded state.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} data The state object that was loaded
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateLoaded
	                     *
	                     *  @example
	                     *    // Show an alert with the filtering value that was saved
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateLoaded": function (settings, data) {
	                     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateLoaded": null,


	                    /**
	                     * Save the table state. This function allows you to define where and how the state
	                     * information for the table is stored By default DataTables will use `localStorage`
	                     * but you might wish to use a server-side database or cookies.
	                     *  @type function
	                     *  @member
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} data The state object to be saved
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateSaveCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateSaveCallback": function (settings, data) {
	                     *          // Send an Ajax request to the server with the state object
	                     *          $.ajax( {
	                     *            "url": "/state_save",
	                     *            "data": data,
	                     *            "dataType": "json",
	                     *            "method": "POST"
	                     *            "success": function () {}
	                     *          } );
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateSaveCallback": function (settings, data) {
	                        try {
	                            (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
	                                'DataTables_' + settings.sInstance + '_' + location.pathname,
	                                JSON.stringify(data)
	                            );
	                        } catch (e) { }
	                    },


	                    /**
	                     * Callback which allows modification of the state to be saved. Called when the table
	                     * has changed state a new state save is required. This method allows modification of
	                     * the state saving object prior to actually doing the save, including addition or
	                     * other state properties or modification. Note that for plug-in authors, you should
	                     * use the `stateSaveParams` event to save parameters for a plug-in.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} data The state object to be saved
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateSaveParams
	                     *
	                     *  @example
	                     *    // Remove a saved filter, so filtering is never saved
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateSaveParams": function (settings, data) {
	                     *          data.oSearch.sSearch = "";
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateSaveParams": null,


	                    /**
	                     * Duration for which the saved state information is considered valid. After this period
	                     * has elapsed the state will be returned to the default.
	                     * Value is given in seconds.
	                     *  @type int
	                     *  @default 7200 <i>(2 hours)</i>
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.stateDuration
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateDuration": 60*60*24; // 1 day
	                     *      } );
	                     *    } )
	                     */
	                    "iStateDuration": 7200,


	                    /**
	                     * When enabled DataTables will not make a request to the server for the first
	                     * page draw - rather it will use the data already on the page (no sorting etc
	                     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
	                     * is used to indicate that deferred loading is required, but it is also used
	                     * to tell DataTables how many records there are in the full table (allowing
	                     * the information element and pagination to be displayed correctly). In the case
	                     * where a filtering is applied to the table on initial load, this can be
	                     * indicated by giving the parameter as an array, where the first element is
	                     * the number of records available after filtering and the second element is the
	                     * number of records without filtering (allowing the table information element
	                     * to be shown correctly).
	                     *  @type int | array
	                     *  @default null
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.deferLoading
	                     *
	                     *  @example
	                     *    // 57 records available in the table, no filtering applied
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "serverSide": true,
	                     *        "ajax": "scripts/server_processing.php",
	                     *        "deferLoading": 57
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "serverSide": true,
	                     *        "ajax": "scripts/server_processing.php",
	                     *        "deferLoading": [ 57, 100 ],
	                     *        "search": {
	                     *          "search": "my_filter"
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "iDeferLoading": null,


	                    /**
	                     * Number of rows to display on a single page when using pagination. If
	                     * feature enabled (`lengthChange`) then the end user will be able to override
	                     * this to a custom setting using a pop-up menu.
	                     *  @type int
	                     *  @default 10
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.pageLength
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "pageLength": 50
	                     *      } );
	                     *    } )
	                     */
	                    "iDisplayLength": 10,


	                    /**
	                     * Define the starting point for data display when using DataTables with
	                     * pagination. Note that this parameter is the number of records, rather than
	                     * the page number, so if you have 10 records per page and want to start on
	                     * the third page, it should be "20".
	                     *  @type int
	                     *  @default 0
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.displayStart
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "displayStart": 20
	                     *      } );
	                     *    } )
	                     */
	                    "iDisplayStart": 0,


	                    /**
	                     * By default DataTables allows keyboard navigation of the table (sorting, paging,
	                     * and filtering) by adding a `tabindex` attribute to the required elements. This
	                     * allows you to tab through the controls and press the enter key to activate them.
	                     * The tabindex is default 0, meaning that the tab follows the flow of the document.
	                     * You can overrule this using this parameter if you wish. Use a value of -1 to
	                     * disable built-in keyboard navigation.
	                     *  @type int
	                     *  @default 0
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.tabIndex
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "tabIndex": 1
	                     *      } );
	                     *    } );
	                     */
	                    "iTabIndex": 0,


	                    /**
	                     * Classes that DataTables assigns to the various components and features
	                     * that it adds to the HTML table. This allows classes to be configured
	                     * during initialisation in addition to through the static
	                     * {@link DataTable.ext.oStdClasses} object).
	                     *  @namespace
	                     *  @name DataTable.defaults.classes
	                     */
	                    "oClasses": {},


	                    /**
	                     * All strings that DataTables uses in the user interface that it creates
	                     * are defined in this object, allowing you to modified them individually or
	                     * completely replace them all as required.
	                     *  @namespace
	                     *  @name DataTable.defaults.language
	                     */
	                    "oLanguage": {
	                        /**
	                         * Strings that are used for WAI-ARIA labels and controls only (these are not
	                         * actually visible on the page, but will be read by screenreaders, and thus
	                         * must be internationalised as well).
	                         *  @namespace
	                         *  @name DataTable.defaults.language.aria
	                         */
	                        "oAria": {
	                            /**
	                             * ARIA label that is added to the table headers when the column may be
	                             * sorted ascending by activing the column (click or return when focused).
	                             * Note that the column header is prefixed to this string.
	                             *  @type string
	                             *  @default : activate to sort column ascending
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.aria.sortAscending
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "aria": {
	                             *            "sortAscending": " - click/return to sort ascending"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sSortAscending": ": activate to sort column ascending",

	                            /**
	                             * ARIA label that is added to the table headers when the column may be
	                             * sorted descending by activing the column (click or return when focused).
	                             * Note that the column header is prefixed to this string.
	                             *  @type string
	                             *  @default : activate to sort column ascending
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.aria.sortDescending
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "aria": {
	                             *            "sortDescending": " - click/return to sort descending"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sSortDescending": ": activate to sort column descending"
	                        },

	                        /**
	                         * Pagination string used by DataTables for the built-in pagination
	                         * control types.
	                         *  @namespace
	                         *  @name DataTable.defaults.language.paginate
	                         */
	                        "oPaginate": {
	                            /**
	                             * Text to use when using the 'full_numbers' type of pagination for the
	                             * button to take the user to the first page.
	                             *  @type string
	                             *  @default First
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.paginate.first
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "paginate": {
	                             *            "first": "First page"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sFirst": "First",


	                            /**
	                             * Text to use when using the 'full_numbers' type of pagination for the
	                             * button to take the user to the last page.
	                             *  @type string
	                             *  @default Last
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.paginate.last
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "paginate": {
	                             *            "last": "Last page"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sLast": "Last",


	                            /**
	                             * Text to use for the 'next' pagination button (to take the user to the
	                             * next page).
	                             *  @type string
	                             *  @default Next
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.paginate.next
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "paginate": {
	                             *            "next": "Next page"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sNext": "Next",


	                            /**
	                             * Text to use for the 'previous' pagination button (to take the user to
	                             * the previous page).
	                             *  @type string
	                             *  @default Previous
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.paginate.previous
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "paginate": {
	                             *            "previous": "Previous page"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sPrevious": "Previous"
	                        },

	                        /**
	                         * This string is shown in preference to `zeroRecords` when the table is
	                         * empty of data (regardless of filtering). Note that this is an optional
	                         * parameter - if it is not given, the value of `zeroRecords` will be used
	                         * instead (either the default or given value).
	                         *  @type string
	                         *  @default No data available in table
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.emptyTable
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "emptyTable": "No data available in table"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sEmptyTable": "No data available in table",


	                        /**
	                         * This string gives information to the end user about the information
	                         * that is current on display on the page. The following tokens can be
	                         * used in the string and will be dynamically replaced as the table
	                         * display updates. This tokens can be placed anywhere in the string, or
	                         * removed as needed by the language requires:
	                         *
	                         * * `\_START\_` - Display index of the first record on the current page
	                         * * `\_END\_` - Display index of the last record on the current page
	                         * * `\_TOTAL\_` - Number of records in the table after filtering
	                         * * `\_MAX\_` - Number of records in the table without filtering
	                         * * `\_PAGE\_` - Current page number
	                         * * `\_PAGES\_` - Total number of pages of data in the table
	                         *
	                         *  @type string
	                         *  @default Showing _START_ to _END_ of _TOTAL_ entries
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.info
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "info": "Showing page _PAGE_ of _PAGES_"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",


	                        /**
	                         * Display information string for when the table is empty. Typically the
	                         * format of this string should match `info`.
	                         *  @type string
	                         *  @default Showing 0 to 0 of 0 entries
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.infoEmpty
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "infoEmpty": "No entries to show"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sInfoEmpty": "Showing 0 to 0 of 0 entries",


	                        /**
	                         * When a user filters the information in a table, this string is appended
	                         * to the information (`info`) to give an idea of how strong the filtering
	                         * is. The variable _MAX_ is dynamically updated.
	                         *  @type string
	                         *  @default (filtered from _MAX_ total entries)
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.infoFiltered
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "infoFiltered": " - filtering from _MAX_ records"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sInfoFiltered": "(filtered from _MAX_ total entries)",


	                        /**
	                         * If can be useful to append extra information to the info string at times,
	                         * and this variable does exactly that. This information will be appended to
	                         * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
	                         * being used) at all times.
	                         *  @type string
	                         *  @default <i>Empty string</i>
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.infoPostFix
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "infoPostFix": "All records shown are derived from real information."
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sInfoPostFix": "",


	                        /**
	                         * This decimal place operator is a little different from the other
	                         * language options since DataTables doesn't output floating point
	                         * numbers, so it won't ever use this for display of a number. Rather,
	                         * what this parameter does is modify the sort methods of the table so
	                         * that numbers which are in a format which has a character other than
	                         * a period (`.`) as a decimal place will be sorted numerically.
	                         *
	                         * Note that numbers with different decimal places cannot be shown in
	                         * the same table and still be sortable, the table must be consistent.
	                         * However, multiple different tables on the page can use different
	                         * decimal place characters.
	                         *  @type string
	                         *  @default 
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.decimal
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "decimal": ","
	                         *          "thousands": "."
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sDecimal": "",


	                        /**
	                         * DataTables has a build in number formatter (`formatNumber`) which is
	                         * used to format large numbers that are used in the table information.
	                         * By default a comma is used, but this can be trivially changed to any
	                         * character you wish with this parameter.
	                         *  @type string
	                         *  @default ,
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.thousands
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "thousands": "'"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sThousands": ",",


	                        /**
	                         * Detail the action that will be taken when the drop down menu for the
	                         * pagination length option is changed. The '_MENU_' variable is replaced
	                         * with a default select list of 10, 25, 50 and 100, and can be replaced
	                         * with a custom select box if required.
	                         *  @type string
	                         *  @default Show _MENU_ entries
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.lengthMenu
	                         *
	                         *  @example
	                         *    // Language change only
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "lengthMenu": "Display _MENU_ records"
	                         *        }
	                         *      } );
	                         *    } );
	                         *
	                         *  @example
	                         *    // Language and options change
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "lengthMenu": 'Display <select>'+
	                         *            '<option value="10">10</option>'+
	                         *            '<option value="20">20</option>'+
	                         *            '<option value="30">30</option>'+
	                         *            '<option value="40">40</option>'+
	                         *            '<option value="50">50</option>'+
	                         *            '<option value="-1">All</option>'+
	                         *            '</select> records'
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sLengthMenu": "Show _MENU_ entries",


	                        /**
	                         * When using Ajax sourced data and during the first draw when DataTables is
	                         * gathering the data, this message is shown in an empty row in the table to
	                         * indicate to the end user the the data is being loaded. Note that this
	                         * parameter is not used when loading data by server-side processing, just
	                         * Ajax sourced data with client-side processing.
	                         *  @type string
	                         *  @default Loading...
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.loadingRecords
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "loadingRecords": "Please wait - loading..."
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sLoadingRecords": "Loading...",


	                        /**
	                         * Text which is displayed when the table is processing a user action
	                         * (usually a sort command or similar).
	                         *  @type string
	                         *  @default Processing...
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.processing
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "processing": "DataTables is currently busy"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sProcessing": "Processing...",


	                        /**
	                         * Details the actions that will be taken when the user types into the
	                         * filtering input text box. The variable "_INPUT_", if used in the string,
	                         * is replaced with the HTML text box for the filtering input allowing
	                         * control over where it appears in the string. If "_INPUT_" is not given
	                         * then the input box is appended to the string automatically.
	                         *  @type string
	                         *  @default Search:
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.search
	                         *
	                         *  @example
	                         *    // Input text box will be appended at the end automatically
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "search": "Filter records:"
	                         *        }
	                         *      } );
	                         *    } );
	                         *
	                         *  @example
	                         *    // Specify where the filter should appear
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "search": "Apply filter _INPUT_ to table"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sSearch": "Search:",


	                        /**
	                         * Assign a `placeholder` attribute to the search `input` element
	                         *  @type string
	                         *  @default 
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.searchPlaceholder
	                         */
	                        "sSearchPlaceholder": "",


	                        /**
	                         * All of the language information can be stored in a file on the
	                         * server-side, which DataTables will look up if this parameter is passed.
	                         * It must store the URL of the language file, which is in a JSON format,
	                         * and the object has the same properties as the oLanguage object in the
	                         * initialiser object (i.e. the above parameters). Please refer to one of
	                         * the example language files to see how this works in action.
	                         *  @type string
	                         *  @default <i>Empty string - i.e. disabled</i>
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.url
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sUrl": "",


	                        /**
	                         * Text shown inside the table records when the is no information to be
	                         * displayed after filtering. `emptyTable` is shown when there is simply no
	                         * information in the table at all (regardless of filtering).
	                         *  @type string
	                         *  @default No matching records found
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.zeroRecords
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "zeroRecords": "No records to display"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sZeroRecords": "No matching records found"
	                    },


	                    /**
	                     * This parameter allows you to have define the global filtering state at
	                     * initialisation time. As an object the `search` parameter must be
	                     * defined, but all other parameters are optional. When `regex` is true,
	                     * the search string will be treated as a regular expression, when false
	                     * (default) it will be treated as a straight string. When `smart`
	                     * DataTables will use it's smart filtering methods (to word match at
	                     * any point in the data), when false this will not be done.
	                     *  @namespace
	                     *  @extends DataTable.models.oSearch
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.search
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "search": {"search": "Initial search"}
	                     *      } );
	                     *    } )
	                     */
	                    "oSearch": $.extend({}, DataTable.models.oSearch),


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     * By default DataTables will look for the property `data` (or `aaData` for
	                     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
	                     * source or for server-side processing - this parameter allows that
	                     * property to be changed. You can use Javascript dotted object notation to
	                     * get a data source for multiple levels of nesting.
	                     *  @type string
	                     *  @default data
	                     *
	                     *  @dtopt Options
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.ajaxDataProp
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "sAjaxDataProp": "data",


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     * You can instruct DataTables to load data from an external
	                     * source using this parameter (use aData if you want to pass data in you
	                     * already have). Simply provide a url a JSON object can be obtained from.
	                     *  @type string
	                     *  @default null
	                     *
	                     *  @dtopt Options
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.ajaxSource
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "sAjaxSource": null,


	                    /**
	                     * This initialisation variable allows you to specify exactly where in the
	                     * DOM you want DataTables to inject the various controls it adds to the page
	                     * (for example you might want the pagination controls at the top of the
	                     * table). DIV elements (with or without a custom class) can also be added to
	                     * aid styling. The follow syntax is used:
	                     *   <ul>
	                     *     <li>The following options are allowed:
	                     *       <ul>
	                     *         <li>'l' - Length changing</li>
	                     *         <li>'f' - Filtering input</li>
	                     *         <li>'t' - The table!</li>
	                     *         <li>'i' - Information</li>
	                     *         <li>'p' - Pagination</li>
	                     *         <li>'r' - pRocessing</li>
	                     *       </ul>
	                     *     </li>
	                     *     <li>The following constants are allowed:
	                     *       <ul>
	                     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
	                     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
	                     *       </ul>
	                     *     </li>
	                     *     <li>The following syntax is expected:
	                     *       <ul>
	                     *         <li>'&lt;' and '&gt;' - div elements</li>
	                     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
	                     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
	                     *       </ul>
	                     *     </li>
	                     *     <li>Examples:
	                     *       <ul>
	                     *         <li>'&lt;"wrapper"flipt&gt;'</li>
	                     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
	                     *       </ul>
	                     *     </li>
	                     *   </ul>
	                     *  @type string
	                     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
	                     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.dom
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
	                     *      } );
	                     *    } );
	                     */
	                    "sDom": "lfrtip",


	                    /**
	                     * Search delay option. This will throttle full table searches that use the
	                     * DataTables provided search input element (it does not effect calls to
	                     * `dt-api search()`, providing a delay before the search is made.
	                     *  @type integer
	                     *  @default 0
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.searchDelay
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "searchDelay": 200
	                     *      } );
	                     *    } )
	                     */
	                    "searchDelay": null,


	                    /**
	                     * DataTables features four different built-in options for the buttons to
	                     * display for pagination control:
	                     *
	                     * * `simple` - 'Previous' and 'Next' buttons only
	                     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
	                     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
	                     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus
	                     *   page numbers
	                     *  
	                     * Further methods can be added using {@link DataTable.ext.oPagination}.
	                     *  @type string
	                     *  @default simple_numbers
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.pagingType
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "pagingType": "full_numbers"
	                     *      } );
	                     *    } )
	                     */
	                    "sPaginationType": "simple_numbers",


	                    /**
	                     * Enable horizontal scrolling. When a table is too wide to fit into a
	                     * certain layout, or you have a large number of columns in the table, you
	                     * can enable x-scrolling to show the table in a viewport, which can be
	                     * scrolled. This property can be `true` which will allow the table to
	                     * scroll horizontally when needed, or any CSS unit, or a number (in which
	                     * case it will be treated as a pixel measurement). Setting as simply `true`
	                     * is recommended.
	                     *  @type boolean|string
	                     *  @default <i>blank string - i.e. disabled</i>
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.scrollX
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "scrollX": true,
	                     *        "scrollCollapse": true
	                     *      } );
	                     *    } );
	                     */
	                    "sScrollX": "",


	                    /**
	                     * This property can be used to force a DataTable to use more width than it
	                     * might otherwise do when x-scrolling is enabled. For example if you have a
	                     * table which requires to be well spaced, this parameter is useful for
	                     * "over-sizing" the table, and thus forcing scrolling. This property can by
	                     * any CSS unit, or a number (in which case it will be treated as a pixel
	                     * measurement).
	                     *  @type string
	                     *  @default <i>blank string - i.e. disabled</i>
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.scrollXInner
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "scrollX": "100%",
	                     *        "scrollXInner": "110%"
	                     *      } );
	                     *    } );
	                     */
	                    "sScrollXInner": "",


	                    /**
	                     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
	                     * to the given height, and enable scrolling for any data which overflows the
	                     * current viewport. This can be used as an alternative to paging to display
	                     * a lot of data in a small area (although paging and scrolling can both be
	                     * enabled at the same time). This property can be any CSS unit, or a number
	                     * (in which case it will be treated as a pixel measurement).
	                     *  @type string
	                     *  @default <i>blank string - i.e. disabled</i>
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.scrollY
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "scrollY": "200px",
	                     *        "paginate": false
	                     *      } );
	                     *    } );
	                     */
	                    "sScrollY": "",


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     * Set the HTTP method that is used to make the Ajax call for server-side
	                     * processing or Ajax sourced data.
	                     *  @type string
	                     *  @default GET
	                     *
	                     *  @dtopt Options
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.serverMethod
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "sServerMethod": "GET",


	                    /**
	                     * DataTables makes use of renderers when displaying HTML elements for
	                     * a table. These renderers can be added or modified by plug-ins to
	                     * generate suitable mark-up for a site. For example the Bootstrap
	                     * integration plug-in for DataTables uses a paging button renderer to
	                     * display pagination buttons in the mark-up required by Bootstrap.
	                     *
	                     * For further information about the renderers available see
	                     * DataTable.ext.renderer
	                     *  @type string|object
	                     *  @default null
	                     *
	                     *  @name DataTable.defaults.renderer
	                     *
	                     */
	                    "renderer": null
	                };

	                _fnHungarianMap(DataTable.defaults);



	                /*
	                 * Developer note - See note in model.defaults.js about the use of Hungarian
	                 * notation and camel case.
	                 */

	                /**
	                 * Column options that can be given to DataTables at initialisation time.
	                 *  @namespace
	                 */
	                DataTable.defaults.column = {
	                    /**
	                     * Define which column(s) an order will occur on for this column. This
	                     * allows a column's ordering to take multiple columns into account when
	                     * doing a sort or use the data from a different column. For example first
	                     * name / last name columns make sense to do a multi-column sort over the
	                     * two columns.
	                     *  @type array|int
	                     *  @default null <i>Takes the value of the column index automatically</i>
	                     *
	                     *  @name DataTable.defaults.column.orderData
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
	                     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
	                     *          { "orderData": 2, "targets": [ 2 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "orderData": [ 0, 1 ] },
	                     *          { "orderData": [ 1, 0 ] },
	                     *          { "orderData": 2 },
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "aDataSort": null,
	                    "iDataSort": -1,


	                    /**
	                     * You can control the default ordering direction, and even alter the
	                     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
	                     * using this parameter.
	                     *  @type array
	                     *  @default [ 'asc', 'desc' ]
	                     *
	                     *  @name DataTable.defaults.column.orderSequence
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
	                     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
	                     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          null,
	                     *          { "orderSequence": [ "asc" ] },
	                     *          { "orderSequence": [ "desc", "asc", "asc" ] },
	                     *          { "orderSequence": [ "desc" ] },
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "asSorting": ['asc', 'desc'],


	                    /**
	                     * Enable or disable filtering on the data in this column.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @name DataTable.defaults.column.searchable
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "searchable": false, "targets": [ 0 ] }
	                     *        ] } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "searchable": false },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ] } );
	                     *    } );
	                     */
	                    "bSearchable": true,


	                    /**
	                     * Enable or disable ordering on this column.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @name DataTable.defaults.column.orderable
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "orderable": false, "targets": [ 0 ] }
	                     *        ] } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "orderable": false },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ] } );
	                     *    } );
	                     */
	                    "bSortable": true,


	                    /**
	                     * Enable or disable the display of this column.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @name DataTable.defaults.column.visible
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "visible": false, "targets": [ 0 ] }
	                     *        ] } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "visible": false },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ] } );
	                     *    } );
	                     */
	                    "bVisible": true,


	                    /**
	                     * Developer definable function that is called whenever a cell is created (Ajax source,
	                     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	                     * allowing you to modify the DOM element (add background colour for example) when the
	                     * element is available.
	                     *  @type function
	                     *  @param {element} td The TD node that has been created
	                     *  @param {*} cellData The Data for the cell
	                     *  @param {array|object} rowData The data for the whole row
	                     *  @param {int} row The row index for the aoData data store
	                     *  @param {int} col The column index for aoColumns
	                     *
	                     *  @name DataTable.defaults.column.createdCell
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [3],
	                     *          "createdCell": function (td, cellData, rowData, row, col) {
	                     *            if ( cellData == "1.7" ) {
	                     *              $(td).css('color', 'blue')
	                     *            }
	                     *          }
	                     *        } ]
	                     *      });
	                     *    } );
	                     */
	                    "fnCreatedCell": null,


	                    /**
	                     * This parameter has been replaced by `data` in DataTables to ensure naming
	                     * consistency. `dataProp` can still be used, as there is backwards
	                     * compatibility in DataTables for this option, but it is strongly
	                     * recommended that you use `data` in preference to `dataProp`.
	                     *  @name DataTable.defaults.column.dataProp
	                     */


	                    /**
	                     * This property can be used to read data from any data source property,
	                     * including deeply nested objects / properties. `data` can be given in a
	                     * number of different ways which effect its behaviour:
	                     *
	                     * * `integer` - treated as an array index for the data source. This is the
	                     *   default that DataTables uses (incrementally increased for each column).
	                     * * `string` - read an object property from the data source. There are
	                     *   three 'special' options that can be used in the string to alter how
	                     *   DataTables reads the data from the source object:
	                     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	                     *      Javascript to read from nested objects, so to can the options
	                     *      specified in `data`. For example: `browser.version` or
	                     *      `browser.name`. If your object parameter name contains a period, use
	                     *      `\\` to escape it - i.e. `first\\.name`.
	                     *    * `[]` - Array notation. DataTables can automatically combine data
	                     *      from and array source, joining the data with the characters provided
	                     *      between the two brackets. For example: `name[, ]` would provide a
	                     *      comma-space separated list from the source array. If no characters
	                     *      are provided between the brackets, the original array source is
	                     *      returned.
	                     *    * `()` - Function notation. Adding `()` to the end of a parameter will
	                     *      execute a function of the name given. For example: `browser()` for a
	                     *      simple function on the data source, `browser.version()` for a
	                     *      function in a nested property or even `browser().version` to get an
	                     *      object property if the function called returns an object. Note that
	                     *      function notation is recommended for use in `render` rather than
	                     *      `data` as it is much simpler to use as a renderer.
	                     * * `null` - use the original data source for the row rather than plucking
	                     *   data directly from it. This action has effects on two other
	                     *   initialisation options:
	                     *    * `defaultContent` - When null is given as the `data` option and
	                     *      `defaultContent` is specified for the column, the value defined by
	                     *      `defaultContent` will be used for the cell.
	                     *    * `render` - When null is used for the `data` option and the `render`
	                     *      option is specified for the column, the whole data source for the
	                     *      row is used for the renderer.
	                     * * `function` - the function given will be executed whenever DataTables
	                     *   needs to set or get the data for a cell in the column. The function
	                     *   takes three parameters:
	                     *    * Parameters:
	                     *      * `{array|object}` The data source for the row
	                     *      * `{string}` The type call data requested - this will be 'set' when
	                     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
	                     *        when gathering data. Note that when `undefined` is given for the
	                     *        type DataTables expects to get the raw data for the object back<
	                     *      * `{*}` Data to set when the second parameter is 'set'.
	                     *    * Return:
	                     *      * The return value from the function is not required when 'set' is
	                     *        the type of call, but otherwise the return is what will be used
	                     *        for the data requested.
	                     *
	                     * Note that `data` is a getter and setter option. If you just require
	                     * formatting of data for output, you will likely want to use `render` which
	                     * is simply a getter and thus simpler to use.
	                     *
	                     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
	                     * name change reflects the flexibility of this property and is consistent
	                     * with the naming of mRender. If 'mDataProp' is given, then it will still
	                     * be used by DataTables, as it automatically maps the old name to the new
	                     * if required.
	                     *
	                     *  @type string|int|function|null
	                     *  @default null <i>Use automatically calculated column index</i>
	                     *
	                     *  @name DataTable.defaults.column.data
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Read table data from objects
	                     *    // JSON structure for each row:
	                     *    //   {
	                     *    //      "engine": {value},
	                     *    //      "browser": {value},
	                     *    //      "platform": {value},
	                     *    //      "version": {value},
	                     *    //      "grade": {value}
	                     *    //   }
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "ajaxSource": "sources/objects.txt",
	                     *        "columns": [
	                     *          { "data": "engine" },
	                     *          { "data": "browser" },
	                     *          { "data": "platform" },
	                     *          { "data": "version" },
	                     *          { "data": "grade" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Read information from deeply nested objects
	                     *    // JSON structure for each row:
	                     *    //   {
	                     *    //      "engine": {value},
	                     *    //      "browser": {value},
	                     *    //      "platform": {
	                     *    //         "inner": {value}
	                     *    //      },
	                     *    //      "details": [
	                     *    //         {value}, {value}
	                     *    //      ]
	                     *    //   }
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "ajaxSource": "sources/deep.txt",
	                     *        "columns": [
	                     *          { "data": "engine" },
	                     *          { "data": "browser" },
	                     *          { "data": "platform.inner" },
	                     *          { "data": "platform.details.0" },
	                     *          { "data": "platform.details.1" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `data` as a function to provide different information for
	                     *    // sorting, filtering and display. In this case, currency (price)
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": function ( source, type, val ) {
	                     *            if (type === 'set') {
	                     *              source.price = val;
	                     *              // Store the computed dislay and filter values for efficiency
	                     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
	                     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
	                     *              return;
	                     *            }
	                     *            else if (type === 'display') {
	                     *              return source.price_display;
	                     *            }
	                     *            else if (type === 'filter') {
	                     *              return source.price_filter;
	                     *            }
	                     *            // 'sort', 'type' and undefined all just use the integer
	                     *            return source.price;
	                     *          }
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using default content
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": null,
	                     *          "defaultContent": "Click to edit"
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using array notation - outputting a list from an array
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": "name[, ]"
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     */
	                    "mData": null,


	                    /**
	                     * This property is the rendering partner to `data` and it is suggested that
	                     * when you want to manipulate data for display (including filtering,
	                     * sorting etc) without altering the underlying data for the table, use this
	                     * property. `render` can be considered to be the the read only companion to
	                     * `data` which is read / write (then as such more complex). Like `data`
	                     * this option can be given in a number of different ways to effect its
	                     * behaviour:
	                     *
	                     * * `integer` - treated as an array index for the data source. This is the
	                     *   default that DataTables uses (incrementally increased for each column).
	                     * * `string` - read an object property from the data source. There are
	                     *   three 'special' options that can be used in the string to alter how
	                     *   DataTables reads the data from the source object:
	                     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	                     *      Javascript to read from nested objects, so to can the options
	                     *      specified in `data`. For example: `browser.version` or
	                     *      `browser.name`. If your object parameter name contains a period, use
	                     *      `\\` to escape it - i.e. `first\\.name`.
	                     *    * `[]` - Array notation. DataTables can automatically combine data
	                     *      from and array source, joining the data with the characters provided
	                     *      between the two brackets. For example: `name[, ]` would provide a
	                     *      comma-space separated list from the source array. If no characters
	                     *      are provided between the brackets, the original array source is
	                     *      returned.
	                     *    * `()` - Function notation. Adding `()` to the end of a parameter will
	                     *      execute a function of the name given. For example: `browser()` for a
	                     *      simple function on the data source, `browser.version()` for a
	                     *      function in a nested property or even `browser().version` to get an
	                     *      object property if the function called returns an object.
	                     * * `object` - use different data for the different data types requested by
	                     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
	                     *   of the object is the data type the property refers to and the value can
	                     *   defined using an integer, string or function using the same rules as
	                     *   `render` normally does. Note that an `_` option _must_ be specified.
	                     *   This is the default value to use if you haven't specified a value for
	                     *   the data type requested by DataTables.
	                     * * `function` - the function given will be executed whenever DataTables
	                     *   needs to set or get the data for a cell in the column. The function
	                     *   takes three parameters:
	                     *    * Parameters:
	                     *      * {array|object} The data source for the row (based on `data`)
	                     *      * {string} The type call data requested - this will be 'filter',
	                     *        'display', 'type' or 'sort'.
	                     *      * {array|object} The full data source for the row (not based on
	                     *        `data`)
	                     *    * Return:
	                     *      * The return value from the function is what will be used for the
	                     *        data requested.
	                     *
	                     *  @type string|int|function|object|null
	                     *  @default null Use the data source value.
	                     *
	                     *  @name DataTable.defaults.column.render
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Create a comma separated list from an array of objects
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "ajaxSource": "sources/deep.txt",
	                     *        "columns": [
	                     *          { "data": "engine" },
	                     *          { "data": "browser" },
	                     *          {
	                     *            "data": "platform",
	                     *            "render": "[, ].name"
	                     *          }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Execute a function to obtain data
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": null, // Use the full data source object for the renderer's source
	                     *          "render": "browserName()"
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // As an object, extracting different data for the different types
	                     *    // This would be used with a data source such as:
	                     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
	                     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
	                     *    // (which has both forms) is used for filtering for if a user inputs either format, while
	                     *    // the formatted phone number is the one that is shown in the table.
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": null, // Use the full data source object for the renderer's source
	                     *          "render": {
	                     *            "_": "phone",
	                     *            "filter": "phone_filter",
	                     *            "display": "phone_display"
	                     *          }
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Use as a function to create a link from the data source
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": "download_link",
	                     *          "render": function ( data, type, full ) {
	                     *            return '<a href="'+data+'">Download</a>';
	                     *          }
	                     *        } ]
	                     *      } );
	                     *    } );
	                     */
	                    "mRender": null,


	                    /**
	                     * Change the cell type created for the column - either TD cells or TH cells. This
	                     * can be useful as TH cells have semantic meaning in the table body, allowing them
	                     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
	                     *  @type string
	                     *  @default td
	                     *
	                     *  @name DataTable.defaults.column.cellType
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Make the first column use TH cells
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "cellType": "th"
	                     *        } ]
	                     *      } );
	                     *    } );
	                     */
	                    "sCellType": "td",


	                    /**
	                     * Class to give to each cell in this column.
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     *
	                     *  @name DataTable.defaults.column.class
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "class": "my_class", "targets": [ 0 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "class": "my_class" },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sClass": "",

	                    /**
	                     * When DataTables calculates the column widths to assign to each column,
	                     * it finds the longest string in each column and then constructs a
	                     * temporary table and reads the widths from that. The problem with this
	                     * is that "mmm" is much wider then "iiii", but the latter is a longer
	                     * string - thus the calculation can go wrong (doing it properly and putting
	                     * it into an DOM object and measuring that is horribly(!) slow). Thus as
	                     * a "work around" we provide this option. It will append its value to the
	                     * text that is found to be the longest string for the column - i.e. padding.
	                     * Generally you shouldn't need this!
	                     *  @type string
	                     *  @default <i>Empty string<i>
	                     *
	                     *  @name DataTable.defaults.column.contentPadding
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          {
	                     *            "contentPadding": "mmm"
	                     *          }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sContentPadding": "",


	                    /**
	                     * Allows a default value to be given for a column's data, and will be used
	                     * whenever a null data source is encountered (this can be because `data`
	                     * is set to null, or because the data source itself is null).
	                     *  @type string
	                     *  @default null
	                     *
	                     *  @name DataTable.defaults.column.defaultContent
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          {
	                     *            "data": null,
	                     *            "defaultContent": "Edit",
	                     *            "targets": [ -1 ]
	                     *          }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          {
	                     *            "data": null,
	                     *            "defaultContent": "Edit"
	                     *          }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sDefaultContent": null,


	                    /**
	                     * This parameter is only used in DataTables' server-side processing. It can
	                     * be exceptionally useful to know what columns are being displayed on the
	                     * client side, and to map these to database fields. When defined, the names
	                     * also allow DataTables to reorder information from the server if it comes
	                     * back in an unexpected order (i.e. if you switch your columns around on the
	                     * client-side, your server-side code does not also need updating).
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     *
	                     *  @name DataTable.defaults.column.name
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "name": "engine", "targets": [ 0 ] },
	                     *          { "name": "browser", "targets": [ 1 ] },
	                     *          { "name": "platform", "targets": [ 2 ] },
	                     *          { "name": "version", "targets": [ 3 ] },
	                     *          { "name": "grade", "targets": [ 4 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "name": "engine" },
	                     *          { "name": "browser" },
	                     *          { "name": "platform" },
	                     *          { "name": "version" },
	                     *          { "name": "grade" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sName": "",


	                    /**
	                     * Defines a data source type for the ordering which can be used to read
	                     * real-time information from the table (updating the internally cached
	                     * version) prior to ordering. This allows ordering to occur on user
	                     * editable elements such as form inputs.
	                     *  @type string
	                     *  @default std
	                     *
	                     *  @name DataTable.defaults.column.orderDataType
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
	                     *          { "type": "numeric", "targets": [ 3 ] },
	                     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
	                     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          null,
	                     *          null,
	                     *          { "orderDataType": "dom-text" },
	                     *          { "orderDataType": "dom-text", "type": "numeric" },
	                     *          { "orderDataType": "dom-select" },
	                     *          { "orderDataType": "dom-checkbox" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sSortDataType": "std",


	                    /**
	                     * The title of this column.
	                     *  @type string
	                     *  @default null <i>Derived from the 'TH' value for this column in the
	                     *    original HTML table.</i>
	                     *
	                     *  @name DataTable.defaults.column.title
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "title": "My column title", "targets": [ 0 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "title": "My column title" },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sTitle": null,


	                    /**
	                     * The type allows you to specify how the data for this column will be
	                     * ordered. Four types (string, numeric, date and html (which will strip
	                     * HTML tags before ordering)) are currently available. Note that only date
	                     * formats understood by Javascript's Date() object will be accepted as type
	                     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
	                     * 'numeric', 'date' or 'html' (by default). Further types can be adding
	                     * through plug-ins.
	                     *  @type string
	                     *  @default null <i>Auto-detected from raw data</i>
	                     *
	                     *  @name DataTable.defaults.column.type
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "type": "html", "targets": [ 0 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "type": "html" },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sType": null,


	                    /**
	                     * Defining the width of the column, this parameter may take any CSS value
	                     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
	                     * been given a specific width through this interface ensuring that the table
	                     * remains readable.
	                     *  @type string
	                     *  @default null <i>Automatic</i>
	                     *
	                     *  @name DataTable.defaults.column.width
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "width": "20%", "targets": [ 0 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "width": "20%" },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sWidth": null
	                };

	                _fnHungarianMap(DataTable.defaults.column);



	                /**
	                 * DataTables settings object - this holds all the information needed for a
	                 * given table, including configuration, data and current application of the
	                 * table options. DataTables does not have a single instance for each DataTable
	                 * with the settings attached to that instance, but rather instances of the
	                 * DataTable "class" are created on-the-fly as needed (typically by a
	                 * $().dataTable() call) and the settings object is then applied to that
	                 * instance.
	                 *
	                 * Note that this object is related to {@link DataTable.defaults} but this
	                 * one is the internal data store for DataTables's cache of columns. It should
	                 * NOT be manipulated outside of DataTables. Any configuration should be done
	                 * through the initialisation options.
	                 *  @namespace
	                 *  @todo Really should attach the settings object to individual instances so we
	                 *    don't need to create new instances on each $().dataTable() call (if the
	                 *    table already exists). It would also save passing oSettings around and
	                 *    into every single function. However, this is a very significant
	                 *    architecture change for DataTables and will almost certainly break
	                 *    backwards compatibility with older installations. This is something that
	                 *    will be done in 2.0.
	                 */
	                DataTable.models.oSettings = {
	                    /**
	                     * Primary features of DataTables and their enablement state.
	                     *  @namespace
	                     */
	                    "oFeatures": {

	                        /**
	                         * Flag to say if DataTables should automatically try to calculate the
	                         * optimum table and columns widths (true) or not (false).
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bAutoWidth": null,

	                        /**
	                         * Delay the creation of TR and TD elements until they are actually
	                         * needed by a driven page draw. This can give a significant speed
	                         * increase for Ajax source and Javascript source data, but makes no
	                         * difference at all fro DOM and server-side processing tables.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bDeferRender": null,

	                        /**
	                         * Enable filtering on the table or not. Note that if this is disabled
	                         * then there is no filtering at all on the table, including fnFilter.
	                         * To just remove the filtering input use sDom and remove the 'f' option.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bFilter": null,

	                        /**
	                         * Table information element (the 'Showing x of y records' div) enable
	                         * flag.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bInfo": null,

	                        /**
	                         * Present a user control allowing the end user to change the page size
	                         * when pagination is enabled.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bLengthChange": null,

	                        /**
	                         * Pagination enabled or not. Note that if this is disabled then length
	                         * changing must also be disabled.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bPaginate": null,

	                        /**
	                         * Processing indicator enable flag whenever DataTables is enacting a
	                         * user request - typically an Ajax request for server-side processing.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bProcessing": null,

	                        /**
	                         * Server-side processing enabled flag - when enabled DataTables will
	                         * get all data from the server for every draw - there is no filtering,
	                         * sorting or paging done on the client-side.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bServerSide": null,

	                        /**
	                         * Sorting enablement flag.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bSort": null,

	                        /**
	                         * Multi-column sorting
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bSortMulti": null,

	                        /**
	                         * Apply a class to the columns which are being sorted to provide a
	                         * visual highlight or not. This can slow things down when enabled since
	                         * there is a lot of DOM interaction.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bSortClasses": null,

	                        /**
	                         * State saving enablement flag.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bStateSave": null
	                    },


	                    /**
	                     * Scrolling settings for a table.
	                     *  @namespace
	                     */
	                    "oScroll": {
	                        /**
	                         * When the table is shorter in height than sScrollY, collapse the
	                         * table container down to the height of the table (when true).
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bCollapse": null,

	                        /**
	                         * Width of the scrollbar for the web-browser's platform. Calculated
	                         * during table initialisation.
	                         *  @type int
	                         *  @default 0
	                         */
	                        "iBarWidth": 0,

	                        /**
	                         * Viewport width for horizontal scrolling. Horizontal scrolling is
	                         * disabled if an empty string.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type string
	                         */
	                        "sX": null,

	                        /**
	                         * Width to expand the table to when using x-scrolling. Typically you
	                         * should not need to use this.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type string
	                         *  @deprecated
	                         */
	                        "sXInner": null,

	                        /**
	                         * Viewport height for vertical scrolling. Vertical scrolling is disabled
	                         * if an empty string.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type string
	                         */
	                        "sY": null
	                    },

	                    /**
	                     * Language information for the table.
	                     *  @namespace
	                     *  @extends DataTable.defaults.oLanguage
	                     */
	                    "oLanguage": {
	                        /**
	                         * Information callback function. See
	                         * {@link DataTable.defaults.fnInfoCallback}
	                         *  @type function
	                         *  @default null
	                         */
	                        "fnInfoCallback": null
	                    },

	                    /**
	                     * Browser support parameters
	                     *  @namespace
	                     */
	                    "oBrowser": {
	                        /**
	                         * Indicate if the browser incorrectly calculates width:100% inside a
	                         * scrolling element (IE6/7)
	                         *  @type boolean
	                         *  @default false
	                         */
	                        "bScrollOversize": false,

	                        /**
	                         * Determine if the vertical scrollbar is on the right or left of the
	                         * scrolling container - needed for rtl language layout, although not
	                         * all browsers move the scrollbar (Safari).
	                         *  @type boolean
	                         *  @default false
	                         */
	                        "bScrollbarLeft": false
	                    },


	                    "ajax": null,


	                    /**
	                     * Array referencing the nodes which are used for the features. The
	                     * parameters of this object match what is allowed by sDom - i.e.
	                     *   <ul>
	                     *     <li>'l' - Length changing</li>
	                     *     <li>'f' - Filtering input</li>
	                     *     <li>'t' - The table!</li>
	                     *     <li>'i' - Information</li>
	                     *     <li>'p' - Pagination</li>
	                     *     <li>'r' - pRocessing</li>
	                     *   </ul>
	                     *  @type array
	                     *  @default []
	                     */
	                    "aanFeatures": [],

	                    /**
	                     * Store data information - see {@link DataTable.models.oRow} for detailed
	                     * information.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoData": [],

	                    /**
	                     * Array of indexes which are in the current display (after filtering etc)
	                     *  @type array
	                     *  @default []
	                     */
	                    "aiDisplay": [],

	                    /**
	                     * Array of indexes for display - no filtering
	                     *  @type array
	                     *  @default []
	                     */
	                    "aiDisplayMaster": [],

	                    /**
	                     * Store information about each column that is in use
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoColumns": [],

	                    /**
	                     * Store information about the table's header
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoHeader": [],

	                    /**
	                     * Store information about the table's footer
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoFooter": [],

	                    /**
	                     * Store the applied global search information in case we want to force a
	                     * research or compare the old search to a new one.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @namespace
	                     *  @extends DataTable.models.oSearch
	                     */
	                    "oPreviousSearch": {},

	                    /**
	                     * Store the applied search for each column - see
	                     * {@link DataTable.models.oSearch} for the format that is used for the
	                     * filtering information for each column.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoPreSearchCols": [],

	                    /**
	                     * Sorting that is applied to the table. Note that the inner arrays are
	                     * used in the following manner:
	                     * <ul>
	                     *   <li>Index 0 - column number</li>
	                     *   <li>Index 1 - current sorting direction</li>
	                     * </ul>
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type array
	                     *  @todo These inner arrays should really be objects
	                     */
	                    "aaSorting": null,

	                    /**
	                     * Sorting that is always applied to the table (i.e. prefixed in front of
	                     * aaSorting).
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aaSortingFixed": [],

	                    /**
	                     * Classes to use for the striping of a table.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type array
	                     *  @default []
	                     */
	                    "asStripeClasses": null,

	                    /**
	                     * If restoring a table - we should restore its striping classes as well
	                     *  @type array
	                     *  @default []
	                     */
	                    "asDestroyStripes": [],

	                    /**
	                     * If restoring a table - we should restore its width
	                     *  @type int
	                     *  @default 0
	                     */
	                    "sDestroyWidth": 0,

	                    /**
	                     * Callback functions array for every time a row is inserted (i.e. on a draw).
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoRowCallback": [],

	                    /**
	                     * Callback functions for the header on each draw.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoHeaderCallback": [],

	                    /**
	                     * Callback function for the footer on each draw.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoFooterCallback": [],

	                    /**
	                     * Array of callback functions for draw callback functions
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoDrawCallback": [],

	                    /**
	                     * Array of callback functions for row created function
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoRowCreatedCallback": [],

	                    /**
	                     * Callback functions for just before the table is redrawn. A return of
	                     * false will be used to cancel the draw.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoPreDrawCallback": [],

	                    /**
	                     * Callback functions for when the table has been initialised.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoInitComplete": [],


	                    /**
	                     * Callbacks for modifying the settings to be stored for state saving, prior to
	                     * saving state.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateSaveParams": [],

	                    /**
	                     * Callbacks for modifying the settings that have been stored for state saving
	                     * prior to using the stored values to restore the state.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateLoadParams": [],

	                    /**
	                     * Callbacks for operating on the settings object once the saved state has been
	                     * loaded
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateLoaded": [],

	                    /**
	                     * Cache the table ID for quick access
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     */
	                    "sTableId": "",

	                    /**
	                     * The TABLE node for the main table
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTable": null,

	                    /**
	                     * Permanent ref to the thead element
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTHead": null,

	                    /**
	                     * Permanent ref to the tfoot element - if it exists
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTFoot": null,

	                    /**
	                     * Permanent ref to the tbody element
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTBody": null,

	                    /**
	                     * Cache the wrapper node (contains all DataTables controlled elements)
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTableWrapper": null,

	                    /**
	                     * Indicate if when using server-side processing the loading of data
	                     * should be deferred until the second draw.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type boolean
	                     *  @default false
	                     */
	                    "bDeferLoading": false,

	                    /**
	                     * Indicate if all required information has been read in
	                     *  @type boolean
	                     *  @default false
	                     */
	                    "bInitialised": false,

	                    /**
	                     * Information about open rows. Each object in the array has the parameters
	                     * 'nTr' and 'nParent'
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoOpenRows": [],

	                    /**
	                     * Dictate the positioning of DataTables' control elements - see
	                     * {@link DataTable.model.oInit.sDom}.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     *  @default null
	                     */
	                    "sDom": null,

	                    /**
	                     * Search delay (in mS)
	                     *  @type integer
	                     *  @default null
	                     */
	                    "searchDelay": null,

	                    /**
	                     * Which type of pagination should be used.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     *  @default two_button
	                     */
	                    "sPaginationType": "two_button",

	                    /**
	                     * The state duration (for `stateSave`) in seconds.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type int
	                     *  @default 0
	                     */
	                    "iStateDuration": 0,

	                    /**
	                     * Array of callback functions for state saving. Each array element is an
	                     * object with the following parameters:
	                     *   <ul>
	                     *     <li>function:fn - function to call. Takes two parameters, oSettings
	                     *       and the JSON string to save that has been thus far created. Returns
	                     *       a JSON string to be inserted into a json object
	                     *       (i.e. '"param": [ 0, 1, 2]')</li>
	                     *     <li>string:sName - name of callback</li>
	                     *   </ul>
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateSave": [],

	                    /**
	                     * Array of callback functions for state loading. Each array element is an
	                     * object with the following parameters:
	                     *   <ul>
	                     *     <li>function:fn - function to call. Takes two parameters, oSettings
	                     *       and the object stored. May return false to cancel state loading</li>
	                     *     <li>string:sName - name of callback</li>
	                     *   </ul>
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateLoad": [],

	                    /**
	                     * State that was saved. Useful for back reference
	                     *  @type object
	                     *  @default null
	                     */
	                    "oSavedState": null,

	                    /**
	                     * State that was loaded. Useful for back reference
	                     *  @type object
	                     *  @default null
	                     */
	                    "oLoadedState": null,

	                    /**
	                     * Source url for AJAX data for the table.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     *  @default null
	                     */
	                    "sAjaxSource": null,

	                    /**
	                     * Property from a given object from which to read the table data from. This
	                     * can be an empty string (when not server-side processing), in which case
	                     * it is  assumed an an array is given directly.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     */
	                    "sAjaxDataProp": null,

	                    /**
	                     * Note if draw should be blocked while getting data
	                     *  @type boolean
	                     *  @default true
	                     */
	                    "bAjaxDataGet": true,

	                    /**
	                     * The last jQuery XHR object that was used for server-side data gathering.
	                     * This can be used for working with the XHR information in one of the
	                     * callbacks
	                     *  @type object
	                     *  @default null
	                     */
	                    "jqXHR": null,

	                    /**
	                     * JSON returned from the server in the last Ajax request
	                     *  @type object
	                     *  @default undefined
	                     */
	                    "json": undefined,

	                    /**
	                     * Data submitted as part of the last Ajax request
	                     *  @type object
	                     *  @default undefined
	                     */
	                    "oAjaxData": undefined,

	                    /**
	                     * Function to get the server-side data.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type function
	                     */
	                    "fnServerData": null,

	                    /**
	                     * Functions which are called prior to sending an Ajax request so extra
	                     * parameters can easily be sent to the server
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoServerParams": [],

	                    /**
	                     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
	                     * required).
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     */
	                    "sServerMethod": null,

	                    /**
	                     * Format numbers for display.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type function
	                     */
	                    "fnFormatNumber": null,

	                    /**
	                     * List of options that can be used for the user selectable length menu.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aLengthMenu": null,

	                    /**
	                     * Counter for the draws that the table does. Also used as a tracker for
	                     * server-side processing
	                     *  @type int
	                     *  @default 0
	                     */
	                    "iDraw": 0,

	                    /**
	                     * Indicate if a redraw is being done - useful for Ajax
	                     *  @type boolean
	                     *  @default false
	                     */
	                    "bDrawing": false,

	                    /**
	                     * Draw index (iDraw) of the last error when parsing the returned data
	                     *  @type int
	                     *  @default -1
	                     */
	                    "iDrawError": -1,

	                    /**
	                     * Paging display length
	                     *  @type int
	                     *  @default 10
	                     */
	                    "_iDisplayLength": 10,

	                    /**
	                     * Paging start point - aiDisplay index
	                     *  @type int
	                     *  @default 0
	                     */
	                    "_iDisplayStart": 0,

	                    /**
	                     * Server-side processing - number of records in the result set
	                     * (i.e. before filtering), Use fnRecordsTotal rather than
	                     * this property to get the value of the number of records, regardless of
	                     * the server-side processing setting.
	                     *  @type int
	                     *  @default 0
	                     *  @private
	                     */
	                    "_iRecordsTotal": 0,

	                    /**
	                     * Server-side processing - number of records in the current display set
	                     * (i.e. after filtering). Use fnRecordsDisplay rather than
	                     * this property to get the value of the number of records, regardless of
	                     * the server-side processing setting.
	                     *  @type boolean
	                     *  @default 0
	                     *  @private
	                     */
	                    "_iRecordsDisplay": 0,

	                    /**
	                     * Flag to indicate if jQuery UI marking and classes should be used.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type boolean
	                     */
	                    "bJUI": null,

	                    /**
	                     * The classes to use for the table
	                     *  @type object
	                     *  @default {}
	                     */
	                    "oClasses": {},

	                    /**
	                     * Flag attached to the settings object so you can check in the draw
	                     * callback if filtering has been done in the draw. Deprecated in favour of
	                     * events.
	                     *  @type boolean
	                     *  @default false
	                     *  @deprecated
	                     */
	                    "bFiltered": false,

	                    /**
	                     * Flag attached to the settings object so you can check in the draw
	                     * callback if sorting has been done in the draw. Deprecated in favour of
	                     * events.
	                     *  @type boolean
	                     *  @default false
	                     *  @deprecated
	                     */
	                    "bSorted": false,

	                    /**
	                     * Indicate that if multiple rows are in the header and there is more than
	                     * one unique cell per column, if the top one (true) or bottom one (false)
	                     * should be used for sorting / title by DataTables.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type boolean
	                     */
	                    "bSortCellsTop": null,

	                    /**
	                     * Initialisation object that is used for the table
	                     *  @type object
	                     *  @default null
	                     */
	                    "oInit": null,

	                    /**
	                     * Destroy callback functions - for plug-ins to attach themselves to the
	                     * destroy so they can clean up markup and events.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoDestroyCallback": [],


	                    /**
	                     * Get the number of records in the current record set, before filtering
	                     *  @type function
	                     */
	                    "fnRecordsTotal": function () {
	                        return _fnDataSource(this) == 'ssp' ?
	                            this._iRecordsTotal * 1 :
	                            this.aiDisplayMaster.length;
	                    },

	                    /**
	                     * Get the number of records in the current record set, after filtering
	                     *  @type function
	                     */
	                    "fnRecordsDisplay": function () {
	                        return _fnDataSource(this) == 'ssp' ?
	                            this._iRecordsDisplay * 1 :
	                            this.aiDisplay.length;
	                    },

	                    /**
	                     * Get the display end point - aiDisplay index
	                     *  @type function
	                     */
	                    "fnDisplayEnd": function () {
	                        var
	                            len = this._iDisplayLength,
	                            start = this._iDisplayStart,
	                            calc = start + len,
	                            records = this.aiDisplay.length,
	                            features = this.oFeatures,
	                            paginate = features.bPaginate;

	                        if (features.bServerSide) {
	                            return paginate === false || len === -1 ?
	                                start + records :
	                                Math.min(start + len, this._iRecordsDisplay);
	                        }
	                        else {
	                            return !paginate || calc > records || len === -1 ?
	                                records :
	                                calc;
	                        }
	                    },

	                    /**
	                     * The DataTables object for this table
	                     *  @type object
	                     *  @default null
	                     */
	                    "oInstance": null,

	                    /**
	                     * Unique identifier for each instance of the DataTables object. If there
	                     * is an ID on the table node, then it takes that value, otherwise an
	                     * incrementing internal counter is used.
	                     *  @type string
	                     *  @default null
	                     */
	                    "sInstance": null,

	                    /**
	                     * tabindex attribute value that is added to DataTables control elements, allowing
	                     * keyboard navigation of the table and its controls.
	                     */
	                    "iTabIndex": 0,

	                    /**
	                     * DIV container for the footer scrolling table if scrolling
	                     */
	                    "nScrollHead": null,

	                    /**
	                     * DIV container for the footer scrolling table if scrolling
	                     */
	                    "nScrollFoot": null,

	                    /**
	                     * Last applied sort
	                     *  @type array
	                     *  @default []
	                     */
	                    "aLastSort": [],

	                    /**
	                     * Stored plug-in instances
	                     *  @type object
	                     *  @default {}
	                     */
	                    "oPlugins": {}
	                };

	                /**
	                 * Extension object for DataTables that is used to provide all extension
	                 * options.
	                 *
	                 * Note that the `DataTable.ext` object is available through
	                 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
	                 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
	                 *  @namespace
	                 *  @extends DataTable.models.ext
	                 */


	                /**
	                 * DataTables extensions
	                 * 
	                 * This namespace acts as a collection area for plug-ins that can be used to
	                 * extend DataTables capabilities. Indeed many of the build in methods
	                 * use this method to provide their own capabilities (sorting methods for
	                 * example).
	                 *
	                 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
	                 * reasons
	                 *
	                 *  @namespace
	                 */
	                DataTable.ext = _ext = {
	                    /**
	                     * Buttons. For use with the Buttons extension for DataTables. This is
	                     * defined here so other extensions can define buttons regardless of load
	                     * order. It is _not_ used by DataTables core.
	                     *
	                     *  @type object
	                     *  @default {}
	                     */
	                    buttons: {},


	                    /**
	                     * Element class names
	                     *
	                     *  @type object
	                     *  @default {}
	                     */
	                    classes: {},


	                    /**
	                     * Error reporting.
	                     * 
	                     * How should DataTables report an error. Can take the value 'alert',
	                     * 'throw', 'none' or a function.
	                     *
	                     *  @type string|function
	                     *  @default alert
	                     */
	                    errMode: "alert",


	                    /**
	                     * Feature plug-ins.
	                     * 
	                     * This is an array of objects which describe the feature plug-ins that are
	                     * available to DataTables. These feature plug-ins are then available for
	                     * use through the `dom` initialisation option.
	                     * 
	                     * Each feature plug-in is described by an object which must have the
	                     * following properties:
	                     * 
	                     * * `fnInit` - function that is used to initialise the plug-in,
	                     * * `cFeature` - a character so the feature can be enabled by the `dom`
	                     *   instillation option. This is case sensitive.
	                     *
	                     * The `fnInit` function has the following input parameters:
	                     *
	                     * 1. `{object}` DataTables settings object: see
	                     *    {@link DataTable.models.oSettings}
	                     *
	                     * And the following return is expected:
	                     * 
	                     * * {node|null} The element which contains your feature. Note that the
	                     *   return may also be void if your plug-in does not require to inject any
	                     *   DOM elements into DataTables control (`dom`) - for example this might
	                     *   be useful when developing a plug-in which allows table control via
	                     *   keyboard entry
	                     *
	                     *  @type array
	                     *
	                     *  @example
	                     *    $.fn.dataTable.ext.features.push( {
	                     *      "fnInit": function( oSettings ) {
	                     *        return new TableTools( { "oDTSettings": oSettings } );
	                     *      },
	                     *      "cFeature": "T"
	                     *    } );
	                     */
	                    feature: [],


	                    /**
	                     * Row searching.
	                     * 
	                     * This method of searching is complimentary to the default type based
	                     * searching, and a lot more comprehensive as it allows you complete control
	                     * over the searching logic. Each element in this array is a function
	                     * (parameters described below) that is called for every row in the table,
	                     * and your logic decides if it should be included in the searching data set
	                     * or not.
	                     *
	                     * Searching functions have the following input parameters:
	                     *
	                     * 1. `{object}` DataTables settings object: see
	                     *    {@link DataTable.models.oSettings}
	                     * 2. `{array|object}` Data for the row to be processed (same as the
	                     *    original format that was passed in as the data source, or an array
	                     *    from a DOM data source
	                     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
	                     *    can be useful to retrieve the `TR` element if you need DOM interaction.
	                     *
	                     * And the following return is expected:
	                     *
	                     * * {boolean} Include the row in the searched result set (true) or not
	                     *   (false)
	                     *
	                     * Note that as with the main search ability in DataTables, technically this
	                     * is "filtering", since it is subtractive. However, for consistency in
	                     * naming we call it searching here.
	                     *
	                     *  @type array
	                     *  @default []
	                     *
	                     *  @example
	                     *    // The following example shows custom search being applied to the
	                     *    // fourth column (i.e. the data[3] index) based on two input values
	                     *    // from the end-user, matching the data in a certain range.
	                     *    $.fn.dataTable.ext.search.push(
	                     *      function( settings, data, dataIndex ) {
	                     *        var min = document.getElementById('min').value * 1;
	                     *        var max = document.getElementById('max').value * 1;
	                     *        var version = data[3] == "-" ? 0 : data[3]*1;
	                     *
	                     *        if ( min == "" && max == "" ) {
	                     *          return true;
	                     *        }
	                     *        else if ( min == "" && version < max ) {
	                     *          return true;
	                     *        }
	                     *        else if ( min < version && "" == max ) {
	                     *          return true;
	                     *        }
	                     *        else if ( min < version && version < max ) {
	                     *          return true;
	                     *        }
	                     *        return false;
	                     *      }
	                     *    );
	                     */
	                    search: [],


	                    /**
	                     * Selector extensions
	                     *
	                     * The `selector` option can be used to extend the options available for the
	                     * selector modifier options (`selector-modifier` object data type) that
	                     * each of the three built in selector types offer (row, column and cell +
	                     * their plural counterparts). For example the Select extension uses this
	                     * mechanism to provide an option to select only rows, columns and cells
	                     * that have been marked as selected by the end user (`{selected: true}`),
	                     * which can be used in conjunction with the existing built in selector
	                     * options.
	                     *
	                     * Each property is an array to which functions can be pushed. The functions
	                     * take three attributes:
	                     *
	                     * * Settings object for the host table
	                     * * Options object (`selector-modifier` object type)
	                     * * Array of selected item indexes
	                     *
	                     * The return is an array of the resulting item indexes after the custom
	                     * selector has been applied.
	                     *
	                     *  @type object
	                     */
	                    selector: {
	                        cell: [],
	                        column: [],
	                        row: []
	                    },


	                    /**
	                     * Internal functions, exposed for used in plug-ins.
	                     * 
	                     * Please note that you should not need to use the internal methods for
	                     * anything other than a plug-in (and even then, try to avoid if possible).
	                     * The internal function may change between releases.
	                     *
	                     *  @type object
	                     *  @default {}
	                     */
	                    internal: {},


	                    /**
	                     * Legacy configuration options. Enable and disable legacy options that
	                     * are available in DataTables.
	                     *
	                     *  @type object
	                     */
	                    legacy: {
	                        /**
	                         * Enable / disable DataTables 1.9 compatible server-side processing
	                         * requests
	                         *
	                         *  @type boolean
	                         *  @default null
	                         */
	                        ajax: null
	                    },


	                    /**
	                     * Pagination plug-in methods.
	                     * 
	                     * Each entry in this object is a function and defines which buttons should
	                     * be shown by the pagination rendering method that is used for the table:
	                     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
	                     * buttons are displayed in the document, while the functions here tell it
	                     * what buttons to display. This is done by returning an array of button
	                     * descriptions (what each button will do).
	                     *
	                     * Pagination types (the four built in options and any additional plug-in
	                     * options defined here) can be used through the `paginationType`
	                     * initialisation parameter.
	                     *
	                     * The functions defined take two parameters:
	                     *
	                     * 1. `{int} page` The current page index
	                     * 2. `{int} pages` The number of pages in the table
	                     *
	                     * Each function is expected to return an array where each element of the
	                     * array can be one of:
	                     *
	                     * * `first` - Jump to first page when activated
	                     * * `last` - Jump to last page when activated
	                     * * `previous` - Show previous page when activated
	                     * * `next` - Show next page when activated
	                     * * `{int}` - Show page of the index given
	                     * * `{array}` - A nested array containing the above elements to add a
	                     *   containing 'DIV' element (might be useful for styling).
	                     *
	                     * Note that DataTables v1.9- used this object slightly differently whereby
	                     * an object with two functions would be defined for each plug-in. That
	                     * ability is still supported by DataTables 1.10+ to provide backwards
	                     * compatibility, but this option of use is now decremented and no longer
	                     * documented in DataTables 1.10+.
	                     *
	                     *  @type object
	                     *  @default {}
	                     *
	                     *  @example
	                     *    // Show previous, next and current page buttons only
	                     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
	                     *      return [ 'previous', page, 'next' ];
	                     *    };
	                     */
	                    pager: {},


	                    renderer: {
	                        pageButton: {},
	                        header: {}
	                    },


	                    /**
	                     * Ordering plug-ins - custom data source
	                     * 
	                     * The extension options for ordering of data available here is complimentary
	                     * to the default type based ordering that DataTables typically uses. It
	                     * allows much greater control over the the data that is being used to
	                     * order a column, but is necessarily therefore more complex.
	                     * 
	                     * This type of ordering is useful if you want to do ordering based on data
	                     * live from the DOM (for example the contents of an 'input' element) rather
	                     * than just the static string that DataTables knows of.
	                     * 
	                     * The way these plug-ins work is that you create an array of the values you
	                     * wish to be ordering for the column in question and then return that
	                     * array. The data in the array much be in the index order of the rows in
	                     * the table (not the currently ordering order!). Which order data gathering
	                     * function is run here depends on the `dt-init columns.orderDataType`
	                     * parameter that is used for the column (if any).
	                     *
	                     * The functions defined take two parameters:
	                     *
	                     * 1. `{object}` DataTables settings object: see
	                     *    {@link DataTable.models.oSettings}
	                     * 2. `{int}` Target column index
	                     *
	                     * Each function is expected to return an array:
	                     *
	                     * * `{array}` Data for the column to be ordering upon
	                     *
	                     *  @type array
	                     *
	                     *  @example
	                     *    // Ordering using `input` node values
	                     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
	                     *    {
	                     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
	                     *        return $('input', td).val();
	                     *      } );
	                     *    }
	                     */
	                    order: {},


	                    /**
	                     * Type based plug-ins.
	                     *
	                     * Each column in DataTables has a type assigned to it, either by automatic
	                     * detection or by direct assignment using the `type` option for the column.
	                     * The type of a column will effect how it is ordering and search (plug-ins
	                     * can also make use of the column type if required).
	                     *
	                     * @namespace
	                     */
	                    type: {
	                        /**
	                         * Type detection functions.
	                         *
	                         * The functions defined in this object are used to automatically detect
	                         * a column's type, making initialisation of DataTables super easy, even
	                         * when complex data is in the table.
	                         *
	                         * The functions defined take two parameters:
	                         *
	                         *  1. `{*}` Data from the column cell to be analysed
	                         *  2. `{settings}` DataTables settings object. This can be used to
	                         *     perform context specific type detection - for example detection
	                         *     based on language settings such as using a comma for a decimal
	                         *     place. Generally speaking the options from the settings will not
	                         *     be required
	                         *
	                         * Each function is expected to return:
	                         *
	                         * * `{string|null}` Data type detected, or null if unknown (and thus
	                         *   pass it on to the other type detection functions.
	                         *
	                         *  @type array
	                         *
	                         *  @example
	                         *    // Currency type detection plug-in:
	                         *    $.fn.dataTable.ext.type.detect.push(
	                         *      function ( data, settings ) {
	                         *        // Check the numeric part
	                         *        if ( ! $.isNumeric( data.substring(1) ) ) {
	                         *          return null;
	                         *        }
	                         *
	                         *        // Check prefixed by currency
	                         *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
	                         *          return 'currency';
	                         *        }
	                         *        return null;
	                         *      }
	                         *    );
	                         */
	                        detect: [],


	                        /**
	                         * Type based search formatting.
	                         *
	                         * The type based searching functions can be used to pre-format the
	                         * data to be search on. For example, it can be used to strip HTML
	                         * tags or to de-format telephone numbers for numeric only searching.
	                         *
	                         * Note that is a search is not defined for a column of a given type,
	                         * no search formatting will be performed.
	                         * 
	                         * Pre-processing of searching data plug-ins - When you assign the sType
	                         * for a column (or have it automatically detected for you by DataTables
	                         * or a type detection plug-in), you will typically be using this for
	                         * custom sorting, but it can also be used to provide custom searching
	                         * by allowing you to pre-processing the data and returning the data in
	                         * the format that should be searched upon. This is done by adding
	                         * functions this object with a parameter name which matches the sType
	                         * for that target column. This is the corollary of <i>afnSortData</i>
	                         * for searching data.
	                         *
	                         * The functions defined take a single parameter:
	                         *
	                         *  1. `{*}` Data from the column cell to be prepared for searching
	                         *
	                         * Each function is expected to return:
	                         *
	                         * * `{string|null}` Formatted string that will be used for the searching.
	                         *
	                         *  @type object
	                         *  @default {}
	                         *
	                         *  @example
	                         *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
	                         *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
	                         *    }
	                         */
	                        search: {},


	                        /**
	                         * Type based ordering.
	                         *
	                         * The column type tells DataTables what ordering to apply to the table
	                         * when a column is sorted upon. The order for each type that is defined,
	                         * is defined by the functions available in this object.
	                         *
	                         * Each ordering option can be described by three properties added to
	                         * this object:
	                         *
	                         * * `{type}-pre` - Pre-formatting function
	                         * * `{type}-asc` - Ascending order function
	                         * * `{type}-desc` - Descending order function
	                         *
	                         * All three can be used together, only `{type}-pre` or only
	                         * `{type}-asc` and `{type}-desc` together. It is generally recommended
	                         * that only `{type}-pre` is used, as this provides the optimal
	                         * implementation in terms of speed, although the others are provided
	                         * for compatibility with existing Javascript sort functions.
	                         *
	                         * `{type}-pre`: Functions defined take a single parameter:
	                         *
	                         *  1. `{*}` Data from the column cell to be prepared for ordering
	                         *
	                         * And return:
	                         *
	                         * * `{*}` Data to be sorted upon
	                         *
	                         * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
	                         * functions, taking two parameters:
	                         *
	                         *  1. `{*}` Data to compare to the second parameter
	                         *  2. `{*}` Data to compare to the first parameter
	                         *
	                         * And returning:
	                         *
	                         * * `{*}` Ordering match: <0 if first parameter should be sorted lower
	                         *   than the second parameter, ===0 if the two parameters are equal and
	                         *   >0 if the first parameter should be sorted height than the second
	                         *   parameter.
	                         * 
	                         *  @type object
	                         *  @default {}
	                         *
	                         *  @example
	                         *    // Numeric ordering of formatted numbers with a pre-formatter
	                         *    $.extend( $.fn.dataTable.ext.type.order, {
	                         *      "string-pre": function(x) {
	                         *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
	                         *        return parseFloat( a );
	                         *      }
	                         *    } );
	                         *
	                         *  @example
	                         *    // Case-sensitive string ordering, with no pre-formatting method
	                         *    $.extend( $.fn.dataTable.ext.order, {
	                         *      "string-case-asc": function(x,y) {
	                         *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
	                         *      },
	                         *      "string-case-desc": function(x,y) {
	                         *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
	                         *      }
	                         *    } );
	                         */
	                        order: {}
	                    },

	                    /**
	                     * Unique DataTables instance counter
	                     *
	                     * @type int
	                     * @private
	                     */
	                    _unique: 0,


	                    //
	                    // Depreciated
	                    // The following properties are retained for backwards compatiblity only.
	                    // The should not be used in new projects and will be removed in a future
	                    // version
	                    //

	                    /**
	                     * Version check function.
	                     *  @type function
	                     *  @depreciated Since 1.10
	                     */
	                    fnVersionCheck: DataTable.fnVersionCheck,


	                    /**
	                     * Index for what 'this' index API functions should use
	                     *  @type int
	                     *  @deprecated Since v1.10
	                     */
	                    iApiIndex: 0,


	                    /**
	                     * jQuery UI class container
	                     *  @type object
	                     *  @deprecated Since v1.10
	                     */
	                    oJUIClasses: {},


	                    /**
	                     * Software version
	                     *  @type string
	                     *  @deprecated Since v1.10
	                     */
	                    sVersion: DataTable.version
	                };


	                //
	                // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
	                //
	                $.extend(_ext, {
	                    afnFiltering: _ext.search,
	                    aTypes: _ext.type.detect,
	                    ofnSearch: _ext.type.search,
	                    oSort: _ext.type.order,
	                    afnSortData: _ext.order,
	                    aoFeatures: _ext.feature,
	                    oApi: _ext.internal,
	                    oStdClasses: _ext.classes,
	                    oPagination: _ext.pager
	                });


	                $.extend(DataTable.ext.classes, {
	                    "sTable": "dataTable",
	                    "sNoFooter": "no-footer",

	                    /* Paging buttons */
	                    "sPageButton": "paginate_button",
	                    "sPageButtonActive": "current",
	                    "sPageButtonDisabled": "disabled",

	                    /* Striping classes */
	                    "sStripeOdd": "odd",
	                    "sStripeEven": "even",

	                    /* Empty row */
	                    "sRowEmpty": "dataTables_empty",

	                    /* Features */
	                    "sWrapper": "dataTables_wrapper",
	                    "sFilter": "dataTables_filter",
	                    "sInfo": "dataTables_info",
	                    "sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
	                    "sLength": "dataTables_length",
	                    "sProcessing": "dataTables_processing",

	                    /* Sorting */
	                    "sSortAsc": "sorting_asc",
	                    "sSortDesc": "sorting_desc",
	                    "sSortable": "sorting", /* Sortable in both directions */
	                    "sSortableAsc": "sorting_asc_disabled",
	                    "sSortableDesc": "sorting_desc_disabled",
	                    "sSortableNone": "sorting_disabled",
	                    "sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */

	                    /* Filtering */
	                    "sFilterInput": "",

	                    /* Page length */
	                    "sLengthSelect": "",

	                    /* Scrolling */
	                    "sScrollWrapper": "dataTables_scroll",
	                    "sScrollHead": "dataTables_scrollHead",
	                    "sScrollHeadInner": "dataTables_scrollHeadInner",
	                    "sScrollBody": "dataTables_scrollBody",
	                    "sScrollFoot": "dataTables_scrollFoot",
	                    "sScrollFootInner": "dataTables_scrollFootInner",

	                    /* Misc */
	                    "sHeaderTH": "",
	                    "sFooterTH": "",

	                    // Deprecated
	                    "sSortJUIAsc": "",
	                    "sSortJUIDesc": "",
	                    "sSortJUI": "",
	                    "sSortJUIAscAllowed": "",
	                    "sSortJUIDescAllowed": "",
	                    "sSortJUIWrapper": "",
	                    "sSortIcon": "",
	                    "sJUIHeader": "",
	                    "sJUIFooter": ""
	                });


	                (function () {

	                    // Reused strings for better compression. Closure compiler appears to have a
	                    // weird edge case where it is trying to expand strings rather than use the
	                    // variable version. This results in about 200 bytes being added, for very
	                    // little preference benefit since it this run on script load only.
	                    var _empty = '';
	                    _empty = '';

	                    var _stateDefault = _empty + 'ui-state-default';
	                    var _sortIcon = _empty + 'css_right ui-icon ui-icon-';
	                    var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';

	                    $.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {
	                        /* Full numbers paging buttons */
	                        "sPageButton": "fg-button ui-button " + _stateDefault,
	                        "sPageButtonActive": "ui-state-disabled",
	                        "sPageButtonDisabled": "ui-state-disabled",

	                        /* Features */
	                        "sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi " +
	                            "ui-buttonset-multi paging_", /* Note that the type is postfixed */

	                        /* Sorting */
	                        "sSortAsc": _stateDefault + " sorting_asc",
	                        "sSortDesc": _stateDefault + " sorting_desc",
	                        "sSortable": _stateDefault + " sorting",
	                        "sSortableAsc": _stateDefault + " sorting_asc_disabled",
	                        "sSortableDesc": _stateDefault + " sorting_desc_disabled",
	                        "sSortableNone": _stateDefault + " sorting_disabled",
	                        "sSortJUIAsc": _sortIcon + "triangle-1-n",
	                        "sSortJUIDesc": _sortIcon + "triangle-1-s",
	                        "sSortJUI": _sortIcon + "carat-2-n-s",
	                        "sSortJUIAscAllowed": _sortIcon + "carat-1-n",
	                        "sSortJUIDescAllowed": _sortIcon + "carat-1-s",
	                        "sSortJUIWrapper": "DataTables_sort_wrapper",
	                        "sSortIcon": "DataTables_sort_icon",

	                        /* Scrolling */
	                        "sScrollHead": "dataTables_scrollHead " + _stateDefault,
	                        "sScrollFoot": "dataTables_scrollFoot " + _stateDefault,

	                        /* Misc */
	                        "sHeaderTH": _stateDefault,
	                        "sFooterTH": _stateDefault,
	                        "sJUIHeader": _headerFooter + " ui-corner-tl ui-corner-tr",
	                        "sJUIFooter": _headerFooter + " ui-corner-bl ui-corner-br"
	                    });

	                }());



	                var extPagination = DataTable.ext.pager;

	                function _numbers(page, pages) {
	                    var
	                        numbers = [],
	                        buttons = extPagination.numbers_length,
	                        half = Math.floor(buttons / 2),
	                        i = 1;

	                    if (pages <= buttons) {
	                        numbers = _range(0, pages);
	                    }
	                    else if (page <= half) {
	                        numbers = _range(0, buttons - 2);
	                        numbers.push('ellipsis');
	                        numbers.push(pages - 1);
	                    }
	                    else if (page >= pages - 1 - half) {
	                        numbers = _range(pages - (buttons - 2), pages);
	                        numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6
	                        numbers.splice(0, 0, 0);
	                    }
	                    else {
	                        numbers = _range(page - half + 2, page + half - 1);
	                        numbers.push('ellipsis');
	                        numbers.push(pages - 1);
	                        numbers.splice(0, 0, 'ellipsis');
	                        numbers.splice(0, 0, 0);
	                    }

	                    numbers.DT_el = 'span';
	                    return numbers;
	                }


	                $.extend(extPagination, {
	                    simple: function (page, pages) {
	                        return ['previous', 'next'];
	                    },

	                    full: function (page, pages) {
	                        return ['first', 'previous', 'next', 'last'];
	                    },

	                    simple_numbers: function (page, pages) {
	                        return ['previous', _numbers(page, pages), 'next'];
	                    },

	                    full_numbers: function (page, pages) {
	                        return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
	                    },

	                    // For testing and plug-ins to use
	                    _numbers: _numbers,

	                    // Number of number buttons (including ellipsis) to show. _Must be odd!_
	                    numbers_length: 7
	                });


	                $.extend(true, DataTable.ext.renderer, {
	                    pageButton: {
	                        _: function (settings, host, idx, buttons, page, pages) {
	                            var classes = settings.oClasses;
	                            var lang = settings.oLanguage.oPaginate;
	                            var btnDisplay, btnClass, counter = 0;

	                            var attach = function (container, buttons) {
	                                var i, ien, node, button;
	                                var clickHandler = function (e) {
	                                    _fnPageChange(settings, e.data.action, true);
	                                };

	                                for (i = 0, ien = buttons.length ; i < ien ; i++) {
	                                    button = buttons[i];

	                                    if ($.isArray(button)) {
	                                        var inner = $('<' + (button.DT_el || 'div') + '/>')
	                                            .appendTo(container);
	                                        attach(inner, button);
	                                    }
	                                    else {
	                                        btnDisplay = '';
	                                        btnClass = '';

	                                        switch (button) {
	                                            case 'ellipsis':
	                                                container.append('<span class="ellipsis">&#x2026;</span>');
	                                                break;

	                                            case 'first':
	                                                btnDisplay = lang.sFirst;
	                                                btnClass = button + (page > 0 ?
	                                                    '' : ' ' + classes.sPageButtonDisabled);
	                                                break;

	                                            case 'previous':
	                                                btnDisplay = lang.sPrevious;
	                                                btnClass = button + (page > 0 ?
	                                                    '' : ' ' + classes.sPageButtonDisabled);
	                                                break;

	                                            case 'next':
	                                                btnDisplay = lang.sNext;
	                                                btnClass = button + (page < pages - 1 ?
	                                                    '' : ' ' + classes.sPageButtonDisabled);
	                                                break;

	                                            case 'last':
	                                                btnDisplay = lang.sLast;
	                                                btnClass = button + (page < pages - 1 ?
	                                                    '' : ' ' + classes.sPageButtonDisabled);
	                                                break;

	                                            default:
	                                                btnDisplay = button + 1;
	                                                btnClass = page === button ?
	                                                    classes.sPageButtonActive : '';
	                                                break;
	                                        }

	                                        if (btnDisplay) {
	                                            node = $('<a>', {
	                                                'class': classes.sPageButton + ' ' + btnClass,
	                                                'aria-controls': settings.sTableId,
	                                                'data-dt-idx': counter,
	                                                'tabindex': settings.iTabIndex,
	                                                'id': idx === 0 && typeof button === 'string' ?
	                                                    settings.sTableId + '_' + button :
	                                                    null
	                                            })
	                                                .html(btnDisplay)
	                                                .appendTo(container);

	                                            _fnBindAction(
	                                                node, { action: button }, clickHandler
	                                            );

	                                            counter++;
	                                        }
	                                    }
	                                }
	                            };

	                            // IE9 throws an 'unknown error' if document.activeElement is used
	                            // inside an iframe or frame. Try / catch the error. Not good for
	                            // accessibility, but neither are frames.
	                            var activeEl;

	                            try {
	                                // Because this approach is destroying and recreating the paging
	                                // elements, focus is lost on the select button which is bad for
	                                // accessibility. So we want to restore focus once the draw has
	                                // completed
	                                activeEl = $(document.activeElement).data('dt-idx');
	                            }
	                            catch (e) { }

	                            attach($(host).empty(), buttons);

	                            if (activeEl) {
	                                $(host).find('[data-dt-idx=' + activeEl + ']').focus();
	                            }
	                        }
	                    }
	                });



	                // Built in type detection. See model.ext.aTypes for information about
	                // what is required from this methods.
	                $.extend(DataTable.ext.type.detect, [
	                    // Plain numbers - first since V8 detects some plain numbers as dates
	                    // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
	                    function (d, settings) {
	                        var decimal = settings.oLanguage.sDecimal;
	                        return _isNumber(d, decimal) ? 'num' + decimal : null;
	                    },

	                    // Dates (only those recognised by the browser's Date.parse)
	                    function (d, settings) {
	                        // V8 will remove any unknown characters at the start and end of the
	                        // expression, leading to false matches such as `$245.12` or `10%` being
	                        // a valid date. See forum thread 18941 for detail.
	                        if (d && !(d instanceof Date) && (!_re_date_start.test(d) || !_re_date_end.test(d))) {
	                            return null;
	                        }
	                        var parsed = Date.parse(d);
	                        return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
	                    },

	                    // Formatted numbers
	                    function (d, settings) {
	                        var decimal = settings.oLanguage.sDecimal;
	                        return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
	                    },

	                    // HTML numeric
	                    function (d, settings) {
	                        var decimal = settings.oLanguage.sDecimal;
	                        return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
	                    },

	                    // HTML numeric, formatted
	                    function (d, settings) {
	                        var decimal = settings.oLanguage.sDecimal;
	                        return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
	                    },

	                    // HTML (this is strict checking - there must be html)
	                    function (d, settings) {
	                        return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
	                            'html' : null;
	                    }
	                ]);



	                // Filter formatting functions. See model.ext.ofnSearch for information about
	                // what is required from these methods.
	                // 
	                // Note that additional search methods are added for the html numbers and
	                // html formatted numbers by `_addNumericSort()` when we know what the decimal
	                // place is


	                $.extend(DataTable.ext.type.search, {
	                    html: function (data) {
	                        return _empty(data) ?
	                            data :
	                            typeof data === 'string' ?
	                                data
	                                    .replace(_re_new_lines, " ")
	                                    .replace(_re_html, "") :
	                                '';
	                    },

	                    string: function (data) {
	                        return _empty(data) ?
	                            data :
	                            typeof data === 'string' ?
	                                data.replace(_re_new_lines, " ") :
	                                data;
	                    }
	                });



	                var __numericReplace = function (d, decimalPlace, re1, re2) {
	                    if (d !== 0 && (!d || d === '-')) {
	                        return -Infinity;
	                    }

	                    // If a decimal place other than `.` is used, it needs to be given to the
	                    // function so we can detect it and replace with a `.` which is the only
	                    // decimal place Javascript recognises - it is not locale aware.
	                    if (decimalPlace) {
	                        d = _numToDecimal(d, decimalPlace);
	                    }

	                    if (d.replace) {
	                        if (re1) {
	                            d = d.replace(re1, '');
	                        }

	                        if (re2) {
	                            d = d.replace(re2, '');
	                        }
	                    }

	                    return d * 1;
	                };


	                // Add the numeric 'deformatting' functions for sorting and search. This is done
	                // in a function to provide an easy ability for the language options to add
	                // additional methods if a non-period decimal place is used.
	                function _addNumericSort(decimalPlace) {
	                    $.each(
	                        {
	                            // Plain numbers
	                            "num": function (d) {
	                                return __numericReplace(d, decimalPlace);
	                            },

	                            // Formatted numbers
	                            "num-fmt": function (d) {
	                                return __numericReplace(d, decimalPlace, _re_formatted_numeric);
	                            },

	                            // HTML numeric
	                            "html-num": function (d) {
	                                return __numericReplace(d, decimalPlace, _re_html);
	                            },

	                            // HTML numeric, formatted
	                            "html-num-fmt": function (d) {
	                                return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
	                            }
	                        },
	                        function (key, fn) {
	                            // Add the ordering method
	                            _ext.type.order[key + decimalPlace + '-pre'] = fn;

	                            // For HTML types add a search formatter that will strip the HTML
	                            if (key.match(/^html\-/)) {
	                                _ext.type.search[key + decimalPlace] = _ext.type.search.html;
	                            }
	                        }
	                    );
	                }


	                // Default sort methods
	                $.extend(_ext.type.order, {
	                    // Dates
	                    "date-pre": function (d) {
	                        return Date.parse(d) || 0;
	                    },

	                    // html
	                    "html-pre": function (a) {
	                        return _empty(a) ?
	                            '' :
	                            a.replace ?
	                                a.replace(/<.*?>/g, "").toLowerCase() :
	                                a + '';
	                    },

	                    // string
	                    "string-pre": function (a) {
	                        // This is a little complex, but faster than always calling toString,
	                        // http://jsperf.com/tostring-v-check
	                        return _empty(a) ?
	                            '' :
	                            typeof a === 'string' ?
	                                a.toLowerCase() :
	                                !a.toString ?
	                                    '' :
	                                    a.toString();
	                    },

	                    // string-asc and -desc are retained only for compatibility with the old
	                    // sort methods
	                    "string-asc": function (x, y) {
	                        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
	                    },

	                    "string-desc": function (x, y) {
	                        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
	                    }
	                });


	                // Numeric sorting types - order doesn't matter here
	                _addNumericSort('');


	                $.extend(true, DataTable.ext.renderer, {
	                    header: {
	                        _: function (settings, cell, column, classes) {
	                            // No additional mark-up required
	                            // Attach a sort listener to update on sort - note that using the
	                            // `DT` namespace will allow the event to be removed automatically
	                            // on destroy, while the `dt` namespaced event is the one we are
	                            // listening for
	                            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
	                                if (settings !== ctx) { // need to check this this is the host
	                                    return;               // table, not a nested one
	                                }

	                                var colIdx = column.idx;

	                                cell
	                                    .removeClass(
	                                        column.sSortingClass + ' ' +
	                                        classes.sSortAsc + ' ' +
	                                        classes.sSortDesc
	                                    )
	                                    .addClass(columns[colIdx] == 'asc' ?
	                                        classes.sSortAsc : columns[colIdx] == 'desc' ?
	                                            classes.sSortDesc :
	                                            column.sSortingClass
	                                    );
	                            });
	                        },

	                        jqueryui: function (settings, cell, column, classes) {
	                            $('<div/>')
	                                .addClass(classes.sSortJUIWrapper)
	                                .append(cell.contents())
	                                .append($('<span/>')
	                                    .addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)
	                                )
	                                .appendTo(cell);

	                            // Attach a sort listener to update on sort
	                            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
	                                if (settings !== ctx) {
	                                    return;
	                                }

	                                var colIdx = column.idx;

	                                cell
	                                    .removeClass(classes.sSortAsc + " " + classes.sSortDesc)
	                                    .addClass(columns[colIdx] == 'asc' ?
	                                        classes.sSortAsc : columns[colIdx] == 'desc' ?
	                                            classes.sSortDesc :
	                                            column.sSortingClass
	                                    );

	                                cell
	                                    .find('span.' + classes.sSortIcon)
	                                    .removeClass(
	                                        classes.sSortJUIAsc + " " +
	                                        classes.sSortJUIDesc + " " +
	                                        classes.sSortJUI + " " +
	                                        classes.sSortJUIAscAllowed + " " +
	                                        classes.sSortJUIDescAllowed
	                                    )
	                                    .addClass(columns[colIdx] == 'asc' ?
	                                        classes.sSortJUIAsc : columns[colIdx] == 'desc' ?
	                                            classes.sSortJUIDesc :
	                                            column.sSortingClassJUI
	                                    );
	                            });
	                        }
	                    }
	                });

	                /*
	                 * Public helper functions. These aren't used internally by DataTables, or
	                 * called by any of the options passed into DataTables, but they can be used
	                 * externally by developers working with DataTables. They are helper functions
	                 * to make working with DataTables a little bit easier.
	                 */

	                /**
	                 * Helpers for `columns.render`.
	                 *
	                 * The options defined here can be used with the `columns.render` initialisation
	                 * option to provide a display renderer. The following functions are defined:
	                 *
	                 * * `number` - Will format numeric data (defined by `columns.data`) for
	                 *   display, retaining the original unformatted data for sorting and filtering.
	                 *   It takes 4 parameters:
	                 *   * `string` - Thousands grouping separator
	                 *   * `string` - Decimal point indicator
	                 *   * `integer` - Number of decimal points to show
	                 *   * `string` (optional) - Prefix.
	                 *
	                 * @example
	                 *   // Column definition using the number renderer
	                 *   {
	                 *     data: "salary",
	                 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
	                 *   }
	                 *
	                 * @namespace
	                 */
	                DataTable.render = {
	                    number: function (thousands, decimal, precision, prefix) {
	                        return {
	                            display: function (d) {
	                                if (typeof d !== 'number' && typeof d !== 'string') {
	                                    return d;
	                                }

	                                var negative = d < 0 ? '-' : '';
	                                d = Math.abs(parseFloat(d));

	                                var intPart = parseInt(d, 10);
	                                var floatPart = precision ?
	                                    decimal + (d - intPart).toFixed(precision).substring(2) :
	                                    '';

	                                return negative + (prefix || '') +
	                                    intPart.toString().replace(
	                                        /\B(?=(\d{3})+(?!\d))/g, thousands
	                                    ) +
	                                    floatPart;
	                            }
	                        };
	                    }
	                };


	                /*
	                 * This is really a good bit rubbish this method of exposing the internal methods
	                 * publicly... - To be fixed in 2.0 using methods on the prototype
	                 */


	                /**
	                 * Create a wrapper function for exporting an internal functions to an external API.
	                 *  @param {string} fn API function name
	                 *  @returns {function} wrapped function
	                 *  @memberof DataTable#internal
	                 */
	                function _fnExternApiFunc(fn) {
	                    return function () {
	                        var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
	                            Array.prototype.slice.call(arguments)
	                        );
	                        return DataTable.ext.internal[fn].apply(this, args);
	                    };
	                }


	                /**
	                 * Reference to internal functions for use by plug-in developers. Note that
	                 * these methods are references to internal functions and are considered to be
	                 * private. If you use these methods, be aware that they are liable to change
	                 * between versions.
	                 *  @namespace
	                 */
	                $.extend(DataTable.ext.internal, {
	                    _fnExternApiFunc: _fnExternApiFunc,
	                    _fnBuildAjax: _fnBuildAjax,
	                    _fnAjaxUpdate: _fnAjaxUpdate,
	                    _fnAjaxParameters: _fnAjaxParameters,
	                    _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
	                    _fnAjaxDataSrc: _fnAjaxDataSrc,
	                    _fnAddColumn: _fnAddColumn,
	                    _fnColumnOptions: _fnColumnOptions,
	                    _fnAdjustColumnSizing: _fnAdjustColumnSizing,
	                    _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
	                    _fnColumnIndexToVisible: _fnColumnIndexToVisible,
	                    _fnVisbleColumns: _fnVisbleColumns,
	                    _fnGetColumns: _fnGetColumns,
	                    _fnColumnTypes: _fnColumnTypes,
	                    _fnApplyColumnDefs: _fnApplyColumnDefs,
	                    _fnHungarianMap: _fnHungarianMap,
	                    _fnCamelToHungarian: _fnCamelToHungarian,
	                    _fnLanguageCompat: _fnLanguageCompat,
	                    _fnBrowserDetect: _fnBrowserDetect,
	                    _fnAddData: _fnAddData,
	                    _fnAddTr: _fnAddTr,
	                    _fnNodeToDataIndex: _fnNodeToDataIndex,
	                    _fnNodeToColumnIndex: _fnNodeToColumnIndex,
	                    _fnGetCellData: _fnGetCellData,
	                    _fnSetCellData: _fnSetCellData,
	                    _fnSplitObjNotation: _fnSplitObjNotation,
	                    _fnGetObjectDataFn: _fnGetObjectDataFn,
	                    _fnSetObjectDataFn: _fnSetObjectDataFn,
	                    _fnGetDataMaster: _fnGetDataMaster,
	                    _fnClearTable: _fnClearTable,
	                    _fnDeleteIndex: _fnDeleteIndex,
	                    _fnInvalidate: _fnInvalidate,
	                    _fnGetRowElements: _fnGetRowElements,
	                    _fnCreateTr: _fnCreateTr,
	                    _fnBuildHead: _fnBuildHead,
	                    _fnDrawHead: _fnDrawHead,
	                    _fnDraw: _fnDraw,
	                    _fnReDraw: _fnReDraw,
	                    _fnAddOptionsHtml: _fnAddOptionsHtml,
	                    _fnDetectHeader: _fnDetectHeader,
	                    _fnGetUniqueThs: _fnGetUniqueThs,
	                    _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
	                    _fnFilterComplete: _fnFilterComplete,
	                    _fnFilterCustom: _fnFilterCustom,
	                    _fnFilterColumn: _fnFilterColumn,
	                    _fnFilter: _fnFilter,
	                    _fnFilterCreateSearch: _fnFilterCreateSearch,
	                    _fnEscapeRegex: _fnEscapeRegex,
	                    _fnFilterData: _fnFilterData,
	                    _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
	                    _fnUpdateInfo: _fnUpdateInfo,
	                    _fnInfoMacros: _fnInfoMacros,
	                    _fnInitialise: _fnInitialise,
	                    _fnInitComplete: _fnInitComplete,
	                    _fnLengthChange: _fnLengthChange,
	                    _fnFeatureHtmlLength: _fnFeatureHtmlLength,
	                    _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
	                    _fnPageChange: _fnPageChange,
	                    _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
	                    _fnProcessingDisplay: _fnProcessingDisplay,
	                    _fnFeatureHtmlTable: _fnFeatureHtmlTable,
	                    _fnScrollDraw: _fnScrollDraw,
	                    _fnApplyToChildren: _fnApplyToChildren,
	                    _fnCalculateColumnWidths: _fnCalculateColumnWidths,
	                    _fnThrottle: _fnThrottle,
	                    _fnConvertToWidth: _fnConvertToWidth,
	                    _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,
	                    _fnGetWidestNode: _fnGetWidestNode,
	                    _fnGetMaxLenString: _fnGetMaxLenString,
	                    _fnStringToCss: _fnStringToCss,
	                    _fnScrollBarWidth: _fnScrollBarWidth,
	                    _fnSortFlatten: _fnSortFlatten,
	                    _fnSort: _fnSort,
	                    _fnSortAria: _fnSortAria,
	                    _fnSortListener: _fnSortListener,
	                    _fnSortAttachListener: _fnSortAttachListener,
	                    _fnSortingClasses: _fnSortingClasses,
	                    _fnSortData: _fnSortData,
	                    _fnSaveState: _fnSaveState,
	                    _fnLoadState: _fnLoadState,
	                    _fnSettingsFromNode: _fnSettingsFromNode,
	                    _fnLog: _fnLog,
	                    _fnMap: _fnMap,
	                    _fnBindAction: _fnBindAction,
	                    _fnCallbackReg: _fnCallbackReg,
	                    _fnCallbackFire: _fnCallbackFire,
	                    _fnLengthOverflow: _fnLengthOverflow,
	                    _fnRenderer: _fnRenderer,
	                    _fnDataSource: _fnDataSource,
	                    _fnRowAttributes: _fnRowAttributes,
	                    _fnCalculateEnd: function () { } // Used by a lot of plug-ins, but redundant
	                    // in 1.10, so this dead-end function is
	                    // added to prevent errors
	                });


	                // jQuery access
	                $.fn.dataTable = DataTable;

	                // Legacy aliases
	                $.fn.dataTableSettings = DataTable.settings;
	                $.fn.dataTableExt = DataTable.ext;

	                // With a capital `D` we return a DataTables API instance rather than a
	                // jQuery object
	                $.fn.DataTable = function (opts) {
	                    return $(this).dataTable(opts).api();
	                };

	                // All properties that are available to $.fn.dataTable should also be
	                // available on $.fn.DataTable
	                $.each(DataTable, function (prop, val) {
	                    $.fn.DataTable[prop] = val;
	                });


	                // Information about events fired by DataTables - for documentation.
	                /**
	                 * Draw event, fired whenever the table is redrawn on the page, at the same
	                 * point as fnDrawCallback. This may be useful for binding events or
	                 * performing calculations when the table is altered at all.
	                 *  @name DataTable#draw.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Search event, fired when the searching applied to the table (using the
	                 * built-in global search, or column filters) is altered.
	                 *  @name DataTable#search.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Page change event, fired when the paging of the table is altered.
	                 *  @name DataTable#page.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Order event, fired when the ordering applied to the table is altered.
	                 *  @name DataTable#order.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * DataTables initialisation complete event, fired when the table is fully
	                 * drawn, including Ajax data loaded, if Ajax data is required.
	                 *  @name DataTable#init.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {object} json The JSON object request from the server - only
	                 *    present if client-side Ajax sourced data is used</li></ol>
	                 */

	                /**
	                 * State save event, fired when the table has changed state a new state save
	                 * is required. This event allows modification of the state saving object
	                 * prior to actually doing the save, including addition or other state
	                 * properties (for plug-ins) or modification of a DataTables core property.
	                 *  @name DataTable#stateSaveParams.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {object} json The state information to be saved
	                 */

	                /**
	                 * State load event, fired when the table is loading state from the stored
	                 * data, but prior to the settings object being modified by the saved state
	                 * - allowing modification of the saved state is required or loading of
	                 * state for a plug-in.
	                 *  @name DataTable#stateLoadParams.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {object} json The saved state information
	                 */

	                /**
	                 * State loaded event, fired when state has been loaded from stored data and
	                 * the settings object has been modified by the loaded data.
	                 *  @name DataTable#stateLoaded.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {object} json The saved state information
	                 */

	                /**
	                 * Processing event, fired when DataTables is doing some kind of processing
	                 * (be it, order, searcg or anything else). It can be used to indicate to
	                 * the end user that there is something happening, or that something has
	                 * finished.
	                 *  @name DataTable#processing.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
	                 */

	                /**
	                 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
	                 * request to made to the server for new data. This event is called before
	                 * DataTables processed the returned data, so it can also be used to pre-
	                 * process the data returned from the server, if needed.
	                 *
	                 * Note that this trigger is called in `fnServerData`, if you override
	                 * `fnServerData` and which to use this event, you need to trigger it in you
	                 * success function.
	                 *  @name DataTable#xhr.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 *  @param {object} json JSON returned from the server
	                 *
	                 *  @example
	                 *     // Use a custom property returned from the server in another DOM element
	                 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	                 *       $('#status').html( json.status );
	                 *     } );
	                 *
	                 *  @example
	                 *     // Pre-process the data returned from the server
	                 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	                 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
	                 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
	                 *       }
	                 *       // Note no return - manipulate the data directly in the JSON object.
	                 *     } );
	                 */

	                /**
	                 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
	                 * or passing the bDestroy:true parameter in the initialisation object. This
	                 * can be used to remove bound events, added DOM nodes, etc.
	                 *  @name DataTable#destroy.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Page length change event, fired when number of records to show on each
	                 * page (the length) is changed.
	                 *  @name DataTable#length.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 *  @param {integer} len New length
	                 */

	                /**
	                 * Column sizing has changed.
	                 *  @name DataTable#column-sizing.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Column visibility has changed.
	                 *  @name DataTable#column-visibility.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 *  @param {int} column Column index
	                 *  @param {bool} vis `false` if column now hidden, or `true` if visible
	                 */

	                return $.fn.dataTable;
	            }));

	        }(window, document));
	               
	    },
	    RunDataTable: function (CSSidselector) {

	        this.jqueryTableInit();

	        $(CSSidselector).DataTable({
	            "language": svlanguageSettings
	        });

	    }
	}

	let svlanguageSettings = {
	    "sEmptyTable": "Tabellen inneh" + String.fromCharCode(229) + "ller ingen data",
	    "sInfo": "Visar _START_ till _END_ av totalt _TOTAL_ rader",
	    "sInfoEmpty": "Visar 0 till 0 av totalt 0 rader",
	    "sInfoFiltered": "(filtrerade fr" + String.fromCharCode(229) + "n totalt _MAX_ rader)",
	    "sInfoPostFix": "",
	    "sInfoThousands": " ",
	    "sLengthMenu": "Visa _MENU_ rader",
	    "sLoadingRecords": "Laddar...",
	    "sProcessing": "Bearbetar...",
	    "sSearch": "S" + String.fromCharCode(246) + "k:",
	    "sZeroRecords": "Hittade inga matchande resultat",
	    "oPaginate": {
	        "sFirst": "F" + String.fromCharCode(246) + "rsta",
	        "sLast": "Sista",
	        "sNext": "N" + String.fromCharCode(228) + "sta",
	        "sPrevious": "F" + String.fromCharCode(246) + "reg" + String.fromCharCode(229) + "ende"
	    },
	    "oAria": {
	        "sSortAscending": ": aktivera f" + String.fromCharCode(246) + "r att sortera kolumnen i stigande ordning",
	        "sSortDescending": ": aktivera f" + String.fromCharCode(246) + "r att sortera kolumnen i fallande ordning"
	    }
	};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	let fillobj = __webpack_require__(5);
	let servicecall = __webpack_require__(9);
	let $ = __webpack_require__(2);

	module.exports = {
	    init: function () {
	        this.cacheDom();
	        this.bindEvent();
	        this.render();
	    },
	    cacheDom: function () {
	        this.$body = $('body');
	        this.$bb_aj_approve = $(".bb_aj_approve");
	        this.$bb_aj_modalContainer = $("#bb_aj_modalContainer");
	    },
	    bindEvent: function (userid) {
	        let that = this;
	        this.$body.on('click', '.bb_aj_approve', function (e) {
	            let id = $(this).attr('data-tipid');
	            fillobj.getCurrentItem(id);
	            that.$bb_aj_modalContainer.show();
	            return false;
	        });

	        this.$body.on('click', '.bb_aj_delete', function (e) {
	            let id = $(this).attr('data-tipid');
	            fillobj.deleteitemBox(id);
	            that.$bb_aj_modalContainer.show();
	            return false;
	        });
	       
	        this.$body.on('change', '.bb_aj_valtboktips', function (e) {
	            let id = $(this).attr('data-tipid');
	            let val = 0;
	            
	            if (this.checked) {
	               val = 1;               
	            }
	            if (servicecall.approvetip(id, val)) {
	                console.log("approved json");
	            };

	            $(this).val(this.checked); 
	            return false;
	        });

	        this.$body.on('click', '#bb_aj_SaveEditToServer', function (e) {
	            let id = $(this).attr('data-tipid');                        
	            let rub = $("#bb_aj_cur_title").val();

	            fillobj.saveitemBox(id,rub);
	            that.$bb_aj_modalContainer.show();
	            
	            return false;
	        });
	               
	        this.$body.on('click', '.bb_aj_closeModal', function (e) {
	            that.$bb_aj_modalContainer.hide();
	            return false;
	        });
	                
	    },
	    render: function () {

	    }
	}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	let _hh = __webpack_require__(6)
	let edt = __webpack_require__(7);
	let appsettingsobject = __webpack_require__(8);
	let appsettings = appsettingsobject.config;

	module.exports = {
	    
	    getCurrentItem: function (id) {
	        let _currentobj = appsettings.dataset.currentdatalist;

	        let currobj = _currentobj.Boktips.filter(item => item.TipID == id);
	                
	        _hh.injecthtmltemplate("#bb_aj_modalContainer", appsettings.handlebartemplate.hb_editor_tmp, currobj, function () {
	            edt.remove();
	            edt.init("#bb_aj_modalbody");
	                       
	            return true;
	        });             
	    },
	    saveitemBox: function (tipid, rub) {
	        let obj = { "TipID": tipid, "rubrik": rub};

	        _hh.injecthtmltemplate("#bb_aj_modalContainer", appsettings.handlebartemplate.hb_savebox_tmp, obj, function () {
	            return true;
	        });
	    },
	    deleteitemBox: function (tipid) {
	        let obj = { "TipID": tipid };

	        _hh.injecthtmltemplate("#bb_aj_modalContainer", appsettings.handlebartemplate.hb_delbox_tmp, obj, function () {            
	            return true;
	        });    
	    },
	    editcontent: function () {
	        //edt.activeEditor.getContent('');
	    },

	} //end moduleexport


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(2);

	module.exports = {
	    injecthtmltemplate: function (targetClass, usetemplateName, currentdata, callback) {
	        
	        $.get(usetemplateName, function (data) {
	            var temptpl = Handlebars.compile(data);
	            $(targetClass).html(temptpl(currentdata));
	            callback();
	        }, 'html');
	    }
	}

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	
	module.exports = {
	    _editorn: tinyMCE,
	    init: function (CSSidselector) {
	                   
	        this._editorn.init({
	            selector: CSSidselector,
	            menubar: false,
	            toolbar: 'undo redo | styleselect | bold italic | link image'
	        });

	    },//end init
	    remove: function () {
	        this._editorn.remove();
	    },
	    clear: function () {
	        this._editorn.activeEditor.setContent('');
	    },
	    setcontent: function (content) {
	        this._editorn.activeEditor.setContent(content);
	    }
	} //end moduleexport

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	
	module.exports = {
	    config: (function () {
	        //let _apiserver = "http://localhost:59015";
	        //let _dnnURL = "http://localdev.kivdev.se";
	        //let _apiserver = "http://dev1.barnensbibliotek.se:8080";
	        //let _dnnURL = "http://dev1.barnensbibliotek.se";
	        //let _apiserver = "http://dev1.barnensbibliotek.se:8080";
	        //let _dnnURL = "http://nytt.barnensbibliotek.se";
	        let _apiserver = "https://www2.barnensbibliotek.se";
	        let _dnnURL = "https://www.barnensbibliotek.se";
	        let _devkey = "alf";
	        let _apidevkeyend = "/devkey/" + _devkey + "/?type=jsonp&callback=?";
	        let _htmltemplateURL = "/DesktopModules/bb_aj_Boktips_Admin/template/";        
	        let _currentdatalist;
	        //// template
	        
	        let _hb_booktipList_template = _htmltemplateURL + "template_datatableRow.txt";   
	        let _hb_editor_template = _htmltemplateURL + "template_editor.txt"; 
	        let _hb_savebox_template = _htmltemplateURL + "template_save.txt";
	        let _hb_deletebox_template = _htmltemplateURL + "template_tabort.txt";
	        
	        // anvndarens senaste boktips
	        let _fn_booktipList = function (userid) {
	            return _apiserver + "/Api_v1/boktips/bylatest/1/devkey/" + _devkey + "/?type=json";
	        }
	        let _fn_booktipSave = function () {
	            return _apiserver + "/Api_v3.1/boktips/typ/editboktips/devkey/" + _devkey + "/?type=jsonp";
	        }
	        let _fn_booktipDelete = function () {            
	            return _apiserver + "/Api_v3.1/boktips/typ/deleteboktips/devkey/" + _devkey + "/?type=json";
	        }
	        let _fn_booktipApprove = function (tipid, val) {
	            return _apiserver + "/Api_v3.1/boktips/typ/approve/val/" + tipid + "/txtval/" + val + "/devkey/" + _devkey + "/?type=json";
	        }
	        let _fn_booktipListToAprove = function () {
	            return _apiserver + "/Api_v3.1/boktips/typ/toapprove/val/0/txtval/0/devkey/" + _devkey + "/?type=json";
	        }
	        let _fn_booktipListAll = function () {
	            return _apiserver + "/Api_v3.1/boktips/typ/getall/val/0/txtval/0/devkey/" + _devkey + "/?type=json";
	        }
	           
	        return {
	            apiserver: _apiserver,
	            dnnURL: _dnnURL,
	            htmltemplateurl: _dnnURL + _htmltemplateURL,
	            devkey: _devkey,
	            handlebartemplate: {
	                hb_booktipList_tmp: _hb_booktipList_template,
	                hb_editor_tmp: _hb_editor_template,
	                hb_savebox_tmp: _hb_savebox_template,
	                hb_delbox_tmp: _hb_deletebox_template
	            },
	            api: {                
	                boktipslistor: {
	                    getboktipslistToApprove: _fn_booktipListToAprove,
	                    getboktipslistAll: _fn_booktipListAll
	                },
	                approve: _fn_booktipApprove,
	                save: _fn_booktipSave,
	                delete: _fn_booktipDelete,
	                autocomplete: {
	                    geturl: ""
	                },                
	                devkeyend: _apidevkeyend
	            },
	            dataset: {
	                currentdatalist:  _currentdatalist
	            },

	            debug: "false"
	        }
	    })(),
	    
	}



/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	let _service_old = __webpack_require__(10);
	let _service = __webpack_require__(11);
	let appsettingsobject = __webpack_require__(8);
	let appsettings = appsettingsobject.config;

	module.exports = {
	    approvetip: function (tipid, val) {
	        let jsondatapromise = _service.getjsondata(appsettings.api.approve(tipid, val));

	        jsondatapromise
	            .then(jsondata => { return true; })
	            .catch(err => false);
	    },
	    deletetip: function (tipid, callback) {
	        let dataopt = {           
	            "TipID": tipid
	        }

	        _service_old.postjsondata(appsettings.api.delete(), dataopt, function (data) {
	            callback(data);
	        });      

	    },
	    savetip: function (tipid, rubrik, content, callback) {
	        let dataopt = {
	            "TipID": tipid,
	            "Title": rubrik,            
	            "Review": content  
	        }

	        _service_old.postjsondata(appsettings.api.save(), dataopt, function (data) {
	            callback(data);
	        });

	    }
	}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(2);

	module.exports = {
	    getjsondata: function (url, callback) {
	        if (!url) {
	            return false;
	        } else {
	            //console.log("Searchservicen hmtar Arrangemangdata");
	            $.ajax({
	                async: true,
	                type: "get",
	                dataType: 'jsonp',
	                url: url,
	                success: function (data) {
	                    console.log("Search Detalj arrangemang hmtat: ");
	                    callback(data);
	                },
	                error: function (xhr, ajaxOptions, thrownError) {
	                    alert("Ntt blev fel vid hmtning av arrangemang!");
	                }
	            })
	        };
	    },
	    postjsondata: function (url, postdata, callback) {
	        if (!url) {
	            return false;
	        } else {
	            //console.log("Searchservicen hmtar Arrangemangdata");
	            $.ajax({
	                async: true,

	                type: "post",
	                url: url,
	                data: postdata,
	                success: function (data) {
	                    console.log("Hmtar Data: ");
	                    callback(data);
	                },
	                error: function (xhr, ajaxOptions, thrownError) {
	                    alert("Ntt blev fel vid hmtning av POST json!");
	                }
	            })
	        };
	    }
	}

/***/ }),
/* 11 */
/***/ (function(module, exports) {

	
	module.exports = {
	    getjsondata: function (url) {
	        return fetch(url)
	            .then(res => res.json())
	            .then(jsondata => jsondata)
	            
	    },
	    postjsondata: function (url, postdata) {

	        const option = {
	            method: 'POST', 
	            mode:"no-cors",
	            body: JSON.stringify(postdata),
	            headers: {
	                "Content-Type": "application/json"
	            }

	        }
	        return fetch(url, option)
	            .then(res => res.json())
	            .then(jsondata => jsondata)

	    },
	    fetchjsonpdata: function (url, postdata) {
	        //postdata= { data: medskick, merdata: mera }
	        const option = {
	            method: 'POST',
	            header: 'application/json',
	            body: JSON.stringify(postdata)

	        }
	        return fetch(url, option)
	            .then(res => res.responseText())
	            .then(jsonText => JSON.parse(jsonText))

	    }
	}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	
	let appsettingsobject = __webpack_require__(8);
	let appsettings = appsettingsobject.config;

	module.exports = {
	    init: function () {

	        Handlebars.registerHelper('checkapproved', function (Approve) {                        
	            if (Approve==1) {
	               return  "checked";
	            };            
	        });

	       
	    }
	}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhhbmRsZWJhcnMuanMiLCJhal9iYl9ib2t0aXBzYWRtaW5fS3J5cGluYnVuZGxlV2VicGFjay4xLjAuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2dUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJhal9iYl9ib2t0aXBzYWRtaW5fYnVuZGxlLjEuMC4wLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIVxyXG5BTkRSRUFTIEhBTkRMRUJBUlNcclxuIEBsaWNlbnNlXHJcbiBoYW5kbGViYXJzIHY0LjAuMTBcclxuXHJcbkNvcHlyaWdodCAoQykgMjAxMS0yMDE2IGJ5IFllaHVkYSBLYXR6XHJcblxyXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xyXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxyXG5cclxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcblRIRSBTT0ZUV0FSRS5cclxuXHJcbiovXHJcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG5cdFx0ZXhwb3J0c1tcIkhhbmRsZWJhcnNcIl0gPSBmYWN0b3J5KCk7XHJcblx0ZWxzZVxyXG5cdFx0cm9vdFtcIkhhbmRsZWJhcnNcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xyXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcCBBTkRSRUFTIEhBTkRMRUJBUlNcclxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcclxuXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcblxyXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXHJcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcblxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXHJcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxyXG4vKioqKioqLyBcdFx0fTtcclxuXHJcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG5cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xyXG5cclxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0fVxyXG5cclxuXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xyXG5cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcblxyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuXHJcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNSdW50aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzUnVudGltZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzUnVudGltZSk7XHJcblxyXG5cdC8vIENvbXBpbGVyIGltcG9ydHNcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQ29tcGlsZXJBc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQ29tcGlsZXJBc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFuZGxlYmFyc0NvbXBpbGVyQXN0KTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQ29tcGlsZXJCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0NvbXBpbGVyQ29tcGlsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQ29tcGlsZXJKYXZhc2NyaXB0Q29tcGlsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQ29tcGlsZXJKYXZhc2NyaXB0Q29tcGlsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFuZGxlYmFyc0NvbXBpbGVySmF2YXNjcmlwdENvbXBpbGVyKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQ29tcGlsZXJWaXNpdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0NvbXBpbGVyVmlzaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzQ29tcGlsZXJWaXNpdG9yKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzTm9Db25mbGljdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNOb0NvbmZsaWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNOb0NvbmZsaWN0KTtcclxuXHJcblx0dmFyIF9jcmVhdGUgPSBfaGFuZGxlYmFyc1J1bnRpbWUyWydkZWZhdWx0J10uY3JlYXRlO1xyXG5cdGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuXHQgIHZhciBoYiA9IF9jcmVhdGUoKTtcclxuXHJcblx0ICBoYi5jb21waWxlID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XHJcblx0ICAgIHJldHVybiBfaGFuZGxlYmFyc0NvbXBpbGVyQ29tcGlsZXIuY29tcGlsZShpbnB1dCwgb3B0aW9ucywgaGIpO1xyXG5cdCAgfTtcclxuXHQgIGhiLnByZWNvbXBpbGUgPSBmdW5jdGlvbiAoaW5wdXQsIG9wdGlvbnMpIHtcclxuXHQgICAgcmV0dXJuIF9oYW5kbGViYXJzQ29tcGlsZXJDb21waWxlci5wcmVjb21waWxlKGlucHV0LCBvcHRpb25zLCBoYik7XHJcblx0ICB9O1xyXG5cclxuXHQgIGhiLkFTVCA9IF9oYW5kbGViYXJzQ29tcGlsZXJBc3QyWydkZWZhdWx0J107XHJcblx0ICBoYi5Db21waWxlciA9IF9oYW5kbGViYXJzQ29tcGlsZXJDb21waWxlci5Db21waWxlcjtcclxuXHQgIGhiLkphdmFTY3JpcHRDb21waWxlciA9IF9oYW5kbGViYXJzQ29tcGlsZXJKYXZhc2NyaXB0Q29tcGlsZXIyWydkZWZhdWx0J107XHJcblx0ICBoYi5QYXJzZXIgPSBfaGFuZGxlYmFyc0NvbXBpbGVyQmFzZS5wYXJzZXI7XHJcblx0ICBoYi5wYXJzZSA9IF9oYW5kbGViYXJzQ29tcGlsZXJCYXNlLnBhcnNlO1xyXG5cclxuXHQgIHJldHVybiBoYjtcclxuXHR9XHJcblxyXG5cdHZhciBpbnN0ID0gY3JlYXRlKCk7XHJcblx0aW5zdC5jcmVhdGUgPSBjcmVhdGU7XHJcblxyXG5cdF9oYW5kbGViYXJzTm9Db25mbGljdDJbJ2RlZmF1bHQnXShpbnN0KTtcclxuXHJcblx0aW5zdC5WaXNpdG9yID0gX2hhbmRsZWJhcnNDb21waWxlclZpc2l0b3IyWydkZWZhdWx0J107XHJcblxyXG5cdGluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGluc3Q7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHRleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZ1bmN0aW9uIChvYmopIHtcclxuXHQgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XHJcblx0ICAgIFwiZGVmYXVsdFwiOiBvYmpcclxuXHQgIH07XHJcblx0fTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpWydkZWZhdWx0J107XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHJcblx0dmFyIGJhc2UgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaGFuZGxlYmFyc0Jhc2UpO1xyXG5cclxuXHQvLyBFYWNoIG9mIHRoZXNlIGF1Z21lbnQgdGhlIEhhbmRsZWJhcnMgb2JqZWN0LiBObyBuZWVkIHRvIHNldHVwIGhlcmUuXHJcblx0Ly8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzU2FmZVN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNTYWZlU3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNTYWZlU3RyaW5nKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzRXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzRXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNFeGNlcHRpb24pO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNVdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9oYW5kbGViYXJzVXRpbHMpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNSdW50aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcblxyXG5cdHZhciBydW50aW1lID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2hhbmRsZWJhcnNSdW50aW1lKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzTm9Db25mbGljdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNOb0NvbmZsaWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNOb0NvbmZsaWN0KTtcclxuXHJcblx0Ly8gRm9yIGNvbXBhdGliaWxpdHkgYW5kIHVzYWdlIG91dHNpZGUgb2YgbW9kdWxlIHN5c3RlbXMsIG1ha2UgdGhlIEhhbmRsZWJhcnMgb2JqZWN0IGEgbmFtZXNwYWNlXHJcblx0ZnVuY3Rpb24gY3JlYXRlKCkge1xyXG5cdCAgdmFyIGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XHJcblxyXG5cdCAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcclxuXHQgIGhiLlNhZmVTdHJpbmcgPSBfaGFuZGxlYmFyc1NhZmVTdHJpbmcyWydkZWZhdWx0J107XHJcblx0ICBoYi5FeGNlcHRpb24gPSBfaGFuZGxlYmFyc0V4Y2VwdGlvbjJbJ2RlZmF1bHQnXTtcclxuXHQgIGhiLlV0aWxzID0gVXRpbHM7XHJcblx0ICBoYi5lc2NhcGVFeHByZXNzaW9uID0gVXRpbHMuZXNjYXBlRXhwcmVzc2lvbjtcclxuXHJcblx0ICBoYi5WTSA9IHJ1bnRpbWU7XHJcblx0ICBoYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChzcGVjKSB7XHJcblx0ICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcclxuXHQgIH07XHJcblxyXG5cdCAgcmV0dXJuIGhiO1xyXG5cdH1cclxuXHJcblx0dmFyIGluc3QgPSBjcmVhdGUoKTtcclxuXHRpbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcclxuXHJcblx0X2hhbmRsZWJhcnNOb0NvbmZsaWN0MlsnZGVmYXVsdCddKGluc3QpO1xyXG5cclxuXHRpbnN0WydkZWZhdWx0J10gPSBpbnN0O1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBpbnN0O1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0ICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XHJcblx0ICAgIHJldHVybiBvYmo7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICB2YXIgbmV3T2JqID0ge307XHJcblxyXG5cdCAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcblx0ICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XHJcblx0ICAgIHJldHVybiBuZXdPYmo7XHJcblx0ICB9XHJcblx0fTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLkhhbmRsZWJhcnNFbnZpcm9ubWVudCA9IEhhbmRsZWJhcnNFbnZpcm9ubWVudDtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblxyXG5cdHZhciBfZGVjb3JhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG5cclxuXHR2YXIgX2xvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG5cclxuXHR2YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xyXG5cclxuXHR2YXIgVkVSU0lPTiA9ICc0LjAuMTAnO1xyXG5cdGV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XHJcblx0dmFyIENPTVBJTEVSX1JFVklTSU9OID0gNztcclxuXHJcblx0ZXhwb3J0cy5DT01QSUxFUl9SRVZJU0lPTiA9IENPTVBJTEVSX1JFVklTSU9OO1xyXG5cdHZhciBSRVZJU0lPTl9DSEFOR0VTID0ge1xyXG5cdCAgMTogJzw9IDEuMC5yYy4yJywgLy8gMS4wLnJjLjIgaXMgYWN0dWFsbHkgcmV2MiBidXQgZG9lc24ndCByZXBvcnQgaXRcclxuXHQgIDI6ICc9PSAxLjAuMC1yYy4zJyxcclxuXHQgIDM6ICc9PSAxLjAuMC1yYy40JyxcclxuXHQgIDQ6ICc9PSAxLngueCcsXHJcblx0ICA1OiAnPT0gMi4wLjAtYWxwaGEueCcsXHJcblx0ICA2OiAnPj0gMi4wLjAtYmV0YS4xJyxcclxuXHQgIDc6ICc+PSA0LjAuMCdcclxuXHR9O1xyXG5cclxuXHRleHBvcnRzLlJFVklTSU9OX0NIQU5HRVMgPSBSRVZJU0lPTl9DSEFOR0VTO1xyXG5cdHZhciBvYmplY3RUeXBlID0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcblxyXG5cdGZ1bmN0aW9uIEhhbmRsZWJhcnNFbnZpcm9ubWVudChoZWxwZXJzLCBwYXJ0aWFscywgZGVjb3JhdG9ycykge1xyXG5cdCAgdGhpcy5oZWxwZXJzID0gaGVscGVycyB8fCB7fTtcclxuXHQgIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcclxuXHQgIHRoaXMuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMgfHwge307XHJcblxyXG5cdCAgX2hlbHBlcnMucmVnaXN0ZXJEZWZhdWx0SGVscGVycyh0aGlzKTtcclxuXHQgIF9kZWNvcmF0b3JzLnJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnModGhpcyk7XHJcblx0fVxyXG5cclxuXHRIYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xyXG5cdCAgY29uc3RydWN0b3I6IEhhbmRsZWJhcnNFbnZpcm9ubWVudCxcclxuXHJcblx0ICBsb2dnZXI6IF9sb2dnZXIyWydkZWZhdWx0J10sXHJcblx0ICBsb2c6IF9sb2dnZXIyWydkZWZhdWx0J10ubG9nLFxyXG5cclxuXHQgIHJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbiByZWdpc3RlckhlbHBlcihuYW1lLCBmbikge1xyXG5cdCAgICBpZiAoX3V0aWxzLnRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcclxuXHQgICAgICBpZiAoZm4pIHtcclxuXHQgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGhlbHBlcnMnKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgX3V0aWxzLmV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMuaGVscGVyc1tuYW1lXSA9IGZuO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgdW5yZWdpc3RlckhlbHBlcjogZnVuY3Rpb24gdW5yZWdpc3RlckhlbHBlcihuYW1lKSB7XHJcblx0ICAgIGRlbGV0ZSB0aGlzLmhlbHBlcnNbbmFtZV07XHJcblx0ICB9LFxyXG5cclxuXHQgIHJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24gcmVnaXN0ZXJQYXJ0aWFsKG5hbWUsIHBhcnRpYWwpIHtcclxuXHQgICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XHJcblx0ICAgICAgX3V0aWxzLmV4dGVuZCh0aGlzLnBhcnRpYWxzLCBuYW1lKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBpZiAodHlwZW9mIHBhcnRpYWwgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHBhcnRpYWwgY2FsbGVkIFwiJyArIG5hbWUgKyAnXCIgYXMgdW5kZWZpbmVkJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHRoaXMucGFydGlhbHNbbmFtZV0gPSBwYXJ0aWFsO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgdW5yZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uIHVucmVnaXN0ZXJQYXJ0aWFsKG5hbWUpIHtcclxuXHQgICAgZGVsZXRlIHRoaXMucGFydGlhbHNbbmFtZV07XHJcblx0ICB9LFxyXG5cclxuXHQgIHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbiByZWdpc3RlckRlY29yYXRvcihuYW1lLCBmbikge1xyXG5cdCAgICBpZiAoX3V0aWxzLnRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcclxuXHQgICAgICBpZiAoZm4pIHtcclxuXHQgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGRlY29yYXRvcnMnKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgX3V0aWxzLmV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMuZGVjb3JhdG9yc1tuYW1lXSA9IGZuO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgdW5yZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gdW5yZWdpc3RlckRlY29yYXRvcihuYW1lKSB7XHJcblx0ICAgIGRlbGV0ZSB0aGlzLmRlY29yYXRvcnNbbmFtZV07XHJcblx0ICB9XHJcblx0fTtcclxuXHJcblx0dmFyIGxvZyA9IF9sb2dnZXIyWydkZWZhdWx0J10ubG9nO1xyXG5cclxuXHRleHBvcnRzLmxvZyA9IGxvZztcclxuXHRleHBvcnRzLmNyZWF0ZUZyYW1lID0gX3V0aWxzLmNyZWF0ZUZyYW1lO1xyXG5cdGV4cG9ydHMubG9nZ2VyID0gX2xvZ2dlcjJbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xyXG5cdGV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XHJcblx0ZXhwb3J0cy5lc2NhcGVFeHByZXNzaW9uID0gZXNjYXBlRXhwcmVzc2lvbjtcclxuXHRleHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xyXG5cdGV4cG9ydHMuY3JlYXRlRnJhbWUgPSBjcmVhdGVGcmFtZTtcclxuXHRleHBvcnRzLmJsb2NrUGFyYW1zID0gYmxvY2tQYXJhbXM7XHJcblx0ZXhwb3J0cy5hcHBlbmRDb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoO1xyXG5cdHZhciBlc2NhcGUgPSB7XHJcblx0ICAnJic6ICcmYW1wOycsXHJcblx0ICAnPCc6ICcmbHQ7JyxcclxuXHQgICc+JzogJyZndDsnLFxyXG5cdCAgJ1wiJzogJyZxdW90OycsXHJcblx0ICBcIidcIjogJyYjeDI3OycsXHJcblx0ICAnYCc6ICcmI3g2MDsnLFxyXG5cdCAgJz0nOiAnJiN4M0Q7J1xyXG5cdH07XHJcblxyXG5cdHZhciBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXHJcblx0ICAgIHBvc3NpYmxlID0gL1smPD5cIidgPV0vO1xyXG5cclxuXHRmdW5jdGlvbiBlc2NhcGVDaGFyKGNocikge1xyXG5cdCAgcmV0dXJuIGVzY2FwZVtjaHJdO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZXh0ZW5kKG9iaiAvKiAsIC4uLnNvdXJjZSAqLykge1xyXG5cdCAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgZm9yICh2YXIga2V5IGluIGFyZ3VtZW50c1tpXSkge1xyXG5cdCAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJndW1lbnRzW2ldLCBrZXkpKSB7XHJcblx0ICAgICAgICBvYmpba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIHJldHVybiBvYmo7XHJcblx0fVxyXG5cclxuXHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuXHRleHBvcnRzLnRvU3RyaW5nID0gdG9TdHJpbmc7XHJcblx0Ly8gU291cmNlZCBmcm9tIGxvZGFzaFxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHRcclxuXHQvKiBlc2xpbnQtZGlzYWJsZSBmdW5jLXN0eWxlICovXHJcblx0dmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XHJcblx0ICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG5cdH07XHJcblx0Ly8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXHJcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHRpZiAoaXNGdW5jdGlvbigveC8pKSB7XHJcblx0ICBleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XHJcblx0ICB9O1xyXG5cdH1cclxuXHRleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xyXG5cclxuXHQvKiBlc2xpbnQtZW5hYmxlIGZ1bmMtc3R5bGUgKi9cclxuXHJcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XHJcblx0ICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nIDogZmFsc2U7XHJcblx0fTtcclxuXHJcblx0ZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcclxuXHQvLyBPbGRlciBJRSB2ZXJzaW9ucyBkbyBub3QgZGlyZWN0bHkgc3VwcG9ydCBpbmRleE9mIHNvIHdlIG11c3QgaW1wbGVtZW50IG91ciBvd24sIHNhZGx5LlxyXG5cclxuXHRmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xyXG5cdCAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcclxuXHQgICAgICByZXR1cm4gaTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIC0xO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcclxuXHQgIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xyXG5cdCAgICAvLyBkb24ndCBlc2NhcGUgU2FmZVN0cmluZ3MsIHNpbmNlIHRoZXkncmUgYWxyZWFkeSBzYWZlXHJcblx0ICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xyXG5cdCAgICAgIHJldHVybiBzdHJpbmcudG9IVE1MKCk7XHJcblx0ICAgIH0gZWxzZSBpZiAoc3RyaW5nID09IG51bGwpIHtcclxuXHQgICAgICByZXR1cm4gJyc7XHJcblx0ICAgIH0gZWxzZSBpZiAoIXN0cmluZykge1xyXG5cdCAgICAgIHJldHVybiBzdHJpbmcgKyAnJztcclxuXHQgICAgfVxyXG5cclxuXHQgICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXHJcblx0ICAgIC8vIHRoZSByZWdleCB0ZXN0IHdpbGwgZG8gdGhpcyB0cmFuc3BhcmVudGx5IGJlaGluZCB0aGUgc2NlbmVzLCBjYXVzaW5nIGlzc3VlcyBpZlxyXG5cdCAgICAvLyBhbiBvYmplY3QncyB0byBzdHJpbmcgaGFzIGVzY2FwZWQgY2hhcmFjdGVycyBpbiBpdC5cclxuXHQgICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHtcclxuXHQgICAgcmV0dXJuIHN0cmluZztcclxuXHQgIH1cclxuXHQgIHJldHVybiBzdHJpbmcucmVwbGFjZShiYWRDaGFycywgZXNjYXBlQ2hhcik7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XHJcblx0ICBpZiAoIXZhbHVlICYmIHZhbHVlICE9PSAwKSB7XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICByZXR1cm4gZmFsc2U7XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVGcmFtZShvYmplY3QpIHtcclxuXHQgIHZhciBmcmFtZSA9IGV4dGVuZCh7fSwgb2JqZWN0KTtcclxuXHQgIGZyYW1lLl9wYXJlbnQgPSBvYmplY3Q7XHJcblx0ICByZXR1cm4gZnJhbWU7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBibG9ja1BhcmFtcyhwYXJhbXMsIGlkcykge1xyXG5cdCAgcGFyYW1zLnBhdGggPSBpZHM7XHJcblx0ICByZXR1cm4gcGFyYW1zO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYXBwZW5kQ29udGV4dFBhdGgoY29udGV4dFBhdGgsIGlkKSB7XHJcblx0ICByZXR1cm4gKGNvbnRleHRQYXRoID8gY29udGV4dFBhdGggKyAnLicgOiAnJykgKyBpZDtcclxuXHR9XHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBlcnJvclByb3BzID0gWydkZXNjcmlwdGlvbicsICdmaWxlTmFtZScsICdsaW5lTnVtYmVyJywgJ21lc3NhZ2UnLCAnbmFtZScsICdudW1iZXInLCAnc3RhY2snXTtcclxuXHJcblx0ZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UsIG5vZGUpIHtcclxuXHQgIHZhciBsb2MgPSBub2RlICYmIG5vZGUubG9jLFxyXG5cdCAgICAgIGxpbmUgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgY29sdW1uID0gdW5kZWZpbmVkO1xyXG5cdCAgaWYgKGxvYykge1xyXG5cdCAgICBsaW5lID0gbG9jLnN0YXJ0LmxpbmU7XHJcblx0ICAgIGNvbHVtbiA9IGxvYy5zdGFydC5jb2x1bW47XHJcblxyXG5cdCAgICBtZXNzYWdlICs9ICcgLSAnICsgbGluZSArICc6JyArIGNvbHVtbjtcclxuXHQgIH1cclxuXHJcblx0ICB2YXIgdG1wID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbWVzc2FnZSk7XHJcblxyXG5cdCAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXHJcblx0ICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBlcnJvclByb3BzLmxlbmd0aDsgaWR4KyspIHtcclxuXHQgICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XHJcblx0ICB9XHJcblxyXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG5cdCAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFeGNlcHRpb24pO1xyXG5cdCAgfVxyXG5cclxuXHQgIHRyeSB7XHJcblx0ICAgIGlmIChsb2MpIHtcclxuXHQgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lO1xyXG5cclxuXHQgICAgICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSB1bmRlciBzYWZhcmkgd2hlcmUgd2UgY2FuJ3QgZGlyZWN0bHkgc2V0IHRoZSBjb2x1bW4gdmFsdWVcclxuXHQgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICAgIGlmIChfT2JqZWN0JGRlZmluZVByb3BlcnR5KSB7XHJcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbHVtbicsIHtcclxuXHQgICAgICAgICAgdmFsdWU6IGNvbHVtbixcclxuXHQgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSBjYXRjaCAobm9wKSB7XHJcblx0ICAgIC8qIElnbm9yZSBpZiB0aGUgYnJvd3NlciBpcyB2ZXJ5IHBhcnRpY3VsYXIgKi9cclxuXHQgIH1cclxuXHR9XHJcblxyXG5cdEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gRXhjZXB0aW9uO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oOCksIF9fZXNNb2R1bGU6IHRydWUgfTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XHJcblx0ICByZXR1cm4gJC5zZXREZXNjKGl0LCBrZXksIGRlc2MpO1xyXG5cdH07XHJcblxyXG4vKioqLyB9KSxcclxuLyogOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdHZhciAkT2JqZWN0ID0gT2JqZWN0O1xyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgY3JlYXRlOiAgICAgJE9iamVjdC5jcmVhdGUsXHJcblx0ICBnZXRQcm90bzogICAkT2JqZWN0LmdldFByb3RvdHlwZU9mLFxyXG5cdCAgaXNFbnVtOiAgICAge30ucHJvcGVydHlJc0VudW1lcmFibGUsXHJcblx0ICBnZXREZXNjOiAgICAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcclxuXHQgIHNldERlc2M6ICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHksXHJcblx0ICBzZXREZXNjczogICAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMsXHJcblx0ICBnZXRLZXlzOiAgICAkT2JqZWN0LmtleXMsXHJcblx0ICBnZXROYW1lczogICAkT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXHJcblx0ICBnZXRTeW1ib2xzOiAkT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcclxuXHQgIGVhY2g6ICAgICAgIFtdLmZvckVhY2hcclxuXHR9O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMgPSByZWdpc3RlckRlZmF1bHRIZWxwZXJzO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblxyXG5cdHZhciBfaGVscGVyc0VhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc0VhY2gpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNIZWxwZXJNaXNzaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblxyXG5cdHZhciBfaGVscGVyc0hlbHBlck1pc3NpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc0hlbHBlck1pc3NpbmcpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNJZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNJZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzSWYpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNMb2cgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxuXHJcblx0dmFyIF9oZWxwZXJzTG9nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNMb2cpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNMb29rdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuXHJcblx0dmFyIF9oZWxwZXJzTG9va3VwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNMb29rdXApO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNXaXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcblxyXG5cdHZhciBfaGVscGVyc1dpdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc1dpdGgpO1xyXG5cclxuXHRmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XHJcblx0ICBfaGVscGVyc0Jsb2NrSGVscGVyTWlzc2luZzJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XHJcblx0ICBfaGVscGVyc0VhY2gyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xyXG5cdCAgX2hlbHBlcnNIZWxwZXJNaXNzaW5nMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzSWYyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xyXG5cdCAgX2hlbHBlcnNMb2cyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xyXG5cdCAgX2hlbHBlcnNMb29rdXAyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xyXG5cdCAgX2hlbHBlcnNXaXRoMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHR9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdibG9ja0hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbiAoY29udGV4dCwgb3B0aW9ucykge1xyXG5cdCAgICB2YXIgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcclxuXHQgICAgICAgIGZuID0gb3B0aW9ucy5mbjtcclxuXHJcblx0ICAgIGlmIChjb250ZXh0ID09PSB0cnVlKSB7XHJcblx0ICAgICAgcmV0dXJuIGZuKHRoaXMpO1xyXG5cdCAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGZhbHNlIHx8IGNvbnRleHQgPT0gbnVsbCkge1xyXG5cdCAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xyXG5cdCAgICB9IGVsc2UgaWYgKF91dGlscy5pc0FycmF5KGNvbnRleHQpKSB7XHJcblx0ICAgICAgaWYgKGNvbnRleHQubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XHJcblx0ICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgcmV0dXJuIGluc3RhbmNlLmhlbHBlcnMuZWFjaChjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcclxuXHQgICAgICAgIHZhciBkYXRhID0gX3V0aWxzLmNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XHJcblx0ICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5uYW1lKTtcclxuXHQgICAgICAgIG9wdGlvbnMgPSB7IGRhdGE6IGRhdGEgfTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdlYWNoJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcclxuXHQgICAgaWYgKCFvcHRpb25zKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgZm4gPSBvcHRpb25zLmZuLFxyXG5cdCAgICAgICAgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcclxuXHQgICAgICAgIGkgPSAwLFxyXG5cdCAgICAgICAgcmV0ID0gJycsXHJcblx0ICAgICAgICBkYXRhID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgY29udGV4dFBhdGggPSB1bmRlZmluZWQ7XHJcblxyXG5cdCAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XHJcblx0ICAgICAgY29udGV4dFBhdGggPSBfdXRpbHMuYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSkgKyAnLic7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmIChfdXRpbHMuaXNGdW5jdGlvbihjb250ZXh0KSkge1xyXG5cdCAgICAgIGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmIChvcHRpb25zLmRhdGEpIHtcclxuXHQgICAgICBkYXRhID0gX3V0aWxzLmNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XHJcblx0ICAgICAgaWYgKGRhdGEpIHtcclxuXHQgICAgICAgIGRhdGEua2V5ID0gZmllbGQ7XHJcblx0ICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XHJcblx0ICAgICAgICBkYXRhLmZpcnN0ID0gaW5kZXggPT09IDA7XHJcblx0ICAgICAgICBkYXRhLmxhc3QgPSAhIWxhc3Q7XHJcblxyXG5cdCAgICAgICAgaWYgKGNvbnRleHRQYXRoKSB7XHJcblx0ICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGZpZWxkO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtmaWVsZF0sIHtcclxuXHQgICAgICAgIGRhdGE6IGRhdGEsXHJcblx0ICAgICAgICBibG9ja1BhcmFtczogX3V0aWxzLmJsb2NrUGFyYW1zKFtjb250ZXh0W2ZpZWxkXSwgZmllbGRdLCBbY29udGV4dFBhdGggKyBmaWVsZCwgbnVsbF0pXHJcblx0ICAgICAgfSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmIChjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xyXG5cdCAgICAgIGlmIChfdXRpbHMuaXNBcnJheShjb250ZXh0KSkge1xyXG5cdCAgICAgICAgZm9yICh2YXIgaiA9IGNvbnRleHQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0ICAgICAgICAgIGlmIChpIGluIGNvbnRleHQpIHtcclxuXHQgICAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdmFyIHByaW9yS2V5ID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0KSB7XHJcblx0ICAgICAgICAgIGlmIChjb250ZXh0Lmhhc093blByb3BlcnR5KGtleSkpIHtcclxuXHQgICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcclxuXHQgICAgICAgICAgICAvLyB0aGUgbGFzdCBpdGVyYXRpb24gd2l0aG91dCBoYXZlIHRvIHNjYW4gdGhlIG9iamVjdCB0d2ljZSBhbmQgY3JlYXRlXHJcblx0ICAgICAgICAgICAgLy8gYW4gaXRlcm1lZGlhdGUga2V5cyBhcnJheS5cclxuXHQgICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihwcmlvcktleSwgaSAtIDEpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBwcmlvcktleSA9IGtleTtcclxuXHQgICAgICAgICAgICBpKys7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGlmIChwcmlvcktleSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxLCB0cnVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmIChpID09PSAwKSB7XHJcblx0ICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH0pO1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdoZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24gKCkgLyogW2FyZ3MsIF1vcHRpb25zICove1xyXG5cdCAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdCAgICAgIC8vIEEgbWlzc2luZyBmaWVsZCBpbiBhIHt7Zm9vfX0gY29uc3RydWN0LlxyXG5cdCAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgLy8gU29tZW9uZSBpcyBhY3R1YWxseSB0cnlpbmcgdG8gY2FsbCBzb21ldGhpbmcsIGJsb3cgdXAuXHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uIChjb25kaXRpb25hbCwgb3B0aW9ucykge1xyXG5cdCAgICBpZiAoX3V0aWxzLmlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7XHJcblx0ICAgICAgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5jYWxsKHRoaXMpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHJlbmRlciB0aGUgcG9zaXRpdmUgcGF0aCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IGFuZCBub3QgZW1wdHkuXHJcblx0ICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXHJcblx0ICAgIC8vIGJlaGF2aW9yIG9mIGlzRW1wdHkuIEVmZmVjdGl2ZWx5IHRoaXMgZGV0ZXJtaW5lcyBpZiAwIGlzIGhhbmRsZWQgYnkgdGhlIHBvc2l0aXZlIHBhdGggb3IgbmVnYXRpdmUuXHJcblx0ICAgIGlmICghb3B0aW9ucy5oYXNoLmluY2x1ZGVaZXJvICYmICFjb25kaXRpb25hbCB8fCBfdXRpbHMuaXNFbXB0eShjb25kaXRpb25hbCkpIHtcclxuXHQgICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiBvcHRpb25zLmZuKHRoaXMpO1xyXG5cdCAgICB9XHJcblx0ICB9KTtcclxuXHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24gKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XHJcblx0ICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzWydpZiddLmNhbGwodGhpcywgY29uZGl0aW9uYWwsIHsgZm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNoIH0pO1xyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uICgpIC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi97XHJcblx0ICAgIHZhciBhcmdzID0gW3VuZGVmaW5lZF0sXHJcblx0ICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblx0ICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBsZXZlbCA9IDE7XHJcblx0ICAgIGlmIChvcHRpb25zLmhhc2gubGV2ZWwgIT0gbnVsbCkge1xyXG5cdCAgICAgIGxldmVsID0gb3B0aW9ucy5oYXNoLmxldmVsO1xyXG5cdCAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xyXG5cdCAgICAgIGxldmVsID0gb3B0aW9ucy5kYXRhLmxldmVsO1xyXG5cdCAgICB9XHJcblx0ICAgIGFyZ3NbMF0gPSBsZXZlbDtcclxuXHJcblx0ICAgIGluc3RhbmNlLmxvZy5hcHBseShpbnN0YW5jZSwgYXJncyk7XHJcblx0ICB9KTtcclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9va3VwJywgZnVuY3Rpb24gKG9iaiwgZmllbGQpIHtcclxuXHQgICAgcmV0dXJuIG9iaiAmJiBvYmpbZmllbGRdO1xyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcclxuXHQgICAgaWYgKF91dGlscy5pc0Z1bmN0aW9uKGNvbnRleHQpKSB7XHJcblx0ICAgICAgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGZuID0gb3B0aW9ucy5mbjtcclxuXHJcblx0ICAgIGlmICghX3V0aWxzLmlzRW1wdHkoY29udGV4dCkpIHtcclxuXHQgICAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YTtcclxuXHQgICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XHJcblx0ICAgICAgICBkYXRhID0gX3V0aWxzLmNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XHJcblx0ICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIHtcclxuXHQgICAgICAgIGRhdGE6IGRhdGEsXHJcblx0ICAgICAgICBibG9ja1BhcmFtczogX3V0aWxzLmJsb2NrUGFyYW1zKFtjb250ZXh0XSwgW2RhdGEgJiYgZGF0YS5jb250ZXh0UGF0aF0pXHJcblx0ICAgICAgfSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyA9IHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnM7XHJcblxyXG5cdHZhciBfZGVjb3JhdG9yc0lubGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5cclxuXHR2YXIgX2RlY29yYXRvcnNJbmxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVjb3JhdG9yc0lubGluZSk7XHJcblxyXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnMoaW5zdGFuY2UpIHtcclxuXHQgIF9kZWNvcmF0b3JzSW5saW5lMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHR9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVyRGVjb3JhdG9yKCdpbmxpbmUnLCBmdW5jdGlvbiAoZm4sIHByb3BzLCBjb250YWluZXIsIG9wdGlvbnMpIHtcclxuXHQgICAgdmFyIHJldCA9IGZuO1xyXG5cdCAgICBpZiAoIXByb3BzLnBhcnRpYWxzKSB7XHJcblx0ICAgICAgcHJvcHMucGFydGlhbHMgPSB7fTtcclxuXHQgICAgICByZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhcnRpYWxzIHN0YWNrIGZyYW1lIHByaW9yIHRvIGV4ZWMuXHJcblx0ICAgICAgICB2YXIgb3JpZ2luYWwgPSBjb250YWluZXIucGFydGlhbHM7XHJcblx0ICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBfdXRpbHMuZXh0ZW5kKHt9LCBvcmlnaW5hbCwgcHJvcHMucGFydGlhbHMpO1xyXG5cdCAgICAgICAgdmFyIHJldCA9IGZuKGNvbnRleHQsIG9wdGlvbnMpO1xyXG5cdCAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3JpZ2luYWw7XHJcblx0ICAgICAgICByZXR1cm4gcmV0O1xyXG5cdCAgICAgIH07XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHByb3BzLnBhcnRpYWxzW29wdGlvbnMuYXJnc1swXV0gPSBvcHRpb25zLmZuO1xyXG5cclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH0pO1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0dmFyIGxvZ2dlciA9IHtcclxuXHQgIG1ldGhvZE1hcDogWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSxcclxuXHQgIGxldmVsOiAnaW5mbycsXHJcblxyXG5cdCAgLy8gTWFwcyBhIGdpdmVuIGxldmVsIHZhbHVlIHRvIHRoZSBgbWV0aG9kTWFwYCBpbmRleGVzIGFib3ZlLlxyXG5cdCAgbG9va3VwTGV2ZWw6IGZ1bmN0aW9uIGxvb2t1cExldmVsKGxldmVsKSB7XHJcblx0ICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgdmFyIGxldmVsTWFwID0gX3V0aWxzLmluZGV4T2YobG9nZ2VyLm1ldGhvZE1hcCwgbGV2ZWwudG9Mb3dlckNhc2UoKSk7XHJcblx0ICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcclxuXHQgICAgICAgIGxldmVsID0gbGV2ZWxNYXA7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiBsZXZlbDtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGhvc3QgZW52aXJvbm1lbnRcclxuXHQgIGxvZzogZnVuY3Rpb24gbG9nKGxldmVsKSB7XHJcblx0ICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcclxuXHJcblx0ICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWwpIHtcclxuXHQgICAgICB2YXIgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XHJcblx0ICAgICAgaWYgKCFjb25zb2xlW21ldGhvZF0pIHtcclxuXHQgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG5cdCAgICAgICAgbWV0aG9kID0gJ2xvZyc7XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZSA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuXHQgICAgICAgIG1lc3NhZ2VbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgY29uc29sZVttZXRob2RdLmFwcGx5KGNvbnNvbGUsIG1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGxvZ2dlcjtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdC8vIEJ1aWxkIG91dCBvdXIgYmFzaWMgU2FmZVN0cmluZyB0eXBlXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XHJcblx0ICB0aGlzLnN0cmluZyA9IHN0cmluZztcclxuXHR9XHJcblxyXG5cdFNhZmVTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gU2FmZVN0cmluZy5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgcmV0dXJuICcnICsgdGhpcy5zdHJpbmc7XHJcblx0fTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gU2FmZVN0cmluZztcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9PYmplY3Qkc2VhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpWydkZWZhdWx0J107XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMylbJ2RlZmF1bHQnXTtcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0ZXhwb3J0cy5jaGVja1JldmlzaW9uID0gY2hlY2tSZXZpc2lvbjtcclxuXHRleHBvcnRzLnRlbXBsYXRlID0gdGVtcGxhdGU7XHJcblx0ZXhwb3J0cy53cmFwUHJvZ3JhbSA9IHdyYXBQcm9ncmFtO1xyXG5cdGV4cG9ydHMucmVzb2x2ZVBhcnRpYWwgPSByZXNvbHZlUGFydGlhbDtcclxuXHRleHBvcnRzLmludm9rZVBhcnRpYWwgPSBpbnZva2VQYXJ0aWFsO1xyXG5cdGV4cG9ydHMubm9vcCA9IG5vb3A7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHR2YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfdXRpbHMpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XHJcblxyXG5cdHZhciBfYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG5cdGZ1bmN0aW9uIGNoZWNrUmV2aXNpb24oY29tcGlsZXJJbmZvKSB7XHJcblx0ICB2YXIgY29tcGlsZXJSZXZpc2lvbiA9IGNvbXBpbGVySW5mbyAmJiBjb21waWxlckluZm9bMF0gfHwgMSxcclxuXHQgICAgICBjdXJyZW50UmV2aXNpb24gPSBfYmFzZS5DT01QSUxFUl9SRVZJU0lPTjtcclxuXHJcblx0ICBpZiAoY29tcGlsZXJSZXZpc2lvbiAhPT0gY3VycmVudFJldmlzaW9uKSB7XHJcblx0ICAgIGlmIChjb21waWxlclJldmlzaW9uIDwgY3VycmVudFJldmlzaW9uKSB7XHJcblx0ICAgICAgdmFyIHJ1bnRpbWVWZXJzaW9ucyA9IF9iYXNlLlJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcclxuXHQgICAgICAgICAgY29tcGlsZXJWZXJzaW9ucyA9IF9iYXNlLlJFVklTSU9OX0NIQU5HRVNbY29tcGlsZXJSZXZpc2lvbl07XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGFuIG9sZGVyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgKyAnUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIHJ1bnRpbWVWZXJzaW9ucyArICcpIG9yIGRvd25ncmFkZSB5b3VyIHJ1bnRpbWUgdG8gYW4gb2xkZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVyVmVyc2lvbnMgKyAnKS4nKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICAvLyBVc2UgdGhlIGVtYmVkZGVkIHZlcnNpb24gaW5mbyBzaW5jZSB0aGUgcnVudGltZSBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyByZXZpc2lvbiB5ZXRcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYSBuZXdlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICsgJ1BsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVySW5mb1sxXSArICcpLicpO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMsIGVudikge1xyXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgIGlmICghZW52KSB7XHJcblx0ICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGUnKTtcclxuXHQgIH1cclxuXHQgIGlmICghdGVtcGxhdGVTcGVjIHx8ICF0ZW1wbGF0ZVNwZWMubWFpbikge1xyXG5cdCAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVW5rbm93biB0ZW1wbGF0ZSBvYmplY3Q6ICcgKyB0eXBlb2YgdGVtcGxhdGVTcGVjKTtcclxuXHQgIH1cclxuXHJcblx0ICB0ZW1wbGF0ZVNwZWMubWFpbi5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWMubWFpbl9kO1xyXG5cclxuXHQgIC8vIE5vdGU6IFVzaW5nIGVudi5WTSByZWZlcmVuY2VzIHJhdGhlciB0aGFuIGxvY2FsIHZhciByZWZlcmVuY2VzIHRocm91Z2hvdXQgdGhpcyBzZWN0aW9uIHRvIGFsbG93XHJcblx0ICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxyXG5cdCAgZW52LlZNLmNoZWNrUmV2aXNpb24odGVtcGxhdGVTcGVjLmNvbXBpbGVyKTtcclxuXHJcblx0ICBmdW5jdGlvbiBpbnZva2VQYXJ0aWFsV3JhcHBlcihwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XHJcblx0ICAgIGlmIChvcHRpb25zLmhhc2gpIHtcclxuXHQgICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBvcHRpb25zLmhhc2gpO1xyXG5cdCAgICAgIGlmIChvcHRpb25zLmlkcykge1xyXG5cdCAgICAgICAgb3B0aW9ucy5pZHNbMF0gPSB0cnVlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgcGFydGlhbCA9IGVudi5WTS5yZXNvbHZlUGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpO1xyXG5cdCAgICB2YXIgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcclxuXHJcblx0ICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xyXG5cdCAgICAgIG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXSA9IGVudi5jb21waWxlKHBhcnRpYWwsIHRlbXBsYXRlU3BlYy5jb21waWxlck9wdGlvbnMsIGVudik7XHJcblx0ICAgICAgcmVzdWx0ID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdKGNvbnRleHQsIG9wdGlvbnMpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xyXG5cdCAgICAgIGlmIChvcHRpb25zLmluZGVudCkge1xyXG5cdCAgICAgICAgdmFyIGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgICAgICAgIGlmICghbGluZXNbaV0gJiYgaSArIDEgPT09IGwpIHtcclxuXHQgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgbGluZXNbaV0gPSBvcHRpb25zLmluZGVudCArIGxpbmVzW2ldO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBjb21waWxlZCB3aGVuIHJ1bm5pbmcgaW4gcnVudGltZS1vbmx5IG1vZGUnKTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIC8vIEp1c3QgYWRkIHdhdGVyXHJcblx0ICB2YXIgY29udGFpbmVyID0ge1xyXG5cdCAgICBzdHJpY3Q6IGZ1bmN0aW9uIHN0cmljdChvYmosIG5hbWUpIHtcclxuXHQgICAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcclxuXHQgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdcIicgKyBuYW1lICsgJ1wiIG5vdCBkZWZpbmVkIGluICcgKyBvYmopO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICByZXR1cm4gb2JqW25hbWVdO1xyXG5cdCAgICB9LFxyXG5cdCAgICBsb29rdXA6IGZ1bmN0aW9uIGxvb2t1cChkZXB0aHMsIG5hbWUpIHtcclxuXHQgICAgICB2YXIgbGVuID0gZGVwdGhzLmxlbmd0aDtcclxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgICBpZiAoZGVwdGhzW2ldICYmIGRlcHRoc1tpXVtuYW1lXSAhPSBudWxsKSB7XHJcblx0ICAgICAgICAgIHJldHVybiBkZXB0aHNbaV1bbmFtZV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9LFxyXG5cdCAgICBsYW1iZGE6IGZ1bmN0aW9uIGxhbWJkYShjdXJyZW50LCBjb250ZXh0KSB7XHJcblx0ICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50ID09PSAnZnVuY3Rpb24nID8gY3VycmVudC5jYWxsKGNvbnRleHQpIDogY3VycmVudDtcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXHJcblx0ICAgIGludm9rZVBhcnRpYWw6IGludm9rZVBhcnRpYWxXcmFwcGVyLFxyXG5cclxuXHQgICAgZm46IGZ1bmN0aW9uIGZuKGkpIHtcclxuXHQgICAgICB2YXIgcmV0ID0gdGVtcGxhdGVTcGVjW2ldO1xyXG5cdCAgICAgIHJldC5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWNbaSArICdfZCddO1xyXG5cdCAgICAgIHJldHVybiByZXQ7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICBwcm9ncmFtczogW10sXHJcblx0ICAgIHByb2dyYW06IGZ1bmN0aW9uIHByb2dyYW0oaSwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xyXG5cdCAgICAgIHZhciBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0sXHJcblx0ICAgICAgICAgIGZuID0gdGhpcy5mbihpKTtcclxuXHQgICAgICBpZiAoZGF0YSB8fCBkZXB0aHMgfHwgYmxvY2tQYXJhbXMgfHwgZGVjbGFyZWRCbG9ja1BhcmFtcykge1xyXG5cdCAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocyk7XHJcblx0ICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcclxuXHQgICAgICAgIHByb2dyYW1XcmFwcGVyID0gdGhpcy5wcm9ncmFtc1tpXSA9IHdyYXBQcm9ncmFtKHRoaXMsIGksIGZuKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgcmV0dXJuIHByb2dyYW1XcmFwcGVyO1xyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSh2YWx1ZSwgZGVwdGgpIHtcclxuXHQgICAgICB3aGlsZSAodmFsdWUgJiYgZGVwdGgtLSkge1xyXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5fcGFyZW50O1xyXG5cdCAgICAgIH1cclxuXHQgICAgICByZXR1cm4gdmFsdWU7XHJcblx0ICAgIH0sXHJcblx0ICAgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShwYXJhbSwgY29tbW9uKSB7XHJcblx0ICAgICAgdmFyIG9iaiA9IHBhcmFtIHx8IGNvbW1vbjtcclxuXHJcblx0ICAgICAgaWYgKHBhcmFtICYmIGNvbW1vbiAmJiBwYXJhbSAhPT0gY29tbW9uKSB7XHJcblx0ICAgICAgICBvYmogPSBVdGlscy5leHRlbmQoe30sIGNvbW1vbiwgcGFyYW0pO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgcmV0dXJuIG9iajtcclxuXHQgICAgfSxcclxuXHQgICAgLy8gQW4gZW1wdHkgb2JqZWN0IHRvIHVzZSBhcyByZXBsYWNlbWVudCBmb3IgbnVsbC1jb250ZXh0c1xyXG5cdCAgICBudWxsQ29udGV4dDogX09iamVjdCRzZWFsKHt9KSxcclxuXHJcblx0ICAgIG5vb3A6IGVudi5WTS5ub29wLFxyXG5cdCAgICBjb21waWxlckluZm86IHRlbXBsYXRlU3BlYy5jb21waWxlclxyXG5cdCAgfTtcclxuXHJcblx0ICBmdW5jdGlvbiByZXQoY29udGV4dCkge1xyXG5cdCAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xyXG5cclxuXHQgICAgdmFyIGRhdGEgPSBvcHRpb25zLmRhdGE7XHJcblxyXG5cdCAgICByZXQuX3NldHVwKG9wdGlvbnMpO1xyXG5cdCAgICBpZiAoIW9wdGlvbnMucGFydGlhbCAmJiB0ZW1wbGF0ZVNwZWMudXNlRGF0YSkge1xyXG5cdCAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgZGVwdGhzID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcclxuXHQgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMpIHtcclxuXHQgICAgICBpZiAob3B0aW9ucy5kZXB0aHMpIHtcclxuXHQgICAgICAgIGRlcHRocyA9IGNvbnRleHQgIT0gb3B0aW9ucy5kZXB0aHNbMF0gPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKSA6IG9wdGlvbnMuZGVwdGhzO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBkZXB0aHMgPSBbY29udGV4dF07XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBmdW5jdGlvbiBtYWluKGNvbnRleHQgLyosIG9wdGlvbnMqLykge1xyXG5cdCAgICAgIHJldHVybiAnJyArIHRlbXBsYXRlU3BlYy5tYWluKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XHJcblx0ICAgIH1cclxuXHQgICAgbWFpbiA9IGV4ZWN1dGVEZWNvcmF0b3JzKHRlbXBsYXRlU3BlYy5tYWluLCBtYWluLCBjb250YWluZXIsIG9wdGlvbnMuZGVwdGhzIHx8IFtdLCBkYXRhLCBibG9ja1BhcmFtcyk7XHJcblx0ICAgIHJldHVybiBtYWluKGNvbnRleHQsIG9wdGlvbnMpO1xyXG5cdCAgfVxyXG5cdCAgcmV0LmlzVG9wID0gdHJ1ZTtcclxuXHJcblx0ICByZXQuX3NldHVwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgaWYgKCFvcHRpb25zLnBhcnRpYWwpIHtcclxuXHQgICAgICBjb250YWluZXIuaGVscGVycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmhlbHBlcnMsIGVudi5oZWxwZXJzKTtcclxuXHJcblx0ICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsKSB7XHJcblx0ICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5wYXJ0aWFscywgZW52LnBhcnRpYWxzKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsIHx8IHRlbXBsYXRlU3BlYy51c2VEZWNvcmF0b3JzKSB7XHJcblx0ICAgICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmRlY29yYXRvcnMsIGVudi5kZWNvcmF0b3JzKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XHJcblx0ICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gb3B0aW9ucy5wYXJ0aWFscztcclxuXHQgICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IG9wdGlvbnMuZGVjb3JhdG9ycztcclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHJcblx0ICByZXQuX2NoaWxkID0gZnVuY3Rpb24gKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcclxuXHQgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyAmJiAhYmxvY2tQYXJhbXMpIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnbXVzdCBwYXNzIGJsb2NrIHBhcmFtcycpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzICYmICFkZXB0aHMpIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnbXVzdCBwYXNzIHBhcmVudCBkZXB0aHMnKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgdGVtcGxhdGVTcGVjW2ldLCBkYXRhLCAwLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcclxuXHQgIH07XHJcblx0ICByZXR1cm4gcmV0O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xyXG5cdCAgZnVuY3Rpb24gcHJvZyhjb250ZXh0KSB7XHJcblx0ICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XHJcblxyXG5cdCAgICB2YXIgY3VycmVudERlcHRocyA9IGRlcHRocztcclxuXHQgICAgaWYgKGRlcHRocyAmJiBjb250ZXh0ICE9IGRlcHRoc1swXSAmJiAhKGNvbnRleHQgPT09IGNvbnRhaW5lci5udWxsQ29udGV4dCAmJiBkZXB0aHNbMF0gPT09IG51bGwpKSB7XHJcblx0ICAgICAgY3VycmVudERlcHRocyA9IFtjb250ZXh0XS5jb25jYXQoZGVwdGhzKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuIGZuKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgb3B0aW9ucy5kYXRhIHx8IGRhdGEsIGJsb2NrUGFyYW1zICYmIFtvcHRpb25zLmJsb2NrUGFyYW1zXS5jb25jYXQoYmxvY2tQYXJhbXMpLCBjdXJyZW50RGVwdGhzKTtcclxuXHQgIH1cclxuXHJcblx0ICBwcm9nID0gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcyk7XHJcblxyXG5cdCAgcHJvZy5wcm9ncmFtID0gaTtcclxuXHQgIHByb2cuZGVwdGggPSBkZXB0aHMgPyBkZXB0aHMubGVuZ3RoIDogMDtcclxuXHQgIHByb2cuYmxvY2tQYXJhbXMgPSBkZWNsYXJlZEJsb2NrUGFyYW1zIHx8IDA7XHJcblx0ICByZXR1cm4gcHJvZztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlc29sdmVQYXJ0aWFsKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcclxuXHQgIGlmICghcGFydGlhbCkge1xyXG5cdCAgICBpZiAob3B0aW9ucy5uYW1lID09PSAnQHBhcnRpYWwtYmxvY2snKSB7XHJcblx0ICAgICAgcGFydGlhbCA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV07XHJcblx0ICAgIH1cclxuXHQgIH0gZWxzZSBpZiAoIXBhcnRpYWwuY2FsbCAmJiAhb3B0aW9ucy5uYW1lKSB7XHJcblx0ICAgIC8vIFRoaXMgaXMgYSBkeW5hbWljIHBhcnRpYWwgdGhhdCByZXR1cm5lZCBhIHN0cmluZ1xyXG5cdCAgICBvcHRpb25zLm5hbWUgPSBwYXJ0aWFsO1xyXG5cdCAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1twYXJ0aWFsXTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBwYXJ0aWFsO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW52b2tlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XHJcblx0ICAvLyBVc2UgdGhlIGN1cnJlbnQgY2xvc3VyZSBjb250ZXh0IHRvIHNhdmUgdGhlIHBhcnRpYWwtYmxvY2sgaWYgdGhpcyBwYXJ0aWFsXHJcblx0ICB2YXIgY3VycmVudFBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcclxuXHQgIG9wdGlvbnMucGFydGlhbCA9IHRydWU7XHJcblx0ICBpZiAob3B0aW9ucy5pZHMpIHtcclxuXHQgICAgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoID0gb3B0aW9ucy5pZHNbMF0gfHwgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBwYXJ0aWFsQmxvY2sgPSB1bmRlZmluZWQ7XHJcblx0ICBpZiAob3B0aW9ucy5mbiAmJiBvcHRpb25zLmZuICE9PSBub29wKSB7XHJcblx0ICAgIChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgb3B0aW9ucy5kYXRhID0gX2Jhc2UuY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcclxuXHQgICAgICAvLyBXcmFwcGVyIGZ1bmN0aW9uIHRvIGdldCBhY2Nlc3MgdG8gY3VycmVudFBhcnRpYWxCbG9jayBmcm9tIHRoZSBjbG9zdXJlXHJcblx0ICAgICAgdmFyIGZuID0gb3B0aW9ucy5mbjtcclxuXHQgICAgICBwYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IGZ1bmN0aW9uIHBhcnRpYWxCbG9ja1dyYXBwZXIoY29udGV4dCkge1xyXG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcclxuXHJcblx0ICAgICAgICAvLyBSZXN0b3JlIHRoZSBwYXJ0aWFsLWJsb2NrIGZyb20gdGhlIGNsb3N1cmUgZm9yIHRoZSBleGVjdXRpb24gb2YgdGhlIGJsb2NrXHJcblx0ICAgICAgICAvLyBpLmUuIHRoZSBwYXJ0IGluc2lkZSB0aGUgYmxvY2sgb2YgdGhlIHBhcnRpYWwgY2FsbC5cclxuXHQgICAgICAgIG9wdGlvbnMuZGF0YSA9IF9iYXNlLmNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XHJcblx0ICAgICAgICBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IGN1cnJlbnRQYXJ0aWFsQmxvY2s7XHJcblx0ICAgICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XHJcblx0ICAgICAgfTtcclxuXHQgICAgICBpZiAoZm4ucGFydGlhbHMpIHtcclxuXHQgICAgICAgIG9wdGlvbnMucGFydGlhbHMgPSBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMucGFydGlhbHMsIGZuLnBhcnRpYWxzKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0pKCk7XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFsQmxvY2spIHtcclxuXHQgICAgcGFydGlhbCA9IHBhcnRpYWxCbG9jaztcclxuXHQgIH1cclxuXHJcblx0ICBpZiAocGFydGlhbCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgZm91bmQnKTtcclxuXHQgIH0gZWxzZSBpZiAocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcblx0ICAgIHJldHVybiBwYXJ0aWFsKGNvbnRleHQsIG9wdGlvbnMpO1xyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbm9vcCgpIHtcclxuXHQgIHJldHVybiAnJztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGluaXREYXRhKGNvbnRleHQsIGRhdGEpIHtcclxuXHQgIGlmICghZGF0YSB8fCAhKCdyb290JyBpbiBkYXRhKSkge1xyXG5cdCAgICBkYXRhID0gZGF0YSA/IF9iYXNlLmNyZWF0ZUZyYW1lKGRhdGEpIDoge307XHJcblx0ICAgIGRhdGEucm9vdCA9IGNvbnRleHQ7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gZGF0YTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpIHtcclxuXHQgIGlmIChmbi5kZWNvcmF0b3IpIHtcclxuXHQgICAgdmFyIHByb3BzID0ge307XHJcblx0ICAgIHByb2cgPSBmbi5kZWNvcmF0b3IocHJvZywgcHJvcHMsIGNvbnRhaW5lciwgZGVwdGhzICYmIGRlcHRoc1swXSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XHJcblx0ICAgIFV0aWxzLmV4dGVuZChwcm9nLCBwcm9wcyk7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gcHJvZztcclxuXHR9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMjQpLCBfX2VzTW9kdWxlOiB0cnVlIH07XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzApLk9iamVjdC5zZWFsO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gMTkuMS4yLjE3IE9iamVjdC5zZWFsKE8pXHJcblx0dmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XHJcblxyXG5cdF9fd2VicGFja19yZXF1aXJlX18oMjcpKCdzZWFsJywgZnVuY3Rpb24oJHNlYWwpe1xyXG5cdCAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpe1xyXG5cdCAgICByZXR1cm4gJHNlYWwgJiYgaXNPYmplY3QoaXQpID8gJHNlYWwoaXQpIDogaXQ7XHJcblx0ICB9O1xyXG5cdH0pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XHJcblx0ICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xyXG5cdH07XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcclxuXHR2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpXHJcblx0ICAsIGNvcmUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKVxyXG5cdCAgLCBmYWlscyAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xyXG5cdCAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxyXG5cdCAgICAsIGV4cCA9IHt9O1xyXG5cdCAgZXhwW0tFWV0gPSBleGVjKGZuKTtcclxuXHQgICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0dmFyIGdsb2JhbCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpXHJcblx0ICAsIGNvcmUgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzApXHJcblx0ICAsIGN0eCAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpXHJcblx0ICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xyXG5cclxuXHR2YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XHJcblx0ICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxyXG5cdCAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcclxuXHQgICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXHJcblx0ICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxyXG5cdCAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcclxuXHQgICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXHJcblx0ICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcclxuXHQgICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXHJcblx0ICAgICwga2V5LCBvd24sIG91dDtcclxuXHQgIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xyXG5cdCAgZm9yKGtleSBpbiBzb3VyY2Upe1xyXG5cdCAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcclxuXHQgICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYga2V5IGluIHRhcmdldDtcclxuXHQgICAgaWYob3duICYmIGtleSBpbiBleHBvcnRzKWNvbnRpbnVlO1xyXG5cdCAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxyXG5cdCAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xyXG5cdCAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcclxuXHQgICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cclxuXHQgICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcclxuXHQgICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcclxuXHQgICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcclxuXHQgICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcclxuXHQgICAgICB2YXIgRiA9IGZ1bmN0aW9uKHBhcmFtKXtcclxuXHQgICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQyA/IG5ldyBDKHBhcmFtKSA6IEMocGFyYW0pO1xyXG5cdCAgICAgIH07XHJcblx0ICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xyXG5cdCAgICAgIHJldHVybiBGO1xyXG5cdCAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcclxuXHQgICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xyXG5cdCAgICBpZihJU19QUk9UTykoZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSkpW2tleV0gPSBvdXQ7XHJcblx0ICB9XHJcblx0fTtcclxuXHQvLyB0eXBlIGJpdG1hcFxyXG5cdCRleHBvcnQuRiA9IDE7ICAvLyBmb3JjZWRcclxuXHQkZXhwb3J0LkcgPSAyOyAgLy8gZ2xvYmFsXHJcblx0JGV4cG9ydC5TID0gNDsgIC8vIHN0YXRpY1xyXG5cdCRleHBvcnQuUCA9IDg7ICAvLyBwcm90b1xyXG5cdCRleHBvcnQuQiA9IDE2OyAvLyBiaW5kXHJcblx0JGV4cG9ydC5XID0gMzI7IC8vIHdyYXBcclxuXHRtb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxyXG5cdHZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxyXG5cdCAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG5cdGlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcxLjIuNid9O1xyXG5cdGlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXHJcblx0dmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XHJcblx0ICBhRnVuY3Rpb24oZm4pO1xyXG5cdCAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcclxuXHQgIHN3aXRjaChsZW5ndGgpe1xyXG5cdCAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcclxuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcclxuXHQgICAgfTtcclxuXHQgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XHJcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XHJcblx0ICAgIH07XHJcblx0ICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xyXG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xyXG5cdCAgICB9O1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xyXG5cdCAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcclxuXHQgIH07XHJcblx0fTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xyXG5cdCAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcclxuXHQgIHJldHVybiBpdDtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcclxuXHQgIHRyeSB7XHJcblx0ICAgIHJldHVybiAhIWV4ZWMoKTtcclxuXHQgIH0gY2F0Y2goZSl7XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfVxyXG5cdH07XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogZ2xvYmFsIHdpbmRvdyAqL1xyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKEhhbmRsZWJhcnMpIHtcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93LFxyXG5cdCAgICAgICRIYW5kbGViYXJzID0gcm9vdC5IYW5kbGViYXJzO1xyXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgIEhhbmRsZWJhcnMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgaWYgKHJvb3QuSGFuZGxlYmFycyA9PT0gSGFuZGxlYmFycykge1xyXG5cdCAgICAgIHJvb3QuSGFuZGxlYmFycyA9ICRIYW5kbGViYXJzO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBIYW5kbGViYXJzO1xyXG5cdCAgfTtcclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSgpKSkpXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0dmFyIEFTVCA9IHtcclxuXHQgIC8vIFB1YmxpYyBBUEkgdXNlZCB0byBldmFsdWF0ZSBkZXJpdmVkIGF0dHJpYnV0ZXMgcmVnYXJkaW5nIEFTVCBub2Rlc1xyXG5cdCAgaGVscGVyczoge1xyXG5cdCAgICAvLyBhIG11c3RhY2hlIGlzIGRlZmluaXRlbHkgYSBoZWxwZXIgaWY6XHJcblx0ICAgIC8vICogaXQgaXMgYW4gZWxpZ2libGUgaGVscGVyLCBhbmRcclxuXHQgICAgLy8gKiBpdCBoYXMgYXQgbGVhc3Qgb25lIHBhcmFtZXRlciBvciBoYXNoIHNlZ21lbnRcclxuXHQgICAgaGVscGVyRXhwcmVzc2lvbjogZnVuY3Rpb24gaGVscGVyRXhwcmVzc2lvbihub2RlKSB7XHJcblx0ICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nIHx8IChub2RlLnR5cGUgPT09ICdNdXN0YWNoZVN0YXRlbWVudCcgfHwgbm9kZS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSAmJiAhIShub2RlLnBhcmFtcyAmJiBub2RlLnBhcmFtcy5sZW5ndGggfHwgbm9kZS5oYXNoKTtcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIHNjb3BlZElkOiBmdW5jdGlvbiBzY29wZWRJZChwYXRoKSB7XHJcblx0ICAgICAgcmV0dXJuICgvXlxcLnx0aGlzXFxiLy50ZXN0KHBhdGgub3JpZ2luYWwpXHJcblx0ICAgICAgKTtcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIC8vIGFuIElEIGlzIHNpbXBsZSBpZiBpdCBvbmx5IGhhcyBvbmUgcGFydCwgYW5kIHRoYXQgcGFydCBpcyBub3RcclxuXHQgICAgLy8gYC4uYCBvciBgdGhpc2AuXHJcblx0ICAgIHNpbXBsZUlkOiBmdW5jdGlvbiBzaW1wbGVJZChwYXRoKSB7XHJcblx0ICAgICAgcmV0dXJuIHBhdGgucGFydHMubGVuZ3RoID09PSAxICYmICFBU1QuaGVscGVycy5zY29wZWRJZChwYXRoKSAmJiAhcGF0aC5kZXB0aDtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdC8vIE11c3QgYmUgZXhwb3J0ZWQgYXMgYW4gb2JqZWN0IHJhdGhlciB0aGFuIHRoZSByb290IG9mIHRoZSBtb2R1bGUgYXMgdGhlIGppc29uIGxleGVyXHJcblx0Ly8gbXVzdCBtb2RpZnkgdGhlIG9iamVjdCB0byBvcGVyYXRlIHByb3Blcmx5LlxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IEFTVDtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oMylbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLnBhcnNlID0gcGFyc2U7XHJcblxyXG5cdHZhciBfcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcblxyXG5cdHZhciBfcGFyc2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BhcnNlcik7XHJcblxyXG5cdHZhciBfd2hpdGVzcGFjZUNvbnRyb2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcclxuXHJcblx0dmFyIF93aGl0ZXNwYWNlQ29udHJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93aGl0ZXNwYWNlQ29udHJvbCk7XHJcblxyXG5cdHZhciBfaGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG5cclxuXHR2YXIgSGVscGVycyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9oZWxwZXJzKTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdGV4cG9ydHMucGFyc2VyID0gX3BhcnNlcjJbJ2RlZmF1bHQnXTtcclxuXHJcblx0dmFyIHl5ID0ge307XHJcblx0X3V0aWxzLmV4dGVuZCh5eSwgSGVscGVycyk7XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XHJcblx0ICAvLyBKdXN0IHJldHVybiBpZiBhbiBhbHJlYWR5LWNvbXBpbGVkIEFTVCB3YXMgcGFzc2VkIGluLlxyXG5cdCAgaWYgKGlucHV0LnR5cGUgPT09ICdQcm9ncmFtJykge1xyXG5cdCAgICByZXR1cm4gaW5wdXQ7XHJcblx0ICB9XHJcblxyXG5cdCAgX3BhcnNlcjJbJ2RlZmF1bHQnXS55eSA9IHl5O1xyXG5cclxuXHQgIC8vIEFsdGVyaW5nIHRoZSBzaGFyZWQgb2JqZWN0IGhlcmUsIGJ1dCB0aGlzIGlzIG9rIGFzIHBhcnNlciBpcyBhIHN5bmMgb3BlcmF0aW9uXHJcblx0ICB5eS5sb2NJbmZvID0gZnVuY3Rpb24gKGxvY0luZm8pIHtcclxuXHQgICAgcmV0dXJuIG5ldyB5eS5Tb3VyY2VMb2NhdGlvbihvcHRpb25zICYmIG9wdGlvbnMuc3JjTmFtZSwgbG9jSW5mbyk7XHJcblx0ICB9O1xyXG5cclxuXHQgIHZhciBzdHJpcCA9IG5ldyBfd2hpdGVzcGFjZUNvbnRyb2wyWydkZWZhdWx0J10ob3B0aW9ucyk7XHJcblx0ICByZXR1cm4gc3RyaXAuYWNjZXB0KF9wYXJzZXIyWydkZWZhdWx0J10ucGFyc2UoaW5wdXQpKTtcclxuXHR9XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyBGaWxlIGlnbm9yZWQgaW4gY292ZXJhZ2UgdGVzdHMgdmlhIHNldHRpbmcgaW4gLmlzdGFuYnVsLnltbFxyXG5cdC8qIEppc29uIGdlbmVyYXRlZCBwYXJzZXIgKi9cclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHR2YXIgaGFuZGxlYmFycyA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIHZhciBwYXJzZXIgPSB7IHRyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHt9LFxyXG5cdCAgICAgICAgeXk6IHt9LFxyXG5cdCAgICAgICAgc3ltYm9sc186IHsgXCJlcnJvclwiOiAyLCBcInJvb3RcIjogMywgXCJwcm9ncmFtXCI6IDQsIFwiRU9GXCI6IDUsIFwicHJvZ3JhbV9yZXBldGl0aW9uMFwiOiA2LCBcInN0YXRlbWVudFwiOiA3LCBcIm11c3RhY2hlXCI6IDgsIFwiYmxvY2tcIjogOSwgXCJyYXdCbG9ja1wiOiAxMCwgXCJwYXJ0aWFsXCI6IDExLCBcInBhcnRpYWxCbG9ja1wiOiAxMiwgXCJjb250ZW50XCI6IDEzLCBcIkNPTU1FTlRcIjogMTQsIFwiQ09OVEVOVFwiOiAxNSwgXCJvcGVuUmF3QmxvY2tcIjogMTYsIFwicmF3QmxvY2tfcmVwZXRpdGlvbl9wbHVzMFwiOiAxNywgXCJFTkRfUkFXX0JMT0NLXCI6IDE4LCBcIk9QRU5fUkFXX0JMT0NLXCI6IDE5LCBcImhlbHBlck5hbWVcIjogMjAsIFwib3BlblJhd0Jsb2NrX3JlcGV0aXRpb24wXCI6IDIxLCBcIm9wZW5SYXdCbG9ja19vcHRpb24wXCI6IDIyLCBcIkNMT1NFX1JBV19CTE9DS1wiOiAyMywgXCJvcGVuQmxvY2tcIjogMjQsIFwiYmxvY2tfb3B0aW9uMFwiOiAyNSwgXCJjbG9zZUJsb2NrXCI6IDI2LCBcIm9wZW5JbnZlcnNlXCI6IDI3LCBcImJsb2NrX29wdGlvbjFcIjogMjgsIFwiT1BFTl9CTE9DS1wiOiAyOSwgXCJvcGVuQmxvY2tfcmVwZXRpdGlvbjBcIjogMzAsIFwib3BlbkJsb2NrX29wdGlvbjBcIjogMzEsIFwib3BlbkJsb2NrX29wdGlvbjFcIjogMzIsIFwiQ0xPU0VcIjogMzMsIFwiT1BFTl9JTlZFUlNFXCI6IDM0LCBcIm9wZW5JbnZlcnNlX3JlcGV0aXRpb24wXCI6IDM1LCBcIm9wZW5JbnZlcnNlX29wdGlvbjBcIjogMzYsIFwib3BlbkludmVyc2Vfb3B0aW9uMVwiOiAzNywgXCJvcGVuSW52ZXJzZUNoYWluXCI6IDM4LCBcIk9QRU5fSU5WRVJTRV9DSEFJTlwiOiAzOSwgXCJvcGVuSW52ZXJzZUNoYWluX3JlcGV0aXRpb24wXCI6IDQwLCBcIm9wZW5JbnZlcnNlQ2hhaW5fb3B0aW9uMFwiOiA0MSwgXCJvcGVuSW52ZXJzZUNoYWluX29wdGlvbjFcIjogNDIsIFwiaW52ZXJzZUFuZFByb2dyYW1cIjogNDMsIFwiSU5WRVJTRVwiOiA0NCwgXCJpbnZlcnNlQ2hhaW5cIjogNDUsIFwiaW52ZXJzZUNoYWluX29wdGlvbjBcIjogNDYsIFwiT1BFTl9FTkRCTE9DS1wiOiA0NywgXCJPUEVOXCI6IDQ4LCBcIm11c3RhY2hlX3JlcGV0aXRpb24wXCI6IDQ5LCBcIm11c3RhY2hlX29wdGlvbjBcIjogNTAsIFwiT1BFTl9VTkVTQ0FQRURcIjogNTEsIFwibXVzdGFjaGVfcmVwZXRpdGlvbjFcIjogNTIsIFwibXVzdGFjaGVfb3B0aW9uMVwiOiA1MywgXCJDTE9TRV9VTkVTQ0FQRURcIjogNTQsIFwiT1BFTl9QQVJUSUFMXCI6IDU1LCBcInBhcnRpYWxOYW1lXCI6IDU2LCBcInBhcnRpYWxfcmVwZXRpdGlvbjBcIjogNTcsIFwicGFydGlhbF9vcHRpb24wXCI6IDU4LCBcIm9wZW5QYXJ0aWFsQmxvY2tcIjogNTksIFwiT1BFTl9QQVJUSUFMX0JMT0NLXCI6IDYwLCBcIm9wZW5QYXJ0aWFsQmxvY2tfcmVwZXRpdGlvbjBcIjogNjEsIFwib3BlblBhcnRpYWxCbG9ja19vcHRpb24wXCI6IDYyLCBcInBhcmFtXCI6IDYzLCBcInNleHByXCI6IDY0LCBcIk9QRU5fU0VYUFJcIjogNjUsIFwic2V4cHJfcmVwZXRpdGlvbjBcIjogNjYsIFwic2V4cHJfb3B0aW9uMFwiOiA2NywgXCJDTE9TRV9TRVhQUlwiOiA2OCwgXCJoYXNoXCI6IDY5LCBcImhhc2hfcmVwZXRpdGlvbl9wbHVzMFwiOiA3MCwgXCJoYXNoU2VnbWVudFwiOiA3MSwgXCJJRFwiOiA3MiwgXCJFUVVBTFNcIjogNzMsIFwiYmxvY2tQYXJhbXNcIjogNzQsIFwiT1BFTl9CTE9DS19QQVJBTVNcIjogNzUsIFwiYmxvY2tQYXJhbXNfcmVwZXRpdGlvbl9wbHVzMFwiOiA3NiwgXCJDTE9TRV9CTE9DS19QQVJBTVNcIjogNzcsIFwicGF0aFwiOiA3OCwgXCJkYXRhTmFtZVwiOiA3OSwgXCJTVFJJTkdcIjogODAsIFwiTlVNQkVSXCI6IDgxLCBcIkJPT0xFQU5cIjogODIsIFwiVU5ERUZJTkVEXCI6IDgzLCBcIk5VTExcIjogODQsIFwiREFUQVwiOiA4NSwgXCJwYXRoU2VnbWVudHNcIjogODYsIFwiU0VQXCI6IDg3LCBcIiRhY2NlcHRcIjogMCwgXCIkZW5kXCI6IDEgfSxcclxuXHQgICAgICAgIHRlcm1pbmFsc186IHsgMjogXCJlcnJvclwiLCA1OiBcIkVPRlwiLCAxNDogXCJDT01NRU5UXCIsIDE1OiBcIkNPTlRFTlRcIiwgMTg6IFwiRU5EX1JBV19CTE9DS1wiLCAxOTogXCJPUEVOX1JBV19CTE9DS1wiLCAyMzogXCJDTE9TRV9SQVdfQkxPQ0tcIiwgMjk6IFwiT1BFTl9CTE9DS1wiLCAzMzogXCJDTE9TRVwiLCAzNDogXCJPUEVOX0lOVkVSU0VcIiwgMzk6IFwiT1BFTl9JTlZFUlNFX0NIQUlOXCIsIDQ0OiBcIklOVkVSU0VcIiwgNDc6IFwiT1BFTl9FTkRCTE9DS1wiLCA0ODogXCJPUEVOXCIsIDUxOiBcIk9QRU5fVU5FU0NBUEVEXCIsIDU0OiBcIkNMT1NFX1VORVNDQVBFRFwiLCA1NTogXCJPUEVOX1BBUlRJQUxcIiwgNjA6IFwiT1BFTl9QQVJUSUFMX0JMT0NLXCIsIDY1OiBcIk9QRU5fU0VYUFJcIiwgNjg6IFwiQ0xPU0VfU0VYUFJcIiwgNzI6IFwiSURcIiwgNzM6IFwiRVFVQUxTXCIsIDc1OiBcIk9QRU5fQkxPQ0tfUEFSQU1TXCIsIDc3OiBcIkNMT1NFX0JMT0NLX1BBUkFNU1wiLCA4MDogXCJTVFJJTkdcIiwgODE6IFwiTlVNQkVSXCIsIDgyOiBcIkJPT0xFQU5cIiwgODM6IFwiVU5ERUZJTkVEXCIsIDg0OiBcIk5VTExcIiwgODU6IFwiREFUQVwiLCA4NzogXCJTRVBcIiB9LFxyXG5cdCAgICAgICAgcHJvZHVjdGlvbnNfOiBbMCwgWzMsIDJdLCBbNCwgMV0sIFs3LCAxXSwgWzcsIDFdLCBbNywgMV0sIFs3LCAxXSwgWzcsIDFdLCBbNywgMV0sIFs3LCAxXSwgWzEzLCAxXSwgWzEwLCAzXSwgWzE2LCA1XSwgWzksIDRdLCBbOSwgNF0sIFsyNCwgNl0sIFsyNywgNl0sIFszOCwgNl0sIFs0MywgMl0sIFs0NSwgM10sIFs0NSwgMV0sIFsyNiwgM10sIFs4LCA1XSwgWzgsIDVdLCBbMTEsIDVdLCBbMTIsIDNdLCBbNTksIDVdLCBbNjMsIDFdLCBbNjMsIDFdLCBbNjQsIDVdLCBbNjksIDFdLCBbNzEsIDNdLCBbNzQsIDNdLCBbMjAsIDFdLCBbMjAsIDFdLCBbMjAsIDFdLCBbMjAsIDFdLCBbMjAsIDFdLCBbMjAsIDFdLCBbMjAsIDFdLCBbNTYsIDFdLCBbNTYsIDFdLCBbNzksIDJdLCBbNzgsIDFdLCBbODYsIDNdLCBbODYsIDFdLCBbNiwgMF0sIFs2LCAyXSwgWzE3LCAxXSwgWzE3LCAyXSwgWzIxLCAwXSwgWzIxLCAyXSwgWzIyLCAwXSwgWzIyLCAxXSwgWzI1LCAwXSwgWzI1LCAxXSwgWzI4LCAwXSwgWzI4LCAxXSwgWzMwLCAwXSwgWzMwLCAyXSwgWzMxLCAwXSwgWzMxLCAxXSwgWzMyLCAwXSwgWzMyLCAxXSwgWzM1LCAwXSwgWzM1LCAyXSwgWzM2LCAwXSwgWzM2LCAxXSwgWzM3LCAwXSwgWzM3LCAxXSwgWzQwLCAwXSwgWzQwLCAyXSwgWzQxLCAwXSwgWzQxLCAxXSwgWzQyLCAwXSwgWzQyLCAxXSwgWzQ2LCAwXSwgWzQ2LCAxXSwgWzQ5LCAwXSwgWzQ5LCAyXSwgWzUwLCAwXSwgWzUwLCAxXSwgWzUyLCAwXSwgWzUyLCAyXSwgWzUzLCAwXSwgWzUzLCAxXSwgWzU3LCAwXSwgWzU3LCAyXSwgWzU4LCAwXSwgWzU4LCAxXSwgWzYxLCAwXSwgWzYxLCAyXSwgWzYyLCAwXSwgWzYyLCAxXSwgWzY2LCAwXSwgWzY2LCAyXSwgWzY3LCAwXSwgWzY3LCAxXSwgWzcwLCAxXSwgWzcwLCAyXSwgWzc2LCAxXSwgWzc2LCAyXV0sXHJcblx0ICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kXHJcblx0ICAgICAgICAvKiovKSB7XHJcblxyXG5cdCAgICAgICAgICAgIHZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XHJcblx0ICAgICAgICAgICAgc3dpdGNoICh5eXN0YXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAkJFskMCAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVQcm9ncmFtKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDg6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDb21tZW50U3RhdGVtZW50JyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeXkuc3RyaXBDb21tZW50KCQkWyQwXSksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDBdLCAkJFskMF0pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxMDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ29udGVudFN0YXRlbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWw6ICQkWyQwXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJCRbJDBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxMTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVSYXdCbG9jaygkJFskMCAtIDJdLCAkJFskMCAtIDFdLCAkJFskMF0sIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHBhdGg6ICQkWyQwIC0gM10sIHBhcmFtczogJCRbJDAgLSAyXSwgaGFzaDogJCRbJDAgLSAxXSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTM6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlQmxvY2soJCRbJDAgLSAzXSwgJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCBmYWxzZSwgdGhpcy5fJCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVCbG9jaygkJFskMCAtIDNdLCAkJFskMCAtIDJdLCAkJFskMCAtIDFdLCAkJFskMF0sIHRydWUsIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTU6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IG9wZW46ICQkWyQwIC0gNV0sIHBhdGg6ICQkWyQwIC0gNF0sIHBhcmFtczogJCRbJDAgLSAzXSwgaGFzaDogJCRbJDAgLSAyXSwgYmxvY2tQYXJhbXM6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNV0sICQkWyQwXSkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE2OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBwYXRoOiAkJFskMCAtIDRdLCBwYXJhbXM6ICQkWyQwIC0gM10sIGhhc2g6ICQkWyQwIC0gMl0sIGJsb2NrUGFyYW1zOiAkJFskMCAtIDFdLCBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDVdLCAkJFskMF0pIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgcGF0aDogJCRbJDAgLSA0XSwgcGFyYW1zOiAkJFskMCAtIDNdLCBoYXNoOiAkJFskMCAtIDJdLCBibG9ja1BhcmFtczogJCRbJDAgLSAxXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA1XSwgJCRbJDBdKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTg6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gMV0sICQkWyQwIC0gMV0pLCBwcm9ncmFtOiAkJFskMF0gfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGludmVyc2UgPSB5eS5wcmVwYXJlQmxvY2soJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCAkJFskMF0sIGZhbHNlLCB0aGlzLl8kKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmFtID0geXkucHJlcGFyZVByb2dyYW0oW2ludmVyc2VdLCAkJFskMCAtIDFdLmxvYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwcm9ncmFtLmNoYWluZWQgPSB0cnVlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgc3RyaXA6ICQkWyQwIC0gMl0uc3RyaXAsIHByb2dyYW06IHByb2dyYW0sIGNoYWluOiB0cnVlIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyMTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgcGF0aDogJCRbJDAgLSAxXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSAyXSwgJCRbJDBdKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlTXVzdGFjaGUoJCRbJDAgLSAzXSwgJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDAgLSA0XSwgeXkuc3RyaXBGbGFncygkJFskMCAtIDRdLCAkJFskMF0pLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDIzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZU11c3RhY2hlKCQkWyQwIC0gM10sICQkWyQwIC0gMl0sICQkWyQwIC0gMV0sICQkWyQwIC0gNF0sIHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA0XSwgJCRbJDBdKSwgdGhpcy5fJCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUGFydGlhbFN0YXRlbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJCRbJDAgLSAzXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6ICQkWyQwIC0gMl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogJCRbJDAgLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6ICcnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNF0sICQkWyQwXSksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZVBhcnRpYWxCbG9jaygkJFskMCAtIDJdLCAkJFskMCAtIDFdLCAkJFskMF0sIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjY6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHBhdGg6ICQkWyQwIC0gM10sIHBhcmFtczogJCRbJDAgLSAyXSwgaGFzaDogJCRbJDAgLSAxXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA0XSwgJCRbJDBdKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjc6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyODpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdTdWJFeHByZXNzaW9uJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAkJFskMCAtIDNdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogJCRbJDAgLSAyXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiAkJFskMCAtIDFdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgdHlwZTogJ0hhc2gnLCBwYWlyczogJCRbJDBdLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDMxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnSGFzaFBhaXInLCBrZXk6IHl5LmlkKCQkWyQwIC0gMl0pLCB2YWx1ZTogJCRbJDBdLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDMyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkuaWQoJCRbJDAgLSAxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzU6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdTdHJpbmdMaXRlcmFsJywgdmFsdWU6ICQkWyQwXSwgb3JpZ2luYWw6ICQkWyQwXSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgdHlwZTogJ051bWJlckxpdGVyYWwnLCB2YWx1ZTogTnVtYmVyKCQkWyQwXSksIG9yaWdpbmFsOiBOdW1iZXIoJCRbJDBdKSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgdHlwZTogJ0Jvb2xlYW5MaXRlcmFsJywgdmFsdWU6ICQkWyQwXSA9PT0gJ3RydWUnLCBvcmlnaW5hbDogJCRbJDBdID09PSAndHJ1ZScsIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzg6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdVbmRlZmluZWRMaXRlcmFsJywgb3JpZ2luYWw6IHVuZGVmaW5lZCwgdmFsdWU6IHVuZGVmaW5lZCwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgdHlwZTogJ051bGxMaXRlcmFsJywgb3JpZ2luYWw6IG51bGwsIHZhbHVlOiBudWxsLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDE6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0MjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVQYXRoKHRydWUsICQkWyQwXSwgdGhpcy5fJCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0MzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVQYXRoKGZhbHNlLCAkJFskMF0sIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDJdLnB1c2goeyBwYXJ0OiB5eS5pZCgkJFskMF0pLCBvcmlnaW5hbDogJCRbJDBdLCBzZXBhcmF0b3I6ICQkWyQwIC0gMV0gfSk7dGhpcy4kID0gJCRbJDAgLSAyXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW3sgcGFydDogeXkuaWQoJCRbJDBdKSwgb3JpZ2luYWw6ICQkWyQwXSB9XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ2OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0NzpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDg6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbJCRbJDBdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA1MDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTE6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDU4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA1OTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNjQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDY1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA3MDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzE6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDc4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA3OTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgODI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDgzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA4NjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgODc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDkwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5MTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDk1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5ODpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFskJFskMF1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTk6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEwMDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFskJFskMF1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTAxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdGFibGU6IFt7IDM6IDEsIDQ6IDIsIDU6IFsyLCA0Nl0sIDY6IDMsIDE0OiBbMiwgNDZdLCAxNTogWzIsIDQ2XSwgMTk6IFsyLCA0Nl0sIDI5OiBbMiwgNDZdLCAzNDogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyAxOiBbM10gfSwgeyA1OiBbMSwgNF0gfSwgeyA1OiBbMiwgMl0sIDc6IDUsIDg6IDYsIDk6IDcsIDEwOiA4LCAxMTogOSwgMTI6IDEwLCAxMzogMTEsIDE0OiBbMSwgMTJdLCAxNTogWzEsIDIwXSwgMTY6IDE3LCAxOTogWzEsIDIzXSwgMjQ6IDE1LCAyNzogMTYsIDI5OiBbMSwgMjFdLCAzNDogWzEsIDIyXSwgMzk6IFsyLCAyXSwgNDQ6IFsyLCAyXSwgNDc6IFsyLCAyXSwgNDg6IFsxLCAxM10sIDUxOiBbMSwgMTRdLCA1NTogWzEsIDE4XSwgNTk6IDE5LCA2MDogWzEsIDI0XSB9LCB7IDE6IFsyLCAxXSB9LCB7IDU6IFsyLCA0N10sIDE0OiBbMiwgNDddLCAxNTogWzIsIDQ3XSwgMTk6IFsyLCA0N10sIDI5OiBbMiwgNDddLCAzNDogWzIsIDQ3XSwgMzk6IFsyLCA0N10sIDQ0OiBbMiwgNDddLCA0NzogWzIsIDQ3XSwgNDg6IFsyLCA0N10sIDUxOiBbMiwgNDddLCA1NTogWzIsIDQ3XSwgNjA6IFsyLCA0N10gfSwgeyA1OiBbMiwgM10sIDE0OiBbMiwgM10sIDE1OiBbMiwgM10sIDE5OiBbMiwgM10sIDI5OiBbMiwgM10sIDM0OiBbMiwgM10sIDM5OiBbMiwgM10sIDQ0OiBbMiwgM10sIDQ3OiBbMiwgM10sIDQ4OiBbMiwgM10sIDUxOiBbMiwgM10sIDU1OiBbMiwgM10sIDYwOiBbMiwgM10gfSwgeyA1OiBbMiwgNF0sIDE0OiBbMiwgNF0sIDE1OiBbMiwgNF0sIDE5OiBbMiwgNF0sIDI5OiBbMiwgNF0sIDM0OiBbMiwgNF0sIDM5OiBbMiwgNF0sIDQ0OiBbMiwgNF0sIDQ3OiBbMiwgNF0sIDQ4OiBbMiwgNF0sIDUxOiBbMiwgNF0sIDU1OiBbMiwgNF0sIDYwOiBbMiwgNF0gfSwgeyA1OiBbMiwgNV0sIDE0OiBbMiwgNV0sIDE1OiBbMiwgNV0sIDE5OiBbMiwgNV0sIDI5OiBbMiwgNV0sIDM0OiBbMiwgNV0sIDM5OiBbMiwgNV0sIDQ0OiBbMiwgNV0sIDQ3OiBbMiwgNV0sIDQ4OiBbMiwgNV0sIDUxOiBbMiwgNV0sIDU1OiBbMiwgNV0sIDYwOiBbMiwgNV0gfSwgeyA1OiBbMiwgNl0sIDE0OiBbMiwgNl0sIDE1OiBbMiwgNl0sIDE5OiBbMiwgNl0sIDI5OiBbMiwgNl0sIDM0OiBbMiwgNl0sIDM5OiBbMiwgNl0sIDQ0OiBbMiwgNl0sIDQ3OiBbMiwgNl0sIDQ4OiBbMiwgNl0sIDUxOiBbMiwgNl0sIDU1OiBbMiwgNl0sIDYwOiBbMiwgNl0gfSwgeyA1OiBbMiwgN10sIDE0OiBbMiwgN10sIDE1OiBbMiwgN10sIDE5OiBbMiwgN10sIDI5OiBbMiwgN10sIDM0OiBbMiwgN10sIDM5OiBbMiwgN10sIDQ0OiBbMiwgN10sIDQ3OiBbMiwgN10sIDQ4OiBbMiwgN10sIDUxOiBbMiwgN10sIDU1OiBbMiwgN10sIDYwOiBbMiwgN10gfSwgeyA1OiBbMiwgOF0sIDE0OiBbMiwgOF0sIDE1OiBbMiwgOF0sIDE5OiBbMiwgOF0sIDI5OiBbMiwgOF0sIDM0OiBbMiwgOF0sIDM5OiBbMiwgOF0sIDQ0OiBbMiwgOF0sIDQ3OiBbMiwgOF0sIDQ4OiBbMiwgOF0sIDUxOiBbMiwgOF0sIDU1OiBbMiwgOF0sIDYwOiBbMiwgOF0gfSwgeyA1OiBbMiwgOV0sIDE0OiBbMiwgOV0sIDE1OiBbMiwgOV0sIDE5OiBbMiwgOV0sIDI5OiBbMiwgOV0sIDM0OiBbMiwgOV0sIDM5OiBbMiwgOV0sIDQ0OiBbMiwgOV0sIDQ3OiBbMiwgOV0sIDQ4OiBbMiwgOV0sIDUxOiBbMiwgOV0sIDU1OiBbMiwgOV0sIDYwOiBbMiwgOV0gfSwgeyAyMDogMjUsIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDM2LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDQ6IDM3LCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDM5OiBbMiwgNDZdLCA0NDogWzIsIDQ2XSwgNDc6IFsyLCA0Nl0sIDQ4OiBbMiwgNDZdLCA1MTogWzIsIDQ2XSwgNTU6IFsyLCA0Nl0sIDYwOiBbMiwgNDZdIH0sIHsgNDogMzgsIDY6IDMsIDE0OiBbMiwgNDZdLCAxNTogWzIsIDQ2XSwgMTk6IFsyLCA0Nl0sIDI5OiBbMiwgNDZdLCAzNDogWzIsIDQ2XSwgNDQ6IFsyLCA0Nl0sIDQ3OiBbMiwgNDZdLCA0ODogWzIsIDQ2XSwgNTE6IFsyLCA0Nl0sIDU1OiBbMiwgNDZdLCA2MDogWzIsIDQ2XSB9LCB7IDEzOiA0MCwgMTU6IFsxLCAyMF0sIDE3OiAzOSB9LCB7IDIwOiA0MiwgNTY6IDQxLCA2NDogNDMsIDY1OiBbMSwgNDRdLCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDQ6IDQ1LCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDQ3OiBbMiwgNDZdLCA0ODogWzIsIDQ2XSwgNTE6IFsyLCA0Nl0sIDU1OiBbMiwgNDZdLCA2MDogWzIsIDQ2XSB9LCB7IDU6IFsyLCAxMF0sIDE0OiBbMiwgMTBdLCAxNTogWzIsIDEwXSwgMTg6IFsyLCAxMF0sIDE5OiBbMiwgMTBdLCAyOTogWzIsIDEwXSwgMzQ6IFsyLCAxMF0sIDM5OiBbMiwgMTBdLCA0NDogWzIsIDEwXSwgNDc6IFsyLCAxMF0sIDQ4OiBbMiwgMTBdLCA1MTogWzIsIDEwXSwgNTU6IFsyLCAxMF0sIDYwOiBbMiwgMTBdIH0sIHsgMjA6IDQ2LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA0NywgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyMDogNDgsIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDQyLCA1NjogNDksIDY0OiA0MywgNjU6IFsxLCA0NF0sIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMzM6IFsyLCA3OF0sIDQ5OiA1MCwgNjU6IFsyLCA3OF0sIDcyOiBbMiwgNzhdLCA4MDogWzIsIDc4XSwgODE6IFsyLCA3OF0sIDgyOiBbMiwgNzhdLCA4MzogWzIsIDc4XSwgODQ6IFsyLCA3OF0sIDg1OiBbMiwgNzhdIH0sIHsgMjM6IFsyLCAzM10sIDMzOiBbMiwgMzNdLCA1NDogWzIsIDMzXSwgNjU6IFsyLCAzM10sIDY4OiBbMiwgMzNdLCA3MjogWzIsIDMzXSwgNzU6IFsyLCAzM10sIDgwOiBbMiwgMzNdLCA4MTogWzIsIDMzXSwgODI6IFsyLCAzM10sIDgzOiBbMiwgMzNdLCA4NDogWzIsIDMzXSwgODU6IFsyLCAzM10gfSwgeyAyMzogWzIsIDM0XSwgMzM6IFsyLCAzNF0sIDU0OiBbMiwgMzRdLCA2NTogWzIsIDM0XSwgNjg6IFsyLCAzNF0sIDcyOiBbMiwgMzRdLCA3NTogWzIsIDM0XSwgODA6IFsyLCAzNF0sIDgxOiBbMiwgMzRdLCA4MjogWzIsIDM0XSwgODM6IFsyLCAzNF0sIDg0OiBbMiwgMzRdLCA4NTogWzIsIDM0XSB9LCB7IDIzOiBbMiwgMzVdLCAzMzogWzIsIDM1XSwgNTQ6IFsyLCAzNV0sIDY1OiBbMiwgMzVdLCA2ODogWzIsIDM1XSwgNzI6IFsyLCAzNV0sIDc1OiBbMiwgMzVdLCA4MDogWzIsIDM1XSwgODE6IFsyLCAzNV0sIDgyOiBbMiwgMzVdLCA4MzogWzIsIDM1XSwgODQ6IFsyLCAzNV0sIDg1OiBbMiwgMzVdIH0sIHsgMjM6IFsyLCAzNl0sIDMzOiBbMiwgMzZdLCA1NDogWzIsIDM2XSwgNjU6IFsyLCAzNl0sIDY4OiBbMiwgMzZdLCA3MjogWzIsIDM2XSwgNzU6IFsyLCAzNl0sIDgwOiBbMiwgMzZdLCA4MTogWzIsIDM2XSwgODI6IFsyLCAzNl0sIDgzOiBbMiwgMzZdLCA4NDogWzIsIDM2XSwgODU6IFsyLCAzNl0gfSwgeyAyMzogWzIsIDM3XSwgMzM6IFsyLCAzN10sIDU0OiBbMiwgMzddLCA2NTogWzIsIDM3XSwgNjg6IFsyLCAzN10sIDcyOiBbMiwgMzddLCA3NTogWzIsIDM3XSwgODA6IFsyLCAzN10sIDgxOiBbMiwgMzddLCA4MjogWzIsIDM3XSwgODM6IFsyLCAzN10sIDg0OiBbMiwgMzddLCA4NTogWzIsIDM3XSB9LCB7IDIzOiBbMiwgMzhdLCAzMzogWzIsIDM4XSwgNTQ6IFsyLCAzOF0sIDY1OiBbMiwgMzhdLCA2ODogWzIsIDM4XSwgNzI6IFsyLCAzOF0sIDc1OiBbMiwgMzhdLCA4MDogWzIsIDM4XSwgODE6IFsyLCAzOF0sIDgyOiBbMiwgMzhdLCA4MzogWzIsIDM4XSwgODQ6IFsyLCAzOF0sIDg1OiBbMiwgMzhdIH0sIHsgMjM6IFsyLCAzOV0sIDMzOiBbMiwgMzldLCA1NDogWzIsIDM5XSwgNjU6IFsyLCAzOV0sIDY4OiBbMiwgMzldLCA3MjogWzIsIDM5XSwgNzU6IFsyLCAzOV0sIDgwOiBbMiwgMzldLCA4MTogWzIsIDM5XSwgODI6IFsyLCAzOV0sIDgzOiBbMiwgMzldLCA4NDogWzIsIDM5XSwgODU6IFsyLCAzOV0gfSwgeyAyMzogWzIsIDQzXSwgMzM6IFsyLCA0M10sIDU0OiBbMiwgNDNdLCA2NTogWzIsIDQzXSwgNjg6IFsyLCA0M10sIDcyOiBbMiwgNDNdLCA3NTogWzIsIDQzXSwgODA6IFsyLCA0M10sIDgxOiBbMiwgNDNdLCA4MjogWzIsIDQzXSwgODM6IFsyLCA0M10sIDg0OiBbMiwgNDNdLCA4NTogWzIsIDQzXSwgODc6IFsxLCA1MV0gfSwgeyA3MjogWzEsIDM1XSwgODY6IDUyIH0sIHsgMjM6IFsyLCA0NV0sIDMzOiBbMiwgNDVdLCA1NDogWzIsIDQ1XSwgNjU6IFsyLCA0NV0sIDY4OiBbMiwgNDVdLCA3MjogWzIsIDQ1XSwgNzU6IFsyLCA0NV0sIDgwOiBbMiwgNDVdLCA4MTogWzIsIDQ1XSwgODI6IFsyLCA0NV0sIDgzOiBbMiwgNDVdLCA4NDogWzIsIDQ1XSwgODU6IFsyLCA0NV0sIDg3OiBbMiwgNDVdIH0sIHsgNTI6IDUzLCA1NDogWzIsIDgyXSwgNjU6IFsyLCA4Ml0sIDcyOiBbMiwgODJdLCA4MDogWzIsIDgyXSwgODE6IFsyLCA4Ml0sIDgyOiBbMiwgODJdLCA4MzogWzIsIDgyXSwgODQ6IFsyLCA4Ml0sIDg1OiBbMiwgODJdIH0sIHsgMjU6IDU0LCAzODogNTYsIDM5OiBbMSwgNThdLCA0MzogNTcsIDQ0OiBbMSwgNTldLCA0NTogNTUsIDQ3OiBbMiwgNTRdIH0sIHsgMjg6IDYwLCA0MzogNjEsIDQ0OiBbMSwgNTldLCA0NzogWzIsIDU2XSB9LCB7IDEzOiA2MywgMTU6IFsxLCAyMF0sIDE4OiBbMSwgNjJdIH0sIHsgMTU6IFsyLCA0OF0sIDE4OiBbMiwgNDhdIH0sIHsgMzM6IFsyLCA4Nl0sIDU3OiA2NCwgNjU6IFsyLCA4Nl0sIDcyOiBbMiwgODZdLCA4MDogWzIsIDg2XSwgODE6IFsyLCA4Nl0sIDgyOiBbMiwgODZdLCA4MzogWzIsIDg2XSwgODQ6IFsyLCA4Nl0sIDg1OiBbMiwgODZdIH0sIHsgMzM6IFsyLCA0MF0sIDY1OiBbMiwgNDBdLCA3MjogWzIsIDQwXSwgODA6IFsyLCA0MF0sIDgxOiBbMiwgNDBdLCA4MjogWzIsIDQwXSwgODM6IFsyLCA0MF0sIDg0OiBbMiwgNDBdLCA4NTogWzIsIDQwXSB9LCB7IDMzOiBbMiwgNDFdLCA2NTogWzIsIDQxXSwgNzI6IFsyLCA0MV0sIDgwOiBbMiwgNDFdLCA4MTogWzIsIDQxXSwgODI6IFsyLCA0MV0sIDgzOiBbMiwgNDFdLCA4NDogWzIsIDQxXSwgODU6IFsyLCA0MV0gfSwgeyAyMDogNjUsIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjY6IDY2LCA0NzogWzEsIDY3XSB9LCB7IDMwOiA2OCwgMzM6IFsyLCA1OF0sIDY1OiBbMiwgNThdLCA3MjogWzIsIDU4XSwgNzU6IFsyLCA1OF0sIDgwOiBbMiwgNThdLCA4MTogWzIsIDU4XSwgODI6IFsyLCA1OF0sIDgzOiBbMiwgNThdLCA4NDogWzIsIDU4XSwgODU6IFsyLCA1OF0gfSwgeyAzMzogWzIsIDY0XSwgMzU6IDY5LCA2NTogWzIsIDY0XSwgNzI6IFsyLCA2NF0sIDc1OiBbMiwgNjRdLCA4MDogWzIsIDY0XSwgODE6IFsyLCA2NF0sIDgyOiBbMiwgNjRdLCA4MzogWzIsIDY0XSwgODQ6IFsyLCA2NF0sIDg1OiBbMiwgNjRdIH0sIHsgMjE6IDcwLCAyMzogWzIsIDUwXSwgNjU6IFsyLCA1MF0sIDcyOiBbMiwgNTBdLCA4MDogWzIsIDUwXSwgODE6IFsyLCA1MF0sIDgyOiBbMiwgNTBdLCA4MzogWzIsIDUwXSwgODQ6IFsyLCA1MF0sIDg1OiBbMiwgNTBdIH0sIHsgMzM6IFsyLCA5MF0sIDYxOiA3MSwgNjU6IFsyLCA5MF0sIDcyOiBbMiwgOTBdLCA4MDogWzIsIDkwXSwgODE6IFsyLCA5MF0sIDgyOiBbMiwgOTBdLCA4MzogWzIsIDkwXSwgODQ6IFsyLCA5MF0sIDg1OiBbMiwgOTBdIH0sIHsgMjA6IDc1LCAzMzogWzIsIDgwXSwgNTA6IDcyLCA2MzogNzMsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA3NCwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNzI6IFsxLCA4MF0gfSwgeyAyMzogWzIsIDQyXSwgMzM6IFsyLCA0Ml0sIDU0OiBbMiwgNDJdLCA2NTogWzIsIDQyXSwgNjg6IFsyLCA0Ml0sIDcyOiBbMiwgNDJdLCA3NTogWzIsIDQyXSwgODA6IFsyLCA0Ml0sIDgxOiBbMiwgNDJdLCA4MjogWzIsIDQyXSwgODM6IFsyLCA0Ml0sIDg0OiBbMiwgNDJdLCA4NTogWzIsIDQyXSwgODc6IFsxLCA1MV0gfSwgeyAyMDogNzUsIDUzOiA4MSwgNTQ6IFsyLCA4NF0sIDYzOiA4MiwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNjk6IDgzLCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyNjogODQsIDQ3OiBbMSwgNjddIH0sIHsgNDc6IFsyLCA1NV0gfSwgeyA0OiA4NSwgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCAzOTogWzIsIDQ2XSwgNDQ6IFsyLCA0Nl0sIDQ3OiBbMiwgNDZdLCA0ODogWzIsIDQ2XSwgNTE6IFsyLCA0Nl0sIDU1OiBbMiwgNDZdLCA2MDogWzIsIDQ2XSB9LCB7IDQ3OiBbMiwgMjBdIH0sIHsgMjA6IDg2LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDQ6IDg3LCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDQ3OiBbMiwgNDZdLCA0ODogWzIsIDQ2XSwgNTE6IFsyLCA0Nl0sIDU1OiBbMiwgNDZdLCA2MDogWzIsIDQ2XSB9LCB7IDI2OiA4OCwgNDc6IFsxLCA2N10gfSwgeyA0NzogWzIsIDU3XSB9LCB7IDU6IFsyLCAxMV0sIDE0OiBbMiwgMTFdLCAxNTogWzIsIDExXSwgMTk6IFsyLCAxMV0sIDI5OiBbMiwgMTFdLCAzNDogWzIsIDExXSwgMzk6IFsyLCAxMV0sIDQ0OiBbMiwgMTFdLCA0NzogWzIsIDExXSwgNDg6IFsyLCAxMV0sIDUxOiBbMiwgMTFdLCA1NTogWzIsIDExXSwgNjA6IFsyLCAxMV0gfSwgeyAxNTogWzIsIDQ5XSwgMTg6IFsyLCA0OV0gfSwgeyAyMDogNzUsIDMzOiBbMiwgODhdLCA1ODogODksIDYzOiA5MCwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNjk6IDkxLCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA2NTogWzIsIDk0XSwgNjY6IDkyLCA2ODogWzIsIDk0XSwgNzI6IFsyLCA5NF0sIDgwOiBbMiwgOTRdLCA4MTogWzIsIDk0XSwgODI6IFsyLCA5NF0sIDgzOiBbMiwgOTRdLCA4NDogWzIsIDk0XSwgODU6IFsyLCA5NF0gfSwgeyA1OiBbMiwgMjVdLCAxNDogWzIsIDI1XSwgMTU6IFsyLCAyNV0sIDE5OiBbMiwgMjVdLCAyOTogWzIsIDI1XSwgMzQ6IFsyLCAyNV0sIDM5OiBbMiwgMjVdLCA0NDogWzIsIDI1XSwgNDc6IFsyLCAyNV0sIDQ4OiBbMiwgMjVdLCA1MTogWzIsIDI1XSwgNTU6IFsyLCAyNV0sIDYwOiBbMiwgMjVdIH0sIHsgMjA6IDkzLCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA3NSwgMzE6IDk0LCAzMzogWzIsIDYwXSwgNjM6IDk1LCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2OTogOTYsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzU6IFsyLCA2MF0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyMDogNzUsIDMzOiBbMiwgNjZdLCAzNjogOTcsIDYzOiA5OCwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNjk6IDk5LCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc1OiBbMiwgNjZdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDc1LCAyMjogMTAwLCAyMzogWzIsIDUyXSwgNjM6IDEwMSwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNjk6IDEwMiwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDc1LCAzMzogWzIsIDkyXSwgNjI6IDEwMywgNjM6IDEwNCwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNjk6IDEwNSwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMzM6IFsxLCAxMDZdIH0sIHsgMzM6IFsyLCA3OV0sIDY1OiBbMiwgNzldLCA3MjogWzIsIDc5XSwgODA6IFsyLCA3OV0sIDgxOiBbMiwgNzldLCA4MjogWzIsIDc5XSwgODM6IFsyLCA3OV0sIDg0OiBbMiwgNzldLCA4NTogWzIsIDc5XSB9LCB7IDMzOiBbMiwgODFdIH0sIHsgMjM6IFsyLCAyN10sIDMzOiBbMiwgMjddLCA1NDogWzIsIDI3XSwgNjU6IFsyLCAyN10sIDY4OiBbMiwgMjddLCA3MjogWzIsIDI3XSwgNzU6IFsyLCAyN10sIDgwOiBbMiwgMjddLCA4MTogWzIsIDI3XSwgODI6IFsyLCAyN10sIDgzOiBbMiwgMjddLCA4NDogWzIsIDI3XSwgODU6IFsyLCAyN10gfSwgeyAyMzogWzIsIDI4XSwgMzM6IFsyLCAyOF0sIDU0OiBbMiwgMjhdLCA2NTogWzIsIDI4XSwgNjg6IFsyLCAyOF0sIDcyOiBbMiwgMjhdLCA3NTogWzIsIDI4XSwgODA6IFsyLCAyOF0sIDgxOiBbMiwgMjhdLCA4MjogWzIsIDI4XSwgODM6IFsyLCAyOF0sIDg0OiBbMiwgMjhdLCA4NTogWzIsIDI4XSB9LCB7IDIzOiBbMiwgMzBdLCAzMzogWzIsIDMwXSwgNTQ6IFsyLCAzMF0sIDY4OiBbMiwgMzBdLCA3MTogMTA3LCA3MjogWzEsIDEwOF0sIDc1OiBbMiwgMzBdIH0sIHsgMjM6IFsyLCA5OF0sIDMzOiBbMiwgOThdLCA1NDogWzIsIDk4XSwgNjg6IFsyLCA5OF0sIDcyOiBbMiwgOThdLCA3NTogWzIsIDk4XSB9LCB7IDIzOiBbMiwgNDVdLCAzMzogWzIsIDQ1XSwgNTQ6IFsyLCA0NV0sIDY1OiBbMiwgNDVdLCA2ODogWzIsIDQ1XSwgNzI6IFsyLCA0NV0sIDczOiBbMSwgMTA5XSwgNzU6IFsyLCA0NV0sIDgwOiBbMiwgNDVdLCA4MTogWzIsIDQ1XSwgODI6IFsyLCA0NV0sIDgzOiBbMiwgNDVdLCA4NDogWzIsIDQ1XSwgODU6IFsyLCA0NV0sIDg3OiBbMiwgNDVdIH0sIHsgMjM6IFsyLCA0NF0sIDMzOiBbMiwgNDRdLCA1NDogWzIsIDQ0XSwgNjU6IFsyLCA0NF0sIDY4OiBbMiwgNDRdLCA3MjogWzIsIDQ0XSwgNzU6IFsyLCA0NF0sIDgwOiBbMiwgNDRdLCA4MTogWzIsIDQ0XSwgODI6IFsyLCA0NF0sIDgzOiBbMiwgNDRdLCA4NDogWzIsIDQ0XSwgODU6IFsyLCA0NF0sIDg3OiBbMiwgNDRdIH0sIHsgNTQ6IFsxLCAxMTBdIH0sIHsgNTQ6IFsyLCA4M10sIDY1OiBbMiwgODNdLCA3MjogWzIsIDgzXSwgODA6IFsyLCA4M10sIDgxOiBbMiwgODNdLCA4MjogWzIsIDgzXSwgODM6IFsyLCA4M10sIDg0OiBbMiwgODNdLCA4NTogWzIsIDgzXSB9LCB7IDU0OiBbMiwgODVdIH0sIHsgNTogWzIsIDEzXSwgMTQ6IFsyLCAxM10sIDE1OiBbMiwgMTNdLCAxOTogWzIsIDEzXSwgMjk6IFsyLCAxM10sIDM0OiBbMiwgMTNdLCAzOTogWzIsIDEzXSwgNDQ6IFsyLCAxM10sIDQ3OiBbMiwgMTNdLCA0ODogWzIsIDEzXSwgNTE6IFsyLCAxM10sIDU1OiBbMiwgMTNdLCA2MDogWzIsIDEzXSB9LCB7IDM4OiA1NiwgMzk6IFsxLCA1OF0sIDQzOiA1NywgNDQ6IFsxLCA1OV0sIDQ1OiAxMTIsIDQ2OiAxMTEsIDQ3OiBbMiwgNzZdIH0sIHsgMzM6IFsyLCA3MF0sIDQwOiAxMTMsIDY1OiBbMiwgNzBdLCA3MjogWzIsIDcwXSwgNzU6IFsyLCA3MF0sIDgwOiBbMiwgNzBdLCA4MTogWzIsIDcwXSwgODI6IFsyLCA3MF0sIDgzOiBbMiwgNzBdLCA4NDogWzIsIDcwXSwgODU6IFsyLCA3MF0gfSwgeyA0NzogWzIsIDE4XSB9LCB7IDU6IFsyLCAxNF0sIDE0OiBbMiwgMTRdLCAxNTogWzIsIDE0XSwgMTk6IFsyLCAxNF0sIDI5OiBbMiwgMTRdLCAzNDogWzIsIDE0XSwgMzk6IFsyLCAxNF0sIDQ0OiBbMiwgMTRdLCA0NzogWzIsIDE0XSwgNDg6IFsyLCAxNF0sIDUxOiBbMiwgMTRdLCA1NTogWzIsIDE0XSwgNjA6IFsyLCAxNF0gfSwgeyAzMzogWzEsIDExNF0gfSwgeyAzMzogWzIsIDg3XSwgNjU6IFsyLCA4N10sIDcyOiBbMiwgODddLCA4MDogWzIsIDg3XSwgODE6IFsyLCA4N10sIDgyOiBbMiwgODddLCA4MzogWzIsIDg3XSwgODQ6IFsyLCA4N10sIDg1OiBbMiwgODddIH0sIHsgMzM6IFsyLCA4OV0gfSwgeyAyMDogNzUsIDYzOiAxMTYsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY3OiAxMTUsIDY4OiBbMiwgOTZdLCA2OTogMTE3LCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAzMzogWzEsIDExOF0gfSwgeyAzMjogMTE5LCAzMzogWzIsIDYyXSwgNzQ6IDEyMCwgNzU6IFsxLCAxMjFdIH0sIHsgMzM6IFsyLCA1OV0sIDY1OiBbMiwgNTldLCA3MjogWzIsIDU5XSwgNzU6IFsyLCA1OV0sIDgwOiBbMiwgNTldLCA4MTogWzIsIDU5XSwgODI6IFsyLCA1OV0sIDgzOiBbMiwgNTldLCA4NDogWzIsIDU5XSwgODU6IFsyLCA1OV0gfSwgeyAzMzogWzIsIDYxXSwgNzU6IFsyLCA2MV0gfSwgeyAzMzogWzIsIDY4XSwgMzc6IDEyMiwgNzQ6IDEyMywgNzU6IFsxLCAxMjFdIH0sIHsgMzM6IFsyLCA2NV0sIDY1OiBbMiwgNjVdLCA3MjogWzIsIDY1XSwgNzU6IFsyLCA2NV0sIDgwOiBbMiwgNjVdLCA4MTogWzIsIDY1XSwgODI6IFsyLCA2NV0sIDgzOiBbMiwgNjVdLCA4NDogWzIsIDY1XSwgODU6IFsyLCA2NV0gfSwgeyAzMzogWzIsIDY3XSwgNzU6IFsyLCA2N10gfSwgeyAyMzogWzEsIDEyNF0gfSwgeyAyMzogWzIsIDUxXSwgNjU6IFsyLCA1MV0sIDcyOiBbMiwgNTFdLCA4MDogWzIsIDUxXSwgODE6IFsyLCA1MV0sIDgyOiBbMiwgNTFdLCA4MzogWzIsIDUxXSwgODQ6IFsyLCA1MV0sIDg1OiBbMiwgNTFdIH0sIHsgMjM6IFsyLCA1M10gfSwgeyAzMzogWzEsIDEyNV0gfSwgeyAzMzogWzIsIDkxXSwgNjU6IFsyLCA5MV0sIDcyOiBbMiwgOTFdLCA4MDogWzIsIDkxXSwgODE6IFsyLCA5MV0sIDgyOiBbMiwgOTFdLCA4MzogWzIsIDkxXSwgODQ6IFsyLCA5MV0sIDg1OiBbMiwgOTFdIH0sIHsgMzM6IFsyLCA5M10gfSwgeyA1OiBbMiwgMjJdLCAxNDogWzIsIDIyXSwgMTU6IFsyLCAyMl0sIDE5OiBbMiwgMjJdLCAyOTogWzIsIDIyXSwgMzQ6IFsyLCAyMl0sIDM5OiBbMiwgMjJdLCA0NDogWzIsIDIyXSwgNDc6IFsyLCAyMl0sIDQ4OiBbMiwgMjJdLCA1MTogWzIsIDIyXSwgNTU6IFsyLCAyMl0sIDYwOiBbMiwgMjJdIH0sIHsgMjM6IFsyLCA5OV0sIDMzOiBbMiwgOTldLCA1NDogWzIsIDk5XSwgNjg6IFsyLCA5OV0sIDcyOiBbMiwgOTldLCA3NTogWzIsIDk5XSB9LCB7IDczOiBbMSwgMTA5XSB9LCB7IDIwOiA3NSwgNjM6IDEyNiwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA1OiBbMiwgMjNdLCAxNDogWzIsIDIzXSwgMTU6IFsyLCAyM10sIDE5OiBbMiwgMjNdLCAyOTogWzIsIDIzXSwgMzQ6IFsyLCAyM10sIDM5OiBbMiwgMjNdLCA0NDogWzIsIDIzXSwgNDc6IFsyLCAyM10sIDQ4OiBbMiwgMjNdLCA1MTogWzIsIDIzXSwgNTU6IFsyLCAyM10sIDYwOiBbMiwgMjNdIH0sIHsgNDc6IFsyLCAxOV0gfSwgeyA0NzogWzIsIDc3XSB9LCB7IDIwOiA3NSwgMzM6IFsyLCA3Ml0sIDQxOiAxMjcsIDYzOiAxMjgsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiAxMjksIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzU6IFsyLCA3Ml0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA1OiBbMiwgMjRdLCAxNDogWzIsIDI0XSwgMTU6IFsyLCAyNF0sIDE5OiBbMiwgMjRdLCAyOTogWzIsIDI0XSwgMzQ6IFsyLCAyNF0sIDM5OiBbMiwgMjRdLCA0NDogWzIsIDI0XSwgNDc6IFsyLCAyNF0sIDQ4OiBbMiwgMjRdLCA1MTogWzIsIDI0XSwgNTU6IFsyLCAyNF0sIDYwOiBbMiwgMjRdIH0sIHsgNjg6IFsxLCAxMzBdIH0sIHsgNjU6IFsyLCA5NV0sIDY4OiBbMiwgOTVdLCA3MjogWzIsIDk1XSwgODA6IFsyLCA5NV0sIDgxOiBbMiwgOTVdLCA4MjogWzIsIDk1XSwgODM6IFsyLCA5NV0sIDg0OiBbMiwgOTVdLCA4NTogWzIsIDk1XSB9LCB7IDY4OiBbMiwgOTddIH0sIHsgNTogWzIsIDIxXSwgMTQ6IFsyLCAyMV0sIDE1OiBbMiwgMjFdLCAxOTogWzIsIDIxXSwgMjk6IFsyLCAyMV0sIDM0OiBbMiwgMjFdLCAzOTogWzIsIDIxXSwgNDQ6IFsyLCAyMV0sIDQ3OiBbMiwgMjFdLCA0ODogWzIsIDIxXSwgNTE6IFsyLCAyMV0sIDU1OiBbMiwgMjFdLCA2MDogWzIsIDIxXSB9LCB7IDMzOiBbMSwgMTMxXSB9LCB7IDMzOiBbMiwgNjNdIH0sIHsgNzI6IFsxLCAxMzNdLCA3NjogMTMyIH0sIHsgMzM6IFsxLCAxMzRdIH0sIHsgMzM6IFsyLCA2OV0gfSwgeyAxNTogWzIsIDEyXSB9LCB7IDE0OiBbMiwgMjZdLCAxNTogWzIsIDI2XSwgMTk6IFsyLCAyNl0sIDI5OiBbMiwgMjZdLCAzNDogWzIsIDI2XSwgNDc6IFsyLCAyNl0sIDQ4OiBbMiwgMjZdLCA1MTogWzIsIDI2XSwgNTU6IFsyLCAyNl0sIDYwOiBbMiwgMjZdIH0sIHsgMjM6IFsyLCAzMV0sIDMzOiBbMiwgMzFdLCA1NDogWzIsIDMxXSwgNjg6IFsyLCAzMV0sIDcyOiBbMiwgMzFdLCA3NTogWzIsIDMxXSB9LCB7IDMzOiBbMiwgNzRdLCA0MjogMTM1LCA3NDogMTM2LCA3NTogWzEsIDEyMV0gfSwgeyAzMzogWzIsIDcxXSwgNjU6IFsyLCA3MV0sIDcyOiBbMiwgNzFdLCA3NTogWzIsIDcxXSwgODA6IFsyLCA3MV0sIDgxOiBbMiwgNzFdLCA4MjogWzIsIDcxXSwgODM6IFsyLCA3MV0sIDg0OiBbMiwgNzFdLCA4NTogWzIsIDcxXSB9LCB7IDMzOiBbMiwgNzNdLCA3NTogWzIsIDczXSB9LCB7IDIzOiBbMiwgMjldLCAzMzogWzIsIDI5XSwgNTQ6IFsyLCAyOV0sIDY1OiBbMiwgMjldLCA2ODogWzIsIDI5XSwgNzI6IFsyLCAyOV0sIDc1OiBbMiwgMjldLCA4MDogWzIsIDI5XSwgODE6IFsyLCAyOV0sIDgyOiBbMiwgMjldLCA4MzogWzIsIDI5XSwgODQ6IFsyLCAyOV0sIDg1OiBbMiwgMjldIH0sIHsgMTQ6IFsyLCAxNV0sIDE1OiBbMiwgMTVdLCAxOTogWzIsIDE1XSwgMjk6IFsyLCAxNV0sIDM0OiBbMiwgMTVdLCAzOTogWzIsIDE1XSwgNDQ6IFsyLCAxNV0sIDQ3OiBbMiwgMTVdLCA0ODogWzIsIDE1XSwgNTE6IFsyLCAxNV0sIDU1OiBbMiwgMTVdLCA2MDogWzIsIDE1XSB9LCB7IDcyOiBbMSwgMTM4XSwgNzc6IFsxLCAxMzddIH0sIHsgNzI6IFsyLCAxMDBdLCA3NzogWzIsIDEwMF0gfSwgeyAxNDogWzIsIDE2XSwgMTU6IFsyLCAxNl0sIDE5OiBbMiwgMTZdLCAyOTogWzIsIDE2XSwgMzQ6IFsyLCAxNl0sIDQ0OiBbMiwgMTZdLCA0NzogWzIsIDE2XSwgNDg6IFsyLCAxNl0sIDUxOiBbMiwgMTZdLCA1NTogWzIsIDE2XSwgNjA6IFsyLCAxNl0gfSwgeyAzMzogWzEsIDEzOV0gfSwgeyAzMzogWzIsIDc1XSB9LCB7IDMzOiBbMiwgMzJdIH0sIHsgNzI6IFsyLCAxMDFdLCA3NzogWzIsIDEwMV0gfSwgeyAxNDogWzIsIDE3XSwgMTU6IFsyLCAxN10sIDE5OiBbMiwgMTddLCAyOTogWzIsIDE3XSwgMzQ6IFsyLCAxN10sIDM5OiBbMiwgMTddLCA0NDogWzIsIDE3XSwgNDc6IFsyLCAxN10sIDQ4OiBbMiwgMTddLCA1MTogWzIsIDE3XSwgNTU6IFsyLCAxN10sIDYwOiBbMiwgMTddIH1dLFxyXG5cdCAgICAgICAgZGVmYXVsdEFjdGlvbnM6IHsgNDogWzIsIDFdLCA1NTogWzIsIDU1XSwgNTc6IFsyLCAyMF0sIDYxOiBbMiwgNTddLCA3NDogWzIsIDgxXSwgODM6IFsyLCA4NV0sIDg3OiBbMiwgMThdLCA5MTogWzIsIDg5XSwgMTAyOiBbMiwgNTNdLCAxMDU6IFsyLCA5M10sIDExMTogWzIsIDE5XSwgMTEyOiBbMiwgNzddLCAxMTc6IFsyLCA5N10sIDEyMDogWzIsIDYzXSwgMTIzOiBbMiwgNjldLCAxMjQ6IFsyLCAxMl0sIDEzNjogWzIsIDc1XSwgMTM3OiBbMiwgMzJdIH0sXHJcblx0ICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xyXG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xyXG5cdCAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuXHQgICAgICAgICAgICAgICAgc3RhY2sgPSBbMF0sXHJcblx0ICAgICAgICAgICAgICAgIHZzdGFjayA9IFtudWxsXSxcclxuXHQgICAgICAgICAgICAgICAgbHN0YWNrID0gW10sXHJcblx0ICAgICAgICAgICAgICAgIHRhYmxlID0gdGhpcy50YWJsZSxcclxuXHQgICAgICAgICAgICAgICAgeXl0ZXh0ID0gXCJcIixcclxuXHQgICAgICAgICAgICAgICAgeXlsaW5lbm8gPSAwLFxyXG5cdCAgICAgICAgICAgICAgICB5eWxlbmcgPSAwLFxyXG5cdCAgICAgICAgICAgICAgICByZWNvdmVyaW5nID0gMCxcclxuXHQgICAgICAgICAgICAgICAgVEVSUk9SID0gMixcclxuXHQgICAgICAgICAgICAgICAgRU9GID0gMTtcclxuXHQgICAgICAgICAgICB0aGlzLmxleGVyLnNldElucHV0KGlucHV0KTtcclxuXHQgICAgICAgICAgICB0aGlzLmxleGVyLnl5ID0gdGhpcy55eTtcclxuXHQgICAgICAgICAgICB0aGlzLnl5LmxleGVyID0gdGhpcy5sZXhlcjtcclxuXHQgICAgICAgICAgICB0aGlzLnl5LnBhcnNlciA9IHRoaXM7XHJcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxleGVyLnl5bGxvYyA9PSBcInVuZGVmaW5lZFwiKSB0aGlzLmxleGVyLnl5bGxvYyA9IHt9O1xyXG5cdCAgICAgICAgICAgIHZhciB5eWxvYyA9IHRoaXMubGV4ZXIueXlsbG9jO1xyXG5cdCAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5bG9jKTtcclxuXHQgICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5sZXhlci5vcHRpb25zICYmIHRoaXMubGV4ZXIub3B0aW9ucy5yYW5nZXM7XHJcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnl5LnBhcnNlRXJyb3IgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5wYXJzZUVycm9yID0gdGhpcy55eS5wYXJzZUVycm9yO1xyXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHBvcFN0YWNrKG4pIHtcclxuXHQgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XHJcblx0ICAgICAgICAgICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcclxuXHQgICAgICAgICAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBmdW5jdGlvbiBsZXgoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbjtcclxuXHQgICAgICAgICAgICAgICAgdG9rZW4gPSBzZWxmLmxleGVyLmxleCgpIHx8IDE7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09IFwibnVtYmVyXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB2YXIgc3ltYm9sLFxyXG5cdCAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCxcclxuXHQgICAgICAgICAgICAgICAgc3RhdGUsXHJcblx0ICAgICAgICAgICAgICAgIGFjdGlvbixcclxuXHQgICAgICAgICAgICAgICAgYSxcclxuXHQgICAgICAgICAgICAgICAgcixcclxuXHQgICAgICAgICAgICAgICAgeXl2YWwgPSB7fSxcclxuXHQgICAgICAgICAgICAgICAgcCxcclxuXHQgICAgICAgICAgICAgICAgbGVuLFxyXG5cdCAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcclxuXHQgICAgICAgICAgICAgICAgZXhwZWN0ZWQ7XHJcblx0ICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09IFwidW5kZWZpbmVkXCIgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVyclN0ciA9IFwiXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY292ZXJpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IDIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaChcIidcIiArIHRoaXMudGVybWluYWxzX1twXSArIFwiJ1wiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9IFwiUGFyc2UgZXJyb3Igb24gbGluZSBcIiArICh5eWxpbmVubyArIDEpICsgXCI6XFxuXCIgKyB0aGlzLmxleGVyLnNob3dQb3NpdGlvbigpICsgXCJcXG5FeHBlY3RpbmcgXCIgKyBleHBlY3RlZC5qb2luKFwiLCBcIikgKyBcIiwgZ290ICdcIiArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgXCInXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gXCJQYXJzZSBlcnJvciBvbiBsaW5lIFwiICsgKHl5bGluZW5vICsgMSkgKyBcIjogVW5leHBlY3RlZCBcIiArIChzeW1ib2wgPT0gMSA/IFwiZW5kIG9mIGlucHV0XCIgOiBcIidcIiArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgXCInXCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7IHRleHQ6IHRoaXMubGV4ZXIubWF0Y2gsIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsIGxpbmU6IHRoaXMubGV4ZXIueXlsaW5lbm8sIGxvYzogeXlsb2MsIGV4cGVjdGVkOiBleHBlY3RlZCB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiBcIiArIHN0YXRlICsgXCIsIHRva2VuOiBcIiArIHN5bWJvbCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdnN0YWNrLnB1c2godGhpcy5sZXhlci55eXRleHQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxzdGFjay5wdXNoKHRoaXMubGV4ZXIueXlsbG9jKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl5bGVuZyA9IHRoaXMubGV4ZXIueXlsZW5nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB5eXRleHQgPSB0aGlzLmxleGVyLnl5dGV4dDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXlsaW5lbm8gPSB0aGlzLmxleGVyLnl5bGluZW5vO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB5eWxvYyA9IHRoaXMubGV4ZXIueXlsbG9jO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHJlY292ZXJpbmctLTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeXl2YWwuXyQgPSB7IGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfbGluZSwgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSwgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbiwgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9jb2x1bW4gfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW2xzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwoeXl2YWwsIHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgdGhpcy55eSwgYWN0aW9uWzFdLCB2c3RhY2ssIGxzdGFjayk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0YWJsZVtzdGFja1tzdGFjay5sZW5ndGggLSAyXV1bc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cdCAgICAvKiBKaXNvbiBnZW5lcmF0ZWQgbGV4ZXIgKi9cclxuXHQgICAgdmFyIGxleGVyID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHZhciBsZXhlciA9IHsgRU9GOiAxLFxyXG5cdCAgICAgICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnl5LnBhcnNlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHNldElucHV0OiBmdW5jdGlvbiBzZXRJbnB1dChpbnB1dCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb3JlID0gdGhpcy5fbGVzcyA9IHRoaXMuZG9uZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYyA9IHsgZmlyc3RfbGluZTogMSwgZmlyc3RfY29sdW1uOiAwLCBsYXN0X2xpbmU6IDEsIGxhc3RfY29sdW1uOiAwIH07XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLCAwXTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbiBpbnB1dCgpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnl5bGVuZysrO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCsrO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm1hdGNoICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGNoLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGxpbmVzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUrKztcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2g7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICB1bnB1dDogZnVuY3Rpb24gdW5wdXQoY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgIC8vdGhpcy55eWxlbmcgLT0gbGVuO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XHJcblx0ICAgICAgICAgICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIDEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jID0geyBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMCkgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBtb3JlOiBmdW5jdGlvbiBtb3JlKCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBsZXNzOiBmdW5jdGlvbiBsZXNzKG4pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHBhc3RJbnB1dDogZnVuY3Rpb24gcGFzdElucHV0KCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uIHVwY29taW5nSW5wdXQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcclxuXHQgICAgICAgICAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwIC0gbmV4dC5sZW5ndGgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwgMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJyA6ICcnKSkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbiBzaG93UG9zaXRpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbihcIi1cIik7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjICsgXCJeXCI7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkgdGhpcy5kb25lID0gdHJ1ZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciB0b2tlbiwgbWF0Y2gsIHRlbXBNYXRjaCwgaW5kZXgsIGNvbCwgbGluZXM7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy55eXRleHQgPSAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMpIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7IGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGggfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3RoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArPSB0aGlzLnl5bGVuZ107XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gbWF0Y2hbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIHJ1bGVzW2luZGV4XSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHRoaXMuZG9uZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSByZXR1cm4gdG9rZW47ZWxzZSByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwgeyB0ZXh0OiBcIlwiLCB0b2tlbjogbnVsbCwgbGluZTogdGhpcy55eWxpbmVubyB9KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgbGV4OiBmdW5jdGlvbiBsZXgoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGJlZ2luOiBmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24gcG9wU3RhdGUoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgX2N1cnJlbnRSdWxlczogZnVuY3Rpb24gX2N1cnJlbnRSdWxlcygpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uIHRvcFN0YXRlKCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDJdO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xyXG5cdCAgICAgICAgICAgIH0gfTtcclxuXHQgICAgICAgIGxleGVyLm9wdGlvbnMgPSB7fTtcclxuXHQgICAgICAgIGxleGVyLnBlcmZvcm1BY3Rpb24gPSBmdW5jdGlvbiBhbm9ueW1vdXMoeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlRcclxuXHQgICAgICAgIC8qKi8pIHtcclxuXHJcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc3RyaXAoc3RhcnQsIGVuZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4geXlfLnl5dGV4dCA9IHl5Xy55eXRleHQuc3Vic3RyKHN0YXJ0LCB5eV8ueXlsZW5nIC0gZW5kKTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHZhciBZWVNUQVRFID0gWVlfU1RBUlQ7XHJcblx0ICAgICAgICAgICAgc3dpdGNoICgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh5eV8ueXl0ZXh0LnNsaWNlKC0yKSA9PT0gXCJcXFxcXFxcXFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAoMCwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihcIm11XCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh5eV8ueXl0ZXh0LnNsaWNlKC0xKSA9PT0gXCJcXFxcXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJpcCgwLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKFwiZW11XCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKFwibXVcIik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoeXlfLnl5dGV4dCkgcmV0dXJuIDE1O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE1O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKCdyYXcnKTtyZXR1cm4gMTU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHVzaW5nIGB0aGlzLnRvcFN0YXRlKClgIGJlbG93LCBidXQgaXQgY3VycmVudGx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRoZSBzZWNvbmQgdG9wIGluc3RlYWQgb2YgdGhlIGZpcnN0IHRvcC4gT3BlbmVkIGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBpc3N1ZSBhYm91dCBpdCBhdCBodHRwczovL2dpdGh1Yi5jb20vemFhY2gvamlzb24vaXNzdWVzLzI5MVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSA9PT0gJ3JhdycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cig1LCB5eV8ueXlsZW5nIC0gOSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdFTkRfUkFXX0JMT0NLJztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDY1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgODpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA2ODtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDk6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxMDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oJ3JhdycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDIzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDExOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDU1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTI6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNjA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxMzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAyOTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQ3O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTU6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7cmV0dXJuIDQ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTY6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7cmV0dXJuIDQ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTc6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMzQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxODpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAzOTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDUxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjA6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyMTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudW5wdXQoeXlfLnl5dGV4dCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKCdjb20nKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyMjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyMzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA0ODtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDczO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjU6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyNjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA3MjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg3O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjg6XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjk6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7cmV0dXJuIDU0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7cmV0dXJuIDMzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzE6XHJcblx0ICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0gc3RyaXAoMSwgMikucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO3JldHVybiA4MDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDMyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgeXlfLnl5dGV4dCA9IHN0cmlwKDEsIDIpLnJlcGxhY2UoL1xcXFwnL2csIFwiJ1wiKTtyZXR1cm4gODA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDgyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzU6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gODI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA4MztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDg0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzg6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gODE7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA3NTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDc3O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDE6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0MjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnJlcGxhY2UoL1xcXFwoW1xcXFxcXF1dKS9nLCAnJDEnKTtyZXR1cm4gNzI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0MzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0NDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgIGxleGVyLnJ1bGVzID0gWy9eKD86W15cXHgwMF0qPyg/PShcXHtcXHspKSkvLCAvXig/OlteXFx4MDBdKykvLCAvXig/OlteXFx4MDBdezIsfT8oPz0oXFx7XFx7fFxcXFxcXHtcXHt8XFxcXFxcXFxcXHtcXHt8JCkpKS8sIC9eKD86XFx7XFx7XFx7XFx7KD89W15cXC9dKSkvLCAvXig/Olxce1xce1xce1xce1xcL1teXFxzIVwiIyUtLFxcLlxcLzstPkBcXFstXFxeYFxcey1+XSsoPz1bPX1cXHNcXC8uXSlcXH1cXH1cXH1cXH0pLywgL14oPzpbXlxceDAwXSo/KD89KFxce1xce1xce1xceykpKS8sIC9eKD86W1xcc1xcU10qPy0tKH4pP1xcfVxcfSkvLCAvXig/OlxcKCkvLCAvXig/OlxcKSkvLCAvXig/Olxce1xce1xce1xceykvLCAvXig/OlxcfVxcfVxcfVxcfSkvLCAvXig/Olxce1xceyh+KT8+KS8sIC9eKD86XFx7XFx7KH4pPyM+KS8sIC9eKD86XFx7XFx7KH4pPyNcXCo/KS8sIC9eKD86XFx7XFx7KH4pP1xcLykvLCAvXig/Olxce1xceyh+KT9cXF5cXHMqKH4pP1xcfVxcfSkvLCAvXig/Olxce1xceyh+KT9cXHMqZWxzZVxccyoofik/XFx9XFx9KS8sIC9eKD86XFx7XFx7KH4pP1xcXikvLCAvXig/Olxce1xceyh+KT9cXHMqZWxzZVxcYikvLCAvXig/Olxce1xceyh+KT9cXHspLywgL14oPzpcXHtcXHsofik/JikvLCAvXig/Olxce1xceyh+KT8hLS0pLywgL14oPzpcXHtcXHsofik/IVtcXHNcXFNdKj9cXH1cXH0pLywgL14oPzpcXHtcXHsofik/XFwqPykvLCAvXig/Oj0pLywgL14oPzpcXC5cXC4pLywgL14oPzpcXC4oPz0oWz1+fVxcc1xcLy4pfF0pKSkvLCAvXig/OltcXC8uXSkvLCAvXig/OlxccyspLywgL14oPzpcXH0ofik/XFx9XFx9KS8sIC9eKD86KH4pP1xcfVxcfSkvLCAvXig/OlwiKFxcXFxbXCJdfFteXCJdKSpcIikvLCAvXig/OicoXFxcXFsnXXxbXiddKSonKS8sIC9eKD86QCkvLCAvXig/OnRydWUoPz0oW359XFxzKV0pKSkvLCAvXig/OmZhbHNlKD89KFt+fVxccyldKSkpLywgL14oPzp1bmRlZmluZWQoPz0oW359XFxzKV0pKSkvLCAvXig/Om51bGwoPz0oW359XFxzKV0pKSkvLCAvXig/Oi0/WzAtOV0rKD86XFwuWzAtOV0rKT8oPz0oW359XFxzKV0pKSkvLCAvXig/OmFzXFxzK1xcfCkvLCAvXig/OlxcfCkvLCAvXig/OihbXlxccyFcIiMlLSxcXC5cXC87LT5AXFxbLVxcXmBcXHstfl0rKD89KFs9fn1cXHNcXC8uKXxdKSkpKS8sIC9eKD86XFxbKFxcXFxcXF18W15cXF1dKSpcXF0pLywgL14oPzouKS8sIC9eKD86JCkvXTtcclxuXHQgICAgICAgIGxleGVyLmNvbmRpdGlvbnMgPSB7IFwibXVcIjogeyBcInJ1bGVzXCI6IFs3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCwgNDEsIDQyLCA0MywgNDRdLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcImVtdVwiOiB7IFwicnVsZXNcIjogWzJdLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcImNvbVwiOiB7IFwicnVsZXNcIjogWzZdLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcInJhd1wiOiB7IFwicnVsZXNcIjogWzMsIDQsIDVdLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcIklOSVRJQUxcIjogeyBcInJ1bGVzXCI6IFswLCAxLCA0NF0sIFwiaW5jbHVzaXZlXCI6IHRydWUgfSB9O1xyXG5cdCAgICAgICAgcmV0dXJuIGxleGVyO1xyXG5cdCAgICB9KSgpO1xyXG5cdCAgICBwYXJzZXIubGV4ZXIgPSBsZXhlcjtcclxuXHQgICAgZnVuY3Rpb24gUGFyc2VyKCkge1xyXG5cdCAgICAgICAgdGhpcy55eSA9IHt9O1xyXG5cdCAgICB9UGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xyXG5cdCAgICByZXR1cm4gbmV3IFBhcnNlcigpO1xyXG5cdH0pKCk7ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBoYW5kbGViYXJzO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzggKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3Zpc2l0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcclxuXHJcblx0dmFyIF92aXNpdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Zpc2l0b3IpO1xyXG5cclxuXHRmdW5jdGlvbiBXaGl0ZXNwYWNlQ29udHJvbCgpIHtcclxuXHQgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XHJcblxyXG5cdCAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHR9XHJcblx0V2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlID0gbmV3IF92aXNpdG9yMlsnZGVmYXVsdCddKCk7XHJcblxyXG5cdFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5Qcm9ncmFtID0gZnVuY3Rpb24gKHByb2dyYW0pIHtcclxuXHQgIHZhciBkb1N0YW5kYWxvbmUgPSAhdGhpcy5vcHRpb25zLmlnbm9yZVN0YW5kYWxvbmU7XHJcblxyXG5cdCAgdmFyIGlzUm9vdCA9ICF0aGlzLmlzUm9vdFNlZW47XHJcblx0ICB0aGlzLmlzUm9vdFNlZW4gPSB0cnVlO1xyXG5cclxuXHQgIHZhciBib2R5ID0gcHJvZ3JhbS5ib2R5O1xyXG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBib2R5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICB2YXIgY3VycmVudCA9IGJvZHlbaV0sXHJcblx0ICAgICAgICBzdHJpcCA9IHRoaXMuYWNjZXB0KGN1cnJlbnQpO1xyXG5cclxuXHQgICAgaWYgKCFzdHJpcCkge1xyXG5cdCAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgX2lzUHJldldoaXRlc3BhY2UgPSBpc1ByZXZXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCksXHJcblx0ICAgICAgICBfaXNOZXh0V2hpdGVzcGFjZSA9IGlzTmV4dFdoaXRlc3BhY2UoYm9keSwgaSwgaXNSb290KSxcclxuXHQgICAgICAgIG9wZW5TdGFuZGFsb25lID0gc3RyaXAub3BlblN0YW5kYWxvbmUgJiYgX2lzUHJldldoaXRlc3BhY2UsXHJcblx0ICAgICAgICBjbG9zZVN0YW5kYWxvbmUgPSBzdHJpcC5jbG9zZVN0YW5kYWxvbmUgJiYgX2lzTmV4dFdoaXRlc3BhY2UsXHJcblx0ICAgICAgICBpbmxpbmVTdGFuZGFsb25lID0gc3RyaXAuaW5saW5lU3RhbmRhbG9uZSAmJiBfaXNQcmV2V2hpdGVzcGFjZSAmJiBfaXNOZXh0V2hpdGVzcGFjZTtcclxuXHJcblx0ICAgIGlmIChzdHJpcC5jbG9zZSkge1xyXG5cdCAgICAgIG9taXRSaWdodChib2R5LCBpLCB0cnVlKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAoc3RyaXAub3Blbikge1xyXG5cdCAgICAgIG9taXRMZWZ0KGJvZHksIGksIHRydWUpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoZG9TdGFuZGFsb25lICYmIGlubGluZVN0YW5kYWxvbmUpIHtcclxuXHQgICAgICBvbWl0UmlnaHQoYm9keSwgaSk7XHJcblxyXG5cdCAgICAgIGlmIChvbWl0TGVmdChib2R5LCBpKSkge1xyXG5cdCAgICAgICAgLy8gSWYgd2UgYXJlIG9uIGEgc3RhbmRhbG9uZSBub2RlLCBzYXZlIHRoZSBpbmRlbnQgaW5mbyBmb3IgcGFydGlhbHNcclxuXHQgICAgICAgIGlmIChjdXJyZW50LnR5cGUgPT09ICdQYXJ0aWFsU3RhdGVtZW50Jykge1xyXG5cdCAgICAgICAgICAvLyBQdWxsIG91dCB0aGUgd2hpdGVzcGFjZSBmcm9tIHRoZSBmaW5hbCBsaW5lXHJcblx0ICAgICAgICAgIGN1cnJlbnQuaW5kZW50ID0gLyhbIFxcdF0rJCkvLmV4ZWMoYm9keVtpIC0gMV0ub3JpZ2luYWwpWzFdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICBpZiAoZG9TdGFuZGFsb25lICYmIG9wZW5TdGFuZGFsb25lKSB7XHJcblx0ICAgICAgb21pdFJpZ2h0KChjdXJyZW50LnByb2dyYW0gfHwgY3VycmVudC5pbnZlcnNlKS5ib2R5KTtcclxuXHJcblx0ICAgICAgLy8gU3RyaXAgb3V0IHRoZSBwcmV2aW91cyBjb250ZW50IG5vZGUgaWYgaXQncyB3aGl0ZXNwYWNlIG9ubHlcclxuXHQgICAgICBvbWl0TGVmdChib2R5LCBpKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAoZG9TdGFuZGFsb25lICYmIGNsb3NlU3RhbmRhbG9uZSkge1xyXG5cdCAgICAgIC8vIEFsd2F5cyBzdHJpcCB0aGUgbmV4dCBub2RlXHJcblx0ICAgICAgb21pdFJpZ2h0KGJvZHksIGkpO1xyXG5cclxuXHQgICAgICBvbWl0TGVmdCgoY3VycmVudC5pbnZlcnNlIHx8IGN1cnJlbnQucHJvZ3JhbSkuYm9keSk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4gcHJvZ3JhbTtcclxuXHR9O1xyXG5cclxuXHRXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuQmxvY2tTdGF0ZW1lbnQgPSBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuRGVjb3JhdG9yQmxvY2sgPSBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUGFydGlhbEJsb2NrU3RhdGVtZW50ID0gZnVuY3Rpb24gKGJsb2NrKSB7XHJcblx0ICB0aGlzLmFjY2VwdChibG9jay5wcm9ncmFtKTtcclxuXHQgIHRoaXMuYWNjZXB0KGJsb2NrLmludmVyc2UpO1xyXG5cclxuXHQgIC8vIEZpbmQgdGhlIGludmVyc2UgcHJvZ3JhbSB0aGF0IGlzIGludm9sZWQgd2l0aCB3aGl0ZXNwYWNlIHN0cmlwcGluZy5cclxuXHQgIHZhciBwcm9ncmFtID0gYmxvY2sucHJvZ3JhbSB8fCBibG9jay5pbnZlcnNlLFxyXG5cdCAgICAgIGludmVyc2UgPSBibG9jay5wcm9ncmFtICYmIGJsb2NrLmludmVyc2UsXHJcblx0ICAgICAgZmlyc3RJbnZlcnNlID0gaW52ZXJzZSxcclxuXHQgICAgICBsYXN0SW52ZXJzZSA9IGludmVyc2U7XHJcblxyXG5cdCAgaWYgKGludmVyc2UgJiYgaW52ZXJzZS5jaGFpbmVkKSB7XHJcblx0ICAgIGZpcnN0SW52ZXJzZSA9IGludmVyc2UuYm9keVswXS5wcm9ncmFtO1xyXG5cclxuXHQgICAgLy8gV2FsayB0aGUgaW52ZXJzZSBjaGFpbiB0byBmaW5kIHRoZSBsYXN0IGludmVyc2UgdGhhdCBpcyBhY3R1YWxseSBpbiB0aGUgY2hhaW4uXHJcblx0ICAgIHdoaWxlIChsYXN0SW52ZXJzZS5jaGFpbmVkKSB7XHJcblx0ICAgICAgbGFzdEludmVyc2UgPSBsYXN0SW52ZXJzZS5ib2R5W2xhc3RJbnZlcnNlLmJvZHkubGVuZ3RoIC0gMV0ucHJvZ3JhbTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBzdHJpcCA9IHtcclxuXHQgICAgb3BlbjogYmxvY2sub3BlblN0cmlwLm9wZW4sXHJcblx0ICAgIGNsb3NlOiBibG9jay5jbG9zZVN0cmlwLmNsb3NlLFxyXG5cclxuXHQgICAgLy8gRGV0ZXJtaW5lIHRoZSBzdGFuZGFsb25lIGNhbmRpYWN5LiBCYXNpY2FsbHkgZmxhZyBvdXIgY29udGVudCBhcyBiZWluZyBwb3NzaWJseSBzdGFuZGFsb25lXHJcblx0ICAgIC8vIHNvIG91ciBwYXJlbnQgY2FuIGRldGVybWluZSBpZiB3ZSBhY3R1YWxseSBhcmUgc3RhbmRhbG9uZVxyXG5cdCAgICBvcGVuU3RhbmRhbG9uZTogaXNOZXh0V2hpdGVzcGFjZShwcm9ncmFtLmJvZHkpLFxyXG5cdCAgICBjbG9zZVN0YW5kYWxvbmU6IGlzUHJldldoaXRlc3BhY2UoKGZpcnN0SW52ZXJzZSB8fCBwcm9ncmFtKS5ib2R5KVxyXG5cdCAgfTtcclxuXHJcblx0ICBpZiAoYmxvY2sub3BlblN0cmlwLmNsb3NlKSB7XHJcblx0ICAgIG9taXRSaWdodChwcm9ncmFtLmJvZHksIG51bGwsIHRydWUpO1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChpbnZlcnNlKSB7XHJcblx0ICAgIHZhciBpbnZlcnNlU3RyaXAgPSBibG9jay5pbnZlcnNlU3RyaXA7XHJcblxyXG5cdCAgICBpZiAoaW52ZXJzZVN0cmlwLm9wZW4pIHtcclxuXHQgICAgICBvbWl0TGVmdChwcm9ncmFtLmJvZHksIG51bGwsIHRydWUpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoaW52ZXJzZVN0cmlwLmNsb3NlKSB7XHJcblx0ICAgICAgb21pdFJpZ2h0KGZpcnN0SW52ZXJzZS5ib2R5LCBudWxsLCB0cnVlKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAoYmxvY2suY2xvc2VTdHJpcC5vcGVuKSB7XHJcblx0ICAgICAgb21pdExlZnQobGFzdEludmVyc2UuYm9keSwgbnVsbCwgdHJ1ZSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIEZpbmQgc3RhbmRhbG9uZSBlbHNlIHN0YXRtZW50c1xyXG5cdCAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVTdGFuZGFsb25lICYmIGlzUHJldldoaXRlc3BhY2UocHJvZ3JhbS5ib2R5KSAmJiBpc05leHRXaGl0ZXNwYWNlKGZpcnN0SW52ZXJzZS5ib2R5KSkge1xyXG5cdCAgICAgIG9taXRMZWZ0KHByb2dyYW0uYm9keSk7XHJcblx0ICAgICAgb21pdFJpZ2h0KGZpcnN0SW52ZXJzZS5ib2R5KTtcclxuXHQgICAgfVxyXG5cdCAgfSBlbHNlIGlmIChibG9jay5jbG9zZVN0cmlwLm9wZW4pIHtcclxuXHQgICAgb21pdExlZnQocHJvZ3JhbS5ib2R5LCBudWxsLCB0cnVlKTtcclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4gc3RyaXA7XHJcblx0fTtcclxuXHJcblx0V2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkRlY29yYXRvciA9IFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5NdXN0YWNoZVN0YXRlbWVudCA9IGZ1bmN0aW9uIChtdXN0YWNoZSkge1xyXG5cdCAgcmV0dXJuIG11c3RhY2hlLnN0cmlwO1xyXG5cdH07XHJcblxyXG5cdFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5QYXJ0aWFsU3RhdGVtZW50ID0gV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkNvbW1lbnRTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgIHZhciBzdHJpcCA9IG5vZGUuc3RyaXAgfHwge307XHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICBpbmxpbmVTdGFuZGFsb25lOiB0cnVlLFxyXG5cdCAgICBvcGVuOiBzdHJpcC5vcGVuLFxyXG5cdCAgICBjbG9zZTogc3RyaXAuY2xvc2VcclxuXHQgIH07XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gaXNQcmV2V2hpdGVzcGFjZShib2R5LCBpLCBpc1Jvb3QpIHtcclxuXHQgIGlmIChpID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgaSA9IGJvZHkubGVuZ3RoO1xyXG5cdCAgfVxyXG5cclxuXHQgIC8vIE5vZGVzIHRoYXQgZW5kIHdpdGggbmV3bGluZXMgYXJlIGNvbnNpZGVyZWQgd2hpdGVzcGFjZSAoYnV0IGFyZSBzcGVjaWFsXHJcblx0ICAvLyBjYXNlZCBmb3Igc3RyaXAgb3BlcmF0aW9ucylcclxuXHQgIHZhciBwcmV2ID0gYm9keVtpIC0gMV0sXHJcblx0ICAgICAgc2libGluZyA9IGJvZHlbaSAtIDJdO1xyXG5cdCAgaWYgKCFwcmV2KSB7XHJcblx0ICAgIHJldHVybiBpc1Jvb3Q7XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKHByZXYudHlwZSA9PT0gJ0NvbnRlbnRTdGF0ZW1lbnQnKSB7XHJcblx0ICAgIHJldHVybiAoc2libGluZyB8fCAhaXNSb290ID8gL1xccj9cXG5cXHMqPyQvIDogLyhefFxccj9cXG4pXFxzKj8kLykudGVzdChwcmV2Lm9yaWdpbmFsKTtcclxuXHQgIH1cclxuXHR9XHJcblx0ZnVuY3Rpb24gaXNOZXh0V2hpdGVzcGFjZShib2R5LCBpLCBpc1Jvb3QpIHtcclxuXHQgIGlmIChpID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgaSA9IC0xO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBuZXh0ID0gYm9keVtpICsgMV0sXHJcblx0ICAgICAgc2libGluZyA9IGJvZHlbaSArIDJdO1xyXG5cdCAgaWYgKCFuZXh0KSB7XHJcblx0ICAgIHJldHVybiBpc1Jvb3Q7XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKG5leHQudHlwZSA9PT0gJ0NvbnRlbnRTdGF0ZW1lbnQnKSB7XHJcblx0ICAgIHJldHVybiAoc2libGluZyB8fCAhaXNSb290ID8gL15cXHMqP1xccj9cXG4vIDogL15cXHMqPyhcXHI/XFxufCQpLykudGVzdChuZXh0Lm9yaWdpbmFsKTtcclxuXHQgIH1cclxuXHR9XHJcblxyXG5cdC8vIE1hcmtzIHRoZSBub2RlIHRvIHRoZSByaWdodCBvZiB0aGUgcG9zaXRpb24gYXMgb21pdHRlZC5cclxuXHQvLyBJLmUuIHt7Zm9vfX0nICcgd2lsbCBtYXJrIHRoZSAnICcgbm9kZSBhcyBvbWl0dGVkLlxyXG5cdC8vXHJcblx0Ly8gSWYgaSBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgbWFya2VkIGFzIHN1Y2guXHJcblx0Ly9cclxuXHQvLyBJZiBtdWxpdHBsZSBpcyB0cnV0aHkgdGhlbiBhbGwgd2hpdGVzcGFjZSB3aWxsIGJlIHN0cmlwcGVkIG91dCB1bnRpbCBub24td2hpdGVzcGFjZVxyXG5cdC8vIGNvbnRlbnQgaXMgbWV0LlxyXG5cdGZ1bmN0aW9uIG9taXRSaWdodChib2R5LCBpLCBtdWx0aXBsZSkge1xyXG5cdCAgdmFyIGN1cnJlbnQgPSBib2R5W2kgPT0gbnVsbCA/IDAgOiBpICsgMV07XHJcblx0ICBpZiAoIWN1cnJlbnQgfHwgY3VycmVudC50eXBlICE9PSAnQ29udGVudFN0YXRlbWVudCcgfHwgIW11bHRpcGxlICYmIGN1cnJlbnQucmlnaHRTdHJpcHBlZCkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblxyXG5cdCAgdmFyIG9yaWdpbmFsID0gY3VycmVudC52YWx1ZTtcclxuXHQgIGN1cnJlbnQudmFsdWUgPSBjdXJyZW50LnZhbHVlLnJlcGxhY2UobXVsdGlwbGUgPyAvXlxccysvIDogL15bIFxcdF0qXFxyP1xcbj8vLCAnJyk7XHJcblx0ICBjdXJyZW50LnJpZ2h0U3RyaXBwZWQgPSBjdXJyZW50LnZhbHVlICE9PSBvcmlnaW5hbDtcclxuXHR9XHJcblxyXG5cdC8vIE1hcmtzIHRoZSBub2RlIHRvIHRoZSBsZWZ0IG9mIHRoZSBwb3NpdGlvbiBhcyBvbWl0dGVkLlxyXG5cdC8vIEkuZS4gJyAne3tmb299fSB3aWxsIG1hcmsgdGhlICcgJyBub2RlIGFzIG9taXR0ZWQuXHJcblx0Ly9cclxuXHQvLyBJZiBpIGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBsYXN0IGNoaWxkIHdpbGwgYmUgbWFya2VkIGFzIHN1Y2guXHJcblx0Ly9cclxuXHQvLyBJZiBtdWxpdHBsZSBpcyB0cnV0aHkgdGhlbiBhbGwgd2hpdGVzcGFjZSB3aWxsIGJlIHN0cmlwcGVkIG91dCB1bnRpbCBub24td2hpdGVzcGFjZVxyXG5cdC8vIGNvbnRlbnQgaXMgbWV0LlxyXG5cdGZ1bmN0aW9uIG9taXRMZWZ0KGJvZHksIGksIG11bHRpcGxlKSB7XHJcblx0ICB2YXIgY3VycmVudCA9IGJvZHlbaSA9PSBudWxsID8gYm9keS5sZW5ndGggLSAxIDogaSAtIDFdO1xyXG5cdCAgaWYgKCFjdXJyZW50IHx8IGN1cnJlbnQudHlwZSAhPT0gJ0NvbnRlbnRTdGF0ZW1lbnQnIHx8ICFtdWx0aXBsZSAmJiBjdXJyZW50LmxlZnRTdHJpcHBlZCkge1xyXG5cdCAgICByZXR1cm47XHJcblx0ICB9XHJcblxyXG5cdCAgLy8gV2Ugb21pdCB0aGUgbGFzdCBub2RlIGlmIGl0J3Mgd2hpdGVzcGFjZSBvbmx5IGFuZCBub3QgcHJlY2VlZGVkIGJ5IGEgbm9uLWNvbnRlbnQgbm9kZS5cclxuXHQgIHZhciBvcmlnaW5hbCA9IGN1cnJlbnQudmFsdWU7XHJcblx0ICBjdXJyZW50LnZhbHVlID0gY3VycmVudC52YWx1ZS5yZXBsYWNlKG11bHRpcGxlID8gL1xccyskLyA6IC9bIFxcdF0rJC8sICcnKTtcclxuXHQgIGN1cnJlbnQubGVmdFN0cmlwcGVkID0gY3VycmVudC52YWx1ZSAhPT0gb3JpZ2luYWw7XHJcblx0ICByZXR1cm4gY3VycmVudC5sZWZ0U3RyaXBwZWQ7XHJcblx0fVxyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBXaGl0ZXNwYWNlQ29udHJvbDtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0ZnVuY3Rpb24gVmlzaXRvcigpIHtcclxuXHQgIHRoaXMucGFyZW50cyA9IFtdO1xyXG5cdH1cclxuXHJcblx0VmlzaXRvci5wcm90b3R5cGUgPSB7XHJcblx0ICBjb25zdHJ1Y3RvcjogVmlzaXRvcixcclxuXHQgIG11dGF0aW5nOiBmYWxzZSxcclxuXHJcblx0ICAvLyBWaXNpdHMgYSBnaXZlbiB2YWx1ZS4gSWYgbXV0YXRpbmcsIHdpbGwgcmVwbGFjZSB0aGUgdmFsdWUgaWYgbmVjZXNzYXJ5LlxyXG5cdCAgYWNjZXB0S2V5OiBmdW5jdGlvbiBhY2NlcHRLZXkobm9kZSwgbmFtZSkge1xyXG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLmFjY2VwdChub2RlW25hbWVdKTtcclxuXHQgICAgaWYgKHRoaXMubXV0YXRpbmcpIHtcclxuXHQgICAgICAvLyBIYWNreSBzYW5pdHkgY2hlY2s6IFRoaXMgbWF5IGhhdmUgYSBmZXcgZmFsc2UgcG9zaXRpdmVzIGZvciB0eXBlIGZvciB0aGUgaGVscGVyXHJcblx0ICAgICAgLy8gbWV0aG9kcyBidXQgd2lsbCBnZW5lcmFsbHkgZG8gdGhlIHJpZ2h0IHRoaW5nIHdpdGhvdXQgYSBsb3Qgb2Ygb3ZlcmhlYWQuXHJcblx0ICAgICAgaWYgKHZhbHVlICYmICFWaXNpdG9yLnByb3RvdHlwZVt2YWx1ZS50eXBlXSkge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1VuZXhwZWN0ZWQgbm9kZSB0eXBlIFwiJyArIHZhbHVlLnR5cGUgKyAnXCIgZm91bmQgd2hlbiBhY2NlcHRpbmcgJyArIG5hbWUgKyAnIG9uICcgKyBub2RlLnR5cGUpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBub2RlW25hbWVdID0gdmFsdWU7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gUGVyZm9ybXMgYW4gYWNjZXB0IG9wZXJhdGlvbiB3aXRoIGFkZGVkIHNhbml0eSBjaGVjayB0byBlbnN1cmVcclxuXHQgIC8vIHJlcXVpcmVkIGtleXMgYXJlIG5vdCByZW1vdmVkLlxyXG5cdCAgYWNjZXB0UmVxdWlyZWQ6IGZ1bmN0aW9uIGFjY2VwdFJlcXVpcmVkKG5vZGUsIG5hbWUpIHtcclxuXHQgICAgdGhpcy5hY2NlcHRLZXkobm9kZSwgbmFtZSk7XHJcblxyXG5cdCAgICBpZiAoIW5vZGVbbmFtZV0pIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXShub2RlLnR5cGUgKyAnIHJlcXVpcmVzICcgKyBuYW1lKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBUcmF2ZXJzZXMgYSBnaXZlbiBhcnJheS4gSWYgbXV0YXRpbmcsIGVtcHR5IHJlc3Buc2VzIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAgLy8gZm9yIGNoaWxkIGVsZW1lbnRzLlxyXG5cdCAgYWNjZXB0QXJyYXk6IGZ1bmN0aW9uIGFjY2VwdEFycmF5KGFycmF5KSB7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgICAgdGhpcy5hY2NlcHRLZXkoYXJyYXksIGkpO1xyXG5cclxuXHQgICAgICBpZiAoIWFycmF5W2ldKSB7XHJcblx0ICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICBpLS07XHJcblx0ICAgICAgICBsLS07XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIGFjY2VwdDogZnVuY3Rpb24gYWNjZXB0KG9iamVjdCkge1xyXG5cdCAgICBpZiAoIW9iamVjdCkge1xyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IFNhbml0eSBjb2RlICovXHJcblx0ICAgIGlmICghdGhpc1tvYmplY3QudHlwZV0pIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVW5rbm93biB0eXBlOiAnICsgb2JqZWN0LnR5cGUsIG9iamVjdCk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcclxuXHQgICAgICB0aGlzLnBhcmVudHMudW5zaGlmdCh0aGlzLmN1cnJlbnQpO1xyXG5cdCAgICB9XHJcblx0ICAgIHRoaXMuY3VycmVudCA9IG9iamVjdDtcclxuXHJcblx0ICAgIHZhciByZXQgPSB0aGlzW29iamVjdC50eXBlXShvYmplY3QpO1xyXG5cclxuXHQgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5wYXJlbnRzLnNoaWZ0KCk7XHJcblxyXG5cdCAgICBpZiAoIXRoaXMubXV0YXRpbmcgfHwgcmV0KSB7XHJcblx0ICAgICAgcmV0dXJuIHJldDtcclxuXHQgICAgfSBlbHNlIGlmIChyZXQgIT09IGZhbHNlKSB7XHJcblx0ICAgICAgcmV0dXJuIG9iamVjdDtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBQcm9ncmFtOiBmdW5jdGlvbiBQcm9ncmFtKHByb2dyYW0pIHtcclxuXHQgICAgdGhpcy5hY2NlcHRBcnJheShwcm9ncmFtLmJvZHkpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBNdXN0YWNoZVN0YXRlbWVudDogdmlzaXRTdWJFeHByZXNzaW9uLFxyXG5cdCAgRGVjb3JhdG9yOiB2aXNpdFN1YkV4cHJlc3Npb24sXHJcblxyXG5cdCAgQmxvY2tTdGF0ZW1lbnQ6IHZpc2l0QmxvY2ssXHJcblx0ICBEZWNvcmF0b3JCbG9jazogdmlzaXRCbG9jayxcclxuXHJcblx0ICBQYXJ0aWFsU3RhdGVtZW50OiB2aXNpdFBhcnRpYWwsXHJcblx0ICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQ6IGZ1bmN0aW9uIFBhcnRpYWxCbG9ja1N0YXRlbWVudChwYXJ0aWFsKSB7XHJcblx0ICAgIHZpc2l0UGFydGlhbC5jYWxsKHRoaXMsIHBhcnRpYWwpO1xyXG5cclxuXHQgICAgdGhpcy5hY2NlcHRLZXkocGFydGlhbCwgJ3Byb2dyYW0nKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgQ29udGVudFN0YXRlbWVudDogZnVuY3Rpb24gQ29udGVudFN0YXRlbWVudCgpIC8qIGNvbnRlbnQgKi97fSxcclxuXHQgIENvbW1lbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIENvbW1lbnRTdGF0ZW1lbnQoKSAvKiBjb21tZW50ICove30sXHJcblxyXG5cdCAgU3ViRXhwcmVzc2lvbjogdmlzaXRTdWJFeHByZXNzaW9uLFxyXG5cclxuXHQgIFBhdGhFeHByZXNzaW9uOiBmdW5jdGlvbiBQYXRoRXhwcmVzc2lvbigpIC8qIHBhdGggKi97fSxcclxuXHJcblx0ICBTdHJpbmdMaXRlcmFsOiBmdW5jdGlvbiBTdHJpbmdMaXRlcmFsKCkgLyogc3RyaW5nICove30sXHJcblx0ICBOdW1iZXJMaXRlcmFsOiBmdW5jdGlvbiBOdW1iZXJMaXRlcmFsKCkgLyogbnVtYmVyICove30sXHJcblx0ICBCb29sZWFuTGl0ZXJhbDogZnVuY3Rpb24gQm9vbGVhbkxpdGVyYWwoKSAvKiBib29sICove30sXHJcblx0ICBVbmRlZmluZWRMaXRlcmFsOiBmdW5jdGlvbiBVbmRlZmluZWRMaXRlcmFsKCkgLyogbGl0ZXJhbCAqL3t9LFxyXG5cdCAgTnVsbExpdGVyYWw6IGZ1bmN0aW9uIE51bGxMaXRlcmFsKCkgLyogbGl0ZXJhbCAqL3t9LFxyXG5cclxuXHQgIEhhc2g6IGZ1bmN0aW9uIEhhc2goaGFzaCkge1xyXG5cdCAgICB0aGlzLmFjY2VwdEFycmF5KGhhc2gucGFpcnMpO1xyXG5cdCAgfSxcclxuXHQgIEhhc2hQYWlyOiBmdW5jdGlvbiBIYXNoUGFpcihwYWlyKSB7XHJcblx0ICAgIHRoaXMuYWNjZXB0UmVxdWlyZWQocGFpciwgJ3ZhbHVlJyk7XHJcblx0ICB9XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gdmlzaXRTdWJFeHByZXNzaW9uKG11c3RhY2hlKSB7XHJcblx0ICB0aGlzLmFjY2VwdFJlcXVpcmVkKG11c3RhY2hlLCAncGF0aCcpO1xyXG5cdCAgdGhpcy5hY2NlcHRBcnJheShtdXN0YWNoZS5wYXJhbXMpO1xyXG5cdCAgdGhpcy5hY2NlcHRLZXkobXVzdGFjaGUsICdoYXNoJyk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIHZpc2l0QmxvY2soYmxvY2spIHtcclxuXHQgIHZpc2l0U3ViRXhwcmVzc2lvbi5jYWxsKHRoaXMsIGJsb2NrKTtcclxuXHJcblx0ICB0aGlzLmFjY2VwdEtleShibG9jaywgJ3Byb2dyYW0nKTtcclxuXHQgIHRoaXMuYWNjZXB0S2V5KGJsb2NrLCAnaW52ZXJzZScpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiB2aXNpdFBhcnRpYWwocGFydGlhbCkge1xyXG5cdCAgdGhpcy5hY2NlcHRSZXF1aXJlZChwYXJ0aWFsLCAnbmFtZScpO1xyXG5cdCAgdGhpcy5hY2NlcHRBcnJheShwYXJ0aWFsLnBhcmFtcyk7XHJcblx0ICB0aGlzLmFjY2VwdEtleShwYXJ0aWFsLCAnaGFzaCcpO1xyXG5cdH1cclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gVmlzaXRvcjtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0ZXhwb3J0cy5Tb3VyY2VMb2NhdGlvbiA9IFNvdXJjZUxvY2F0aW9uO1xyXG5cdGV4cG9ydHMuaWQgPSBpZDtcclxuXHRleHBvcnRzLnN0cmlwRmxhZ3MgPSBzdHJpcEZsYWdzO1xyXG5cdGV4cG9ydHMuc3RyaXBDb21tZW50ID0gc3RyaXBDb21tZW50O1xyXG5cdGV4cG9ydHMucHJlcGFyZVBhdGggPSBwcmVwYXJlUGF0aDtcclxuXHRleHBvcnRzLnByZXBhcmVNdXN0YWNoZSA9IHByZXBhcmVNdXN0YWNoZTtcclxuXHRleHBvcnRzLnByZXBhcmVSYXdCbG9jayA9IHByZXBhcmVSYXdCbG9jaztcclxuXHRleHBvcnRzLnByZXBhcmVCbG9jayA9IHByZXBhcmVCbG9jaztcclxuXHRleHBvcnRzLnByZXBhcmVQcm9ncmFtID0gcHJlcGFyZVByb2dyYW07XHJcblx0ZXhwb3J0cy5wcmVwYXJlUGFydGlhbEJsb2NrID0gcHJlcGFyZVBhcnRpYWxCbG9jaztcclxuXHJcblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xyXG5cclxuXHRmdW5jdGlvbiB2YWxpZGF0ZUNsb3NlKG9wZW4sIGNsb3NlKSB7XHJcblx0ICBjbG9zZSA9IGNsb3NlLnBhdGggPyBjbG9zZS5wYXRoLm9yaWdpbmFsIDogY2xvc2U7XHJcblxyXG5cdCAgaWYgKG9wZW4ucGF0aC5vcmlnaW5hbCAhPT0gY2xvc2UpIHtcclxuXHQgICAgdmFyIGVycm9yTm9kZSA9IHsgbG9jOiBvcGVuLnBhdGgubG9jIH07XHJcblxyXG5cdCAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXShvcGVuLnBhdGgub3JpZ2luYWwgKyBcIiBkb2Vzbid0IG1hdGNoIFwiICsgY2xvc2UsIGVycm9yTm9kZSk7XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihzb3VyY2UsIGxvY0luZm8pIHtcclxuXHQgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdCAgdGhpcy5zdGFydCA9IHtcclxuXHQgICAgbGluZTogbG9jSW5mby5maXJzdF9saW5lLFxyXG5cdCAgICBjb2x1bW46IGxvY0luZm8uZmlyc3RfY29sdW1uXHJcblx0ICB9O1xyXG5cdCAgdGhpcy5lbmQgPSB7XHJcblx0ICAgIGxpbmU6IGxvY0luZm8ubGFzdF9saW5lLFxyXG5cdCAgICBjb2x1bW46IGxvY0luZm8ubGFzdF9jb2x1bW5cclxuXHQgIH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpZCh0b2tlbikge1xyXG5cdCAgaWYgKC9eXFxbLipcXF0kLy50ZXN0KHRva2VuKSkge1xyXG5cdCAgICByZXR1cm4gdG9rZW4uc3Vic3RyKDEsIHRva2VuLmxlbmd0aCAtIDIpO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgcmV0dXJuIHRva2VuO1xyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc3RyaXBGbGFncyhvcGVuLCBjbG9zZSkge1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgb3Blbjogb3Blbi5jaGFyQXQoMikgPT09ICd+JyxcclxuXHQgICAgY2xvc2U6IGNsb3NlLmNoYXJBdChjbG9zZS5sZW5ndGggLSAzKSA9PT0gJ34nXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc3RyaXBDb21tZW50KGNvbW1lbnQpIHtcclxuXHQgIHJldHVybiBjb21tZW50LnJlcGxhY2UoL15cXHtcXHt+P1xcIS0/LT8vLCAnJykucmVwbGFjZSgvLT8tP34/XFx9XFx9JC8sICcnKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVQYXRoKGRhdGEsIHBhcnRzLCBsb2MpIHtcclxuXHQgIGxvYyA9IHRoaXMubG9jSW5mbyhsb2MpO1xyXG5cclxuXHQgIHZhciBvcmlnaW5hbCA9IGRhdGEgPyAnQCcgOiAnJyxcclxuXHQgICAgICBkaWcgPSBbXSxcclxuXHQgICAgICBkZXB0aCA9IDAsXHJcblx0ICAgICAgZGVwdGhTdHJpbmcgPSAnJztcclxuXHJcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICB2YXIgcGFydCA9IHBhcnRzW2ldLnBhcnQsXHJcblxyXG5cdCAgICAvLyBJZiB3ZSBoYXZlIFtdIHN5bnRheCB0aGVuIHdlIGRvIG5vdCB0cmVhdCBwYXRoIHJlZmVyZW5jZXMgYXMgb3BlcmF0b3JzLFxyXG5cdCAgICAvLyBpLmUuIGZvby5bdGhpc10gcmVzb2x2ZXMgdG8gYXBwcm94aW1hdGVseSBjb250ZXh0LmZvb1sndGhpcyddXHJcblx0ICAgIGlzTGl0ZXJhbCA9IHBhcnRzW2ldLm9yaWdpbmFsICE9PSBwYXJ0O1xyXG5cdCAgICBvcmlnaW5hbCArPSAocGFydHNbaV0uc2VwYXJhdG9yIHx8ICcnKSArIHBhcnQ7XHJcblxyXG5cdCAgICBpZiAoIWlzTGl0ZXJhbCAmJiAocGFydCA9PT0gJy4uJyB8fCBwYXJ0ID09PSAnLicgfHwgcGFydCA9PT0gJ3RoaXMnKSkge1xyXG5cdCAgICAgIGlmIChkaWcubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0ludmFsaWQgcGF0aDogJyArIG9yaWdpbmFsLCB7IGxvYzogbG9jIH0pO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xyXG5cdCAgICAgICAgZGVwdGgrKztcclxuXHQgICAgICAgIGRlcHRoU3RyaW5nICs9ICcuLi8nO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBkaWcucHVzaChwYXJ0KTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXHJcblx0ICAgIGRhdGE6IGRhdGEsXHJcblx0ICAgIGRlcHRoOiBkZXB0aCxcclxuXHQgICAgcGFydHM6IGRpZyxcclxuXHQgICAgb3JpZ2luYWw6IG9yaWdpbmFsLFxyXG5cdCAgICBsb2M6IGxvY1xyXG5cdCAgfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVNdXN0YWNoZShwYXRoLCBwYXJhbXMsIGhhc2gsIG9wZW4sIHN0cmlwLCBsb2NJbmZvKSB7XHJcblx0ICAvLyBNdXN0IHVzZSBjaGFyQXQgdG8gc3VwcG9ydCBJRSBwcmUtMTBcclxuXHQgIHZhciBlc2NhcGVGbGFnID0gb3Blbi5jaGFyQXQoMykgfHwgb3Blbi5jaGFyQXQoMiksXHJcblx0ICAgICAgZXNjYXBlZCA9IGVzY2FwZUZsYWcgIT09ICd7JyAmJiBlc2NhcGVGbGFnICE9PSAnJic7XHJcblxyXG5cdCAgdmFyIGRlY29yYXRvciA9IC9cXCovLnRlc3Qob3Blbik7XHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB0eXBlOiBkZWNvcmF0b3IgPyAnRGVjb3JhdG9yJyA6ICdNdXN0YWNoZVN0YXRlbWVudCcsXHJcblx0ICAgIHBhdGg6IHBhdGgsXHJcblx0ICAgIHBhcmFtczogcGFyYW1zLFxyXG5cdCAgICBoYXNoOiBoYXNoLFxyXG5cdCAgICBlc2NhcGVkOiBlc2NhcGVkLFxyXG5cdCAgICBzdHJpcDogc3RyaXAsXHJcblx0ICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlcGFyZVJhd0Jsb2NrKG9wZW5SYXdCbG9jaywgY29udGVudHMsIGNsb3NlLCBsb2NJbmZvKSB7XHJcblx0ICB2YWxpZGF0ZUNsb3NlKG9wZW5SYXdCbG9jaywgY2xvc2UpO1xyXG5cclxuXHQgIGxvY0luZm8gPSB0aGlzLmxvY0luZm8obG9jSW5mbyk7XHJcblx0ICB2YXIgcHJvZ3JhbSA9IHtcclxuXHQgICAgdHlwZTogJ1Byb2dyYW0nLFxyXG5cdCAgICBib2R5OiBjb250ZW50cyxcclxuXHQgICAgc3RyaXA6IHt9LFxyXG5cdCAgICBsb2M6IGxvY0luZm9cclxuXHQgIH07XHJcblxyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgdHlwZTogJ0Jsb2NrU3RhdGVtZW50JyxcclxuXHQgICAgcGF0aDogb3BlblJhd0Jsb2NrLnBhdGgsXHJcblx0ICAgIHBhcmFtczogb3BlblJhd0Jsb2NrLnBhcmFtcyxcclxuXHQgICAgaGFzaDogb3BlblJhd0Jsb2NrLmhhc2gsXHJcblx0ICAgIHByb2dyYW06IHByb2dyYW0sXHJcblx0ICAgIG9wZW5TdHJpcDoge30sXHJcblx0ICAgIGludmVyc2VTdHJpcDoge30sXHJcblx0ICAgIGNsb3NlU3RyaXA6IHt9LFxyXG5cdCAgICBsb2M6IGxvY0luZm9cclxuXHQgIH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVwYXJlQmxvY2sob3BlbkJsb2NrLCBwcm9ncmFtLCBpbnZlcnNlQW5kUHJvZ3JhbSwgY2xvc2UsIGludmVydGVkLCBsb2NJbmZvKSB7XHJcblx0ICBpZiAoY2xvc2UgJiYgY2xvc2UucGF0aCkge1xyXG5cdCAgICB2YWxpZGF0ZUNsb3NlKG9wZW5CbG9jaywgY2xvc2UpO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBkZWNvcmF0b3IgPSAvXFwqLy50ZXN0KG9wZW5CbG9jay5vcGVuKTtcclxuXHJcblx0ICBwcm9ncmFtLmJsb2NrUGFyYW1zID0gb3BlbkJsb2NrLmJsb2NrUGFyYW1zO1xyXG5cclxuXHQgIHZhciBpbnZlcnNlID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgIGludmVyc2VTdHJpcCA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICBpZiAoaW52ZXJzZUFuZFByb2dyYW0pIHtcclxuXHQgICAgaWYgKGRlY29yYXRvcikge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbmV4cGVjdGVkIGludmVyc2UgYmxvY2sgb24gZGVjb3JhdG9yJywgaW52ZXJzZUFuZFByb2dyYW0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoaW52ZXJzZUFuZFByb2dyYW0uY2hhaW4pIHtcclxuXHQgICAgICBpbnZlcnNlQW5kUHJvZ3JhbS5wcm9ncmFtLmJvZHlbMF0uY2xvc2VTdHJpcCA9IGNsb3NlLnN0cmlwO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpbnZlcnNlU3RyaXAgPSBpbnZlcnNlQW5kUHJvZ3JhbS5zdHJpcDtcclxuXHQgICAgaW52ZXJzZSA9IGludmVyc2VBbmRQcm9ncmFtLnByb2dyYW07XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKGludmVydGVkKSB7XHJcblx0ICAgIGludmVydGVkID0gaW52ZXJzZTtcclxuXHQgICAgaW52ZXJzZSA9IHByb2dyYW07XHJcblx0ICAgIHByb2dyYW0gPSBpbnZlcnRlZDtcclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB0eXBlOiBkZWNvcmF0b3IgPyAnRGVjb3JhdG9yQmxvY2snIDogJ0Jsb2NrU3RhdGVtZW50JyxcclxuXHQgICAgcGF0aDogb3BlbkJsb2NrLnBhdGgsXHJcblx0ICAgIHBhcmFtczogb3BlbkJsb2NrLnBhcmFtcyxcclxuXHQgICAgaGFzaDogb3BlbkJsb2NrLmhhc2gsXHJcblx0ICAgIHByb2dyYW06IHByb2dyYW0sXHJcblx0ICAgIGludmVyc2U6IGludmVyc2UsXHJcblx0ICAgIG9wZW5TdHJpcDogb3BlbkJsb2NrLnN0cmlwLFxyXG5cdCAgICBpbnZlcnNlU3RyaXA6IGludmVyc2VTdHJpcCxcclxuXHQgICAgY2xvc2VTdHJpcDogY2xvc2UgJiYgY2xvc2Uuc3RyaXAsXHJcblx0ICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlcGFyZVByb2dyYW0oc3RhdGVtZW50cywgbG9jKSB7XHJcblx0ICBpZiAoIWxvYyAmJiBzdGF0ZW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICB2YXIgZmlyc3RMb2MgPSBzdGF0ZW1lbnRzWzBdLmxvYyxcclxuXHQgICAgICAgIGxhc3RMb2MgPSBzdGF0ZW1lbnRzW3N0YXRlbWVudHMubGVuZ3RoIC0gMV0ubG9jO1xyXG5cclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuXHQgICAgaWYgKGZpcnN0TG9jICYmIGxhc3RMb2MpIHtcclxuXHQgICAgICBsb2MgPSB7XHJcblx0ICAgICAgICBzb3VyY2U6IGZpcnN0TG9jLnNvdXJjZSxcclxuXHQgICAgICAgIHN0YXJ0OiB7XHJcblx0ICAgICAgICAgIGxpbmU6IGZpcnN0TG9jLnN0YXJ0LmxpbmUsXHJcblx0ICAgICAgICAgIGNvbHVtbjogZmlyc3RMb2Muc3RhcnQuY29sdW1uXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZW5kOiB7XHJcblx0ICAgICAgICAgIGxpbmU6IGxhc3RMb2MuZW5kLmxpbmUsXHJcblx0ICAgICAgICAgIGNvbHVtbjogbGFzdExvYy5lbmQuY29sdW1uXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHR5cGU6ICdQcm9ncmFtJyxcclxuXHQgICAgYm9keTogc3RhdGVtZW50cyxcclxuXHQgICAgc3RyaXA6IHt9LFxyXG5cdCAgICBsb2M6IGxvY1xyXG5cdCAgfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVQYXJ0aWFsQmxvY2sob3BlbiwgcHJvZ3JhbSwgY2xvc2UsIGxvY0luZm8pIHtcclxuXHQgIHZhbGlkYXRlQ2xvc2Uob3BlbiwgY2xvc2UpO1xyXG5cclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHR5cGU6ICdQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQnLFxyXG5cdCAgICBuYW1lOiBvcGVuLnBhdGgsXHJcblx0ICAgIHBhcmFtczogb3Blbi5wYXJhbXMsXHJcblx0ICAgIGhhc2g6IG9wZW4uaGFzaCxcclxuXHQgICAgcHJvZ3JhbTogcHJvZ3JhbSxcclxuXHQgICAgb3BlblN0cmlwOiBvcGVuLnN0cmlwLFxyXG5cdCAgICBjbG9zZVN0cmlwOiBjbG9zZSAmJiBjbG9zZS5zdHJpcCxcclxuXHQgICAgbG9jOiB0aGlzLmxvY0luZm8obG9jSW5mbylcclxuXHQgIH07XHJcblx0fVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0LyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGV4cG9ydHMuQ29tcGlsZXIgPSBDb21waWxlcjtcclxuXHRleHBvcnRzLnByZWNvbXBpbGUgPSBwcmVjb21waWxlO1xyXG5cdGV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBfYXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XHJcblxyXG5cdHZhciBfYXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FzdCk7XHJcblxyXG5cdHZhciBzbGljZSA9IFtdLnNsaWNlO1xyXG5cclxuXHRmdW5jdGlvbiBDb21waWxlcigpIHt9XHJcblxyXG5cdC8vIHRoZSBmb3VuZEhlbHBlciByZWdpc3RlciB3aWxsIGRpc2FtYmlndWF0ZSBoZWxwZXIgbG9va3VwIGZyb20gZmluZGluZyBhXHJcblx0Ly8gZnVuY3Rpb24gaW4gYSBjb250ZXh0LiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgbXVzdGFjaGUgY29tcGF0aWJpbGl0eSwgd2hpY2hcclxuXHQvLyByZXF1aXJlcyB0aGF0IGNvbnRleHQgZnVuY3Rpb25zIGluIGJsb2NrcyBhcmUgZXZhbHVhdGVkIGJ5IGJsb2NrSGVscGVyTWlzc2luZyxcclxuXHQvLyBhbmQgdGhlbiBwcm9jZWVkIGFzIGlmIHRoZSByZXN1bHRpbmcgdmFsdWUgd2FzIHByb3ZpZGVkIHRvIGJsb2NrSGVscGVyTWlzc2luZy5cclxuXHJcblx0Q29tcGlsZXIucHJvdG90eXBlID0ge1xyXG5cdCAgY29tcGlsZXI6IENvbXBpbGVyLFxyXG5cclxuXHQgIGVxdWFsczogZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XHJcblx0ICAgIHZhciBsZW4gPSB0aGlzLm9wY29kZXMubGVuZ3RoO1xyXG5cdCAgICBpZiAob3RoZXIub3Bjb2Rlcy5sZW5ndGggIT09IGxlbikge1xyXG5cdCAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIHZhciBvcGNvZGUgPSB0aGlzLm9wY29kZXNbaV0sXHJcblx0ICAgICAgICAgIG90aGVyT3Bjb2RlID0gb3RoZXIub3Bjb2Rlc1tpXTtcclxuXHQgICAgICBpZiAob3Bjb2RlLm9wY29kZSAhPT0gb3RoZXJPcGNvZGUub3Bjb2RlIHx8ICFhcmdFcXVhbHMob3Bjb2RlLmFyZ3MsIG90aGVyT3Bjb2RlLmFyZ3MpKSB7XHJcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBXZSBrbm93IHRoYXQgbGVuZ3RoIGlzIHRoZSBzYW1lIGJldHdlZW4gdGhlIHR3byBhcnJheXMgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSB0aWVkXHJcblx0ICAgIC8vIHRvIHRoZSBvcGNvZGUgYmVoYXZpb3IgYWJvdmUuXHJcblx0ICAgIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuW2ldLmVxdWFscyhvdGhlci5jaGlsZHJlbltpXSkpIHtcclxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfSxcclxuXHJcblx0ICBndWlkOiAwLFxyXG5cclxuXHQgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUocHJvZ3JhbSwgb3B0aW9ucykge1xyXG5cdCAgICB0aGlzLnNvdXJjZU5vZGUgPSBbXTtcclxuXHQgICAgdGhpcy5vcGNvZGVzID0gW107XHJcblx0ICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHQgICAgdGhpcy5zdHJpbmdQYXJhbXMgPSBvcHRpb25zLnN0cmluZ1BhcmFtcztcclxuXHQgICAgdGhpcy50cmFja0lkcyA9IG9wdGlvbnMudHJhY2tJZHM7XHJcblxyXG5cdCAgICBvcHRpb25zLmJsb2NrUGFyYW1zID0gb3B0aW9ucy5ibG9ja1BhcmFtcyB8fCBbXTtcclxuXHJcblx0ICAgIC8vIFRoZXNlIGNoYW5nZXMgd2lsbCBwcm9wYWdhdGUgdG8gdGhlIG90aGVyIGNvbXBpbGVyIGNvbXBvbmVudHNcclxuXHQgICAgdmFyIGtub3duSGVscGVycyA9IG9wdGlvbnMua25vd25IZWxwZXJzO1xyXG5cdCAgICBvcHRpb25zLmtub3duSGVscGVycyA9IHtcclxuXHQgICAgICAnaGVscGVyTWlzc2luZyc6IHRydWUsXHJcblx0ICAgICAgJ2Jsb2NrSGVscGVyTWlzc2luZyc6IHRydWUsXHJcblx0ICAgICAgJ2VhY2gnOiB0cnVlLFxyXG5cdCAgICAgICdpZic6IHRydWUsXHJcblx0ICAgICAgJ3VubGVzcyc6IHRydWUsXHJcblx0ICAgICAgJ3dpdGgnOiB0cnVlLFxyXG5cdCAgICAgICdsb2cnOiB0cnVlLFxyXG5cdCAgICAgICdsb29rdXAnOiB0cnVlXHJcblx0ICAgIH07XHJcblx0ICAgIGlmIChrbm93bkhlbHBlcnMpIHtcclxuXHQgICAgICBmb3IgKHZhciBfbmFtZSBpbiBrbm93bkhlbHBlcnMpIHtcclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICAgICAgICBpZiAoX25hbWUgaW4ga25vd25IZWxwZXJzKSB7XHJcblx0ICAgICAgICAgIHRoaXMub3B0aW9ucy5rbm93bkhlbHBlcnNbX25hbWVdID0ga25vd25IZWxwZXJzW19uYW1lXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiB0aGlzLmFjY2VwdChwcm9ncmFtKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgY29tcGlsZVByb2dyYW06IGZ1bmN0aW9uIGNvbXBpbGVQcm9ncmFtKHByb2dyYW0pIHtcclxuXHQgICAgdmFyIGNoaWxkQ29tcGlsZXIgPSBuZXcgdGhpcy5jb21waWxlcigpLFxyXG5cdCAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXHJcblx0ICAgIHJlc3VsdCA9IGNoaWxkQ29tcGlsZXIuY29tcGlsZShwcm9ncmFtLCB0aGlzLm9wdGlvbnMpLFxyXG5cdCAgICAgICAgZ3VpZCA9IHRoaXMuZ3VpZCsrO1xyXG5cclxuXHQgICAgdGhpcy51c2VQYXJ0aWFsID0gdGhpcy51c2VQYXJ0aWFsIHx8IHJlc3VsdC51c2VQYXJ0aWFsO1xyXG5cclxuXHQgICAgdGhpcy5jaGlsZHJlbltndWlkXSA9IHJlc3VsdDtcclxuXHQgICAgdGhpcy51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocyB8fCByZXN1bHQudXNlRGVwdGhzO1xyXG5cclxuXHQgICAgcmV0dXJuIGd1aWQ7XHJcblx0ICB9LFxyXG5cclxuXHQgIGFjY2VwdDogZnVuY3Rpb24gYWNjZXB0KG5vZGUpIHtcclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IFNhbml0eSBjb2RlICovXHJcblx0ICAgIGlmICghdGhpc1tub2RlLnR5cGVdKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1Vua25vd24gdHlwZTogJyArIG5vZGUudHlwZSwgbm9kZSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMuc291cmNlTm9kZS51bnNoaWZ0KG5vZGUpO1xyXG5cdCAgICB2YXIgcmV0ID0gdGhpc1tub2RlLnR5cGVdKG5vZGUpO1xyXG5cdCAgICB0aGlzLnNvdXJjZU5vZGUuc2hpZnQoKTtcclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH0sXHJcblxyXG5cdCAgUHJvZ3JhbTogZnVuY3Rpb24gUHJvZ3JhbShwcm9ncmFtKSB7XHJcblx0ICAgIHRoaXMub3B0aW9ucy5ibG9ja1BhcmFtcy51bnNoaWZ0KHByb2dyYW0uYmxvY2tQYXJhbXMpO1xyXG5cclxuXHQgICAgdmFyIGJvZHkgPSBwcm9ncmFtLmJvZHksXHJcblx0ICAgICAgICBib2R5TGVuZ3RoID0gYm9keS5sZW5ndGg7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keUxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgdGhpcy5hY2NlcHQoYm9keVtpXSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMub3B0aW9ucy5ibG9ja1BhcmFtcy5zaGlmdCgpO1xyXG5cclxuXHQgICAgdGhpcy5pc1NpbXBsZSA9IGJvZHlMZW5ndGggPT09IDE7XHJcblx0ICAgIHRoaXMuYmxvY2tQYXJhbXMgPSBwcm9ncmFtLmJsb2NrUGFyYW1zID8gcHJvZ3JhbS5ibG9ja1BhcmFtcy5sZW5ndGggOiAwO1xyXG5cclxuXHQgICAgcmV0dXJuIHRoaXM7XHJcblx0ICB9LFxyXG5cclxuXHQgIEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbiBCbG9ja1N0YXRlbWVudChibG9jaykge1xyXG5cdCAgICB0cmFuc2Zvcm1MaXRlcmFsVG9QYXRoKGJsb2NrKTtcclxuXHJcblx0ICAgIHZhciBwcm9ncmFtID0gYmxvY2sucHJvZ3JhbSxcclxuXHQgICAgICAgIGludmVyc2UgPSBibG9jay5pbnZlcnNlO1xyXG5cclxuXHQgICAgcHJvZ3JhbSA9IHByb2dyYW0gJiYgdGhpcy5jb21waWxlUHJvZ3JhbShwcm9ncmFtKTtcclxuXHQgICAgaW52ZXJzZSA9IGludmVyc2UgJiYgdGhpcy5jb21waWxlUHJvZ3JhbShpbnZlcnNlKTtcclxuXHJcblx0ICAgIHZhciB0eXBlID0gdGhpcy5jbGFzc2lmeVNleHByKGJsb2NrKTtcclxuXHJcblx0ICAgIGlmICh0eXBlID09PSAnaGVscGVyJykge1xyXG5cdCAgICAgIHRoaXMuaGVscGVyU2V4cHIoYmxvY2ssIHByb2dyYW0sIGludmVyc2UpO1xyXG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzaW1wbGUnKSB7XHJcblx0ICAgICAgdGhpcy5zaW1wbGVTZXhwcihibG9jayk7XHJcblxyXG5cdCAgICAgIC8vIG5vdyB0aGF0IHRoZSBzaW1wbGUgbXVzdGFjaGUgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG9cclxuXHQgICAgICAvLyBldmFsdWF0ZSBpdCBieSBleGVjdXRpbmcgYGJsb2NrSGVscGVyTWlzc2luZ2BcclxuXHQgICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnZW1wdHlIYXNoJyk7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2Jsb2NrVmFsdWUnLCBibG9jay5wYXRoLm9yaWdpbmFsKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLmFtYmlndW91c1NleHByKGJsb2NrLCBwcm9ncmFtLCBpbnZlcnNlKTtcclxuXHJcblx0ICAgICAgLy8gbm93IHRoYXQgdGhlIHNpbXBsZSBtdXN0YWNoZSBpcyByZXNvbHZlZCwgd2UgbmVlZCB0b1xyXG5cdCAgICAgIC8vIGV2YWx1YXRlIGl0IGJ5IGV4ZWN1dGluZyBgYmxvY2tIZWxwZXJNaXNzaW5nYFxyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIHByb2dyYW0pO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdlbXB0eUhhc2gnKTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnYW1iaWd1b3VzQmxvY2tWYWx1ZScpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XHJcblx0ICB9LFxyXG5cclxuXHQgIERlY29yYXRvckJsb2NrOiBmdW5jdGlvbiBEZWNvcmF0b3JCbG9jayhkZWNvcmF0b3IpIHtcclxuXHQgICAgdmFyIHByb2dyYW0gPSBkZWNvcmF0b3IucHJvZ3JhbSAmJiB0aGlzLmNvbXBpbGVQcm9ncmFtKGRlY29yYXRvci5wcm9ncmFtKTtcclxuXHQgICAgdmFyIHBhcmFtcyA9IHRoaXMuc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXMoZGVjb3JhdG9yLCBwcm9ncmFtLCB1bmRlZmluZWQpLFxyXG5cdCAgICAgICAgcGF0aCA9IGRlY29yYXRvci5wYXRoO1xyXG5cclxuXHQgICAgdGhpcy51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3JlZ2lzdGVyRGVjb3JhdG9yJywgcGFyYW1zLmxlbmd0aCwgcGF0aC5vcmlnaW5hbCk7XHJcblx0ICB9LFxyXG5cclxuXHQgIFBhcnRpYWxTdGF0ZW1lbnQ6IGZ1bmN0aW9uIFBhcnRpYWxTdGF0ZW1lbnQocGFydGlhbCkge1xyXG5cdCAgICB0aGlzLnVzZVBhcnRpYWwgPSB0cnVlO1xyXG5cclxuXHQgICAgdmFyIHByb2dyYW0gPSBwYXJ0aWFsLnByb2dyYW07XHJcblx0ICAgIGlmIChwcm9ncmFtKSB7XHJcblx0ICAgICAgcHJvZ3JhbSA9IHRoaXMuY29tcGlsZVByb2dyYW0ocGFydGlhbC5wcm9ncmFtKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIHBhcmFtcyA9IHBhcnRpYWwucGFyYW1zO1xyXG5cdCAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDEpIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVW5zdXBwb3J0ZWQgbnVtYmVyIG9mIHBhcnRpYWwgYXJndW1lbnRzOiAnICsgcGFyYW1zLmxlbmd0aCwgcGFydGlhbCk7XHJcblx0ICAgIH0gZWxzZSBpZiAoIXBhcmFtcy5sZW5ndGgpIHtcclxuXHQgICAgICBpZiAodGhpcy5vcHRpb25zLmV4cGxpY2l0UGFydGlhbENvbnRleHQpIHtcclxuXHQgICAgICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsICd1bmRlZmluZWQnKTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgcGFyYW1zLnB1c2goeyB0eXBlOiAnUGF0aEV4cHJlc3Npb24nLCBwYXJ0czogW10sIGRlcHRoOiAwIH0pO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIHBhcnRpYWxOYW1lID0gcGFydGlhbC5uYW1lLm9yaWdpbmFsLFxyXG5cdCAgICAgICAgaXNEeW5hbWljID0gcGFydGlhbC5uYW1lLnR5cGUgPT09ICdTdWJFeHByZXNzaW9uJztcclxuXHQgICAgaWYgKGlzRHluYW1pYykge1xyXG5cdCAgICAgIHRoaXMuYWNjZXB0KHBhcnRpYWwubmFtZSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMuc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXMocGFydGlhbCwgcHJvZ3JhbSwgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHJcblx0ICAgIHZhciBpbmRlbnQgPSBwYXJ0aWFsLmluZGVudCB8fCAnJztcclxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5wcmV2ZW50SW5kZW50ICYmIGluZGVudCkge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRDb250ZW50JywgaW5kZW50KTtcclxuXHQgICAgICBpbmRlbnQgPSAnJztcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5vcGNvZGUoJ2ludm9rZVBhcnRpYWwnLCBpc0R5bmFtaWMsIHBhcnRpYWxOYW1lLCBpbmRlbnQpO1xyXG5cdCAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XHJcblx0ICB9LFxyXG5cdCAgUGFydGlhbEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbiBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbEJsb2NrKSB7XHJcblx0ICAgIHRoaXMuUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsQmxvY2spO1xyXG5cdCAgfSxcclxuXHJcblx0ICBNdXN0YWNoZVN0YXRlbWVudDogZnVuY3Rpb24gTXVzdGFjaGVTdGF0ZW1lbnQobXVzdGFjaGUpIHtcclxuXHQgICAgdGhpcy5TdWJFeHByZXNzaW9uKG11c3RhY2hlKTtcclxuXHJcblx0ICAgIGlmIChtdXN0YWNoZS5lc2NhcGVkICYmICF0aGlzLm9wdGlvbnMubm9Fc2NhcGUpIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnYXBwZW5kRXNjYXBlZCcpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmQnKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIERlY29yYXRvcjogZnVuY3Rpb24gRGVjb3JhdG9yKGRlY29yYXRvcikge1xyXG5cdCAgICB0aGlzLkRlY29yYXRvckJsb2NrKGRlY29yYXRvcik7XHJcblx0ICB9LFxyXG5cclxuXHQgIENvbnRlbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIENvbnRlbnRTdGF0ZW1lbnQoY29udGVudCkge1xyXG5cdCAgICBpZiAoY29udGVudC52YWx1ZSkge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdhcHBlbmRDb250ZW50JywgY29udGVudC52YWx1ZSk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgQ29tbWVudFN0YXRlbWVudDogZnVuY3Rpb24gQ29tbWVudFN0YXRlbWVudCgpIHt9LFxyXG5cclxuXHQgIFN1YkV4cHJlc3Npb246IGZ1bmN0aW9uIFN1YkV4cHJlc3Npb24oc2V4cHIpIHtcclxuXHQgICAgdHJhbnNmb3JtTGl0ZXJhbFRvUGF0aChzZXhwcik7XHJcblx0ICAgIHZhciB0eXBlID0gdGhpcy5jbGFzc2lmeVNleHByKHNleHByKTtcclxuXHJcblx0ICAgIGlmICh0eXBlID09PSAnc2ltcGxlJykge1xyXG5cdCAgICAgIHRoaXMuc2ltcGxlU2V4cHIoc2V4cHIpO1xyXG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdoZWxwZXInKSB7XHJcblx0ICAgICAgdGhpcy5oZWxwZXJTZXhwcihzZXhwcik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5hbWJpZ3VvdXNTZXhwcihzZXhwcik7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblx0ICBhbWJpZ3VvdXNTZXhwcjogZnVuY3Rpb24gYW1iaWd1b3VzU2V4cHIoc2V4cHIsIHByb2dyYW0sIGludmVyc2UpIHtcclxuXHQgICAgdmFyIHBhdGggPSBzZXhwci5wYXRoLFxyXG5cdCAgICAgICAgbmFtZSA9IHBhdGgucGFydHNbMF0sXHJcblx0ICAgICAgICBpc0Jsb2NrID0gcHJvZ3JhbSAhPSBudWxsIHx8IGludmVyc2UgIT0gbnVsbDtcclxuXHJcblx0ICAgIHRoaXMub3Bjb2RlKCdnZXRDb250ZXh0JywgcGF0aC5kZXB0aCk7XHJcblxyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgaW52ZXJzZSk7XHJcblxyXG5cdCAgICBwYXRoLnN0cmljdCA9IHRydWU7XHJcblx0ICAgIHRoaXMuYWNjZXB0KHBhdGgpO1xyXG5cclxuXHQgICAgdGhpcy5vcGNvZGUoJ2ludm9rZUFtYmlndW91cycsIG5hbWUsIGlzQmxvY2spO1xyXG5cdCAgfSxcclxuXHJcblx0ICBzaW1wbGVTZXhwcjogZnVuY3Rpb24gc2ltcGxlU2V4cHIoc2V4cHIpIHtcclxuXHQgICAgdmFyIHBhdGggPSBzZXhwci5wYXRoO1xyXG5cdCAgICBwYXRoLnN0cmljdCA9IHRydWU7XHJcblx0ICAgIHRoaXMuYWNjZXB0KHBhdGgpO1xyXG5cdCAgICB0aGlzLm9wY29kZSgncmVzb2x2ZVBvc3NpYmxlTGFtYmRhJyk7XHJcblx0ICB9LFxyXG5cclxuXHQgIGhlbHBlclNleHByOiBmdW5jdGlvbiBoZWxwZXJTZXhwcihzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSkge1xyXG5cdCAgICB2YXIgcGFyYW1zID0gdGhpcy5zZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyhzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSksXHJcblx0ICAgICAgICBwYXRoID0gc2V4cHIucGF0aCxcclxuXHQgICAgICAgIG5hbWUgPSBwYXRoLnBhcnRzWzBdO1xyXG5cclxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5rbm93bkhlbHBlcnNbbmFtZV0pIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnaW52b2tlS25vd25IZWxwZXInLCBwYXJhbXMubGVuZ3RoLCBuYW1lKTtcclxuXHQgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMua25vd25IZWxwZXJzT25seSkge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdZb3Ugc3BlY2lmaWVkIGtub3duSGVscGVyc09ubHksIGJ1dCB1c2VkIHRoZSB1bmtub3duIGhlbHBlciAnICsgbmFtZSwgc2V4cHIpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHBhdGguc3RyaWN0ID0gdHJ1ZTtcclxuXHQgICAgICBwYXRoLmZhbHN5ID0gdHJ1ZTtcclxuXHJcblx0ICAgICAgdGhpcy5hY2NlcHQocGF0aCk7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2ludm9rZUhlbHBlcicsIHBhcmFtcy5sZW5ndGgsIHBhdGgub3JpZ2luYWwsIF9hc3QyWydkZWZhdWx0J10uaGVscGVycy5zaW1wbGVJZChwYXRoKSk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgUGF0aEV4cHJlc3Npb246IGZ1bmN0aW9uIFBhdGhFeHByZXNzaW9uKHBhdGgpIHtcclxuXHQgICAgdGhpcy5hZGREZXB0aChwYXRoLmRlcHRoKTtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCBwYXRoLmRlcHRoKTtcclxuXHJcblx0ICAgIHZhciBuYW1lID0gcGF0aC5wYXJ0c1swXSxcclxuXHQgICAgICAgIHNjb3BlZCA9IF9hc3QyWydkZWZhdWx0J10uaGVscGVycy5zY29wZWRJZChwYXRoKSxcclxuXHQgICAgICAgIGJsb2NrUGFyYW1JZCA9ICFwYXRoLmRlcHRoICYmICFzY29wZWQgJiYgdGhpcy5ibG9ja1BhcmFtSW5kZXgobmFtZSk7XHJcblxyXG5cdCAgICBpZiAoYmxvY2tQYXJhbUlkKSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2xvb2t1cEJsb2NrUGFyYW0nLCBibG9ja1BhcmFtSWQsIHBhdGgucGFydHMpO1xyXG5cdCAgICB9IGVsc2UgaWYgKCFuYW1lKSB7XHJcblx0ICAgICAgLy8gQ29udGV4dCByZWZlcmVuY2UsIGkuZS4gYHt7Zm9vIC59fWAgb3IgYHt7Zm9vIC4ufX1gXHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hDb250ZXh0Jyk7XHJcblx0ICAgIH0gZWxzZSBpZiAocGF0aC5kYXRhKSB7XHJcblx0ICAgICAgdGhpcy5vcHRpb25zLmRhdGEgPSB0cnVlO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdsb29rdXBEYXRhJywgcGF0aC5kZXB0aCwgcGF0aC5wYXJ0cywgcGF0aC5zdHJpY3QpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdsb29rdXBPbkNvbnRleHQnLCBwYXRoLnBhcnRzLCBwYXRoLmZhbHN5LCBwYXRoLnN0cmljdCwgc2NvcGVkKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBTdHJpbmdMaXRlcmFsOiBmdW5jdGlvbiBTdHJpbmdMaXRlcmFsKHN0cmluZykge1xyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaFN0cmluZycsIHN0cmluZy52YWx1ZSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIE51bWJlckxpdGVyYWw6IGZ1bmN0aW9uIE51bWJlckxpdGVyYWwobnVtYmVyKSB7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsIG51bWJlci52YWx1ZSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIEJvb2xlYW5MaXRlcmFsOiBmdW5jdGlvbiBCb29sZWFuTGl0ZXJhbChib29sKSB7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsIGJvb2wudmFsdWUpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBVbmRlZmluZWRMaXRlcmFsOiBmdW5jdGlvbiBVbmRlZmluZWRMaXRlcmFsKCkge1xyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCAndW5kZWZpbmVkJyk7XHJcblx0ICB9LFxyXG5cclxuXHQgIE51bGxMaXRlcmFsOiBmdW5jdGlvbiBOdWxsTGl0ZXJhbCgpIHtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hMaXRlcmFsJywgJ251bGwnKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgSGFzaDogZnVuY3Rpb24gSGFzaChoYXNoKSB7XHJcblx0ICAgIHZhciBwYWlycyA9IGhhc2gucGFpcnMsXHJcblx0ICAgICAgICBpID0gMCxcclxuXHQgICAgICAgIGwgPSBwYWlycy5sZW5ndGg7XHJcblxyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaEhhc2gnKTtcclxuXHJcblx0ICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoUGFyYW0ocGFpcnNbaV0udmFsdWUpO1xyXG5cdCAgICB9XHJcblx0ICAgIHdoaWxlIChpLS0pIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnYXNzaWduVG9IYXNoJywgcGFpcnNbaV0ua2V5KTtcclxuXHQgICAgfVxyXG5cdCAgICB0aGlzLm9wY29kZSgncG9wSGFzaCcpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBIRUxQRVJTXHJcblx0ICBvcGNvZGU6IGZ1bmN0aW9uIG9wY29kZShuYW1lKSB7XHJcblx0ICAgIHRoaXMub3Bjb2Rlcy5wdXNoKHsgb3Bjb2RlOiBuYW1lLCBhcmdzOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGxvYzogdGhpcy5zb3VyY2VOb2RlWzBdLmxvYyB9KTtcclxuXHQgIH0sXHJcblxyXG5cdCAgYWRkRGVwdGg6IGZ1bmN0aW9uIGFkZERlcHRoKGRlcHRoKSB7XHJcblx0ICAgIGlmICghZGVwdGgpIHtcclxuXHQgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMudXNlRGVwdGhzID0gdHJ1ZTtcclxuXHQgIH0sXHJcblxyXG5cdCAgY2xhc3NpZnlTZXhwcjogZnVuY3Rpb24gY2xhc3NpZnlTZXhwcihzZXhwcikge1xyXG5cdCAgICB2YXIgaXNTaW1wbGUgPSBfYXN0MlsnZGVmYXVsdCddLmhlbHBlcnMuc2ltcGxlSWQoc2V4cHIucGF0aCk7XHJcblxyXG5cdCAgICB2YXIgaXNCbG9ja1BhcmFtID0gaXNTaW1wbGUgJiYgISF0aGlzLmJsb2NrUGFyYW1JbmRleChzZXhwci5wYXRoLnBhcnRzWzBdKTtcclxuXHJcblx0ICAgIC8vIGEgbXVzdGFjaGUgaXMgYW4gZWxpZ2libGUgaGVscGVyIGlmOlxyXG5cdCAgICAvLyAqIGl0cyBpZCBpcyBzaW1wbGUgKGEgc2luZ2xlIHBhcnQsIG5vdCBgdGhpc2Agb3IgYC4uYClcclxuXHQgICAgdmFyIGlzSGVscGVyID0gIWlzQmxvY2tQYXJhbSAmJiBfYXN0MlsnZGVmYXVsdCddLmhlbHBlcnMuaGVscGVyRXhwcmVzc2lvbihzZXhwcik7XHJcblxyXG5cdCAgICAvLyBpZiBhIG11c3RhY2hlIGlzIGFuIGVsaWdpYmxlIGhlbHBlciBidXQgbm90IGEgZGVmaW5pdGVcclxuXHQgICAgLy8gaGVscGVyLCBpdCBpcyBhbWJpZ3VvdXMsIGFuZCB3aWxsIGJlIHJlc29sdmVkIGluIGEgbGF0ZXJcclxuXHQgICAgLy8gcGFzcyBvciBhdCBydW50aW1lLlxyXG5cdCAgICB2YXIgaXNFbGlnaWJsZSA9ICFpc0Jsb2NrUGFyYW0gJiYgKGlzSGVscGVyIHx8IGlzU2ltcGxlKTtcclxuXHJcblx0ICAgIC8vIGlmIGFtYmlndW91cywgd2UgY2FuIHBvc3NpYmx5IHJlc29sdmUgdGhlIGFtYmlndWl0eSBub3dcclxuXHQgICAgLy8gQW4gZWxpZ2libGUgaGVscGVyIGlzIG9uZSB0aGF0IGRvZXMgbm90IGhhdmUgYSBjb21wbGV4IHBhdGgsIGkuZS4gYHRoaXMuZm9vYCwgYC4uL2Zvb2AgZXRjLlxyXG5cdCAgICBpZiAoaXNFbGlnaWJsZSAmJiAhaXNIZWxwZXIpIHtcclxuXHQgICAgICB2YXIgX25hbWUyID0gc2V4cHIucGF0aC5wYXJ0c1swXSxcclxuXHQgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0ICAgICAgaWYgKG9wdGlvbnMua25vd25IZWxwZXJzW19uYW1lMl0pIHtcclxuXHQgICAgICAgIGlzSGVscGVyID0gdHJ1ZTtcclxuXHQgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMua25vd25IZWxwZXJzT25seSkge1xyXG5cdCAgICAgICAgaXNFbGlnaWJsZSA9IGZhbHNlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKGlzSGVscGVyKSB7XHJcblx0ICAgICAgcmV0dXJuICdoZWxwZXInO1xyXG5cdCAgICB9IGVsc2UgaWYgKGlzRWxpZ2libGUpIHtcclxuXHQgICAgICByZXR1cm4gJ2FtYmlndW91cyc7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuICdzaW1wbGUnO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIHB1c2hQYXJhbXM6IGZ1bmN0aW9uIHB1c2hQYXJhbXMocGFyYW1zKSB7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFyYW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgIHRoaXMucHVzaFBhcmFtKHBhcmFtc1tpXSk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgcHVzaFBhcmFtOiBmdW5jdGlvbiBwdXNoUGFyYW0odmFsKSB7XHJcblx0ICAgIHZhciB2YWx1ZSA9IHZhbC52YWx1ZSAhPSBudWxsID8gdmFsLnZhbHVlIDogdmFsLm9yaWdpbmFsIHx8ICcnO1xyXG5cclxuXHQgICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XHJcblx0ICAgICAgaWYgKHZhbHVlLnJlcGxhY2UpIHtcclxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihcXC4/XFwuXFwvKSovZywgJycpLnJlcGxhY2UoL1xcLy9nLCAnLicpO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgaWYgKHZhbC5kZXB0aCkge1xyXG5cdCAgICAgICAgdGhpcy5hZGREZXB0aCh2YWwuZGVwdGgpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB0aGlzLm9wY29kZSgnZ2V0Q29udGV4dCcsIHZhbC5kZXB0aCB8fCAwKTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgncHVzaFN0cmluZ1BhcmFtJywgdmFsdWUsIHZhbC50eXBlKTtcclxuXHJcblx0ICAgICAgaWYgKHZhbC50eXBlID09PSAnU3ViRXhwcmVzc2lvbicpIHtcclxuXHQgICAgICAgIC8vIFN1YkV4cHJlc3Npb25zIGdldCBldmFsdWF0ZWQgYW5kIHBhc3NlZCBpblxyXG5cdCAgICAgICAgLy8gaW4gc3RyaW5nIHBhcmFtcyBtb2RlLlxyXG5cdCAgICAgICAgdGhpcy5hY2NlcHQodmFsKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICAgIHZhciBibG9ja1BhcmFtSW5kZXggPSB1bmRlZmluZWQ7XHJcblx0ICAgICAgICBpZiAodmFsLnBhcnRzICYmICFfYXN0MlsnZGVmYXVsdCddLmhlbHBlcnMuc2NvcGVkSWQodmFsKSAmJiAhdmFsLmRlcHRoKSB7XHJcblx0ICAgICAgICAgIGJsb2NrUGFyYW1JbmRleCA9IHRoaXMuYmxvY2tQYXJhbUluZGV4KHZhbC5wYXJ0c1swXSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAoYmxvY2tQYXJhbUluZGV4KSB7XHJcblx0ICAgICAgICAgIHZhciBibG9ja1BhcmFtQ2hpbGQgPSB2YWwucGFydHMuc2xpY2UoMSkuam9pbignLicpO1xyXG5cdCAgICAgICAgICB0aGlzLm9wY29kZSgncHVzaElkJywgJ0Jsb2NrUGFyYW0nLCBibG9ja1BhcmFtSW5kZXgsIGJsb2NrUGFyYW1DaGlsZCk7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICB2YWx1ZSA9IHZhbC5vcmlnaW5hbCB8fCB2YWx1ZTtcclxuXHQgICAgICAgICAgaWYgKHZhbHVlLnJlcGxhY2UpIHtcclxuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL150aGlzKD86XFwufCQpLywgJycpLnJlcGxhY2UoL15cXC5cXC8vLCAnJykucmVwbGFjZSgvXlxcLiQvLCAnJyk7XHJcblx0ICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgIHRoaXMub3Bjb2RlKCdwdXNoSWQnLCB2YWwudHlwZSwgdmFsdWUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgICB0aGlzLmFjY2VwdCh2YWwpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIHNldHVwRnVsbE11c3RhY2hlUGFyYW1zOiBmdW5jdGlvbiBzZXR1cEZ1bGxNdXN0YWNoZVBhcmFtcyhzZXhwciwgcHJvZ3JhbSwgaW52ZXJzZSwgb21pdEVtcHR5KSB7XHJcblx0ICAgIHZhciBwYXJhbXMgPSBzZXhwci5wYXJhbXM7XHJcblx0ICAgIHRoaXMucHVzaFBhcmFtcyhwYXJhbXMpO1xyXG5cclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xyXG5cclxuXHQgICAgaWYgKHNleHByLmhhc2gpIHtcclxuXHQgICAgICB0aGlzLmFjY2VwdChzZXhwci5oYXNoKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnZW1wdHlIYXNoJywgb21pdEVtcHR5KTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuIHBhcmFtcztcclxuXHQgIH0sXHJcblxyXG5cdCAgYmxvY2tQYXJhbUluZGV4OiBmdW5jdGlvbiBibG9ja1BhcmFtSW5kZXgobmFtZSkge1xyXG5cdCAgICBmb3IgKHZhciBkZXB0aCA9IDAsIGxlbiA9IHRoaXMub3B0aW9ucy5ibG9ja1BhcmFtcy5sZW5ndGg7IGRlcHRoIDwgbGVuOyBkZXB0aCsrKSB7XHJcblx0ICAgICAgdmFyIGJsb2NrUGFyYW1zID0gdGhpcy5vcHRpb25zLmJsb2NrUGFyYW1zW2RlcHRoXSxcclxuXHQgICAgICAgICAgcGFyYW0gPSBibG9ja1BhcmFtcyAmJiBfdXRpbHMuaW5kZXhPZihibG9ja1BhcmFtcywgbmFtZSk7XHJcblx0ICAgICAgaWYgKGJsb2NrUGFyYW1zICYmIHBhcmFtID49IDApIHtcclxuXHQgICAgICAgIHJldHVybiBbZGVwdGgsIHBhcmFtXTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBwcmVjb21waWxlKGlucHV0LCBvcHRpb25zLCBlbnYpIHtcclxuXHQgIGlmIChpbnB1dCA9PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycgJiYgaW5wdXQudHlwZSAhPT0gJ1Byb2dyYW0nKSB7XHJcblx0ICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdZb3UgbXVzdCBwYXNzIGEgc3RyaW5nIG9yIEhhbmRsZWJhcnMgQVNUIHRvIEhhbmRsZWJhcnMucHJlY29tcGlsZS4gWW91IHBhc3NlZCAnICsgaW5wdXQpO1xyXG5cdCAgfVxyXG5cclxuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdCAgaWYgKCEoJ2RhdGEnIGluIG9wdGlvbnMpKSB7XHJcblx0ICAgIG9wdGlvbnMuZGF0YSA9IHRydWU7XHJcblx0ICB9XHJcblx0ICBpZiAob3B0aW9ucy5jb21wYXQpIHtcclxuXHQgICAgb3B0aW9ucy51c2VEZXB0aHMgPSB0cnVlO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBhc3QgPSBlbnYucGFyc2UoaW5wdXQsIG9wdGlvbnMpLFxyXG5cdCAgICAgIGVudmlyb25tZW50ID0gbmV3IGVudi5Db21waWxlcigpLmNvbXBpbGUoYXN0LCBvcHRpb25zKTtcclxuXHQgIHJldHVybiBuZXcgZW52LkphdmFTY3JpcHRDb21waWxlcigpLmNvbXBpbGUoZW52aXJvbm1lbnQsIG9wdGlvbnMpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY29tcGlsZShpbnB1dCwgb3B0aW9ucywgZW52KSB7XHJcblx0ICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSBvcHRpb25zID0ge307XHJcblxyXG5cdCAgaWYgKGlucHV0ID09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJyAmJiBpbnB1dC50eXBlICE9PSAnUHJvZ3JhbScpIHtcclxuXHQgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1lvdSBtdXN0IHBhc3MgYSBzdHJpbmcgb3IgSGFuZGxlYmFycyBBU1QgdG8gSGFuZGxlYmFycy5jb21waWxlLiBZb3UgcGFzc2VkICcgKyBpbnB1dCk7XHJcblx0ICB9XHJcblxyXG5cdCAgb3B0aW9ucyA9IF91dGlscy5leHRlbmQoe30sIG9wdGlvbnMpO1xyXG5cdCAgaWYgKCEoJ2RhdGEnIGluIG9wdGlvbnMpKSB7XHJcblx0ICAgIG9wdGlvbnMuZGF0YSA9IHRydWU7XHJcblx0ICB9XHJcblx0ICBpZiAob3B0aW9ucy5jb21wYXQpIHtcclxuXHQgICAgb3B0aW9ucy51c2VEZXB0aHMgPSB0cnVlO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBjb21waWxlZCA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICBmdW5jdGlvbiBjb21waWxlSW5wdXQoKSB7XHJcblx0ICAgIHZhciBhc3QgPSBlbnYucGFyc2UoaW5wdXQsIG9wdGlvbnMpLFxyXG5cdCAgICAgICAgZW52aXJvbm1lbnQgPSBuZXcgZW52LkNvbXBpbGVyKCkuY29tcGlsZShhc3QsIG9wdGlvbnMpLFxyXG5cdCAgICAgICAgdGVtcGxhdGVTcGVjID0gbmV3IGVudi5KYXZhU2NyaXB0Q29tcGlsZXIoKS5jb21waWxlKGVudmlyb25tZW50LCBvcHRpb25zLCB1bmRlZmluZWQsIHRydWUpO1xyXG5cdCAgICByZXR1cm4gZW52LnRlbXBsYXRlKHRlbXBsYXRlU3BlYyk7XHJcblx0ICB9XHJcblxyXG5cdCAgLy8gVGVtcGxhdGUgaXMgb25seSBjb21waWxlZCBvbiBmaXJzdCB1c2UgYW5kIGNhY2hlZCBhZnRlciB0aGF0IHBvaW50LlxyXG5cdCAgZnVuY3Rpb24gcmV0KGNvbnRleHQsIGV4ZWNPcHRpb25zKSB7XHJcblx0ICAgIGlmICghY29tcGlsZWQpIHtcclxuXHQgICAgICBjb21waWxlZCA9IGNvbXBpbGVJbnB1dCgpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBjb21waWxlZC5jYWxsKHRoaXMsIGNvbnRleHQsIGV4ZWNPcHRpb25zKTtcclxuXHQgIH1cclxuXHQgIHJldC5fc2V0dXAgPSBmdW5jdGlvbiAoc2V0dXBPcHRpb25zKSB7XHJcblx0ICAgIGlmICghY29tcGlsZWQpIHtcclxuXHQgICAgICBjb21waWxlZCA9IGNvbXBpbGVJbnB1dCgpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBjb21waWxlZC5fc2V0dXAoc2V0dXBPcHRpb25zKTtcclxuXHQgIH07XHJcblx0ICByZXQuX2NoaWxkID0gZnVuY3Rpb24gKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcclxuXHQgICAgaWYgKCFjb21waWxlZCkge1xyXG5cdCAgICAgIGNvbXBpbGVkID0gY29tcGlsZUlucHV0KCk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGNvbXBpbGVkLl9jaGlsZChpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcclxuXHQgIH07XHJcblx0ICByZXR1cm4gcmV0O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYXJnRXF1YWxzKGEsIGIpIHtcclxuXHQgIGlmIChhID09PSBiKSB7XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChfdXRpbHMuaXNBcnJheShhKSAmJiBfdXRpbHMuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcclxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgaWYgKCFhcmdFcXVhbHMoYVtpXSwgYltpXSkpIHtcclxuXHQgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRydWU7XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1MaXRlcmFsVG9QYXRoKHNleHByKSB7XHJcblx0ICBpZiAoIXNleHByLnBhdGgucGFydHMpIHtcclxuXHQgICAgdmFyIGxpdGVyYWwgPSBzZXhwci5wYXRoO1xyXG5cdCAgICAvLyBDYXN0aW5nIHRvIHN0cmluZyBoZXJlIHRvIG1ha2UgZmFsc2UgYW5kIDAgbGl0ZXJhbCB2YWx1ZXMgcGxheSBuaWNlbHkgd2l0aCB0aGUgcmVzdFxyXG5cdCAgICAvLyBvZiB0aGUgc3lzdGVtLlxyXG5cdCAgICBzZXhwci5wYXRoID0ge1xyXG5cdCAgICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXHJcblx0ICAgICAgZGF0YTogZmFsc2UsXHJcblx0ICAgICAgZGVwdGg6IDAsXHJcblx0ICAgICAgcGFydHM6IFtsaXRlcmFsLm9yaWdpbmFsICsgJyddLFxyXG5cdCAgICAgIG9yaWdpbmFsOiBsaXRlcmFsLm9yaWdpbmFsICsgJycsXHJcblx0ICAgICAgbG9jOiBsaXRlcmFsLmxvY1xyXG5cdCAgICB9O1xyXG5cdCAgfVxyXG5cdH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBfY29kZUdlbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG5cclxuXHR2YXIgX2NvZGVHZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29kZUdlbik7XHJcblxyXG5cdGZ1bmN0aW9uIExpdGVyYWwodmFsdWUpIHtcclxuXHQgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEphdmFTY3JpcHRDb21waWxlcigpIHt9XHJcblxyXG5cdEphdmFTY3JpcHRDb21waWxlci5wcm90b3R5cGUgPSB7XHJcblx0ICAvLyBQVUJMSUMgQVBJOiBZb3UgY2FuIG92ZXJyaWRlIHRoZXNlIG1ldGhvZHMgaW4gYSBzdWJjbGFzcyB0byBwcm92aWRlXHJcblx0ICAvLyBhbHRlcm5hdGl2ZSBjb21waWxlZCBmb3JtcyBmb3IgbmFtZSBsb29rdXAgYW5kIGJ1ZmZlcmluZyBzZW1hbnRpY3NcclxuXHQgIG5hbWVMb29rdXA6IGZ1bmN0aW9uIG5hbWVMb29rdXAocGFyZW50LCBuYW1lIC8qICwgdHlwZSovKSB7XHJcblx0ICAgIGlmIChKYXZhU2NyaXB0Q29tcGlsZXIuaXNWYWxpZEphdmFTY3JpcHRWYXJpYWJsZU5hbWUobmFtZSkpIHtcclxuXHQgICAgICByZXR1cm4gW3BhcmVudCwgJy4nLCBuYW1lXTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gW3BhcmVudCwgJ1snLCBKU09OLnN0cmluZ2lmeShuYW1lKSwgJ10nXTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIGRlcHRoZWRMb29rdXA6IGZ1bmN0aW9uIGRlcHRoZWRMb29rdXAobmFtZSkge1xyXG5cdCAgICByZXR1cm4gW3RoaXMuYWxpYXNhYmxlKCdjb250YWluZXIubG9va3VwJyksICcoZGVwdGhzLCBcIicsIG5hbWUsICdcIiknXTtcclxuXHQgIH0sXHJcblxyXG5cdCAgY29tcGlsZXJJbmZvOiBmdW5jdGlvbiBjb21waWxlckluZm8oKSB7XHJcblx0ICAgIHZhciByZXZpc2lvbiA9IF9iYXNlLkNPTVBJTEVSX1JFVklTSU9OLFxyXG5cdCAgICAgICAgdmVyc2lvbnMgPSBfYmFzZS5SRVZJU0lPTl9DSEFOR0VTW3JldmlzaW9uXTtcclxuXHQgICAgcmV0dXJuIFtyZXZpc2lvbiwgdmVyc2lvbnNdO1xyXG5cdCAgfSxcclxuXHJcblx0ICBhcHBlbmRUb0J1ZmZlcjogZnVuY3Rpb24gYXBwZW5kVG9CdWZmZXIoc291cmNlLCBsb2NhdGlvbiwgZXhwbGljaXQpIHtcclxuXHQgICAgLy8gRm9yY2UgYSBzb3VyY2UgYXMgdGhpcyBzaW1wbGlmaWVzIHRoZSBtZXJnZSBsb2dpYy5cclxuXHQgICAgaWYgKCFfdXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XHJcblx0ICAgICAgc291cmNlID0gW3NvdXJjZV07XHJcblx0ICAgIH1cclxuXHQgICAgc291cmNlID0gdGhpcy5zb3VyY2Uud3JhcChzb3VyY2UsIGxvY2F0aW9uKTtcclxuXHJcblx0ICAgIGlmICh0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlKSB7XHJcblx0ICAgICAgcmV0dXJuIFsncmV0dXJuICcsIHNvdXJjZSwgJzsnXTtcclxuXHQgICAgfSBlbHNlIGlmIChleHBsaWNpdCkge1xyXG5cdCAgICAgIC8vIFRoaXMgaXMgYSBjYXNlIHdoZXJlIHRoZSBidWZmZXIgb3BlcmF0aW9uIG9jY3VycyBhcyBhIGNoaWxkIG9mIGFub3RoZXJcclxuXHQgICAgICAvLyBjb25zdHJ1Y3QsIGdlbmVyYWxseSBicmFjZXMuIFdlIGhhdmUgdG8gZXhwbGljaXRseSBvdXRwdXQgdGhlc2UgYnVmZmVyXHJcblx0ICAgICAgLy8gb3BlcmF0aW9ucyB0byBlbnN1cmUgdGhhdCB0aGUgZW1pdHRlZCBjb2RlIGdvZXMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24uXHJcblx0ICAgICAgcmV0dXJuIFsnYnVmZmVyICs9ICcsIHNvdXJjZSwgJzsnXTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBzb3VyY2UuYXBwZW5kVG9CdWZmZXIgPSB0cnVlO1xyXG5cdCAgICAgIHJldHVybiBzb3VyY2U7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgaW5pdGlhbGl6ZUJ1ZmZlcjogZnVuY3Rpb24gaW5pdGlhbGl6ZUJ1ZmZlcigpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMucXVvdGVkU3RyaW5nKCcnKTtcclxuXHQgIH0sXHJcblx0ICAvLyBFTkQgUFVCTElDIEFQSVxyXG5cclxuXHQgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUoZW52aXJvbm1lbnQsIG9wdGlvbnMsIGNvbnRleHQsIGFzT2JqZWN0KSB7XHJcblx0ICAgIHRoaXMuZW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudDtcclxuXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHQgICAgdGhpcy5zdHJpbmdQYXJhbXMgPSB0aGlzLm9wdGlvbnMuc3RyaW5nUGFyYW1zO1xyXG5cdCAgICB0aGlzLnRyYWNrSWRzID0gdGhpcy5vcHRpb25zLnRyYWNrSWRzO1xyXG5cdCAgICB0aGlzLnByZWNvbXBpbGUgPSAhYXNPYmplY3Q7XHJcblxyXG5cdCAgICB0aGlzLm5hbWUgPSB0aGlzLmVudmlyb25tZW50Lm5hbWU7XHJcblx0ICAgIHRoaXMuaXNDaGlsZCA9ICEhY29udGV4dDtcclxuXHQgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCB7XHJcblx0ICAgICAgZGVjb3JhdG9yczogW10sXHJcblx0ICAgICAgcHJvZ3JhbXM6IFtdLFxyXG5cdCAgICAgIGVudmlyb25tZW50czogW11cclxuXHQgICAgfTtcclxuXHJcblx0ICAgIHRoaXMucHJlYW1ibGUoKTtcclxuXHJcblx0ICAgIHRoaXMuc3RhY2tTbG90ID0gMDtcclxuXHQgICAgdGhpcy5zdGFja1ZhcnMgPSBbXTtcclxuXHQgICAgdGhpcy5hbGlhc2VzID0ge307XHJcblx0ICAgIHRoaXMucmVnaXN0ZXJzID0geyBsaXN0OiBbXSB9O1xyXG5cdCAgICB0aGlzLmhhc2hlcyA9IFtdO1xyXG5cdCAgICB0aGlzLmNvbXBpbGVTdGFjayA9IFtdO1xyXG5cdCAgICB0aGlzLmlubGluZVN0YWNrID0gW107XHJcblx0ICAgIHRoaXMuYmxvY2tQYXJhbXMgPSBbXTtcclxuXHJcblx0ICAgIHRoaXMuY29tcGlsZUNoaWxkcmVuKGVudmlyb25tZW50LCBvcHRpb25zKTtcclxuXHJcblx0ICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgZW52aXJvbm1lbnQudXNlRGVwdGhzIHx8IGVudmlyb25tZW50LnVzZURlY29yYXRvcnMgfHwgdGhpcy5vcHRpb25zLmNvbXBhdDtcclxuXHQgICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgZW52aXJvbm1lbnQudXNlQmxvY2tQYXJhbXM7XHJcblxyXG5cdCAgICB2YXIgb3Bjb2RlcyA9IGVudmlyb25tZW50Lm9wY29kZXMsXHJcblx0ICAgICAgICBvcGNvZGUgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBmaXJzdExvYyA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGkgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBsID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgZm9yIChpID0gMCwgbCA9IG9wY29kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgICAgb3Bjb2RlID0gb3Bjb2Rlc1tpXTtcclxuXHJcblx0ICAgICAgdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uID0gb3Bjb2RlLmxvYztcclxuXHQgICAgICBmaXJzdExvYyA9IGZpcnN0TG9jIHx8IG9wY29kZS5sb2M7XHJcblx0ICAgICAgdGhpc1tvcGNvZGUub3Bjb2RlXS5hcHBseSh0aGlzLCBvcGNvZGUuYXJncyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIEZsdXNoIGFueSB0cmFpbGluZyBjb250ZW50IHRoYXQgbWlnaHQgYmUgcGVuZGluZy5cclxuXHQgICAgdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uID0gZmlyc3RMb2M7XHJcblx0ICAgIHRoaXMucHVzaFNvdXJjZSgnJyk7XHJcblxyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICBpZiAodGhpcy5zdGFja1Nsb3QgfHwgdGhpcy5pbmxpbmVTdGFjay5sZW5ndGggfHwgdGhpcy5jb21waWxlU3RhY2subGVuZ3RoKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0NvbXBpbGUgY29tcGxldGVkIHdpdGggY29udGVudCBsZWZ0IG9uIHN0YWNrJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICghdGhpcy5kZWNvcmF0b3JzLmlzRW1wdHkoKSkge1xyXG5cdCAgICAgIHRoaXMudXNlRGVjb3JhdG9ycyA9IHRydWU7XHJcblxyXG5cdCAgICAgIHRoaXMuZGVjb3JhdG9ycy5wcmVwZW5kKCd2YXIgZGVjb3JhdG9ycyA9IGNvbnRhaW5lci5kZWNvcmF0b3JzO1xcbicpO1xyXG5cdCAgICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKCdyZXR1cm4gZm47Jyk7XHJcblxyXG5cdCAgICAgIGlmIChhc09iamVjdCkge1xyXG5cdCAgICAgICAgdGhpcy5kZWNvcmF0b3JzID0gRnVuY3Rpb24uYXBwbHkodGhpcywgWydmbicsICdwcm9wcycsICdjb250YWluZXInLCAnZGVwdGgwJywgJ2RhdGEnLCAnYmxvY2tQYXJhbXMnLCAnZGVwdGhzJywgdGhpcy5kZWNvcmF0b3JzLm1lcmdlKCldKTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdGhpcy5kZWNvcmF0b3JzLnByZXBlbmQoJ2Z1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aDAsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcXG4nKTtcclxuXHQgICAgICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKCd9XFxuJyk7XHJcblx0ICAgICAgICB0aGlzLmRlY29yYXRvcnMgPSB0aGlzLmRlY29yYXRvcnMubWVyZ2UoKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5kZWNvcmF0b3JzID0gdW5kZWZpbmVkO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgZm4gPSB0aGlzLmNyZWF0ZUZ1bmN0aW9uQ29udGV4dChhc09iamVjdCk7XHJcblx0ICAgIGlmICghdGhpcy5pc0NoaWxkKSB7XHJcblx0ICAgICAgdmFyIHJldCA9IHtcclxuXHQgICAgICAgIGNvbXBpbGVyOiB0aGlzLmNvbXBpbGVySW5mbygpLFxyXG5cdCAgICAgICAgbWFpbjogZm5cclxuXHQgICAgICB9O1xyXG5cclxuXHQgICAgICBpZiAodGhpcy5kZWNvcmF0b3JzKSB7XHJcblx0ICAgICAgICByZXQubWFpbl9kID0gdGhpcy5kZWNvcmF0b3JzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG5cdCAgICAgICAgcmV0LnVzZURlY29yYXRvcnMgPSB0cnVlO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgdmFyIF9jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG5cdCAgICAgIHZhciBwcm9ncmFtcyA9IF9jb250ZXh0LnByb2dyYW1zO1xyXG5cdCAgICAgIHZhciBkZWNvcmF0b3JzID0gX2NvbnRleHQuZGVjb3JhdG9ycztcclxuXHJcblx0ICAgICAgZm9yIChpID0gMCwgbCA9IHByb2dyYW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgICAgaWYgKHByb2dyYW1zW2ldKSB7XHJcblx0ICAgICAgICAgIHJldFtpXSA9IHByb2dyYW1zW2ldO1xyXG5cdCAgICAgICAgICBpZiAoZGVjb3JhdG9yc1tpXSkge1xyXG5cdCAgICAgICAgICAgIHJldFtpICsgJ19kJ10gPSBkZWNvcmF0b3JzW2ldO1xyXG5cdCAgICAgICAgICAgIHJldC51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcclxuXHQgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgaWYgKHRoaXMuZW52aXJvbm1lbnQudXNlUGFydGlhbCkge1xyXG5cdCAgICAgICAgcmV0LnVzZVBhcnRpYWwgPSB0cnVlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAodGhpcy5vcHRpb25zLmRhdGEpIHtcclxuXHQgICAgICAgIHJldC51c2VEYXRhID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRoaXMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgICByZXQudXNlRGVwdGhzID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRoaXMudXNlQmxvY2tQYXJhbXMpIHtcclxuXHQgICAgICAgIHJldC51c2VCbG9ja1BhcmFtcyA9IHRydWU7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0KSB7XHJcblx0ICAgICAgICByZXQuY29tcGF0ID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIGlmICghYXNPYmplY3QpIHtcclxuXHQgICAgICAgIHJldC5jb21waWxlciA9IEpTT04uc3RyaW5naWZ5KHJldC5jb21waWxlcik7XHJcblxyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UuY3VycmVudExvY2F0aW9uID0geyBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDAgfSB9O1xyXG5cdCAgICAgICAgcmV0ID0gdGhpcy5vYmplY3RMaXRlcmFsKHJldCk7XHJcblxyXG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc3JjTmFtZSkge1xyXG5cdCAgICAgICAgICByZXQgPSByZXQudG9TdHJpbmdXaXRoU291cmNlTWFwKHsgZmlsZTogb3B0aW9ucy5kZXN0TmFtZSB9KTtcclxuXHQgICAgICAgICAgcmV0Lm1hcCA9IHJldC5tYXAgJiYgcmV0Lm1hcC50b1N0cmluZygpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgcmV0ID0gcmV0LnRvU3RyaW5nKCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHJldC5jb21waWxlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICByZXR1cm4gcmV0O1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiBmbjtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBwcmVhbWJsZTogZnVuY3Rpb24gcHJlYW1ibGUoKSB7XHJcblx0ICAgIC8vIHRyYWNrIHRoZSBsYXN0IGNvbnRleHQgcHVzaGVkIGludG8gcGxhY2UgdG8gYWxsb3cgc2tpcHBpbmcgdGhlXHJcblx0ICAgIC8vIGdldENvbnRleHQgb3Bjb2RlIHdoZW4gaXQgd291bGQgYmUgYSBub29wXHJcblx0ICAgIHRoaXMubGFzdENvbnRleHQgPSAwO1xyXG5cdCAgICB0aGlzLnNvdXJjZSA9IG5ldyBfY29kZUdlbjJbJ2RlZmF1bHQnXSh0aGlzLm9wdGlvbnMuc3JjTmFtZSk7XHJcblx0ICAgIHRoaXMuZGVjb3JhdG9ycyA9IG5ldyBfY29kZUdlbjJbJ2RlZmF1bHQnXSh0aGlzLm9wdGlvbnMuc3JjTmFtZSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIGNyZWF0ZUZ1bmN0aW9uQ29udGV4dDogZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25Db250ZXh0KGFzT2JqZWN0KSB7XHJcblx0ICAgIHZhciB2YXJEZWNsYXJhdGlvbnMgPSAnJztcclxuXHJcblx0ICAgIHZhciBsb2NhbHMgPSB0aGlzLnN0YWNrVmFycy5jb25jYXQodGhpcy5yZWdpc3RlcnMubGlzdCk7XHJcblx0ICAgIGlmIChsb2NhbHMubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgIHZhckRlY2xhcmF0aW9ucyArPSAnLCAnICsgbG9jYWxzLmpvaW4oJywgJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIEdlbmVyYXRlIG1pbmltaXplciBhbGlhcyBtYXBwaW5nc1xyXG5cdCAgICAvL1xyXG5cdCAgICAvLyBXaGVuIHVzaW5nIHRydWUgU291cmNlTm9kZXMsIHRoaXMgd2lsbCB1cGRhdGUgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIGdpdmVuIGFsaWFzXHJcblx0ICAgIC8vIGFzIHRoZSBzb3VyY2Ugbm9kZXMgYXJlIHJldXNlZCBpbiBzaXR1LiBGb3IgdGhlIG5vbi1zb3VyY2Ugbm9kZSBjb21waWxhdGlvbiBtb2RlLFxyXG5cdCAgICAvLyBhbGlhc2VzIHdpbGwgbm90IGJlIHVzZWQsIGJ1dCB0aGlzIGNhc2UgaXMgYWxyZWFkeSBiZWluZyBydW4gb24gdGhlIGNsaWVudCBhbmRcclxuXHQgICAgLy8gd2UgYXJlbid0IGNvbmNlcm4gYWJvdXQgbWluaW1pemluZyB0aGUgdGVtcGxhdGUgc2l6ZS5cclxuXHQgICAgdmFyIGFsaWFzQ291bnQgPSAwO1xyXG5cdCAgICBmb3IgKHZhciBhbGlhcyBpbiB0aGlzLmFsaWFzZXMpIHtcclxuXHQgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxyXG5cdCAgICAgIHZhciBub2RlID0gdGhpcy5hbGlhc2VzW2FsaWFzXTtcclxuXHJcblx0ICAgICAgaWYgKHRoaXMuYWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShhbGlhcykgJiYgbm9kZS5jaGlsZHJlbiAmJiBub2RlLnJlZmVyZW5jZUNvdW50ID4gMSkge1xyXG5cdCAgICAgICAgdmFyRGVjbGFyYXRpb25zICs9ICcsIGFsaWFzJyArICsrYWxpYXNDb3VudCArICc9JyArIGFsaWFzO1xyXG5cdCAgICAgICAgbm9kZS5jaGlsZHJlblswXSA9ICdhbGlhcycgKyBhbGlhc0NvdW50O1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIHBhcmFtcyA9IFsnY29udGFpbmVyJywgJ2RlcHRoMCcsICdoZWxwZXJzJywgJ3BhcnRpYWxzJywgJ2RhdGEnXTtcclxuXHJcblx0ICAgIGlmICh0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IHRoaXMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgcGFyYW1zLnB1c2goJ2Jsb2NrUGFyYW1zJyk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgcGFyYW1zLnB1c2goJ2RlcHRocycpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBQZXJmb3JtIGEgc2Vjb25kIHBhc3Mgb3ZlciB0aGUgb3V0cHV0IHRvIG1lcmdlIGNvbnRlbnQgd2hlbiBwb3NzaWJsZVxyXG5cdCAgICB2YXIgc291cmNlID0gdGhpcy5tZXJnZVNvdXJjZSh2YXJEZWNsYXJhdGlvbnMpO1xyXG5cclxuXHQgICAgaWYgKGFzT2JqZWN0KSB7XHJcblx0ICAgICAgcGFyYW1zLnB1c2goc291cmNlKTtcclxuXHJcblx0ICAgICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KHRoaXMsIHBhcmFtcyk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMuc291cmNlLndyYXAoWydmdW5jdGlvbignLCBwYXJhbXMuam9pbignLCcpLCAnKSB7XFxuICAnLCBzb3VyY2UsICd9J10pO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgbWVyZ2VTb3VyY2U6IGZ1bmN0aW9uIG1lcmdlU291cmNlKHZhckRlY2xhcmF0aW9ucykge1xyXG5cdCAgICB2YXIgaXNTaW1wbGUgPSB0aGlzLmVudmlyb25tZW50LmlzU2ltcGxlLFxyXG5cdCAgICAgICAgYXBwZW5kT25seSA9ICF0aGlzLmZvcmNlQnVmZmVyLFxyXG5cdCAgICAgICAgYXBwZW5kRmlyc3QgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBzb3VyY2VTZWVuID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgYnVmZmVyU3RhcnQgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBidWZmZXJFbmQgPSB1bmRlZmluZWQ7XHJcblx0ICAgIHRoaXMuc291cmNlLmVhY2goZnVuY3Rpb24gKGxpbmUpIHtcclxuXHQgICAgICBpZiAobGluZS5hcHBlbmRUb0J1ZmZlcikge1xyXG5cdCAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XHJcblx0ICAgICAgICAgIGxpbmUucHJlcGVuZCgnICArICcpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgYnVmZmVyU3RhcnQgPSBsaW5lO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgYnVmZmVyRW5kID0gbGluZTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XHJcblx0ICAgICAgICAgIGlmICghc291cmNlU2Vlbikge1xyXG5cdCAgICAgICAgICAgIGFwcGVuZEZpcnN0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBidWZmZXJTdGFydC5wcmVwZW5kKCdidWZmZXIgKz0gJyk7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgICAgYnVmZmVyRW5kLmFkZCgnOycpO1xyXG5cdCAgICAgICAgICBidWZmZXJTdGFydCA9IGJ1ZmZlckVuZCA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgIH1cclxuXHJcblx0ICAgICAgICBzb3VyY2VTZWVuID0gdHJ1ZTtcclxuXHQgICAgICAgIGlmICghaXNTaW1wbGUpIHtcclxuXHQgICAgICAgICAgYXBwZW5kT25seSA9IGZhbHNlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSk7XHJcblxyXG5cdCAgICBpZiAoYXBwZW5kT25seSkge1xyXG5cdCAgICAgIGlmIChidWZmZXJTdGFydCkge1xyXG5cdCAgICAgICAgYnVmZmVyU3RhcnQucHJlcGVuZCgncmV0dXJuICcpO1xyXG5cdCAgICAgICAgYnVmZmVyRW5kLmFkZCgnOycpO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAoIXNvdXJjZVNlZW4pIHtcclxuXHQgICAgICAgIHRoaXMuc291cmNlLnB1c2goJ3JldHVybiBcIlwiOycpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB2YXJEZWNsYXJhdGlvbnMgKz0gJywgYnVmZmVyID0gJyArIChhcHBlbmRGaXJzdCA/ICcnIDogdGhpcy5pbml0aWFsaXplQnVmZmVyKCkpO1xyXG5cclxuXHQgICAgICBpZiAoYnVmZmVyU3RhcnQpIHtcclxuXHQgICAgICAgIGJ1ZmZlclN0YXJ0LnByZXBlbmQoJ3JldHVybiBidWZmZXIgKyAnKTtcclxuXHQgICAgICAgIGJ1ZmZlckVuZC5hZGQoJzsnKTtcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdGhpcy5zb3VyY2UucHVzaCgncmV0dXJuIGJ1ZmZlcjsnKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICh2YXJEZWNsYXJhdGlvbnMpIHtcclxuXHQgICAgICB0aGlzLnNvdXJjZS5wcmVwZW5kKCd2YXIgJyArIHZhckRlY2xhcmF0aW9ucy5zdWJzdHJpbmcoMikgKyAoYXBwZW5kRmlyc3QgPyAnJyA6ICc7XFxuJykpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gdGhpcy5zb3VyY2UubWVyZ2UoKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2Jsb2NrVmFsdWVdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgdmFsdWVcclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcmV0dXJuIHZhbHVlIG9mIGJsb2NrSGVscGVyTWlzc2luZ1xyXG5cdCAgLy9cclxuXHQgIC8vIFRoZSBwdXJwb3NlIG9mIHRoaXMgb3Bjb2RlIGlzIHRvIHRha2UgYSBibG9jayBvZiB0aGUgZm9ybVxyXG5cdCAgLy8gYHt7I3RoaXMuZm9vfX0uLi57ey90aGlzLmZvb319YCwgcmVzb2x2ZSB0aGUgdmFsdWUgb2YgYGZvb2AsIGFuZFxyXG5cdCAgLy8gcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgd2l0aCB0aGUgcmVzdWx0IG9mIHByb3Blcmx5XHJcblx0ICAvLyBpbnZva2luZyBibG9ja0hlbHBlck1pc3NpbmcuXHJcblx0ICBibG9ja1ZhbHVlOiBmdW5jdGlvbiBibG9ja1ZhbHVlKG5hbWUpIHtcclxuXHQgICAgdmFyIGJsb2NrSGVscGVyTWlzc2luZyA9IHRoaXMuYWxpYXNhYmxlKCdoZWxwZXJzLmJsb2NrSGVscGVyTWlzc2luZycpLFxyXG5cdCAgICAgICAgcGFyYW1zID0gW3RoaXMuY29udGV4dE5hbWUoMCldO1xyXG5cdCAgICB0aGlzLnNldHVwSGVscGVyQXJncyhuYW1lLCAwLCBwYXJhbXMpO1xyXG5cclxuXHQgICAgdmFyIGJsb2NrTmFtZSA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgcGFyYW1zLnNwbGljZSgxLCAwLCBibG9ja05hbWUpO1xyXG5cclxuXHQgICAgdGhpcy5wdXNoKHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbChibG9ja0hlbHBlck1pc3NpbmcsICdjYWxsJywgcGFyYW1zKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFthbWJpZ3VvdXNCbG9ja1ZhbHVlXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHZhbHVlXHJcblx0ICAvLyBDb21waWxlciB2YWx1ZSwgYmVmb3JlOiBsYXN0SGVscGVyPXZhbHVlIG9mIGxhc3QgZm91bmQgaGVscGVyLCBpZiBhbnlcclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlciwgaWYgbm8gbGFzdEhlbHBlcjogc2FtZSBhcyBbYmxvY2tWYWx1ZV1cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlciwgaWYgbGFzdEhlbHBlcjogdmFsdWVcclxuXHQgIGFtYmlndW91c0Jsb2NrVmFsdWU6IGZ1bmN0aW9uIGFtYmlndW91c0Jsb2NrVmFsdWUoKSB7XHJcblx0ICAgIC8vIFdlJ3JlIGJlaW5nIGEgYml0IGNoZWVreSBhbmQgcmV1c2luZyB0aGUgb3B0aW9ucyB2YWx1ZSBmcm9tIHRoZSBwcmlvciBleGVjXHJcblx0ICAgIHZhciBibG9ja0hlbHBlck1pc3NpbmcgPSB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5ibG9ja0hlbHBlck1pc3NpbmcnKSxcclxuXHQgICAgICAgIHBhcmFtcyA9IFt0aGlzLmNvbnRleHROYW1lKDApXTtcclxuXHQgICAgdGhpcy5zZXR1cEhlbHBlckFyZ3MoJycsIDAsIHBhcmFtcywgdHJ1ZSk7XHJcblxyXG5cdCAgICB0aGlzLmZsdXNoSW5saW5lKCk7XHJcblxyXG5cdCAgICB2YXIgY3VycmVudCA9IHRoaXMudG9wU3RhY2soKTtcclxuXHQgICAgcGFyYW1zLnNwbGljZSgxLCAwLCBjdXJyZW50KTtcclxuXHJcblx0ICAgIHRoaXMucHVzaFNvdXJjZShbJ2lmICghJywgdGhpcy5sYXN0SGVscGVyLCAnKSB7ICcsIGN1cnJlbnQsICcgPSAnLCB0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoYmxvY2tIZWxwZXJNaXNzaW5nLCAnY2FsbCcsIHBhcmFtcyksICd9J10pO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbYXBwZW5kQ29udGVudF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gQXBwZW5kcyB0aGUgc3RyaW5nIHZhbHVlIG9mIGBjb250ZW50YCB0byB0aGUgY3VycmVudCBidWZmZXJcclxuXHQgIGFwcGVuZENvbnRlbnQ6IGZ1bmN0aW9uIGFwcGVuZENvbnRlbnQoY29udGVudCkge1xyXG5cdCAgICBpZiAodGhpcy5wZW5kaW5nQ29udGVudCkge1xyXG5cdCAgICAgIGNvbnRlbnQgPSB0aGlzLnBlbmRpbmdDb250ZW50ICsgY29udGVudDtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLnBlbmRpbmdMb2NhdGlvbiA9IHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbjtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5wZW5kaW5nQ29udGVudCA9IGNvbnRlbnQ7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFthcHBlbmRdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBDb2VyY2VzIGB2YWx1ZWAgdG8gYSBTdHJpbmcgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGN1cnJlbnQgYnVmZmVyLlxyXG5cdCAgLy9cclxuXHQgIC8vIElmIGB2YWx1ZWAgaXMgdHJ1dGh5LCBvciAwLCBpdCBpcyBjb2VyY2VkIGludG8gYSBzdHJpbmcgYW5kIGFwcGVuZGVkXHJcblx0ICAvLyBPdGhlcndpc2UsIHRoZSBlbXB0eSBzdHJpbmcgaXMgYXBwZW5kZWRcclxuXHQgIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xyXG5cdCAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XHJcblx0ICAgICAgdGhpcy5yZXBsYWNlU3RhY2soZnVuY3Rpb24gKGN1cnJlbnQpIHtcclxuXHQgICAgICAgIHJldHVybiBbJyAhPSBudWxsID8gJywgY3VycmVudCwgJyA6IFwiXCInXTtcclxuXHQgICAgICB9KTtcclxuXHJcblx0ICAgICAgdGhpcy5wdXNoU291cmNlKHRoaXMuYXBwZW5kVG9CdWZmZXIodGhpcy5wb3BTdGFjaygpKSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdmFyIGxvY2FsID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIHRoaXMucHVzaFNvdXJjZShbJ2lmICgnLCBsb2NhbCwgJyAhPSBudWxsKSB7ICcsIHRoaXMuYXBwZW5kVG9CdWZmZXIobG9jYWwsIHVuZGVmaW5lZCwgdHJ1ZSksICcgfSddKTtcclxuXHQgICAgICBpZiAodGhpcy5lbnZpcm9ubWVudC5pc1NpbXBsZSkge1xyXG5cdCAgICAgICAgdGhpcy5wdXNoU291cmNlKFsnZWxzZSB7ICcsIHRoaXMuYXBwZW5kVG9CdWZmZXIoXCInJ1wiLCB1bmRlZmluZWQsIHRydWUpLCAnIH0nXSk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFthcHBlbmRFc2NhcGVkXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gRXNjYXBlIGB2YWx1ZWAgYW5kIGFwcGVuZCBpdCB0byB0aGUgYnVmZmVyXHJcblx0ICBhcHBlbmRFc2NhcGVkOiBmdW5jdGlvbiBhcHBlbmRFc2NhcGVkKCkge1xyXG5cdCAgICB0aGlzLnB1c2hTb3VyY2UodGhpcy5hcHBlbmRUb0J1ZmZlcihbdGhpcy5hbGlhc2FibGUoJ2NvbnRhaW5lci5lc2NhcGVFeHByZXNzaW9uJyksICcoJywgdGhpcy5wb3BTdGFjaygpLCAnKSddKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtnZXRDb250ZXh0XVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cclxuXHQgIC8vIENvbXBpbGVyIHZhbHVlLCBhZnRlcjogbGFzdENvbnRleHQ9ZGVwdGhcclxuXHQgIC8vXHJcblx0ICAvLyBTZXQgdGhlIHZhbHVlIG9mIHRoZSBgbGFzdENvbnRleHRgIGNvbXBpbGVyIHZhbHVlIHRvIHRoZSBkZXB0aFxyXG5cdCAgZ2V0Q29udGV4dDogZnVuY3Rpb24gZ2V0Q29udGV4dChkZXB0aCkge1xyXG5cdCAgICB0aGlzLmxhc3RDb250ZXh0ID0gZGVwdGg7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtwdXNoQ29udGV4dF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogY3VycmVudENvbnRleHQsIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFB1c2hlcyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgY29udGV4dCBvbnRvIHRoZSBzdGFjay5cclxuXHQgIHB1c2hDb250ZXh0OiBmdW5jdGlvbiBwdXNoQ29udGV4dCgpIHtcclxuXHQgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMuY29udGV4dE5hbWUodGhpcy5sYXN0Q29udGV4dCkpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbbG9va3VwT25Db250ZXh0XVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiBjdXJyZW50Q29udGV4dFtuYW1lXSwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gTG9va3MgdXAgdGhlIHZhbHVlIG9mIGBuYW1lYCBvbiB0aGUgY3VycmVudCBjb250ZXh0IGFuZCBwdXNoZXNcclxuXHQgIC8vIGl0IG9udG8gdGhlIHN0YWNrLlxyXG5cdCAgbG9va3VwT25Db250ZXh0OiBmdW5jdGlvbiBsb29rdXBPbkNvbnRleHQocGFydHMsIGZhbHN5LCBzdHJpY3QsIHNjb3BlZCkge1xyXG5cdCAgICB2YXIgaSA9IDA7XHJcblxyXG5cdCAgICBpZiAoIXNjb3BlZCAmJiB0aGlzLm9wdGlvbnMuY29tcGF0ICYmICF0aGlzLmxhc3RDb250ZXh0KSB7XHJcblx0ICAgICAgLy8gVGhlIGRlcHRoZWQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGFuZGxlIHRoZSB1bmRlZmluZWQgbG9naWMgZm9yIHRoZSByb290IGxldmVsIHRoYXRcclxuXHQgICAgICAvLyBpcyBpbXBsZW1lbnRlZCBiZWxvdywgc28gd2UgZXZhbHVhdGUgdGhhdCBkaXJlY3RseSBpbiBjb21wYXQgbW9kZVxyXG5cdCAgICAgIHRoaXMucHVzaCh0aGlzLmRlcHRoZWRMb29rdXAocGFydHNbaSsrXSkpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMucHVzaENvbnRleHQoKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5yZXNvbHZlUGF0aCgnY29udGV4dCcsIHBhcnRzLCBpLCBmYWxzeSwgc3RyaWN0KTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2xvb2t1cEJsb2NrUGFyYW1dXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGJsb2NrUGFyYW1bbmFtZV0sIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIExvb2tzIHVwIHRoZSB2YWx1ZSBvZiBgcGFydHNgIG9uIHRoZSBnaXZlbiBibG9jayBwYXJhbSBhbmQgcHVzaGVzXHJcblx0ICAvLyBpdCBvbnRvIHRoZSBzdGFjay5cclxuXHQgIGxvb2t1cEJsb2NrUGFyYW06IGZ1bmN0aW9uIGxvb2t1cEJsb2NrUGFyYW0oYmxvY2tQYXJhbUlkLCBwYXJ0cykge1xyXG5cdCAgICB0aGlzLnVzZUJsb2NrUGFyYW1zID0gdHJ1ZTtcclxuXHJcblx0ICAgIHRoaXMucHVzaChbJ2Jsb2NrUGFyYW1zWycsIGJsb2NrUGFyYW1JZFswXSwgJ11bJywgYmxvY2tQYXJhbUlkWzFdLCAnXSddKTtcclxuXHQgICAgdGhpcy5yZXNvbHZlUGF0aCgnY29udGV4dCcsIHBhcnRzLCAxKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2xvb2t1cERhdGFdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGRhdGEsIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFB1c2ggdGhlIGRhdGEgbG9va3VwIG9wZXJhdG9yXHJcblx0ICBsb29rdXBEYXRhOiBmdW5jdGlvbiBsb29rdXBEYXRhKGRlcHRoLCBwYXJ0cywgc3RyaWN0KSB7XHJcblx0ICAgIGlmICghZGVwdGgpIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ2RhdGEnKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ2NvbnRhaW5lci5kYXRhKGRhdGEsICcgKyBkZXB0aCArICcpJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMucmVzb2x2ZVBhdGgoJ2RhdGEnLCBwYXJ0cywgMCwgdHJ1ZSwgc3RyaWN0KTtcclxuXHQgIH0sXHJcblxyXG5cdCAgcmVzb2x2ZVBhdGg6IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHR5cGUsIHBhcnRzLCBpLCBmYWxzeSwgc3RyaWN0KSB7XHJcblx0ICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XHJcblxyXG5cdCAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpY3QgfHwgdGhpcy5vcHRpb25zLmFzc3VtZU9iamVjdHMpIHtcclxuXHQgICAgICB0aGlzLnB1c2goc3RyaWN0TG9va3VwKHRoaXMub3B0aW9ucy5zdHJpY3QgJiYgc3RyaWN0LCB0aGlzLCBwYXJ0cywgdHlwZSkpO1xyXG5cdCAgICAgIHJldHVybjtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aDtcclxuXHQgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xyXG5cdCAgICAgIHRoaXMucmVwbGFjZVN0YWNrKGZ1bmN0aW9uIChjdXJyZW50KSB7XHJcblx0ICAgICAgICB2YXIgbG9va3VwID0gX3RoaXMubmFtZUxvb2t1cChjdXJyZW50LCBwYXJ0c1tpXSwgdHlwZSk7XHJcblx0ICAgICAgICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IHplcm8gYW5kIGZhbHNlIGFyZSBoYW5kbGVkIHByb3Blcmx5IGlmIHRoZSBjb250ZXh0IChmYWxzeSBmbGFnKVxyXG5cdCAgICAgICAgLy8gbmVlZHMgdG8gaGF2ZSB0aGUgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlc2UgdmFsdWVzLlxyXG5cdCAgICAgICAgaWYgKCFmYWxzeSkge1xyXG5cdCAgICAgICAgICByZXR1cm4gWycgIT0gbnVsbCA/ICcsIGxvb2t1cCwgJyA6ICcsIGN1cnJlbnRdO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiB1c2UgZ2VuZXJpYyBmYWxzeSBoYW5kbGluZ1xyXG5cdCAgICAgICAgICByZXR1cm4gWycgJiYgJywgbG9va3VwXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9KTtcclxuXHQgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtyZXNvbHZlUG9zc2libGVMYW1iZGFdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogdmFsdWUsIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXNvbHZlZCB2YWx1ZSwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gSWYgdGhlIGB2YWx1ZWAgaXMgYSBsYW1iZGEsIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGJ5XHJcblx0ICAvLyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBsYW1iZGFcclxuXHQgIHJlc29sdmVQb3NzaWJsZUxhbWJkYTogZnVuY3Rpb24gcmVzb2x2ZVBvc3NpYmxlTGFtYmRhKCkge1xyXG5cdCAgICB0aGlzLnB1c2goW3RoaXMuYWxpYXNhYmxlKCdjb250YWluZXIubGFtYmRhJyksICcoJywgdGhpcy5wb3BTdGFjaygpLCAnLCAnLCB0aGlzLmNvbnRleHROYW1lKDApLCAnKSddKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW3B1c2hTdHJpbmdQYXJhbV1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogc3RyaW5nLCBjdXJyZW50Q29udGV4dCwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGNvZGUgaXMgZGVzaWduZWQgZm9yIHVzZSBpbiBzdHJpbmcgbW9kZSwgd2hpY2hcclxuXHQgIC8vIHByb3ZpZGVzIHRoZSBzdHJpbmcgdmFsdWUgb2YgYSBwYXJhbWV0ZXIgYWxvbmcgd2l0aCBpdHNcclxuXHQgIC8vIGRlcHRoIHJhdGhlciB0aGFuIHJlc29sdmluZyBpdCBpbW1lZGlhdGVseS5cclxuXHQgIHB1c2hTdHJpbmdQYXJhbTogZnVuY3Rpb24gcHVzaFN0cmluZ1BhcmFtKHN0cmluZywgdHlwZSkge1xyXG5cdCAgICB0aGlzLnB1c2hDb250ZXh0KCk7XHJcblx0ICAgIHRoaXMucHVzaFN0cmluZyh0eXBlKTtcclxuXHJcblx0ICAgIC8vIElmIGl0J3MgYSBzdWJleHByZXNzaW9uLCB0aGUgc3RyaW5nIHJlc3VsdFxyXG5cdCAgICAvLyB3aWxsIGJlIHB1c2hlZCBhZnRlciB0aGlzIG9wY29kZS5cclxuXHQgICAgaWYgKHR5cGUgIT09ICdTdWJFeHByZXNzaW9uJykge1xyXG5cdCAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgdGhpcy5wdXNoU3RyaW5nKHN0cmluZyk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChzdHJpbmcpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBlbXB0eUhhc2g6IGZ1bmN0aW9uIGVtcHR5SGFzaChvbWl0RW1wdHkpIHtcclxuXHQgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hJZHNcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hDb250ZXh0c1xyXG5cdCAgICAgIHRoaXMucHVzaCgne30nKTsgLy8gaGFzaFR5cGVzXHJcblx0ICAgIH1cclxuXHQgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKG9taXRFbXB0eSA/ICd1bmRlZmluZWQnIDogJ3t9Jyk7XHJcblx0ICB9LFxyXG5cdCAgcHVzaEhhc2g6IGZ1bmN0aW9uIHB1c2hIYXNoKCkge1xyXG5cdCAgICBpZiAodGhpcy5oYXNoKSB7XHJcblx0ICAgICAgdGhpcy5oYXNoZXMucHVzaCh0aGlzLmhhc2gpO1xyXG5cdCAgICB9XHJcblx0ICAgIHRoaXMuaGFzaCA9IHsgdmFsdWVzOiBbXSwgdHlwZXM6IFtdLCBjb250ZXh0czogW10sIGlkczogW10gfTtcclxuXHQgIH0sXHJcblx0ICBwb3BIYXNoOiBmdW5jdGlvbiBwb3BIYXNoKCkge1xyXG5cdCAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaDtcclxuXHQgICAgdGhpcy5oYXNoID0gdGhpcy5oYXNoZXMucG9wKCk7XHJcblxyXG5cdCAgICBpZiAodGhpcy50cmFja0lkcykge1xyXG5cdCAgICAgIHRoaXMucHVzaCh0aGlzLm9iamVjdExpdGVyYWwoaGFzaC5pZHMpKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2guY29udGV4dHMpKTtcclxuXHQgICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2gudHlwZXMpKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5wdXNoKHRoaXMub2JqZWN0TGl0ZXJhbChoYXNoLnZhbHVlcykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbcHVzaFN0cmluZ11cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcXVvdGVkU3RyaW5nKHN0cmluZyksIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFB1c2ggYSBxdW90ZWQgdmVyc2lvbiBvZiBgc3RyaW5nYCBvbnRvIHRoZSBzdGFja1xyXG5cdCAgcHVzaFN0cmluZzogZnVuY3Rpb24gcHVzaFN0cmluZyhzdHJpbmcpIHtcclxuXHQgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMucXVvdGVkU3RyaW5nKHN0cmluZykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbcHVzaExpdGVyYWxdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHZhbHVlLCAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBQdXNoZXMgYSB2YWx1ZSBvbnRvIHRoZSBzdGFjay4gVGhpcyBvcGVyYXRpb24gcHJldmVudHNcclxuXHQgIC8vIHRoZSBjb21waWxlciBmcm9tIGNyZWF0aW5nIGEgdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGhvbGRcclxuXHQgIC8vIGl0LlxyXG5cdCAgcHVzaExpdGVyYWw6IGZ1bmN0aW9uIHB1c2hMaXRlcmFsKHZhbHVlKSB7XHJcblx0ICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh2YWx1ZSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtwdXNoUHJvZ3JhbV1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcHJvZ3JhbShndWlkKSwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gUHVzaCBhIHByb2dyYW0gZXhwcmVzc2lvbiBvbnRvIHRoZSBzdGFjay4gVGhpcyB0YWtlc1xyXG5cdCAgLy8gYSBjb21waWxlLXRpbWUgZ3VpZCBhbmQgY29udmVydHMgaXQgaW50byBhIHJ1bnRpbWUtYWNjZXNzaWJsZVxyXG5cdCAgLy8gZXhwcmVzc2lvbi5cclxuXHQgIHB1c2hQcm9ncmFtOiBmdW5jdGlvbiBwdXNoUHJvZ3JhbShndWlkKSB7XHJcblx0ICAgIGlmIChndWlkICE9IG51bGwpIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwodGhpcy5wcm9ncmFtRXhwcmVzc2lvbihndWlkKSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKG51bGwpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtyZWdpc3RlckRlY29yYXRvcl1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBQb3BzIG9mZiB0aGUgZGVjb3JhdG9yJ3MgcGFyYW1ldGVycywgaW52b2tlcyB0aGUgZGVjb3JhdG9yLFxyXG5cdCAgLy8gYW5kIGluc2VydHMgdGhlIGRlY29yYXRvciBpbnRvIHRoZSBkZWNvcmF0b3JzIGxpc3QuXHJcblx0ICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gcmVnaXN0ZXJEZWNvcmF0b3IocGFyYW1TaXplLCBuYW1lKSB7XHJcblx0ICAgIHZhciBmb3VuZERlY29yYXRvciA9IHRoaXMubmFtZUxvb2t1cCgnZGVjb3JhdG9ycycsIG5hbWUsICdkZWNvcmF0b3InKSxcclxuXHQgICAgICAgIG9wdGlvbnMgPSB0aGlzLnNldHVwSGVscGVyQXJncyhuYW1lLCBwYXJhbVNpemUpO1xyXG5cclxuXHQgICAgdGhpcy5kZWNvcmF0b3JzLnB1c2goWydmbiA9ICcsIHRoaXMuZGVjb3JhdG9ycy5mdW5jdGlvbkNhbGwoZm91bmREZWNvcmF0b3IsICcnLCBbJ2ZuJywgJ3Byb3BzJywgJ2NvbnRhaW5lcicsIG9wdGlvbnNdKSwgJyB8fCBmbjsnXSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtpbnZva2VIZWxwZXJdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzdWx0IG9mIGhlbHBlciBpbnZvY2F0aW9uXHJcblx0ICAvL1xyXG5cdCAgLy8gUG9wcyBvZmYgdGhlIGhlbHBlcidzIHBhcmFtZXRlcnMsIGludm9rZXMgdGhlIGhlbHBlcixcclxuXHQgIC8vIGFuZCBwdXNoZXMgdGhlIGhlbHBlcidzIHJldHVybiB2YWx1ZSBvbnRvIHRoZSBzdGFjay5cclxuXHQgIC8vXHJcblx0ICAvLyBJZiB0aGUgaGVscGVyIGlzIG5vdCBmb3VuZCwgYGhlbHBlck1pc3NpbmdgIGlzIGNhbGxlZC5cclxuXHQgIGludm9rZUhlbHBlcjogZnVuY3Rpb24gaW52b2tlSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSwgaXNTaW1wbGUpIHtcclxuXHQgICAgdmFyIG5vbkhlbHBlciA9IHRoaXMucG9wU3RhY2soKSxcclxuXHQgICAgICAgIGhlbHBlciA9IHRoaXMuc2V0dXBIZWxwZXIocGFyYW1TaXplLCBuYW1lKSxcclxuXHQgICAgICAgIHNpbXBsZSA9IGlzU2ltcGxlID8gW2hlbHBlci5uYW1lLCAnIHx8ICddIDogJyc7XHJcblxyXG5cdCAgICB2YXIgbG9va3VwID0gWycoJ10uY29uY2F0KHNpbXBsZSwgbm9uSGVscGVyKTtcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuc3RyaWN0KSB7XHJcblx0ICAgICAgbG9va3VwLnB1c2goJyB8fCAnLCB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5oZWxwZXJNaXNzaW5nJykpO1xyXG5cdCAgICB9XHJcblx0ICAgIGxvb2t1cC5wdXNoKCcpJyk7XHJcblxyXG5cdCAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGxvb2t1cCwgJ2NhbGwnLCBoZWxwZXIuY2FsbFBhcmFtcykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbaW52b2tlS25vd25IZWxwZXJdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzdWx0IG9mIGhlbHBlciBpbnZvY2F0aW9uXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGVyYXRpb24gaXMgdXNlZCB3aGVuIHRoZSBoZWxwZXIgaXMga25vd24gdG8gZXhpc3QsXHJcblx0ICAvLyBzbyBhIGBoZWxwZXJNaXNzaW5nYCBmYWxsYmFjayBpcyBub3QgcmVxdWlyZWQuXHJcblx0ICBpbnZva2VLbm93bkhlbHBlcjogZnVuY3Rpb24gaW52b2tlS25vd25IZWxwZXIocGFyYW1TaXplLCBuYW1lKSB7XHJcblx0ICAgIHZhciBoZWxwZXIgPSB0aGlzLnNldHVwSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSk7XHJcblx0ICAgIHRoaXMucHVzaCh0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoaGVscGVyLm5hbWUsICdjYWxsJywgaGVscGVyLmNhbGxQYXJhbXMpKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2ludm9rZUFtYmlndW91c11cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCBwYXJhbXMuLi4sIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiByZXN1bHQgb2YgZGlzYW1iaWd1YXRpb25cclxuXHQgIC8vXHJcblx0ICAvLyBUaGlzIG9wZXJhdGlvbiBpcyB1c2VkIHdoZW4gYW4gZXhwcmVzc2lvbiBsaWtlIGB7e2Zvb319YFxyXG5cdCAgLy8gaXMgcHJvdmlkZWQsIGJ1dCB3ZSBkb24ndCBrbm93IGF0IGNvbXBpbGUtdGltZSB3aGV0aGVyIGl0XHJcblx0ICAvLyBpcyBhIGhlbHBlciBvciBhIHBhdGguXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGVyYXRpb24gZW1pdHMgbW9yZSBjb2RlIHRoYW4gdGhlIG90aGVyIG9wdGlvbnMsXHJcblx0ICAvLyBhbmQgY2FuIGJlIGF2b2lkZWQgYnkgcGFzc2luZyB0aGUgYGtub3duSGVscGVyc2AgYW5kXHJcblx0ICAvLyBga25vd25IZWxwZXJzT25seWAgZmxhZ3MgYXQgY29tcGlsZS10aW1lLlxyXG5cdCAgaW52b2tlQW1iaWd1b3VzOiBmdW5jdGlvbiBpbnZva2VBbWJpZ3VvdXMobmFtZSwgaGVscGVyQ2FsbCkge1xyXG5cdCAgICB0aGlzLnVzZVJlZ2lzdGVyKCdoZWxwZXInKTtcclxuXHJcblx0ICAgIHZhciBub25IZWxwZXIgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblxyXG5cdCAgICB0aGlzLmVtcHR5SGFzaCgpO1xyXG5cdCAgICB2YXIgaGVscGVyID0gdGhpcy5zZXR1cEhlbHBlcigwLCBuYW1lLCBoZWxwZXJDYWxsKTtcclxuXHJcblx0ICAgIHZhciBoZWxwZXJOYW1lID0gdGhpcy5sYXN0SGVscGVyID0gdGhpcy5uYW1lTG9va3VwKCdoZWxwZXJzJywgbmFtZSwgJ2hlbHBlcicpO1xyXG5cclxuXHQgICAgdmFyIGxvb2t1cCA9IFsnKCcsICcoaGVscGVyID0gJywgaGVscGVyTmFtZSwgJyB8fCAnLCBub25IZWxwZXIsICcpJ107XHJcblx0ICAgIGlmICghdGhpcy5vcHRpb25zLnN0cmljdCkge1xyXG5cdCAgICAgIGxvb2t1cFswXSA9ICcoaGVscGVyID0gJztcclxuXHQgICAgICBsb29rdXAucHVzaCgnICE9IG51bGwgPyBoZWxwZXIgOiAnLCB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5oZWxwZXJNaXNzaW5nJykpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLnB1c2goWycoJywgbG9va3VwLCBoZWxwZXIucGFyYW1zSW5pdCA/IFsnKSwoJywgaGVscGVyLnBhcmFtc0luaXRdIDogW10sICcpLCcsICcodHlwZW9mIGhlbHBlciA9PT0gJywgdGhpcy5hbGlhc2FibGUoJ1wiZnVuY3Rpb25cIicpLCAnID8gJywgdGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKCdoZWxwZXInLCAnY2FsbCcsIGhlbHBlci5jYWxsUGFyYW1zKSwgJyA6IGhlbHBlcikpJ10pO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbaW52b2tlUGFydGlhbF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiBjb250ZXh0LCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrIGFmdGVyOiByZXN1bHQgb2YgcGFydGlhbCBpbnZvY2F0aW9uXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGVyYXRpb24gcG9wcyBvZmYgYSBjb250ZXh0LCBpbnZva2VzIGEgcGFydGlhbCB3aXRoIHRoYXQgY29udGV4dCxcclxuXHQgIC8vIGFuZCBwdXNoZXMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2NhdGlvbiBiYWNrLlxyXG5cdCAgaW52b2tlUGFydGlhbDogZnVuY3Rpb24gaW52b2tlUGFydGlhbChpc0R5bmFtaWMsIG5hbWUsIGluZGVudCkge1xyXG5cdCAgICB2YXIgcGFyYW1zID0gW10sXHJcblx0ICAgICAgICBvcHRpb25zID0gdGhpcy5zZXR1cFBhcmFtcyhuYW1lLCAxLCBwYXJhbXMpO1xyXG5cclxuXHQgICAgaWYgKGlzRHluYW1pYykge1xyXG5cdCAgICAgIG5hbWUgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgICAgZGVsZXRlIG9wdGlvbnMubmFtZTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKGluZGVudCkge1xyXG5cdCAgICAgIG9wdGlvbnMuaW5kZW50ID0gSlNPTi5zdHJpbmdpZnkoaW5kZW50KTtcclxuXHQgICAgfVxyXG5cdCAgICBvcHRpb25zLmhlbHBlcnMgPSAnaGVscGVycyc7XHJcblx0ICAgIG9wdGlvbnMucGFydGlhbHMgPSAncGFydGlhbHMnO1xyXG5cdCAgICBvcHRpb25zLmRlY29yYXRvcnMgPSAnY29udGFpbmVyLmRlY29yYXRvcnMnO1xyXG5cclxuXHQgICAgaWYgKCFpc0R5bmFtaWMpIHtcclxuXHQgICAgICBwYXJhbXMudW5zaGlmdCh0aGlzLm5hbWVMb29rdXAoJ3BhcnRpYWxzJywgbmFtZSwgJ3BhcnRpYWwnKSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcGFyYW1zLnVuc2hpZnQobmFtZSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0KSB7XHJcblx0ICAgICAgb3B0aW9ucy5kZXB0aHMgPSAnZGVwdGhzJztcclxuXHQgICAgfVxyXG5cdCAgICBvcHRpb25zID0gdGhpcy5vYmplY3RMaXRlcmFsKG9wdGlvbnMpO1xyXG5cdCAgICBwYXJhbXMucHVzaChvcHRpb25zKTtcclxuXHJcblx0ICAgIHRoaXMucHVzaCh0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoJ2NvbnRhaW5lci5pbnZva2VQYXJ0aWFsJywgJycsIHBhcmFtcykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbYXNzaWduVG9IYXNoXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi4sIGhhc2gsIC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiAuLi4sIGhhc2gsIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFBvcHMgYSB2YWx1ZSBvZmYgdGhlIHN0YWNrIGFuZCBhc3NpZ25zIGl0IHRvIHRoZSBjdXJyZW50IGhhc2hcclxuXHQgIGFzc2lnblRvSGFzaDogZnVuY3Rpb24gYXNzaWduVG9IYXNoKGtleSkge1xyXG5cdCAgICB2YXIgdmFsdWUgPSB0aGlzLnBvcFN0YWNrKCksXHJcblx0ICAgICAgICBjb250ZXh0ID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgdHlwZSA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGlkID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICBpZCA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy5zdHJpbmdQYXJhbXMpIHtcclxuXHQgICAgICB0eXBlID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIGNvbnRleHQgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBoYXNoID0gdGhpcy5oYXNoO1xyXG5cdCAgICBpZiAoY29udGV4dCkge1xyXG5cdCAgICAgIGhhc2guY29udGV4dHNba2V5XSA9IGNvbnRleHQ7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHR5cGUpIHtcclxuXHQgICAgICBoYXNoLnR5cGVzW2tleV0gPSB0eXBlO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmIChpZCkge1xyXG5cdCAgICAgIGhhc2guaWRzW2tleV0gPSBpZDtcclxuXHQgICAgfVxyXG5cdCAgICBoYXNoLnZhbHVlc1trZXldID0gdmFsdWU7XHJcblx0ICB9LFxyXG5cclxuXHQgIHB1c2hJZDogZnVuY3Rpb24gcHVzaElkKHR5cGUsIG5hbWUsIGNoaWxkKSB7XHJcblx0ICAgIGlmICh0eXBlID09PSAnQmxvY2tQYXJhbScpIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ2Jsb2NrUGFyYW1zWycgKyBuYW1lWzBdICsgJ10ucGF0aFsnICsgbmFtZVsxXSArICddJyArIChjaGlsZCA/ICcgKyAnICsgSlNPTi5zdHJpbmdpZnkoJy4nICsgY2hpbGQpIDogJycpKTtcclxuXHQgICAgfSBlbHNlIGlmICh0eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoU3RyaW5nKG5hbWUpO1xyXG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdTdWJFeHByZXNzaW9uJykge1xyXG5cdCAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgndHJ1ZScpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCgnbnVsbCcpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIEhFTFBFUlNcclxuXHJcblx0ICBjb21waWxlcjogSmF2YVNjcmlwdENvbXBpbGVyLFxyXG5cclxuXHQgIGNvbXBpbGVDaGlsZHJlbjogZnVuY3Rpb24gY29tcGlsZUNoaWxkcmVuKGVudmlyb25tZW50LCBvcHRpb25zKSB7XHJcblx0ICAgIHZhciBjaGlsZHJlbiA9IGVudmlyb25tZW50LmNoaWxkcmVuLFxyXG5cdCAgICAgICAgY2hpbGQgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBjb21waWxlciA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuXHQgICAgICBjb21waWxlciA9IG5ldyB0aGlzLmNvbXBpbGVyKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxyXG5cclxuXHQgICAgICB2YXIgZXhpc3RpbmcgPSB0aGlzLm1hdGNoRXhpc3RpbmdQcm9ncmFtKGNoaWxkKTtcclxuXHJcblx0ICAgICAgaWYgKGV4aXN0aW5nID09IG51bGwpIHtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5wcm9ncmFtcy5wdXNoKCcnKTsgLy8gUGxhY2Vob2xkZXIgdG8gcHJldmVudCBuYW1lIGNvbmZsaWN0cyBmb3IgbmVzdGVkIGNoaWxkcmVuXHJcblx0ICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNvbnRleHQucHJvZ3JhbXMubGVuZ3RoO1xyXG5cdCAgICAgICAgY2hpbGQuaW5kZXggPSBpbmRleDtcclxuXHQgICAgICAgIGNoaWxkLm5hbWUgPSAncHJvZ3JhbScgKyBpbmRleDtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5wcm9ncmFtc1tpbmRleF0gPSBjb21waWxlci5jb21waWxlKGNoaWxkLCBvcHRpb25zLCB0aGlzLmNvbnRleHQsICF0aGlzLnByZWNvbXBpbGUpO1xyXG5cdCAgICAgICAgdGhpcy5jb250ZXh0LmRlY29yYXRvcnNbaW5kZXhdID0gY29tcGlsZXIuZGVjb3JhdG9ycztcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5lbnZpcm9ubWVudHNbaW5kZXhdID0gY2hpbGQ7XHJcblxyXG5cdCAgICAgICAgdGhpcy51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocyB8fCBjb21waWxlci51c2VEZXB0aHM7XHJcblx0ICAgICAgICB0aGlzLnVzZUJsb2NrUGFyYW1zID0gdGhpcy51c2VCbG9ja1BhcmFtcyB8fCBjb21waWxlci51c2VCbG9ja1BhcmFtcztcclxuXHQgICAgICAgIGNoaWxkLnVzZURlcHRocyA9IHRoaXMudXNlRGVwdGhzO1xyXG5cdCAgICAgICAgY2hpbGQudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBjaGlsZC5pbmRleCA9IGV4aXN0aW5nLmluZGV4O1xyXG5cdCAgICAgICAgY2hpbGQubmFtZSA9ICdwcm9ncmFtJyArIGV4aXN0aW5nLmluZGV4O1xyXG5cclxuXHQgICAgICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgZXhpc3RpbmcudXNlRGVwdGhzO1xyXG5cdCAgICAgICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgZXhpc3RpbmcudXNlQmxvY2tQYXJhbXM7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgbWF0Y2hFeGlzdGluZ1Byb2dyYW06IGZ1bmN0aW9uIG1hdGNoRXhpc3RpbmdQcm9ncmFtKGNoaWxkKSB7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgdmFyIGVudmlyb25tZW50ID0gdGhpcy5jb250ZXh0LmVudmlyb25tZW50c1tpXTtcclxuXHQgICAgICBpZiAoZW52aXJvbm1lbnQgJiYgZW52aXJvbm1lbnQuZXF1YWxzKGNoaWxkKSkge1xyXG5cdCAgICAgICAgcmV0dXJuIGVudmlyb25tZW50O1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBwcm9ncmFtRXhwcmVzc2lvbjogZnVuY3Rpb24gcHJvZ3JhbUV4cHJlc3Npb24oZ3VpZCkge1xyXG5cdCAgICB2YXIgY2hpbGQgPSB0aGlzLmVudmlyb25tZW50LmNoaWxkcmVuW2d1aWRdLFxyXG5cdCAgICAgICAgcHJvZ3JhbVBhcmFtcyA9IFtjaGlsZC5pbmRleCwgJ2RhdGEnLCBjaGlsZC5ibG9ja1BhcmFtc107XHJcblxyXG5cdCAgICBpZiAodGhpcy51c2VCbG9ja1BhcmFtcyB8fCB0aGlzLnVzZURlcHRocykge1xyXG5cdCAgICAgIHByb2dyYW1QYXJhbXMucHVzaCgnYmxvY2tQYXJhbXMnKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy51c2VEZXB0aHMpIHtcclxuXHQgICAgICBwcm9ncmFtUGFyYW1zLnB1c2goJ2RlcHRocycpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gJ2NvbnRhaW5lci5wcm9ncmFtKCcgKyBwcm9ncmFtUGFyYW1zLmpvaW4oJywgJykgKyAnKSc7XHJcblx0ICB9LFxyXG5cclxuXHQgIHVzZVJlZ2lzdGVyOiBmdW5jdGlvbiB1c2VSZWdpc3RlcihuYW1lKSB7XHJcblx0ICAgIGlmICghdGhpcy5yZWdpc3RlcnNbbmFtZV0pIHtcclxuXHQgICAgICB0aGlzLnJlZ2lzdGVyc1tuYW1lXSA9IHRydWU7XHJcblx0ICAgICAgdGhpcy5yZWdpc3RlcnMubGlzdC5wdXNoKG5hbWUpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIHB1c2g6IGZ1bmN0aW9uIHB1c2goZXhwcikge1xyXG5cdCAgICBpZiAoIShleHByIGluc3RhbmNlb2YgTGl0ZXJhbCkpIHtcclxuXHQgICAgICBleHByID0gdGhpcy5zb3VyY2Uud3JhcChleHByKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5pbmxpbmVTdGFjay5wdXNoKGV4cHIpO1xyXG5cdCAgICByZXR1cm4gZXhwcjtcclxuXHQgIH0sXHJcblxyXG5cdCAgcHVzaFN0YWNrTGl0ZXJhbDogZnVuY3Rpb24gcHVzaFN0YWNrTGl0ZXJhbChpdGVtKSB7XHJcblx0ICAgIHRoaXMucHVzaChuZXcgTGl0ZXJhbChpdGVtKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIHB1c2hTb3VyY2U6IGZ1bmN0aW9uIHB1c2hTb3VyY2Uoc291cmNlKSB7XHJcblx0ICAgIGlmICh0aGlzLnBlbmRpbmdDb250ZW50KSB7XHJcblx0ICAgICAgdGhpcy5zb3VyY2UucHVzaCh0aGlzLmFwcGVuZFRvQnVmZmVyKHRoaXMuc291cmNlLnF1b3RlZFN0cmluZyh0aGlzLnBlbmRpbmdDb250ZW50KSwgdGhpcy5wZW5kaW5nTG9jYXRpb24pKTtcclxuXHQgICAgICB0aGlzLnBlbmRpbmdDb250ZW50ID0gdW5kZWZpbmVkO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoc291cmNlKSB7XHJcblx0ICAgICAgdGhpcy5zb3VyY2UucHVzaChzb3VyY2UpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIHJlcGxhY2VTdGFjazogZnVuY3Rpb24gcmVwbGFjZVN0YWNrKGNhbGxiYWNrKSB7XHJcblx0ICAgIHZhciBwcmVmaXggPSBbJygnXSxcclxuXHQgICAgICAgIHN0YWNrID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgY3JlYXRlZFN0YWNrID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgdXNlZExpdGVyYWwgPSB1bmRlZmluZWQ7XHJcblxyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgICBpZiAoIXRoaXMuaXNJbmxpbmUoKSkge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdyZXBsYWNlU3RhY2sgb24gbm9uLWlubGluZScpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBXZSB3YW50IHRvIG1lcmdlIHRoZSBpbmxpbmUgc3RhdGVtZW50IGludG8gdGhlIHJlcGxhY2VtZW50IHN0YXRlbWVudCB2aWEgJywnXHJcblx0ICAgIHZhciB0b3AgPSB0aGlzLnBvcFN0YWNrKHRydWUpO1xyXG5cclxuXHQgICAgaWYgKHRvcCBpbnN0YW5jZW9mIExpdGVyYWwpIHtcclxuXHQgICAgICAvLyBMaXRlcmFscyBkbyBub3QgbmVlZCB0byBiZSBpbmxpbmVkXHJcblx0ICAgICAgc3RhY2sgPSBbdG9wLnZhbHVlXTtcclxuXHQgICAgICBwcmVmaXggPSBbJygnLCBzdGFja107XHJcblx0ICAgICAgdXNlZExpdGVyYWwgPSB0cnVlO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIC8vIEdldCBvciBjcmVhdGUgdGhlIGN1cnJlbnQgc3RhY2sgbmFtZSBmb3IgdXNlIGJ5IHRoZSBpbmxpbmVcclxuXHQgICAgICBjcmVhdGVkU3RhY2sgPSB0cnVlO1xyXG5cdCAgICAgIHZhciBfbmFtZSA9IHRoaXMuaW5jclN0YWNrKCk7XHJcblxyXG5cdCAgICAgIHByZWZpeCA9IFsnKCgnLCB0aGlzLnB1c2goX25hbWUpLCAnID0gJywgdG9wLCAnKSddO1xyXG5cdCAgICAgIHN0YWNrID0gdGhpcy50b3BTdGFjaygpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgaXRlbSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RhY2spO1xyXG5cclxuXHQgICAgaWYgKCF1c2VkTGl0ZXJhbCkge1xyXG5cdCAgICAgIHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAoY3JlYXRlZFN0YWNrKSB7XHJcblx0ICAgICAgdGhpcy5zdGFja1Nsb3QtLTtcclxuXHQgICAgfVxyXG5cdCAgICB0aGlzLnB1c2gocHJlZml4LmNvbmNhdChpdGVtLCAnKScpKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgaW5jclN0YWNrOiBmdW5jdGlvbiBpbmNyU3RhY2soKSB7XHJcblx0ICAgIHRoaXMuc3RhY2tTbG90Kys7XHJcblx0ICAgIGlmICh0aGlzLnN0YWNrU2xvdCA+IHRoaXMuc3RhY2tWYXJzLmxlbmd0aCkge1xyXG5cdCAgICAgIHRoaXMuc3RhY2tWYXJzLnB1c2goJ3N0YWNrJyArIHRoaXMuc3RhY2tTbG90KTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdGhpcy50b3BTdGFja05hbWUoKTtcclxuXHQgIH0sXHJcblx0ICB0b3BTdGFja05hbWU6IGZ1bmN0aW9uIHRvcFN0YWNrTmFtZSgpIHtcclxuXHQgICAgcmV0dXJuICdzdGFjaycgKyB0aGlzLnN0YWNrU2xvdDtcclxuXHQgIH0sXHJcblx0ICBmbHVzaElubGluZTogZnVuY3Rpb24gZmx1c2hJbmxpbmUoKSB7XHJcblx0ICAgIHZhciBpbmxpbmVTdGFjayA9IHRoaXMuaW5saW5lU3RhY2s7XHJcblx0ICAgIHRoaXMuaW5saW5lU3RhY2sgPSBbXTtcclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGlubGluZVN0YWNrLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgdmFyIGVudHJ5ID0gaW5saW5lU3RhY2tbaV07XHJcblx0ICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcblx0ICAgICAgaWYgKGVudHJ5IGluc3RhbmNlb2YgTGl0ZXJhbCkge1xyXG5cdCAgICAgICAgdGhpcy5jb21waWxlU3RhY2sucHVzaChlbnRyeSk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHZhciBzdGFjayA9IHRoaXMuaW5jclN0YWNrKCk7XHJcblx0ICAgICAgICB0aGlzLnB1c2hTb3VyY2UoW3N0YWNrLCAnID0gJywgZW50cnksICc7J10pO1xyXG5cdCAgICAgICAgdGhpcy5jb21waWxlU3RhY2sucHVzaChzdGFjayk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgaXNJbmxpbmU6IGZ1bmN0aW9uIGlzSW5saW5lKCkge1xyXG5cdCAgICByZXR1cm4gdGhpcy5pbmxpbmVTdGFjay5sZW5ndGg7XHJcblx0ICB9LFxyXG5cclxuXHQgIHBvcFN0YWNrOiBmdW5jdGlvbiBwb3BTdGFjayh3cmFwcGVkKSB7XHJcblx0ICAgIHZhciBpbmxpbmUgPSB0aGlzLmlzSW5saW5lKCksXHJcblx0ICAgICAgICBpdGVtID0gKGlubGluZSA/IHRoaXMuaW5saW5lU3RhY2sgOiB0aGlzLmNvbXBpbGVTdGFjaykucG9wKCk7XHJcblxyXG5cdCAgICBpZiAoIXdyYXBwZWQgJiYgaXRlbSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcclxuXHQgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBpZiAoIWlubGluZSkge1xyXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICAgIGlmICghdGhpcy5zdGFja1Nsb3QpIHtcclxuXHQgICAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0ludmFsaWQgc3RhY2sgcG9wJyk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICB0aGlzLnN0YWNrU2xvdC0tO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICByZXR1cm4gaXRlbTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICB0b3BTdGFjazogZnVuY3Rpb24gdG9wU3RhY2soKSB7XHJcblx0ICAgIHZhciBzdGFjayA9IHRoaXMuaXNJbmxpbmUoKSA/IHRoaXMuaW5saW5lU3RhY2sgOiB0aGlzLmNvbXBpbGVTdGFjayxcclxuXHQgICAgICAgIGl0ZW0gPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcclxuXHJcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG5cdCAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcclxuXHQgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gaXRlbTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBjb250ZXh0TmFtZTogZnVuY3Rpb24gY29udGV4dE5hbWUoY29udGV4dCkge1xyXG5cdCAgICBpZiAodGhpcy51c2VEZXB0aHMgJiYgY29udGV4dCkge1xyXG5cdCAgICAgIHJldHVybiAnZGVwdGhzWycgKyBjb250ZXh0ICsgJ10nO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiAnZGVwdGgnICsgY29udGV4dDtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBxdW90ZWRTdHJpbmc6IGZ1bmN0aW9uIHF1b3RlZFN0cmluZyhzdHIpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMuc291cmNlLnF1b3RlZFN0cmluZyhzdHIpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBvYmplY3RMaXRlcmFsOiBmdW5jdGlvbiBvYmplY3RMaXRlcmFsKG9iaikge1xyXG5cdCAgICByZXR1cm4gdGhpcy5zb3VyY2Uub2JqZWN0TGl0ZXJhbChvYmopO1xyXG5cdCAgfSxcclxuXHJcblx0ICBhbGlhc2FibGU6IGZ1bmN0aW9uIGFsaWFzYWJsZShuYW1lKSB7XHJcblx0ICAgIHZhciByZXQgPSB0aGlzLmFsaWFzZXNbbmFtZV07XHJcblx0ICAgIGlmIChyZXQpIHtcclxuXHQgICAgICByZXQucmVmZXJlbmNlQ291bnQrKztcclxuXHQgICAgICByZXR1cm4gcmV0O1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXQgPSB0aGlzLmFsaWFzZXNbbmFtZV0gPSB0aGlzLnNvdXJjZS53cmFwKG5hbWUpO1xyXG5cdCAgICByZXQuYWxpYXNhYmxlID0gdHJ1ZTtcclxuXHQgICAgcmV0LnJlZmVyZW5jZUNvdW50ID0gMTtcclxuXHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9LFxyXG5cclxuXHQgIHNldHVwSGVscGVyOiBmdW5jdGlvbiBzZXR1cEhlbHBlcihwYXJhbVNpemUsIG5hbWUsIGJsb2NrSGVscGVyKSB7XHJcblx0ICAgIHZhciBwYXJhbXMgPSBbXSxcclxuXHQgICAgICAgIHBhcmFtc0luaXQgPSB0aGlzLnNldHVwSGVscGVyQXJncyhuYW1lLCBwYXJhbVNpemUsIHBhcmFtcywgYmxvY2tIZWxwZXIpO1xyXG5cdCAgICB2YXIgZm91bmRIZWxwZXIgPSB0aGlzLm5hbWVMb29rdXAoJ2hlbHBlcnMnLCBuYW1lLCAnaGVscGVyJyksXHJcblx0ICAgICAgICBjYWxsQ29udGV4dCA9IHRoaXMuYWxpYXNhYmxlKHRoaXMuY29udGV4dE5hbWUoMCkgKyAnICE9IG51bGwgPyAnICsgdGhpcy5jb250ZXh0TmFtZSgwKSArICcgOiAoY29udGFpbmVyLm51bGxDb250ZXh0IHx8IHt9KScpO1xyXG5cclxuXHQgICAgcmV0dXJuIHtcclxuXHQgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuXHQgICAgICBwYXJhbXNJbml0OiBwYXJhbXNJbml0LFxyXG5cdCAgICAgIG5hbWU6IGZvdW5kSGVscGVyLFxyXG5cdCAgICAgIGNhbGxQYXJhbXM6IFtjYWxsQ29udGV4dF0uY29uY2F0KHBhcmFtcylcclxuXHQgICAgfTtcclxuXHQgIH0sXHJcblxyXG5cdCAgc2V0dXBQYXJhbXM6IGZ1bmN0aW9uIHNldHVwUGFyYW1zKGhlbHBlciwgcGFyYW1TaXplLCBwYXJhbXMpIHtcclxuXHQgICAgdmFyIG9wdGlvbnMgPSB7fSxcclxuXHQgICAgICAgIGNvbnRleHRzID0gW10sXHJcblx0ICAgICAgICB0eXBlcyA9IFtdLFxyXG5cdCAgICAgICAgaWRzID0gW10sXHJcblx0ICAgICAgICBvYmplY3RBcmdzID0gIXBhcmFtcyxcclxuXHQgICAgICAgIHBhcmFtID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgaWYgKG9iamVjdEFyZ3MpIHtcclxuXHQgICAgICBwYXJhbXMgPSBbXTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgb3B0aW9ucy5uYW1lID0gdGhpcy5xdW90ZWRTdHJpbmcoaGVscGVyKTtcclxuXHQgICAgb3B0aW9ucy5oYXNoID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cclxuXHQgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICBvcHRpb25zLmhhc2hJZHMgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XHJcblx0ICAgICAgb3B0aW9ucy5oYXNoVHlwZXMgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgICAgb3B0aW9ucy5oYXNoQ29udGV4dHMgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBpbnZlcnNlID0gdGhpcy5wb3BTdGFjaygpLFxyXG5cdCAgICAgICAgcHJvZ3JhbSA9IHRoaXMucG9wU3RhY2soKTtcclxuXHJcblx0ICAgIC8vIEF2b2lkIHNldHRpbmcgZm4gYW5kIGludmVyc2UgaWYgbmVpdGhlciBhcmUgc2V0LiBUaGlzIGFsbG93c1xyXG5cdCAgICAvLyBoZWxwZXJzIHRvIGRvIGEgY2hlY2sgZm9yIGBpZiAob3B0aW9ucy5mbilgXHJcblx0ICAgIGlmIChwcm9ncmFtIHx8IGludmVyc2UpIHtcclxuXHQgICAgICBvcHRpb25zLmZuID0gcHJvZ3JhbSB8fCAnY29udGFpbmVyLm5vb3AnO1xyXG5cdCAgICAgIG9wdGlvbnMuaW52ZXJzZSA9IGludmVyc2UgfHwgJ2NvbnRhaW5lci5ub29wJztcclxuXHQgICAgfVxyXG5cclxuXHQgICAgLy8gVGhlIHBhcmFtZXRlcnMgZ28gb24gdG8gdGhlIHN0YWNrIGluIG9yZGVyIChtYWtpbmcgc3VyZSB0aGF0IHRoZXkgYXJlIGV2YWx1YXRlZCBpbiBvcmRlcilcclxuXHQgICAgLy8gc28gd2UgbmVlZCB0byBwb3AgdGhlbSBvZmYgdGhlIHN0YWNrIGluIHJldmVyc2Ugb3JkZXJcclxuXHQgICAgdmFyIGkgPSBwYXJhbVNpemU7XHJcblx0ICAgIHdoaWxlIChpLS0pIHtcclxuXHQgICAgICBwYXJhbSA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgICBwYXJhbXNbaV0gPSBwYXJhbTtcclxuXHJcblx0ICAgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICAgIGlkc1tpXSA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XHJcblx0ICAgICAgICB0eXBlc1tpXSA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgICAgIGNvbnRleHRzW2ldID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKG9iamVjdEFyZ3MpIHtcclxuXHQgICAgICBvcHRpb25zLmFyZ3MgPSB0aGlzLnNvdXJjZS5nZW5lcmF0ZUFycmF5KHBhcmFtcyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XHJcblx0ICAgICAgb3B0aW9ucy5pZHMgPSB0aGlzLnNvdXJjZS5nZW5lcmF0ZUFycmF5KGlkcyk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XHJcblx0ICAgICAgb3B0aW9ucy50eXBlcyA9IHRoaXMuc291cmNlLmdlbmVyYXRlQXJyYXkodHlwZXMpO1xyXG5cdCAgICAgIG9wdGlvbnMuY29udGV4dHMgPSB0aGlzLnNvdXJjZS5nZW5lcmF0ZUFycmF5KGNvbnRleHRzKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKHRoaXMub3B0aW9ucy5kYXRhKSB7XHJcblx0ICAgICAgb3B0aW9ucy5kYXRhID0gJ2RhdGEnO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0aGlzLnVzZUJsb2NrUGFyYW1zKSB7XHJcblx0ICAgICAgb3B0aW9ucy5ibG9ja1BhcmFtcyA9ICdibG9ja1BhcmFtcyc7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIG9wdGlvbnM7XHJcblx0ICB9LFxyXG5cclxuXHQgIHNldHVwSGVscGVyQXJnczogZnVuY3Rpb24gc2V0dXBIZWxwZXJBcmdzKGhlbHBlciwgcGFyYW1TaXplLCBwYXJhbXMsIHVzZVJlZ2lzdGVyKSB7XHJcblx0ICAgIHZhciBvcHRpb25zID0gdGhpcy5zZXR1cFBhcmFtcyhoZWxwZXIsIHBhcmFtU2l6ZSwgcGFyYW1zKTtcclxuXHQgICAgb3B0aW9ucyA9IHRoaXMub2JqZWN0TGl0ZXJhbChvcHRpb25zKTtcclxuXHQgICAgaWYgKHVzZVJlZ2lzdGVyKSB7XHJcblx0ICAgICAgdGhpcy51c2VSZWdpc3Rlcignb3B0aW9ucycpO1xyXG5cdCAgICAgIHBhcmFtcy5wdXNoKCdvcHRpb25zJyk7XHJcblx0ICAgICAgcmV0dXJuIFsnb3B0aW9ucz0nLCBvcHRpb25zXTtcclxuXHQgICAgfSBlbHNlIGlmIChwYXJhbXMpIHtcclxuXHQgICAgICBwYXJhbXMucHVzaChvcHRpb25zKTtcclxuXHQgICAgICByZXR1cm4gJyc7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHQoZnVuY3Rpb24gKCkge1xyXG5cdCAgdmFyIHJlc2VydmVkV29yZHMgPSAoJ2JyZWFrIGVsc2UgbmV3IHZhcicgKyAnIGNhc2UgZmluYWxseSByZXR1cm4gdm9pZCcgKyAnIGNhdGNoIGZvciBzd2l0Y2ggd2hpbGUnICsgJyBjb250aW51ZSBmdW5jdGlvbiB0aGlzIHdpdGgnICsgJyBkZWZhdWx0IGlmIHRocm93JyArICcgZGVsZXRlIGluIHRyeScgKyAnIGRvIGluc3RhbmNlb2YgdHlwZW9mJyArICcgYWJzdHJhY3QgZW51bSBpbnQgc2hvcnQnICsgJyBib29sZWFuIGV4cG9ydCBpbnRlcmZhY2Ugc3RhdGljJyArICcgYnl0ZSBleHRlbmRzIGxvbmcgc3VwZXInICsgJyBjaGFyIGZpbmFsIG5hdGl2ZSBzeW5jaHJvbml6ZWQnICsgJyBjbGFzcyBmbG9hdCBwYWNrYWdlIHRocm93cycgKyAnIGNvbnN0IGdvdG8gcHJpdmF0ZSB0cmFuc2llbnQnICsgJyBkZWJ1Z2dlciBpbXBsZW1lbnRzIHByb3RlY3RlZCB2b2xhdGlsZScgKyAnIGRvdWJsZSBpbXBvcnQgcHVibGljIGxldCB5aWVsZCBhd2FpdCcgKyAnIG51bGwgdHJ1ZSBmYWxzZScpLnNwbGl0KCcgJyk7XHJcblxyXG5cdCAgdmFyIGNvbXBpbGVyV29yZHMgPSBKYXZhU2NyaXB0Q29tcGlsZXIuUkVTRVJWRURfV09SRFMgPSB7fTtcclxuXHJcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHJlc2VydmVkV29yZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0ICAgIGNvbXBpbGVyV29yZHNbcmVzZXJ2ZWRXb3Jkc1tpXV0gPSB0cnVlO1xyXG5cdCAgfVxyXG5cdH0pKCk7XHJcblxyXG5cdEphdmFTY3JpcHRDb21waWxlci5pc1ZhbGlkSmF2YVNjcmlwdFZhcmlhYmxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0ICByZXR1cm4gIUphdmFTY3JpcHRDb21waWxlci5SRVNFUlZFRF9XT1JEU1tuYW1lXSAmJiAvXlthLXpBLVpfJF1bMC05YS16QS1aXyRdKiQvLnRlc3QobmFtZSk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc3RyaWN0TG9va3VwKHJlcXVpcmVUZXJtaW5hbCwgY29tcGlsZXIsIHBhcnRzLCB0eXBlKSB7XHJcblx0ICB2YXIgc3RhY2sgPSBjb21waWxlci5wb3BTdGFjaygpLFxyXG5cdCAgICAgIGkgPSAwLFxyXG5cdCAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aDtcclxuXHQgIGlmIChyZXF1aXJlVGVybWluYWwpIHtcclxuXHQgICAgbGVuLS07XHJcblx0ICB9XHJcblxyXG5cdCAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICBzdGFjayA9IGNvbXBpbGVyLm5hbWVMb29rdXAoc3RhY2ssIHBhcnRzW2ldLCB0eXBlKTtcclxuXHQgIH1cclxuXHJcblx0ICBpZiAocmVxdWlyZVRlcm1pbmFsKSB7XHJcblx0ICAgIHJldHVybiBbY29tcGlsZXIuYWxpYXNhYmxlKCdjb250YWluZXIuc3RyaWN0JyksICcoJywgc3RhY2ssICcsICcsIGNvbXBpbGVyLnF1b3RlZFN0cmluZyhwYXJ0c1tpXSksICcpJ107XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICByZXR1cm4gc3RhY2s7XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBKYXZhU2NyaXB0Q29tcGlsZXI7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQvKiBnbG9iYWwgZGVmaW5lICovXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0dmFyIFNvdXJjZU5vZGUgPSB1bmRlZmluZWQ7XHJcblxyXG5cdHRyeSB7XHJcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgaWYgKGZhbHNlKSB7XHJcblx0ICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgdGhpcyBpbiBBTUQgZW52aXJvbm1lbnRzLiBGb3IgdGhlc2UgZW52aXJvbm1lbnRzLCB3ZSBhc3VzbWUgdGhhdFxyXG5cdCAgICAvLyB0aGV5IGFyZSBydW5uaW5nIG9uIHRoZSBicm93c2VyIGFuZCB0aHVzIGhhdmUgbm8gbmVlZCBmb3IgdGhlIHNvdXJjZS1tYXAgbGlicmFyeS5cclxuXHQgICAgdmFyIFNvdXJjZU1hcCA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKTtcclxuXHQgICAgU291cmNlTm9kZSA9IFNvdXJjZU1hcC5Tb3VyY2VOb2RlO1xyXG5cdCAgfVxyXG5cdH0gY2F0Y2ggKGVycikge31cclxuXHQvKiBOT1AgKi9cclxuXHJcblx0LyogaXN0YW5idWwgaWdub3JlIGlmOiB0ZXN0ZWQgYnV0IG5vdCBjb3ZlcmVkIGluIGlzdGFuYnVsIGR1ZSB0byBkaXN0IGJ1aWxkICAqL1xyXG5cdGlmICghU291cmNlTm9kZSkge1xyXG5cdCAgU291cmNlTm9kZSA9IGZ1bmN0aW9uIChsaW5lLCBjb2x1bW4sIHNyY0ZpbGUsIGNodW5rcykge1xyXG5cdCAgICB0aGlzLnNyYyA9ICcnO1xyXG5cdCAgICBpZiAoY2h1bmtzKSB7XHJcblx0ICAgICAgdGhpcy5hZGQoY2h1bmtzKTtcclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICBTb3VyY2VOb2RlLnByb3RvdHlwZSA9IHtcclxuXHQgICAgYWRkOiBmdW5jdGlvbiBhZGQoY2h1bmtzKSB7XHJcblx0ICAgICAgaWYgKF91dGlscy5pc0FycmF5KGNodW5rcykpIHtcclxuXHQgICAgICAgIGNodW5rcyA9IGNodW5rcy5qb2luKCcnKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgdGhpcy5zcmMgKz0gY2h1bmtzO1xyXG5cdCAgICB9LFxyXG5cdCAgICBwcmVwZW5kOiBmdW5jdGlvbiBwcmVwZW5kKGNodW5rcykge1xyXG5cdCAgICAgIGlmIChfdXRpbHMuaXNBcnJheShjaHVua3MpKSB7XHJcblx0ICAgICAgICBjaHVua3MgPSBjaHVua3Muam9pbignJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHRoaXMuc3JjID0gY2h1bmtzICsgdGhpcy5zcmM7XHJcblx0ICAgIH0sXHJcblx0ICAgIHRvU3RyaW5nV2l0aFNvdXJjZU1hcDogZnVuY3Rpb24gdG9TdHJpbmdXaXRoU291cmNlTWFwKCkge1xyXG5cdCAgICAgIHJldHVybiB7IGNvZGU6IHRoaXMudG9TdHJpbmcoKSB9O1xyXG5cdCAgICB9LFxyXG5cdCAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0ICAgICAgcmV0dXJuIHRoaXMuc3JjO1xyXG5cdCAgICB9XHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY2FzdENodW5rKGNodW5rLCBjb2RlR2VuLCBsb2MpIHtcclxuXHQgIGlmIChfdXRpbHMuaXNBcnJheShjaHVuaykpIHtcclxuXHQgICAgdmFyIHJldCA9IFtdO1xyXG5cclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgcmV0LnB1c2goY29kZUdlbi53cmFwKGNodW5rW2ldLCBsb2MpKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gcmV0O1xyXG5cdCAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgY2h1bmsgPT09ICdudW1iZXInKSB7XHJcblx0ICAgIC8vIEhhbmRsZSBwcmltaXRpdmVzIHRoYXQgdGhlIFNvdXJjZU5vZGUgd2lsbCB0aHJvdyB1cCBvblxyXG5cdCAgICByZXR1cm4gY2h1bmsgKyAnJztcclxuXHQgIH1cclxuXHQgIHJldHVybiBjaHVuaztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIENvZGVHZW4oc3JjRmlsZSkge1xyXG5cdCAgdGhpcy5zcmNGaWxlID0gc3JjRmlsZTtcclxuXHQgIHRoaXMuc291cmNlID0gW107XHJcblx0fVxyXG5cclxuXHRDb2RlR2VuLnByb3RvdHlwZSA9IHtcclxuXHQgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XHJcblx0ICAgIHJldHVybiAhdGhpcy5zb3VyY2UubGVuZ3RoO1xyXG5cdCAgfSxcclxuXHQgIHByZXBlbmQ6IGZ1bmN0aW9uIHByZXBlbmQoc291cmNlLCBsb2MpIHtcclxuXHQgICAgdGhpcy5zb3VyY2UudW5zaGlmdCh0aGlzLndyYXAoc291cmNlLCBsb2MpKTtcclxuXHQgIH0sXHJcblx0ICBwdXNoOiBmdW5jdGlvbiBwdXNoKHNvdXJjZSwgbG9jKSB7XHJcblx0ICAgIHRoaXMuc291cmNlLnB1c2godGhpcy53cmFwKHNvdXJjZSwgbG9jKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZSgpIHtcclxuXHQgICAgdmFyIHNvdXJjZSA9IHRoaXMuZW1wdHkoKTtcclxuXHQgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChsaW5lKSB7XHJcblx0ICAgICAgc291cmNlLmFkZChbJyAgJywgbGluZSwgJ1xcbiddKTtcclxuXHQgICAgfSk7XHJcblx0ICAgIHJldHVybiBzb3VyY2U7XHJcblx0ICB9LFxyXG5cclxuXHQgIGVhY2g6IGZ1bmN0aW9uIGVhY2goaXRlcikge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5zb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICBpdGVyKHRoaXMuc291cmNlW2ldKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XHJcblx0ICAgIHZhciBsb2MgPSB0aGlzLmN1cnJlbnRMb2NhdGlvbiB8fCB7IHN0YXJ0OiB7fSB9O1xyXG5cdCAgICByZXR1cm4gbmV3IFNvdXJjZU5vZGUobG9jLnN0YXJ0LmxpbmUsIGxvYy5zdGFydC5jb2x1bW4sIHRoaXMuc3JjRmlsZSk7XHJcblx0ICB9LFxyXG5cdCAgd3JhcDogZnVuY3Rpb24gd3JhcChjaHVuaykge1xyXG5cdCAgICB2YXIgbG9jID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5jdXJyZW50TG9jYXRpb24gfHwgeyBzdGFydDoge30gfSA6IGFyZ3VtZW50c1sxXTtcclxuXHJcblx0ICAgIGlmIChjaHVuayBpbnN0YW5jZW9mIFNvdXJjZU5vZGUpIHtcclxuXHQgICAgICByZXR1cm4gY2h1bms7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGNodW5rID0gY2FzdENodW5rKGNodW5rLCB0aGlzLCBsb2MpO1xyXG5cclxuXHQgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKGxvYy5zdGFydC5saW5lLCBsb2Muc3RhcnQuY29sdW1uLCB0aGlzLnNyY0ZpbGUsIGNodW5rKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgZnVuY3Rpb25DYWxsOiBmdW5jdGlvbiBmdW5jdGlvbkNhbGwoZm4sIHR5cGUsIHBhcmFtcykge1xyXG5cdCAgICBwYXJhbXMgPSB0aGlzLmdlbmVyYXRlTGlzdChwYXJhbXMpO1xyXG5cdCAgICByZXR1cm4gdGhpcy53cmFwKFtmbiwgdHlwZSA/ICcuJyArIHR5cGUgKyAnKCcgOiAnKCcsIHBhcmFtcywgJyknXSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIHF1b3RlZFN0cmluZzogZnVuY3Rpb24gcXVvdGVkU3RyaW5nKHN0cikge1xyXG5cdCAgICByZXR1cm4gJ1wiJyArIChzdHIgKyAnJykucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKS5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKSAvLyBQZXIgRWNtYS0yNjIgNy4zICsgNy44LjRcclxuXHQgICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpICsgJ1wiJztcclxuXHQgIH0sXHJcblxyXG5cdCAgb2JqZWN0TGl0ZXJhbDogZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbChvYmopIHtcclxuXHQgICAgdmFyIHBhaXJzID0gW107XHJcblxyXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcblx0ICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBjYXN0Q2h1bmsob2JqW2tleV0sIHRoaXMpO1xyXG5cdCAgICAgICAgaWYgKHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgICBwYWlycy5wdXNoKFt0aGlzLnF1b3RlZFN0cmluZyhrZXkpLCAnOicsIHZhbHVlXSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgcmV0ID0gdGhpcy5nZW5lcmF0ZUxpc3QocGFpcnMpO1xyXG5cdCAgICByZXQucHJlcGVuZCgneycpO1xyXG5cdCAgICByZXQuYWRkKCd9Jyk7XHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9LFxyXG5cclxuXHQgIGdlbmVyYXRlTGlzdDogZnVuY3Rpb24gZ2VuZXJhdGVMaXN0KGVudHJpZXMpIHtcclxuXHQgICAgdmFyIHJldCA9IHRoaXMuZW1wdHkoKTtcclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgaWYgKGkpIHtcclxuXHQgICAgICAgIHJldC5hZGQoJywnKTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHJldC5hZGQoY2FzdENodW5rKGVudHJpZXNbaV0sIHRoaXMpKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH0sXHJcblxyXG5cdCAgZ2VuZXJhdGVBcnJheTogZnVuY3Rpb24gZ2VuZXJhdGVBcnJheShlbnRyaWVzKSB7XHJcblx0ICAgIHZhciByZXQgPSB0aGlzLmdlbmVyYXRlTGlzdChlbnRyaWVzKTtcclxuXHQgICAgcmV0LnByZXBlbmQoJ1snKTtcclxuXHQgICAgcmV0LmFkZCgnXScpO1xyXG5cclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBDb2RlR2VuO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSlcclxufSk7XHJcbjsiLCIvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBkdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblx0dmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdCAgIFxyXG5cdCQoZnVuY3Rpb24gKCkge1xyXG5cclxuXHQgICAgbGV0IGluaXQgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgIFxyXG5cdCAgICAgICAgZHQuaW5pdCgpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpbml0KCk7ICAgICAgXHJcblx0ICAgXHJcblx0ICAgIFxyXG5cdH0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bGV0ICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdGxldCBfZHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cdGxldCBfZHRFdmVudCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblx0bGV0IF9oaCA9IF9fd2VicGFja19yZXF1aXJlX18oNilcclxuXHRsZXQgX2hoX2hlbHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cdGxldCBfc2VydmljZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cdGxldCBzZXJ2aWNlY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblx0bGV0IGFwcHNldHRpbmdzb2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHRsZXQgYXBwc2V0dGluZ3MgPSBhcHBzZXR0aW5nc29iamVjdC5jb25maWc7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNhY2hlRG9tKCk7XHJcblx0ICAgICAgICB0aGlzLmJpbmRFdmVudCgpO1xyXG5cdCAgICAgICAgdGhpcy5FdmVudEhhbmRsZXIoKTtcclxuXHQgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcblx0ICAgIH0sXHJcblx0ICAgIGNhY2hlRG9tOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLiRib2R5ID0gJCgnYm9keScpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfbGlzdGF0b0FwcHJvdmUgPSAkKFwiI2JiX2FqX2xpc3RhdG9BcHByb3ZlXCIpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfbGlzdGFBbGxhID0gJChcIiNiYl9hal9saXN0YUFsbGFcIik7XHJcblx0ICAgICAgICB0aGlzLiRiYl9hal9ib2t0aXBzQWRtaW5MaXN0ID0gJChcIiNiYl9hal9ib2t0aXBzQWRtaW5MaXN0XCIpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdCA9ICQoXCIjYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdFwiKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmluZEV2ZW50OiBmdW5jdGlvbiAodXNlcmlkKSB7XHJcblx0ICAgICAgICBsZXQgdGhhdCA9IHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnI2JiX2FqX2xpc3RhQWxsYScsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcIm5vdC1hY3RpdmVcIik7XHJcblx0ICAgICAgICAgICAgdGhhdC4kYmJfYWpfbGlzdGF0b0FwcHJvdmUucmVtb3ZlQ2xhc3MoXCJub3QtYWN0aXZlXCIpO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LiRiYl9hal9ib2t0aXBzQWRtaW5MaXN0LmhpZGUoKTtcclxuXHQgICAgICAgICAgICBsZXQgZGF0YXRhYmxlcyA9IHRoYXQuJGJiX2FqX2Jva3RpcHNBZG1pbkxpc3QuRGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgZGF0YXRhYmxlcy5kZXN0cm95KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgdGhhdC5zZXJ2aWNlSGFuZGxlcihcIiNiYl9hal9ib2t0aXBzQWRtaW5BTExMaXN0XCIsIGFwcHNldHRpbmdzLmFwaS5ib2t0aXBzbGlzdG9yLmdldGJva3RpcHNsaXN0QWxsKCksIGZ1bmN0aW9uKCl7XHJcblx0ICAgICAgICAgICAgICAgIHRoYXQuJGJiX2FqX2Jva3RpcHNBZG1pbkFMTExpc3Quc2hvdygpO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnI2JiX2FqX2xpc3RhdG9BcHByb3ZlJywgZnVuY3Rpb24gKGUpIHsgICAgICAgIFxyXG5cdCAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJub3QtYWN0aXZlXCIpO1xyXG5cdCAgICAgICAgICAgIHRoYXQuJGJiX2FqX2xpc3RhQWxsYS5yZW1vdmVDbGFzcyhcIm5vdC1hY3RpdmVcIik7XHJcblx0ICAgICAgICAgICAgdGhhdC4kYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdC5oaWRlKCk7XHJcblxyXG5cdCAgICAgICAgICAgIGxldCBkYXRhdGFibGVzID0gdGhhdC4kYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdC5EYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICBkYXRhdGFibGVzLmRlc3Ryb3koKTsgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB0aGF0LnNlcnZpY2VIYW5kbGVyKFwiI2JiX2FqX2Jva3RpcHNBZG1pbkxpc3RcIiwgYXBwc2V0dGluZ3MuYXBpLmJva3RpcHNsaXN0b3IuZ2V0Ym9rdGlwc2xpc3RUb0FwcHJvdmUoKSwgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LiRiYl9hal9ib2t0aXBzQWRtaW5MaXN0LnNob3coKTtcclxuXHQgICAgICAgICAgICB9KTsgICAgICAgICAgIFxyXG5cdCAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJyNiYl9hal9EZWxldGVib2t0aXBzJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgaWQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtdGlwaWQnKTtcclxuXHJcblx0ICAgICAgICAgICAgc2VydmljZWNhbGwuZGVsZXRldGlwKGlkLCBmdW5jdGlvbiAoaXNvaykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZXRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICQoXCIjYmJfYWpfbW9kYWxDb250YWluZXJcIikuaGlkZSgpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJyNiYl9hal9TYXZlYm9rdGlwcycsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgbGV0IGlkID0gJCh0aGlzKS5hdHRyKCdkYXRhLXRpcGlkJyk7XHJcblx0ICAgICAgICAgICAgbGV0IHJ1YiA9ICQoXCIjYmJfYWpfc2F2ZUJva3RpcFJ1YnJpa1wiKS5odG1sKCk7XHJcblx0ICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aW55TUNFLmFjdGl2ZUVkaXRvci5nZXRDb250ZW50KCk7XHJcblxyXG5cdCAgICAgICAgICAgIHNlcnZpY2VjYWxsLnNhdmV0aXAoaWQsIHJ1YiwgY29udGVudCwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgICAgIHRoYXQudXBkYXRldGFibGUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAkKFwiI2JiX2FqX21vZGFsQ29udGFpbmVyXCIpLmhpZGUoKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfSxcclxuXHQgICAgRXZlbnRIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBfZHRFdmVudC5pbml0KCk7XHJcblx0ICAgICAgICBfaGhfaGVscGVyLmluaXQoKTtcclxuXHQgICAgfSxcclxuXHQgICAgdXBkYXRldGFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0ICAgICAgICBsZXQgdmFsZGxpc3QsIHVybGVuLCBjc3NkaXY7XHJcblx0ICAgICAgICBpZiAodGhpcy4kYmJfYWpfYm9rdGlwc0FkbWluTGlzdC5pcygnOnZpc2libGUnKSkge1xyXG5cdCAgICAgICAgICAgIHZhbGRsaXN0ID0gdGhpcy4kYmJfYWpfYm9rdGlwc0FkbWluTGlzdDtcclxuXHQgICAgICAgICAgICB1cmxlbiA9IGFwcHNldHRpbmdzLmFwaS5ib2t0aXBzbGlzdG9yLmdldGJva3RpcHNsaXN0VG9BcHByb3ZlKCk7XHJcblx0ICAgICAgICAgICAgY3NzZGl2ID0gXCIjYmJfYWpfYm9rdGlwc0FkbWluTGlzdFwiXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy4kYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdC5pcygnOnZpc2libGUnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YWxkbGlzdCA9IHRoaXMuJGJiX2FqX2Jva3RpcHNBZG1pbkFMTExpc3RcclxuXHQgICAgICAgICAgICAgICAgdXJsZW4gPSBhcHBzZXR0aW5ncy5hcGkuYm9rdGlwc2xpc3Rvci5nZXRib2t0aXBzbGlzdEFsbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBjc3NkaXYgPSBcIiNiYl9hal9ib2t0aXBzQWRtaW5BTExMaXN0XCJcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfTsgICAgICBcclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgbGV0IGRhdGF0YWJsZXMgPSB2YWxkbGlzdC5EYXRhVGFibGUoKTtcclxuXHQgICAgICAgIGRhdGF0YWJsZXMuZGVzdHJveSgpO1xyXG5cclxuXHQgICAgICAgIHRoaXMuc2VydmljZUhhbmRsZXIoY3NzZGl2LCB1cmxlbiwgZnVuY3Rpb24gKCkgeyB9KTtcclxuXHQgICAgfSxcclxuXHQgICAgc2VydmljZUhhbmRsZXI6IGZ1bmN0aW9uIChjc3NTZWxlY3Rvcix1cmwsIGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICAvL2xldCBqc29uZGF0YXByb21pc2UgPSBfc2VydmljZS5nZXRqc29uZGF0YSgnaHR0cHM6Ly93d3cyLmJhcm5lbnNiaWJsaW90ZWsuc2UvQXBpX3YzLjEvYm9rdGlwcy90eXAvQnlVc2VySWQvdmFsLzcwMTcvdHh0dmFsLzAvZGV2a2V5L2FsZi8/dHlwZT1qc29uJyk7XHJcblx0ICAgICAgICBsZXQganNvbmRhdGFwcm9taXNlID0gX3NlcnZpY2UuZ2V0anNvbmRhdGEodXJsKTtcclxuXHJcblx0ICAgICAgICBqc29uZGF0YXByb21pc2UudGhlbihqc29uZGF0YSA9PiB7XHJcblxyXG5cdCAgICAgICAgICAgIGFwcHNldHRpbmdzLmRhdGFzZXQuY3VycmVudGRhdGFsaXN0ID0ganNvbmRhdGE7XHJcblxyXG5cdCAgICAgICAgICAgIF9oaC5pbmplY3RodG1sdGVtcGxhdGUoY3NzU2VsZWN0b3IsIGFwcHNldHRpbmdzLmhhbmRsZWJhcnRlbXBsYXRlLmhiX2Jvb2t0aXBMaXN0X3RtcCwganNvbmRhdGEsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmdW5rYXIxOlwiICsgYXBwc2V0dGluZ3MuZGF0YXNldC5jdXJyZW50ZGF0YWxpc3QpO1xyXG5cdCAgICAgICAgICAgICAgICBfZHQuUnVuRGF0YVRhYmxlKGNzc1NlbGVjdG9yKTtcclxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmdW5rYXIyOlwiICsgYXBwc2V0dGluZ3MuZGF0YXNldC5jdXJyZW50ZGF0YWxpc3QpO1xyXG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfSk7ICAgIFxyXG5cdCAgICB9LFxyXG5cdCAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgdGhpcy5zZXJ2aWNlSGFuZGxlcihcIiNiYl9hal9ib2t0aXBzQWRtaW5MaXN0XCIsIGFwcHNldHRpbmdzLmFwaS5ib2t0aXBzbGlzdG9yLmdldGJva3RpcHNsaXN0VG9BcHByb3ZlKCksIGZ1bmN0aW9uICgpIHsgfSk7XHJcblx0ICAgICAgICAvL3RoaXMuc2VydmljZUhhbmRsZXIoXCIjYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdFwiLCBhcHBzZXR0aW5ncy5hcGkuYm9rdGlwc2xpc3Rvci5nZXRib2t0aXBzbGlzdEFsbCgpKTtcclxuXHQgICAgfVxyXG5cdH1cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIVxuXHQgKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjMuMVxuXHQgKiBodHRwczovL2pxdWVyeS5jb20vXG5cdCAqXG5cdCAqIEluY2x1ZGVzIFNpenpsZS5qc1xuXHQgKiBodHRwczovL3NpenpsZWpzLmNvbS9cblx0ICpcblx0ICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuXHQgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2Vcblx0ICogaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2Vcblx0ICpcblx0ICogRGF0ZTogMjAxOC0wMS0yMFQxNzoyNFpcblx0ICovXG5cdCggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcdFwidXNlIHN0cmljdFwiO1xuXG5cdFx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHRcdC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG5cdFx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XG5cdFx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0XHRmYWN0b3J5KCBnbG9iYWwsIHRydWUgKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwialF1ZXJ5IHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHRcdH1cblxuXHQvLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxuXHR9ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuXHQvLyBFZGdlIDw9IDEyIC0gMTMrLCBGaXJlZm94IDw9MTggLSA0NSssIElFIDEwIC0gMTEsIFNhZmFyaSA1LjEgLSA5KywgaU9TIDYgLSA5LjFcblx0Ly8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG5cdC8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG5cdC8vIGVub3VnaCB0aGF0IGFsbCBzdWNoIGF0dGVtcHRzIGFyZSBndWFyZGVkIGluIGEgdHJ5IGJsb2NrLlxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgYXJyID0gW107XG5cblx0dmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG5cdHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuXHR2YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cblx0dmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XG5cblx0dmFyIHB1c2ggPSBhcnIucHVzaDtcblxuXHR2YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG5cdHZhciBjbGFzczJ0eXBlID0ge307XG5cblx0dmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxuXHR2YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHR2YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxuXHR2YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG5cdHZhciBzdXBwb3J0ID0ge307XG5cblx0dmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cblx0ICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuXHQgICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcblx0ICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cblx0ICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuXHQgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG5cdCAgfTtcblxuXG5cdHZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHRcdH07XG5cblxuXG5cblx0XHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHRcdHR5cGU6IHRydWUsXG5cdFx0XHRzcmM6IHRydWUsXG5cdFx0XHRub01vZHVsZTogdHJ1ZVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBkb2MsIG5vZGUgKSB7XG5cdFx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHRcdHZhciBpLFxuXHRcdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblx0XHRcdFx0XHRpZiAoIG5vZGVbIGkgXSApIHtcblx0XHRcdFx0XHRcdHNjcmlwdFsgaSBdID0gbm9kZVsgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdH1cblxuXG5cdGZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH1cblx0LyogZ2xvYmFsIFN5bWJvbCAqL1xuXHQvLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuXHQvLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxuXHR2YXJcblx0XHR2ZXJzaW9uID0gXCIzLjMuMVwiLFxuXG5cdFx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0XHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRcdHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG5cdGpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0XHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdFx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdFx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHRcdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRcdGxlbmd0aDogMCxcblxuXHRcdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9LFxuXG5cdFx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHRcdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdFx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0XHR9LFxuXG5cdFx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHRcdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRcdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0XHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdFx0fSxcblxuXHRcdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHRcdH0gKSApO1xuXHRcdH0sXG5cblx0XHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHRcdH0sXG5cblx0XHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHRcdH0sXG5cblx0XHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHRcdH0sXG5cblx0XHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdFx0fSxcblxuXHRcdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHRcdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRcdHB1c2g6IHB1c2gsXG5cdFx0c29ydDogYXJyLnNvcnQsXG5cdFx0c3BsaWNlOiBhcnIuc3BsaWNlXG5cdH07XG5cblx0alF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRcdGkgPSAxLFxuXHRcdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdGRlZXAgPSBmYWxzZTtcblxuXHRcdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0XHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdFx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHRcdHRhcmdldCA9IHt9O1xuXHRcdH1cblxuXHRcdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRcdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRcdGktLTtcblx0XHR9XG5cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdGpRdWVyeS5leHRlbmQoIHtcblxuXHRcdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRcdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0XHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRcdGlzUmVhZHk6IHRydWUsXG5cblx0XHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdFx0fSxcblxuXHRcdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0XHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0XHR9LFxuXG5cdFx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdFx0dmFyIG5hbWU7XG5cblx0XHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0XHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRcdERPTUV2YWwoIGNvZGUgKTtcblx0XHR9LFxuXG5cdFx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0XHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdFx0fSxcblxuXHRcdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0XHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9LFxuXG5cdFx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdFx0aiA9IDAsXG5cdFx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHRcdH1cblxuXHRcdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdFx0cmV0dXJuIGZpcnN0O1xuXHRcdH0sXG5cblx0XHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaGVzO1xuXHRcdH0sXG5cblx0XHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0XHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0cmV0ID0gW107XG5cblx0XHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0XHR9LFxuXG5cdFx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdFx0Z3VpZDogMSxcblxuXHRcdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHRcdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdFx0c3VwcG9ydDogc3VwcG9ydFxuXHR9ICk7XG5cblx0aWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG5cdH1cblxuXHQvLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcblx0alF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdH0gKTtcblxuXHRmdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHRcdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0XHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0XHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdFx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xuXHR9XG5cdHZhciBTaXp6bGUgPVxuXHQvKiFcblx0ICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy4zXG5cdCAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuXHQgKlxuXHQgKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuXHQgKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2Vcblx0ICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuXHQgKlxuXHQgKiBEYXRlOiAyMDE2LTA4LTA4XG5cdCAqL1xuXHQoZnVuY3Rpb24oIHdpbmRvdyApIHtcblxuXHR2YXIgaSxcblx0XHRzdXBwb3J0LFxuXHRcdEV4cHIsXG5cdFx0Z2V0VGV4dCxcblx0XHRpc1hNTCxcblx0XHR0b2tlbml6ZSxcblx0XHRjb21waWxlLFxuXHRcdHNlbGVjdCxcblx0XHRvdXRlcm1vc3RDb250ZXh0LFxuXHRcdHNvcnRJbnB1dCxcblx0XHRoYXNEdXBsaWNhdGUsXG5cblx0XHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdFx0c2V0RG9jdW1lbnQsXG5cdFx0ZG9jdW1lbnQsXG5cdFx0ZG9jRWxlbSxcblx0XHRkb2N1bWVudElzSFRNTCxcblx0XHRyYnVnZ3lRU0EsXG5cdFx0cmJ1Z2d5TWF0Y2hlcyxcblx0XHRtYXRjaGVzLFxuXHRcdGNvbnRhaW5zLFxuXG5cdFx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRcdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdFx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRcdGRpcnJ1bnMgPSAwLFxuXHRcdGRvbmUgPSAwLFxuXHRcdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRcdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRcdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRcdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fSxcblxuXHRcdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0XHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRcdGFyciA9IFtdLFxuXHRcdHBvcCA9IGFyci5wb3AsXG5cdFx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0XHRwdXNoID0gYXJyLnB1c2gsXG5cdFx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdFx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdFx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRcdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fSxcblxuXHRcdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdFx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0XHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdFx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHRcdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRcdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIipcXFxcXVwiLFxuXG5cdFx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFx0XCIuKlwiICtcblx0XHRcdFwiKVxcXFwpfClcIixcblxuXHRcdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0XHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0XHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0XHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0XHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRcdHJhdHRyaWJ1dGVRdW90ZXMgPSBuZXcgUmVnRXhwKCBcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiICksXG5cblx0XHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRcdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRcdG1hdGNoRXhwciA9IHtcblx0XHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXHRcdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XHRcIm5lZWRzQ29udGV4dFwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgK1xuXHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0XHR9LFxuXG5cdFx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdFx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRcdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdFx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdFx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdFx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0XHQvLyBDU1MgZXNjYXBlc1xuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0XHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRcdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcblx0XHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxuXHRcdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRcdGVzY2FwZWQgOlxuXHRcdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHRcdH0sXG5cblx0XHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRcdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0XHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdFx0fSxcblxuXHRcdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0XHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHRcdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHRcdC8vIGVycm9yIGluIElFXG5cdFx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0RG9jdW1lbnQoKTtcblx0XHR9LFxuXG5cdFx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xuXHRcdFx0fSxcblx0XHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdFx0KTtcblxuXHQvLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxuXHR0cnkge1xuXHRcdHB1c2guYXBwbHkoXG5cdFx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHRcdCk7XG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0XHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdFx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHRcdH0gOlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHRcdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRcdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRcdGlmICggIXNlZWQgKSB7XG5cblx0XHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0XHR9XG5cdFx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PThcblx0XHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIG90aGVyc1xuXHRcdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuXHQgKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG5cdCAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuXHQgKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdFx0dmFyIGtleXMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5cy5zaGlmdCgpIF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH1cblxuXHQvKipcblx0ICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcblx0ICovXG5cdGZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdFx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdFx0cmV0dXJuIGZuO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcblx0ICovXG5cdGZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0XHR9XG5cdFx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdFx0ZWwgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHRcdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXG5cdFx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0RXhwci5hdHRySGFuZGxlWyBhcnJbaV0gXSA9IGhhbmRsZXI7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3Ncblx0ICogQHBhcmFtIHtFbGVtZW50fSBhXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gYlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcblx0ICovXG5cdGZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0XHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0XHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0XHRpZiAoIGRpZmYgKSB7XG5cdFx0XHRyZXR1cm4gZGlmZjtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRcdGlmICggY3VyICkge1xuXHRcdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGEgPyAxIDogLTE7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciA6ZW5hYmxlZC86ZGlzYWJsZWRcblx0ICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGRpc2FibGVkICkge1xuXG5cdFx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBPbmx5IGNlcnRhaW4gZWxlbWVudHMgY2FuIG1hdGNoIDplbmFibGVkIG9yIDpkaXNhYmxlZFxuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRcdGlmICggXCJmb3JtXCIgaW4gZWxlbSApIHtcblxuXHRcdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjYXRlZ29yeS1saXN0ZWRcblx0XHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1vcHRpb24tZGlzYWJsZWRcblx0XHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiBlbGVtZW50cyBkZWZlciB0byBhIHBhcmVudCBvcHRncm91cCBpZiBwcmVzZW50XG5cdFx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0ucGFyZW50Tm9kZS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdFx0Ly8gVXNlIHRoZSBpc0Rpc2FibGVkIHNob3J0Y3V0IHByb3BlcnR5IHRvIGNoZWNrIGZvciBkaXNhYmxlZCBmaWVsZHNldCBhbmNlc3RvcnNcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHR2YXIgaixcblx0XHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuXHQgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcblx0ICovXG5cdGZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRcdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG5cdH1cblxuXHQvLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuXHRzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuXHQvKipcblx0ICogRGV0ZWN0cyBYTUwgbm9kZXNcblx0ICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcblx0ICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuXHQgKi9cblx0aXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdFx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdFx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG5cdCAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcblx0ICovXG5cdHNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdFx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHRcdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdFx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRcdHJldHVybiBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRcdGRvY3VtZW50ID0gZG9jO1xuXHRcdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdFx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRcdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBBdHRyaWJ1dGVzXG5cdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHRcdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHRcdH0pO1xuXG5cdFx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRcdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0XHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdFx0fSk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRTwxMFxuXHRcdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHRcdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHRcdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRcdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHRcdH0pO1xuXG5cdFx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdFx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gVGFnXG5cdFx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gOlxuXG5cdFx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0XHRpID0gMCxcblx0XHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQ2xhc3Ncblx0XHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRcdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHRcdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdFx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdFx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0XHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0XHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdFx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdFx0cmJ1Z2d5UVNBID0gW107XG5cblx0XHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRcdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0XHQvKiBDb250YWluc1xuXHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0XHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0XHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0XHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0XHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRcdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0XHQpKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cblx0XHQvKiBTb3J0aW5nXG5cdFx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdFx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRcdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdFx0MTtcblxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdFx0MDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cixcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRcdGN1ciA9IGE7XG5cdFx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdFx0fVxuXHRcdFx0Y3VyID0gYjtcblx0XHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdFx0aSsrO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaSA/XG5cdFx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0XHQwO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH07XG5cblx0U2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdFx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcblx0fTtcblxuXHRTaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdFx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdFx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0XHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0XHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cblx0XHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xuXHR9O1xuXG5cdFNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHRcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRcdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xuXHR9O1xuXG5cdFNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdFx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHR9XG5cblx0XHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblxuXHRcdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHR2YWwgOlxuXHRcdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdH07XG5cblx0U2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdFx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdH07XG5cblx0U2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcblx0fTtcblxuXHQvKipcblx0ICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuXHQgKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuXHQgKi9cblx0U2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IDA7XG5cblx0XHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdFx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0XHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0XHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdFx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdFx0c29ydElucHV0ID0gbnVsbDtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuXHQgKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cblx0ICovXG5cdGdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBub2RlLFxuXHRcdFx0cmV0ID0gXCJcIixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0XHR9XG5cdFx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cdEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdFx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdFx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdFx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0XHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdFx0YXR0ckhhbmRsZToge30sXG5cblx0XHRmaW5kOiB7fSxcblxuXHRcdHJlbGF0aXZlOiB7XG5cdFx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0XHR9LFxuXG5cdFx0cHJlRmlsdGVyOiB7XG5cdFx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdFx0fSxcblxuXHRcdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHRcdCovXG5cdFx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0sXG5cblx0XHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGZpbHRlcjoge1xuXG5cdFx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSxcblxuXHRcdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0XHR9IDpcblxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZm47XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHBzZXVkb3M6IHtcblx0XHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH0pLFxuXG5cdFx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSksXG5cblx0XHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdFx0fTtcblx0XHRcdH0pLFxuXG5cdFx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHR9KSxcblxuXHRcdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdFx0fSxcblxuXHRcdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENvbnRlbnRzXG5cdFx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHRcdH0sXG5cblx0XHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHRcdH0sXG5cblx0XHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHRcdH0sXG5cblx0XHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0XHR9KSxcblxuXHRcdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0XHR9KSxcblxuXHRcdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHRcdH0pLFxuXG5cdFx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRcdHZhciBpID0gMDtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdFx0fSksXG5cblx0XHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHRcdH0pLFxuXG5cdFx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0XHR9KSxcblxuXHRcdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHRcdH0pXG5cdFx0fVxuXHR9O1xuXG5cdEV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG5cdC8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5cdGZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRcdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcblx0fVxuXHRmb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRcdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG5cdH1cblxuXHQvLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcblx0ZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5cdHNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuXHRFeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG5cdHRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdFx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdFx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHRcdH1cblxuXHRcdHNvRmFyID0gc2VsZWN0b3I7XG5cdFx0Z3JvdXBzID0gW107XG5cdFx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdFx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmlsdGVyc1xuXHRcdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0XHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0XHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0XHRzb0ZhciA/XG5cdFx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG5cdH07XG5cblx0ZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBzZWxlY3Rvcjtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdFx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdFx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IDpcblxuXHRcdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRcdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSA6XG5cdFx0XHRtYXRjaGVyc1swXTtcblx0fVxuXG5cdGZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0XHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdFx0fVxuXHRcdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHRcdH1cblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHRcdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSBdO1xuXG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0XHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0XHR9O1xuXG5cdFx0cmV0dXJuIGJ5U2V0ID9cblx0XHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdFx0c3VwZXJNYXRjaGVyO1xuXHR9XG5cblx0Y29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0XHR2YXIgaSxcblx0XHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRcdGlmICggIWNhY2hlZCApIHtcblx0XHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cdFx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGVkO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG5cdCAqICBzZWxlY3RvciBmdW5jdGlvbnNcblx0ICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcblx0ICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcblx0ICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuXHQgKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuXHQgKi9cblx0c2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0XHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRcdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0XHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdFx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdFx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHRcdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRcdHNlZWQsXG5cdFx0XHRjb250ZXh0LFxuXHRcdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdFx0cmVzdWx0cyxcblx0XHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHQpO1xuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9O1xuXG5cdC8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cblx0Ly8gU29ydCBzdGFiaWxpdHlcblx0c3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG5cdC8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcblx0Ly8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuXHRzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuXHQvLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcblx0c2V0RG9jdW1lbnQoKTtcblxuXHQvLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuXHQvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcblx0c3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRcdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG5cdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5cdGlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdFx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xuXHR9KSApIHtcblx0XHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0Ly8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuXHRpZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRcdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0XHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xuXHR9KSApIHtcblx0XHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0Ly8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuXHRpZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xuXHR9KSApIHtcblx0XHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXHRcdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBTaXp6bGU7XG5cblx0fSkoIHdpbmRvdyApO1xuXG5cblxuXHRqUXVlcnkuZmluZCA9IFNpenpsZTtcblx0alF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG5cdC8vIERlcHJlY2F0ZWRcblx0alF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xuXHRqUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcblx0alF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcblx0alF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xuXHRqUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cdGpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cblx0dmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHRcdHZhciBtYXRjaGVkID0gW10sXG5cdFx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoZWQ7XG5cdH07XG5cblxuXHR2YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdFx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlZDtcblx0fTtcblxuXG5cdHZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuXHRmdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuXHQgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdH07XG5cdHZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuXHQvLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuXHRmdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBTaW5nbGUgZWxlbWVudFxuXHRcdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdFx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcblx0fVxuXG5cdGpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0XHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0XHRpZiAoIG5vdCApIHtcblx0XHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdFx0fVxuXG5cdFx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcblx0fTtcblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0dmFyIGksIHJldCxcblx0XHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0XHR9LFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdFx0fSxcblx0XHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdFx0fSxcblx0XHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0XHR0aGlzLFxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0XHRmYWxzZVxuXHRcdFx0KS5sZW5ndGg7XG5cdFx0fVxuXHR9ICk7XG5cblxuXHQvLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cblx0Ly8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG5cdHZhciByb290alF1ZXJ5LFxuXG5cdFx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0XHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdFx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdFx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRcdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRcdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdFx0fTtcblxuXHQvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5cdGluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG5cdC8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2Vcblx0cm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG5cdHZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHRcdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdFx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdFx0Y29udGVudHM6IHRydWUsXG5cdFx0XHRuZXh0OiB0cnVlLFxuXHRcdFx0cHJldjogdHJ1ZVxuXHRcdH07XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHRcdHZhciBjdXIsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0XHR9LFxuXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdFx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdFx0KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdFx0KTtcblx0XHR9XG5cdH0gKTtcblxuXHRmdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdFx0cmV0dXJuIGN1cjtcblx0fVxuXG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHRcdH0sXG5cdFx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHRcdH0sXG5cdFx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0XHR9LFxuXHRcdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHRcdH0sXG5cdFx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHRcdH0sXG5cdFx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0XHR9LFxuXHRcdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHRcdH0sXG5cdFx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdFx0fSxcblx0XHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdFx0fSxcblx0XHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0XHR9LFxuXHRcdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0ICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0ICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0ICAgICAgICAvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHQgICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHQgICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHRcdH1cblx0fSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHRcdH07XG5cdH0gKTtcblx0dmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuXHQvLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuXHRmdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIG9iamVjdDtcblx0fVxuXG5cdC8qXG5cdCAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuXHQgKlxuXHQgKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuXHQgKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3Rcblx0ICpcblx0ICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcblx0ICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuXHQgKlxuXHQgKiBQb3NzaWJsZSBvcHRpb25zOlxuXHQgKlxuXHQgKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG5cdCAqXG5cdCAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuXHQgKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG5cdCAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuXHQgKlxuXHQgKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuXHQgKlxuXHQgKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2Vcblx0ICpcblx0ICovXG5cdGpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0XHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdFx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRcdGZpcmluZyxcblxuXHRcdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRcdG1lbW9yeSxcblxuXHRcdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRcdGZpcmVkLFxuXG5cdFx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0XHRsb2NrZWQsXG5cblx0XHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0XHRsaXN0ID0gW10sXG5cblx0XHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdFx0c2VsZiA9IHtcblxuXHRcdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cmV0dXJuIHNlbGY7XG5cdH07XG5cblxuXHRmdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0XHRyZXR1cm4gdjtcblx0fVxuXHRmdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0XHR0aHJvdyBleDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdFx0dmFyIG1ldGhvZDtcblxuXHRcdHRyeSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHRcdH1cblxuXHRcdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHRcdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0XHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHRcdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5leHRlbmQoIHtcblxuXHRcdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRcdF0sXG5cdFx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsbCBkb25lIVxuXHRcdFx0cmV0dXJuIGRlZmVycmVkO1xuXHRcdH0sXG5cblx0XHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0XHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0XHR2YXJcblxuXHRcdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdFx0fVxuXHR9ICk7XG5cblxuXHQvLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcblx0Ly8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG5cdHZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5cdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0XHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRcdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdFx0fVxuXHR9O1xuXG5cblxuXG5cdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9ICk7XG5cdH07XG5cblxuXG5cblx0Ly8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG5cdHZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxuXHRqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0XHRyZWFkeUxpc3Rcblx0XHRcdC50aGVuKCBmbiApXG5cblx0XHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0XHR9ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRqUXVlcnkuZXh0ZW5kKCB7XG5cblx0XHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRcdGlzUmVhZHk6IGZhbHNlLFxuXG5cdFx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHRcdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdFx0cmVhZHlXYWl0OiAxLFxuXG5cdFx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRcdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuXHQvLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuXHRmdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdFx0alF1ZXJ5LnJlYWR5KCk7XG5cdH1cblxuXHQvLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuXHQvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuXHQvLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cblx0aWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0XHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHRcdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0fVxuXG5cblxuXG5cdC8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuXHQvLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cblx0dmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0XHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdFx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHRcdH1cblxuXHRcdC8vIFNldHMgb25lIHZhbHVlXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJhdyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBmbiApIHtcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRcdHJldHVybiBlbGVtcztcblx0XHR9XG5cblx0XHQvLyBHZXRzXG5cdFx0aWYgKCBidWxrICkge1xuXHRcdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xuXHR9O1xuXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRcdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuXHQvLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcblx0ZnVuY3Rpb24gZmNhbWVsQ2FzZSggYWxsLCBsZXR0ZXIgKSB7XG5cdFx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHR9XG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0ZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG5cdH1cblx0dmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBBY2NlcHRzIG9ubHk6XG5cdFx0Ly8gIC0gTm9kZVxuXHRcdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0XHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHRcdC8vICAtIE9iamVjdFxuXHRcdC8vICAgIC0gQW55XG5cdFx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xuXHR9O1xuXG5cblxuXG5cdGZ1bmN0aW9uIERhdGEoKSB7XG5cdFx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xuXHR9XG5cblx0RGF0YS51aWQgPSAxO1xuXG5cdERhdGEucHJvdG90eXBlID0ge1xuXG5cdFx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHRcdHZhciBwcm9wLFxuXHRcdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNhY2hlO1xuXHRcdH0sXG5cdFx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHRcdH0sXG5cdFx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHRcdC8vXG5cdFx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHRcdC8vXG5cdFx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHRcdC8vXG5cdFx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0XHQvL1xuXHRcdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdFx0Ly9cblx0XHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0XHQvL1xuXHRcdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0XHR9XG5cdH07XG5cdHZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cblx0dmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cblx0Ly9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcblx0Ly9cblx0Ly9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcblx0Ly9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuXHQvL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG5cdC8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuXHQvL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuXHQvL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG5cdC8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxuXHR2YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRcdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuXHRmdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRcdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0XHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRcdHJldHVybiArZGF0YTtcblx0XHR9XG5cblx0XHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0XHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0XHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCgge1xuXHRcdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHRcdH0sXG5cblx0XHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHRcdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRcdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0XHR9LFxuXG5cdFx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fSApO1xuXG5cblx0alF1ZXJ5LmV4dGVuZCgge1xuXHRcdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHRcdHZhciBxdWV1ZTtcblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHRcdH07XG5cblx0XHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZm4gKSB7XG5cblx0XHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRcdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdFx0fSApXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdFx0c2V0dGVyLS07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSxcblx0XHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cdFx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fSxcblxuXHRcdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0XHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0XHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdFx0dmFyIHRtcCxcblx0XHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlc29sdmUoKTtcblx0XHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0XHR9XG5cdH0gKTtcblx0dmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG5cdHZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG5cdHZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxuXHR2YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRcdGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgJiZcblxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0XHR9O1xuXG5cdHZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHRcdHZhciByZXQsIG5hbWUsXG5cdFx0XHRvbGQgPSB7fTtcblxuXHRcdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0XHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xuXG5cblxuXG5cdGZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdFx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdFx0fSxcblx0XHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdFx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYWRqdXN0ZWQ7XG5cdH1cblxuXG5cdHZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5cdGZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHRcdHZhciB0ZW1wLFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdFx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdFx0cmV0dXJuIGRpc3BsYXk7XG5cdFx0fVxuXG5cdFx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdFx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHR9XG5cdFx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHRmdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdFx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0XHR2YWx1ZXMgPSBbXSxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHRcdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1lbnRzO1xuXHR9XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdFx0fSxcblx0XHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHRcdH0sXG5cdFx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdH0gKTtcblx0dmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG5cdHZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cblx0dmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG5cdC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG5cdHZhciB3cmFwTWFwID0ge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHRcdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdFx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHRcdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0XHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdFx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0XHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdFx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdFx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG5cdH07XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0d3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG5cdHdyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG5cdHdyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cblx0ZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHRcdHZhciByZXQ7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXQgPSBbXTtcblx0XHR9XG5cblx0XHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cblx0Ly8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5cdGZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXG5cdHZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuXHRmdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHRcdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXG5cdFx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdFx0bm9kZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0XHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZyYWdtZW50O1xuXHR9XG5cblxuXHQoIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdFx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdFx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdFx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdFx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cdH0gKSgpO1xuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXJcblx0XHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdFx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdFx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5cdGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cblx0ZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7IH1cblx0fVxuXG5cdGZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdFx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRcdHJldHVybiBlbGVtO1xuXHRcdH1cblxuXHRcdGlmICggb25lID09PSAxICkge1xuXHRcdFx0b3JpZ0ZuID0gZm47XG5cdFx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Lypcblx0ICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuXHQgKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuXHQgKi9cblx0alF1ZXJ5LmV2ZW50ID0ge1xuXG5cdFx0Z2xvYmFsOiB7fSxcblxuXHRcdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRcdGkgPSAwO1xuXHRcdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdFx0Ly8gYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXG5cdFx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0XHR9LFxuXG5cdFx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRcdGN1ciA9IHRoaXM7XG5cdFx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHRcdH0sXG5cblx0XHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0XHR9LFxuXG5cdFx0c3BlY2lhbDoge1xuXHRcdFx0bG9hZDoge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRmb2N1czoge1xuXG5cdFx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHRcdH0sXG5cdFx0XHRibHVyOiB7XG5cdFx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0XHR9LFxuXHRcdFx0Y2xpY2s6IHtcblxuXHRcdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgbm9kZU5hbWUoIHRoaXMsIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0alF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHRcdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRcdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0XHR9XG5cdH07XG5cblx0alF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0XHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0XHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdFx0fVxuXG5cdFx0Ly8gRXZlbnQgb2JqZWN0XG5cdFx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0XHQvLyBFdmVudCB0eXBlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudHlwZSA9IHNyYztcblx0XHR9XG5cblx0XHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRcdGlmICggcHJvcHMgKSB7XG5cdFx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHRcdH1cblxuXHRcdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdFx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdFx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHRcdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xuXHR9O1xuXG5cdC8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5cdGpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0XHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRcdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0XHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdFx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdFx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0YWx0S2V5OiB0cnVlLFxuXHRcdGJ1YmJsZXM6IHRydWUsXG5cdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0XHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0XHRjdHJsS2V5OiB0cnVlLFxuXHRcdGRldGFpbDogdHJ1ZSxcblx0XHRldmVudFBoYXNlOiB0cnVlLFxuXHRcdG1ldGFLZXk6IHRydWUsXG5cdFx0cGFnZVg6IHRydWUsXG5cdFx0cGFnZVk6IHRydWUsXG5cdFx0c2hpZnRLZXk6IHRydWUsXG5cdFx0dmlldzogdHJ1ZSxcblx0XHRcImNoYXJcIjogdHJ1ZSxcblx0XHRjaGFyQ29kZTogdHJ1ZSxcblx0XHRrZXk6IHRydWUsXG5cdFx0a2V5Q29kZTogdHJ1ZSxcblx0XHRidXR0b246IHRydWUsXG5cdFx0YnV0dG9uczogdHJ1ZSxcblx0XHRjbGllbnRYOiB0cnVlLFxuXHRcdGNsaWVudFk6IHRydWUsXG5cdFx0b2Zmc2V0WDogdHJ1ZSxcblx0XHRvZmZzZXRZOiB0cnVlLFxuXHRcdHBvaW50ZXJJZDogdHJ1ZSxcblx0XHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0XHRzY3JlZW5YOiB0cnVlLFxuXHRcdHNjcmVlblk6IHRydWUsXG5cdFx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0XHR0b0VsZW1lbnQ6IHRydWUsXG5cdFx0dG91Y2hlczogdHJ1ZSxcblxuXHRcdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHRcdH1cblx0fSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuXHQvLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncblx0Ly8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cblx0Ly8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcblx0Ly9cblx0Ly8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuXHQvLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcblx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG5cdC8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0XHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdFx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdFx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxuXHR9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRcdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHRcdH0sXG5cdFx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHRcdH0sXG5cdFx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9ICk7XG5cblxuXHR2YXJcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRcdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdFx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHRcdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdFx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0XHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHRcdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRcdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0XHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cblx0Ly8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5cdGZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0Ly8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuXHRmdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRcdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cdGZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdFx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0XHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRcdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRcdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdFx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcblx0ZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0XHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0XHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdFx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0XHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0XHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggbCApIHtcblx0XHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgZG9jLCBub2RlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY29sbGVjdGlvbjtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHRcdHZhciBub2RlLFxuXHRcdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0XHRyZXR1cm4gY2xvbmU7XG5cdFx0fSxcblxuXHRcdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHRcdH0sXG5cblx0XHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdFx0fSxcblxuXHRcdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdFx0fSwgaWdub3JlZCApO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdFx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0XHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdFx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0XHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcblx0fSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0dmFyIGVsZW1zLFxuXHRcdFx0XHRyZXQgPSBbXSxcblx0XHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHRcdH07XG5cdH0gKTtcblx0dmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG5cdHZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHRcdH07XG5cblx0dmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuXHQoIGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdFx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0XHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0XHRzY3JvbGxib3hTaXplVmFsID0gZGl2Lm9mZnNldFdpZHRoID09PSAzNiB8fCBcImFic29sdXRlXCI7XG5cblx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRcdGRpdiA9IG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHRcdH1cblxuXHRcdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0XHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRcdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRcdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0XHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRcdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0XHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHRcdH0sXG5cdFx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHRcdH0sXG5cdFx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0XHR9LFxuXHRcdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHRcdH0sXG5cdFx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICkoKTtcblxuXG5cdGZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdFx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdFx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHRcdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHRcdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0XHRyZXQgKyBcIlwiIDpcblx0XHRcdHJldDtcblx0fVxuXG5cblx0ZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdFx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cblx0dmFyXG5cblx0XHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdFx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdFx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdFx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRcdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdFx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdFx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdFx0fSxcblxuXHRcdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0XHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG5cdC8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcblx0ZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0XHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHRcdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG5cdC8vIGEgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5LlxuXHRmdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHRcdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0XHRpZiAoICFyZXQgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0XHQvLyBBbnkgcmVsYXRpdmUgKCsvLSkgdmFsdWVzIGhhdmUgYWxyZWFkeSBiZWVuXG5cdFx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdFx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdFx0cmV0dXJuIG1hdGNoZXMgP1xuXG5cdFx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0XHR2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHRcdHZhciBpID0gZGltZW5zaW9uID09PSBcIndpZHRoXCIgPyAxIDogMCxcblx0XHRcdGV4dHJhID0gMCxcblx0XHRcdGRlbHRhID0gMDtcblxuXHRcdC8vIEFkanVzdG1lbnQgbWF5IG5vdCBiZSBuZWNlc3Nhcnlcblx0XHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRcdGlmICggYm94ID09PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGdldCBoZXJlIHdpdGggYSBjb250ZW50LWJveCwgd2UncmUgc2Vla2luZyBcInBhZGRpbmdcIiBvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCJcblx0XHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXh0cmEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0XHQvLyBcInBhZGRpbmdcIiBvciBcIm1hcmdpblwiXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0XHRpZiAoIGJveCA9PT0gXCJjb250ZW50XCIgKSB7XG5cdFx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3IgXCJjb250ZW50XCIgb3IgXCJwYWRkaW5nXCIsIHN1YnRyYWN0IGJvcmRlclxuXHRcdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWNjb3VudCBmb3IgcG9zaXRpdmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlciB3aGVuIHJlcXVlc3RlZCBieSBwcm92aWRpbmcgY29tcHV0ZWRWYWxcblx0XHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0XHQvLyBBc3N1bWluZyBpbnRlZ2VyIHNjcm9sbCBndXR0ZXIsIHN1YnRyYWN0IHRoZSByZXN0IGFuZCByb3VuZCBkb3duXG5cdFx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRjb21wdXRlZFZhbCAtXG5cdFx0XHRcdGRlbHRhIC1cblx0XHRcdFx0ZXh0cmEgLVxuXHRcdFx0XHQwLjVcblx0XHRcdCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVsdGE7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdFx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHRcdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveDtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIFJldHVybiBhIGNvbmZvdW5kaW5nIG5vbi1waXhlbCB2YWx1ZSBvciBmZWlnbiBpZ25vcmFuY2UsIGFzIGFwcHJvcHJpYXRlLlxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9XG5cdFx0XHR2YWwgPSBcImF1dG9cIjtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHRcdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdmFsdWVJc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSApO1xuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdFx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHRcdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdFx0aWYgKCB2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApIHtcblxuXHRcdFx0dmFsID0gZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdO1xuXG5cdFx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgcHJvdmlkZSBib3JkZXItYm94IHZhbHVlc1xuXHRcdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdFx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRcdHJldHVybiAoIHZhbCArXG5cdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdGVsZW0sXG5cdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0XHRzdHlsZXMsXG5cblx0XHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdFx0dmFsXG5cdFx0XHQpXG5cdFx0KSArIFwicHhcIjtcblx0fVxuXG5cdGpRdWVyeS5leHRlbmQoIHtcblxuXHRcdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHRcdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRcdGNzc0hvb2tzOiB7XG5cdFx0XHRvcGFjaXR5OiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRcdGNzc051bWJlcjoge1xuXHRcdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFx0XCJ6b29tXCI6IHRydWVcblx0XHR9LFxuXG5cdFx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHRcdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0XHRjc3NQcm9wczoge30sXG5cblx0XHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRcdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKSxcblx0XHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0XHQvLyB3YW50IHRvIHF1ZXJ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGFkanVzdENTUyggZWxlbSwgbmFtZSwgcmV0ICk7XG5cblx0XHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRcdGlzQm9yZGVyQm94ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzdXBwb3J0LnNjcm9sbGJveFNpemUoKSA9PT0gc3R5bGVzLnBvc2l0aW9uICkge1xuXHRcdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0XHQwLjVcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcblxuXHRqUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0KSArIFwicHhcIjtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG5cblx0Ly8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xuXHRqUXVlcnkuZWFjaCgge1xuXHRcdG1hcmdpbjogXCJcIixcblx0XHRwYWRkaW5nOiBcIlwiLFxuXHRcdGJvcmRlcjogXCJXaWR0aFwiXG5cdH0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdFx0fVxuXHR9ICk7XG5cblxuXHRmdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdFx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcblx0fVxuXHRqUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuXHRUd2Vlbi5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRcdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdH0sXG5cdFx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0XHR9LFxuXHRcdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0XHR2YXIgZWFzZWQsXG5cdFx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9O1xuXG5cdFR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuXHRUd2Vlbi5wcm9wSG9va3MgPSB7XG5cdFx0X2RlZmF1bHQ6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0alF1ZXJ5LmVhc2luZyA9IHtcblx0XHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdFx0cmV0dXJuIHA7XG5cdFx0fSxcblx0XHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHRcdH0sXG5cdFx0X2RlZmF1bHQ6IFwic3dpbmdcIlxuXHR9O1xuXG5cdGpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG5cdC8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5cdGpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cblx0dmFyXG5cdFx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdFx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdFx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cblx0ZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdFx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdFx0fVxuXG5cdFx0XHRqUXVlcnkuZngudGljaygpO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcblx0ZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xuXHR9XG5cblx0Ly8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cblx0ZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0XHR2YXIgd2hpY2gsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHRcdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0XHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRcdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRcdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0XHR9XG5cblx0XHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGF0dHJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdFx0dmFyIHR3ZWVuLFxuXHRcdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHRcdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0XHRhbmltID0gdGhpcyxcblx0XHRcdG9yaWcgPSB7fSxcblx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdFx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdFx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdFx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRcdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRcdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0fVxuXHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHRcdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0XHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0XHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHRcdHZhciByZXN1bHQsXG5cdFx0XHRzdG9wcGVkLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdFx0fSApLFxuXHRcdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSxcblx0XHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdFx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0XHRhbmltYXRpb25cblx0XHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdFx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdFx0fSApXG5cdFx0KTtcblxuXHRcdHJldHVybiBhbmltYXRpb247XG5cdH1cblxuXHRqUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0XHR0d2VlbmVyczoge1xuXHRcdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSBdXG5cdFx0fSxcblxuXHRcdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcHJvcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0XHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHRcdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHRcdH07XG5cblx0XHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0XHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0XHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0XHR9XG5cblx0XHQvLyBRdWV1ZWluZ1xuXHRcdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0XHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIG9wdDtcblx0fTtcblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH0sXG5cdFx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdFx0fSxcblx0XHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdH07XG5cblx0XHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSxcblx0XHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0gKTtcblxuXHRqUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH07XG5cdH0gKTtcblxuXHQvLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5cdGpRdWVyeS5lYWNoKCB7XG5cdFx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0XHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0XHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0XHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0XHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdFx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cblx0fSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdFx0fTtcblx0fSApO1xuXG5cdGpRdWVyeS50aW1lcnMgPSBbXTtcblx0alF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGltZXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0XHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0XHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdFx0fVxuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdGpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0XHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG5cdH07XG5cblx0alF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5cdGpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpblByb2dyZXNzID0gdHJ1ZTtcblx0XHRzY2hlZHVsZSgpO1xuXHR9O1xuXG5cdGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0aW5Qcm9ncmVzcyA9IG51bGw7XG5cdH07XG5cblx0alF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0XHRzbG93OiA2MDAsXG5cdFx0ZmFzdDogMjAwLFxuXG5cdFx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRcdF9kZWZhdWx0OiA0MDBcblx0fTtcblxuXG5cdC8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cblx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cblx0alF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdFx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0XHR9O1xuXHRcdH0gKTtcblx0fTtcblxuXG5cdCggZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdFx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHRcdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRcdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0XHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdFx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0XHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG5cdH0gKSgpO1xuXG5cblx0dmFyIGJvb2xIb29rLFxuXHRcdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCgge1xuXHRcdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0XHR9LFxuXG5cdFx0YXR0ckhvb2tzOiB7XG5cdFx0XHR0eXBlOiB7XG5cdFx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgbmFtZSxcblx0XHRcdFx0aSA9IDAsXG5cblx0XHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdC8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcblx0Ym9vbEhvb2sgPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9O1xuXG5cdGpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0XHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH07XG5cdH0gKTtcblxuXG5cblxuXHR2YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdFx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LmV4dGVuZCgge1xuXHRcdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdFx0fSxcblxuXHRcdHByb3BIb29rczoge1xuXHRcdFx0dGFiSW5kZXg6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRwcm9wRml4OiB7XG5cdFx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHRcdH1cblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcblx0Ly8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuXHQvLyBvbiB0aGUgb3B0aW9uXG5cdC8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG5cdC8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcblx0Ly8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG5cdC8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuXHRpZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRcdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdGpRdWVyeS5lYWNoKCBbXG5cdFx0XCJ0YWJJbmRleFwiLFxuXHRcdFwicmVhZE9ubHlcIixcblx0XHRcIm1heExlbmd0aFwiLFxuXHRcdFwiY2VsbFNwYWNpbmdcIixcblx0XHRcImNlbGxQYWRkaW5nXCIsXG5cdFx0XCJyb3dTcGFuXCIsXG5cdFx0XCJjb2xTcGFuXCIsXG5cdFx0XCJ1c2VNYXBcIixcblx0XHRcImZyYW1lQm9yZGVyXCIsXG5cdFx0XCJjb250ZW50RWRpdGFibGVcIlxuXHRdLCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xuXHR9ICk7XG5cblxuXG5cblx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdFx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdFx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0XHR9XG5cblxuXHRmdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG5cdH1cblxuXHRmdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0gKTtcblxuXG5cblxuXHR2YXIgcnJldHVybiA9IC9cXHIvZztcblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHtcblx0XHR2YWxIb29rczoge1xuXHRcdFx0b3B0aW9uOiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNlbGVjdDoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdC8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5cdGpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0XHR9O1xuXHRcdH1cblx0fSApO1xuXG5cblxuXG5cdC8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5cdHN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cblx0dmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRcdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH07XG5cblx0alF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0XHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0XHR9XG5cdFx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRcdGV2ZW50IDpcblx0XHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdFx0bnVsbDtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRcdGkgPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0XHR9LFxuXG5cdFx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdFx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0XHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRcdGV2ZW50LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHRcdH1cblxuXHR9ICk7XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHRcdH0gKTtcblx0XHR9LFxuXHRcdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuXHQvLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG5cdC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG5cdC8vXG5cdC8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuXHQvLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcblx0Ly8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG5cdC8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5cdGlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0XHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHRcdH07XG5cblx0XHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9ICk7XG5cdH1cblx0dmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG5cdHZhciBub25jZSA9IERhdGUubm93KCk7XG5cblx0dmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cblx0Ly8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xuXHRqUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHR2YXIgeG1sO1xuXHRcdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHRcdHRyeSB7XG5cdFx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0eG1sID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdFx0fVxuXHRcdHJldHVybiB4bWw7XG5cdH07XG5cblxuXHR2YXJcblx0XHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0XHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdFx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRcdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuXHRmdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRcdGFkZFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG5cdC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xuXHRqUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdFx0dmFyIHByZWZpeCxcblx0XHRcdHMgPSBbXSxcblx0XHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHRcdH0gKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0XHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xuXHR9O1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdFx0fSxcblx0XHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHRcdH0gKVxuXHRcdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHRcdH0gKVxuXHRcdFx0Lm1hcCggZnVuY3Rpb24oIGksIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0fSApLmdldCgpO1xuXHRcdH1cblx0fSApO1xuXG5cblx0dmFyXG5cdFx0cjIwID0gLyUyMC9nLFxuXHRcdHJoYXNoID0gLyMuKiQvLFxuXHRcdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdFx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdFx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdFx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0XHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0XHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0XHQvKiBQcmVmaWx0ZXJzXG5cdFx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0XHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHRcdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0XHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdFx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHRcdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0XHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHRcdCAqL1xuXHRcdHByZWZpbHRlcnMgPSB7fSxcblxuXHRcdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0XHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdFx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHRcdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHRcdCAqL1xuXHRcdHRyYW5zcG9ydHMgPSB7fSxcblxuXHRcdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRcdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHRcdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRcdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdFx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG5cdC8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcblx0ZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0XHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcblx0ZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHRcdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdFx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHRcdH1cblxuXHRcdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xuXHR9XG5cblx0Ly8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG5cdC8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG5cdC8vIEZpeGVzICM5ODg3XG5cdGZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHRcdHZhciBrZXksIGRlZXAsXG5cdFx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0XHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZGVlcCApIHtcblx0XHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXHQvKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG5cdCAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG5cdCAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHRcdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdFx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0XHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0XHRpZiAoIGN0ICkge1xuXHRcdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdFx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdFx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0XHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0XHR9XG5cdH1cblxuXHQvKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG5cdCAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHRcdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdFx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdFx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdFx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCgge1xuXG5cdFx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdFx0YWN0aXZlOiAwLFxuXG5cdFx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRcdGxhc3RNb2RpZmllZDoge30sXG5cdFx0ZXRhZzoge30sXG5cblx0XHRhamF4U2V0dGluZ3M6IHtcblx0XHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0XHRhc3luYzogdHJ1ZSxcblx0XHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0XHQvKlxuXHRcdFx0dGltZW91dDogMCxcblx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0XHRjYWNoZTogbnVsbCxcblx0XHRcdHRocm93czogZmFsc2UsXG5cdFx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0XHRoZWFkZXJzOiB7fSxcblx0XHRcdCovXG5cblx0XHRcdGFjY2VwdHM6IHtcblx0XHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdFx0fSxcblxuXHRcdFx0Y29udGVudHM6IHtcblx0XHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHRcdH0sXG5cblx0XHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHRcdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0XHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRcdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHRcdH0sXG5cblx0XHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0XHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHRcdC8vIE1haW4gbWV0aG9kXG5cdFx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRcdGksXG5cblx0XHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlKysgKSArIHVuY2FjaGVkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fSxcblxuXHRcdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdFx0fSxcblxuXHRcdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0XHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dXJsOiB1cmwsXG5cdFx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0XHR9O1xuXHR9ICk7XG5cblxuXHRqUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRcdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdFx0dHlwZTogXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdFx0Y2FjaGU6IHRydWUsXG5cdFx0XHRhc3luYzogZmFsc2UsXG5cdFx0XHRnbG9iYWw6IGZhbHNlLFxuXHRcdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHRcdH0gKTtcblx0fTtcblxuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRcdHZhciB3cmFwO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0gKTtcblxuXG5cdGpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcblx0fTtcblx0alF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcblx0fTtcblxuXG5cblxuXHRqUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHRcdH0gY2F0Y2ggKCBlICkge31cblx0fTtcblxuXHR2YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHRcdDA6IDIwMCxcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdFx0MTIyMzogMjA0XG5cdFx0fSxcblx0XHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5cdHN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcblx0c3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cblx0alF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHRcdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0XHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0gKTtcblxuXG5cblxuXHQvLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxuXHRqUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxuXHRqUXVlcnkuYWpheFNldHVwKCB7XG5cdFx0YWNjZXB0czoge1xuXHRcdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdFx0fSxcblx0XHRjb250ZW50czoge1xuXHRcdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0XHR9LFxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdC8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cblx0alF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRcdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxuXHRqUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0XHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0fSApO1xuXG5cblxuXG5cdHZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0XHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG5cdC8vIERlZmF1bHQganNvbnAgc2V0dGluZ3Ncblx0alF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRcdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdFx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xuXHRqUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHRcdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcdFwidXJsXCIgOlxuXHRcdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdFx0KTtcblxuXHRcdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0XHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0XHR9XG5cdH0gKTtcblxuXG5cblxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG5cdC8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcblx0Ly8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG5cdC8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cblx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuXHRzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRcdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRcdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xuXHR9ICkoKTtcblxuXG5cdC8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuXHQvLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG5cdC8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdC8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcblx0alF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0XHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRcdGNvbnRleHQgPSBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdFx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0XHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdFx0Ly8gU2luZ2xlIHRhZ1xuXHRcdGlmICggcGFyc2VkICkge1xuXHRcdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdFx0fVxuXG5cdFx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRcdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2Vcblx0ICovXG5cdGpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0XHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRcdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHRcdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdFx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0XHRkYXRhOiBwYXJhbXNcblx0XHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblxuXG5cblx0Ly8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcblx0alF1ZXJ5LmVhY2goIFtcblx0XHRcImFqYXhTdGFydFwiLFxuXHRcdFwiYWpheFN0b3BcIixcblx0XHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcdFwiYWpheEVycm9yXCIsXG5cdFx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcdFwiYWpheFNlbmRcIlxuXHRdLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0XHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHRcdH07XG5cdH0gKTtcblxuXG5cblxuXHRqUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0XHR9ICkubGVuZ3RoO1xuXHR9O1xuXG5cblxuXG5cdGpRdWVyeS5vZmZzZXQgPSB7XG5cdFx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHRcdH1cblxuXHRcdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdFx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHRcdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRcdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHRcdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0XHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0XHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdFx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHRcdC8vXG5cdFx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdFx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdFx0Ly9cblx0XHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRcdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5cdGpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0XHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdFx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHRcdHZhciB3aW47XG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0XHR9O1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuXHQvLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuXHQvLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcblx0Ly8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcblx0Ly8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcblx0Ly8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcblx0alF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH0gKTtcblxuXG5cdC8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xuXHRqUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdFx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHRcdH07XG5cdFx0fSApO1xuXHR9ICk7XG5cblxuXHRqUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdFx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0XHR9O1xuXHR9ICk7XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHRcdH1cblx0fSApO1xuXG5cblxuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRcdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdFx0fSxcblx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHRcdH0sXG5cdFx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdC8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcblx0Ly8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5cdGpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0XHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRcdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdFx0Y29udGV4dCA9IGZuO1xuXHRcdFx0Zm4gPSB0bXA7XG5cdFx0fVxuXG5cdFx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0XHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRcdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXG5cdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRcdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdFx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0XHRyZXR1cm4gcHJveHk7XG5cdH07XG5cblx0alF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRcdGlmICggaG9sZCApIHtcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0XHR9IGVsc2Uge1xuXHRcdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdFx0fVxuXHR9O1xuXHRqUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cdGpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xuXHRqUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcblx0alF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXHRqUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcblx0alF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcblx0alF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cblx0alF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5cdGpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0XHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdFx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0XHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0XHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xuXHR9O1xuXG5cblxuXG5cdC8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuXHQvLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG5cdC8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuXHQvLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG5cdC8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuXHQvLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcblx0Ly8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG5cdC8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG5cdC8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cblx0Ly8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5cdGlmICggdHJ1ZSApIHtcblx0XHQhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnk7XG5cdFx0fS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHR9XG5cblxuXG5cblx0dmFyXG5cblx0XHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHRcdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdFx0XyQgPSB3aW5kb3cuJDtcblxuXHRqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRcdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHRcdHdpbmRvdy4kID0gXyQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnk7XG5cdH07XG5cblx0Ly8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcblx0Ly8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuXHQvLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5cdGlmICggIW5vR2xvYmFsICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcblx0fVxuXG5cblxuXG5cdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiEgRGF0YVRhYmxlcyAxLjEwLjdcclxuXHQgKiDCqTIwMDgtMjAxNCBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxyXG5cdCAqL1xyXG5cdHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHQvKipcclxuXHQgKiBAc3VtbWFyeSAgICAgRGF0YVRhYmxlc1xyXG5cdCAqIEBkZXNjcmlwdGlvbiBQYWdpbmF0ZSwgc2VhcmNoIGFuZCBvcmRlciBIVE1MIHRhYmxlc1xyXG5cdCAqIEB2ZXJzaW9uICAgICAxLjEwLjdcclxuXHQgKiBAZmlsZSAgICAgICAganF1ZXJ5LmRhdGFUYWJsZXMuanNcclxuXHQgKiBAYXV0aG9yICAgICAgU3ByeU1lZGlhIEx0ZCAod3d3LnNwcnltZWRpYS5jby51aylcclxuXHQgKiBAY29udGFjdCAgICAgd3d3LnNwcnltZWRpYS5jby51ay9jb250YWN0XHJcblx0ICogQGNvcHlyaWdodCAgIENvcHlyaWdodCAyMDA4LTIwMTQgU3ByeU1lZGlhIEx0ZC5cclxuXHQgKlxyXG5cdCAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcclxuXHQgKiAgIE1JVCBsaWNlbnNlIC0gaHR0cDovL2RhdGF0YWJsZXMubmV0L2xpY2Vuc2VcclxuXHQgKlxyXG5cdCAqIFRoaXMgc291cmNlIGZpbGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0XHJcblx0ICogV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcclxuXHQgKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxyXG5cdCAqXHJcblx0ICogRm9yIGRldGFpbHMgcGxlYXNlIHJlZmVyIHRvOiBodHRwOi8vd3d3LmRhdGF0YWJsZXMubmV0XHJcblx0ICovXHJcblxyXG5cdC8qanNsaW50IGV2aWw6IHRydWUsIHVuZGVmOiB0cnVlLCBicm93c2VyOiB0cnVlICovXHJcblx0LypnbG9iYWxzICQscmVxdWlyZSxqUXVlcnksZGVmaW5lLF9zZWxlY3Rvcl9ydW4sX3NlbGVjdG9yX29wdHMsX3NlbGVjdG9yX2ZpcnN0LF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyxfZXh0LF9BcGksX2FwaV9yZWdpc3RlcixfYXBpX3JlZ2lzdGVyUGx1cmFsLF9yZV9uZXdfbGluZXMsX3JlX2h0bWwsX3JlX2Zvcm1hdHRlZF9udW1lcmljLF9yZV9lc2NhcGVfcmVnZXgsX2VtcHR5LF9pbnRWYWwsX251bVRvRGVjaW1hbCxfaXNOdW1iZXIsX2lzSHRtbCxfaHRtbE51bWVyaWMsX3BsdWNrLF9wbHVja19vcmRlcixfcmFuZ2UsX3N0cmlwSHRtbCxfdW5pcXVlLF9mbkJ1aWxkQWpheCxfZm5BamF4VXBkYXRlLF9mbkFqYXhQYXJhbWV0ZXJzLF9mbkFqYXhVcGRhdGVEcmF3LF9mbkFqYXhEYXRhU3JjLF9mbkFkZENvbHVtbixfZm5Db2x1bW5PcHRpb25zLF9mbkFkanVzdENvbHVtblNpemluZyxfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCxfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSxfZm5WaXNibGVDb2x1bW5zLF9mbkdldENvbHVtbnMsX2ZuQ29sdW1uVHlwZXMsX2ZuQXBwbHlDb2x1bW5EZWZzLF9mbkh1bmdhcmlhbk1hcCxfZm5DYW1lbFRvSHVuZ2FyaWFuLF9mbkxhbmd1YWdlQ29tcGF0LF9mbkJyb3dzZXJEZXRlY3QsX2ZuQWRkRGF0YSxfZm5BZGRUcixfZm5Ob2RlVG9EYXRhSW5kZXgsX2ZuTm9kZVRvQ29sdW1uSW5kZXgsX2ZuR2V0Q2VsbERhdGEsX2ZuU2V0Q2VsbERhdGEsX2ZuU3BsaXRPYmpOb3RhdGlvbixfZm5HZXRPYmplY3REYXRhRm4sX2ZuU2V0T2JqZWN0RGF0YUZuLF9mbkdldERhdGFNYXN0ZXIsX2ZuQ2xlYXJUYWJsZSxfZm5EZWxldGVJbmRleCxfZm5JbnZhbGlkYXRlLF9mbkdldFJvd0VsZW1lbnRzLF9mbkNyZWF0ZVRyLF9mbkJ1aWxkSGVhZCxfZm5EcmF3SGVhZCxfZm5EcmF3LF9mblJlRHJhdyxfZm5BZGRPcHRpb25zSHRtbCxfZm5EZXRlY3RIZWFkZXIsX2ZuR2V0VW5pcXVlVGhzLF9mbkZlYXR1cmVIdG1sRmlsdGVyLF9mbkZpbHRlckNvbXBsZXRlLF9mbkZpbHRlckN1c3RvbSxfZm5GaWx0ZXJDb2x1bW4sX2ZuRmlsdGVyLF9mbkZpbHRlckNyZWF0ZVNlYXJjaCxfZm5Fc2NhcGVSZWdleCxfZm5GaWx0ZXJEYXRhLF9mbkZlYXR1cmVIdG1sSW5mbyxfZm5VcGRhdGVJbmZvLF9mbkluZm9NYWNyb3MsX2ZuSW5pdGlhbGlzZSxfZm5Jbml0Q29tcGxldGUsX2ZuTGVuZ3RoQ2hhbmdlLF9mbkZlYXR1cmVIdG1sTGVuZ3RoLF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsX2ZuUGFnZUNoYW5nZSxfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcsX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksX2ZuRmVhdHVyZUh0bWxUYWJsZSxfZm5TY3JvbGxEcmF3LF9mbkFwcGx5VG9DaGlsZHJlbixfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMsX2ZuVGhyb3R0bGUsX2ZuQ29udmVydFRvV2lkdGgsX2ZuU2Nyb2xsaW5nV2lkdGhBZGp1c3QsX2ZuR2V0V2lkZXN0Tm9kZSxfZm5HZXRNYXhMZW5TdHJpbmcsX2ZuU3RyaW5nVG9Dc3MsX2ZuU2Nyb2xsQmFyV2lkdGgsX2ZuU29ydEZsYXR0ZW4sX2ZuU29ydCxfZm5Tb3J0QXJpYSxfZm5Tb3J0TGlzdGVuZXIsX2ZuU29ydEF0dGFjaExpc3RlbmVyLF9mblNvcnRpbmdDbGFzc2VzLF9mblNvcnREYXRhLF9mblNhdmVTdGF0ZSxfZm5Mb2FkU3RhdGUsX2ZuU2V0dGluZ3NGcm9tTm9kZSxfZm5Mb2csX2ZuTWFwLF9mbkJpbmRBY3Rpb24sX2ZuQ2FsbGJhY2tSZWcsX2ZuQ2FsbGJhY2tGaXJlLF9mbkxlbmd0aE92ZXJmbG93LF9mblJlbmRlcmVyLF9mbkRhdGFTb3VyY2UsX2ZuUm93QXR0cmlidXRlcyovXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGpxdWVyeVRhYmxlSW5pdDogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgKC8qKiBAbGVuZHMgPGdsb2JhbD4gKi9mdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XHJcblxyXG5cdCAgICAgICAgICAgIChmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG5cdCAgICAgICAgICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0ICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBEZWZpbmUgYXMgYW4gQU1EIG1vZHVsZSBpZiBwb3NzaWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW19fd2VicGFja19yZXF1aXJlX18oMildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE5vZGUvQ29tbW9uSlNcclxuXHQgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoalF1ZXJ5ICYmICFqUXVlcnkuZm4uZGF0YVRhYmxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBEZWZpbmUgdXNpbmcgYnJvd3NlciBnbG9iYWxzIG90aGVyd2lzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBtdWx0aXBsZSBpbnN0YW50aWF0aW9ucyBpZiB0aGUgc2NyaXB0IGlzIGxvYWRlZCB0d2ljZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICgvKiogQGxlbmRzIDxnbG9iYWw+ICovZnVuY3Rpb24gKCQpIHtcclxuXHQgICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBpcyBhIHBsdWctaW4gZm9yIHRoZSBqUXVlcnkgSmF2YXNjcmlwdCBsaWJyYXJ5LiBJdCBpcyBhIGhpZ2hseVxyXG5cdCAgICAgICAgICAgICAgICAgKiBmbGV4aWJsZSB0b29sLCBiYXNlZCB1cG9uIHRoZSBmb3VuZGF0aW9ucyBvZiBwcm9ncmVzc2l2ZSBlbmhhbmNlbWVudCxcclxuXHQgICAgICAgICAgICAgICAgICogd2hpY2ggd2lsbCBhZGQgYWR2YW5jZWQgaW50ZXJhY3Rpb24gY29udHJvbHMgdG8gYW55IEhUTUwgdGFibGUuIEZvciBhXHJcblx0ICAgICAgICAgICAgICAgICAqIGZ1bGwgbGlzdCBvZiBmZWF0dXJlcyBwbGVhc2UgcmVmZXIgdG9cclxuXHQgICAgICAgICAgICAgICAgICogW0RhdGFUYWJsZXMubmV0XShocmVmPVwiaHR0cDovL2RhdGF0YWJsZXMubmV0KS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoZSBgRGF0YVRhYmxlYCBvYmplY3QgaXMgbm90IGEgZ2xvYmFsIHZhcmlhYmxlIGJ1dCBpcyBhbGlhc2VkXHJcblx0ICAgICAgICAgICAgICAgICAqIHRvIGBqUXVlcnkuZm4uRGF0YVRhYmxlYCBhbmQgYGpRdWVyeS5mbi5kYXRhVGFibGVgIHRocm91Z2ggd2hpY2ggaXQgbWF5XHJcblx0ICAgICAgICAgICAgICAgICAqIGJlICBhY2Nlc3NlZC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBjbGFzc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IFtpbml0PXt9XSBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgRGF0YVRhYmxlcy4gT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBhcmUgZGVmaW5lZCBieSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJlcXVpcmVzIGpRdWVyeSAxLjcrXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAvLyBCYXNpYyBpbml0aWFsaXNhdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24ge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIC8vIEluaXRpYWxpc2F0aW9uIHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zIC0gaW4gdGhpcyBjYXNlLCBkaXNhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIC8vIHBhZ2luYXRpb24gYW5kIHNvcnRpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICBcInNvcnRcIjogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIHZhciBEYXRhVGFibGU7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICogSXQgaXMgdXNlZnVsIHRvIGhhdmUgdmFyaWFibGVzIHdoaWNoIGFyZSBzY29wZWQgbG9jYWxseSBzbyBvbmx5IHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIGZ1bmN0aW9ucyBjYW4gYWNjZXNzIHRoZW0gYW5kIHRoZXkgZG9uJ3QgbGVhayBpbnRvIGdsb2JhbCBzcGFjZS5cclxuXHQgICAgICAgICAgICAgICAgICogQXQgdGhlIHNhbWUgdGltZSB0aGVzZSBmdW5jdGlvbnMgYXJlIG9mdGVuIHVzZWZ1bCBvdmVyIG11bHRpcGxlIGZpbGVzIGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBjb3JlIGFuZCBBUEksIHNvIHdlIGxpc3QsIG9yIGF0IGxlYXN0IGRvY3VtZW50LCBhbGwgdmFyaWFibGVzIHdoaWNoIGFyZSB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAqIGJ5IERhdGFUYWJsZXMgYXMgcHJpdmF0ZSB2YXJpYWJsZXMgaGVyZS4gVGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBub1xyXG5cdCAgICAgICAgICAgICAgICAgKiBjbGFzaGluZyBvZiB2YXJpYWJsZSBuYW1lcyBhbmQgdGhhdCB0aGV5IGNhbiBlYXNpbHkgcmVmZXJlbmNlZCBmb3IgcmV1c2UuXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIERlZmluZWQgZWxzZSB3aGVyZVxyXG5cdCAgICAgICAgICAgICAgICAvLyAgX3NlbGVjdG9yX3J1blxyXG5cdCAgICAgICAgICAgICAgICAvLyAgX3NlbGVjdG9yX29wdHNcclxuXHQgICAgICAgICAgICAgICAgLy8gIF9zZWxlY3Rvcl9maXJzdFxyXG5cdCAgICAgICAgICAgICAgICAvLyAgX3NlbGVjdG9yX3Jvd19pbmRleGVzXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX2V4dDsgLy8gRGF0YVRhYmxlLmV4dFxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX0FwaTsgLy8gRGF0YVRhYmxlLkFwaVxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX2FwaV9yZWdpc3RlcjsgLy8gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX2FwaV9yZWdpc3RlclBsdXJhbDsgLy8gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbFxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9yZV9kaWMgPSB7fTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9yZV9uZXdfbGluZXMgPSAvW1xcclxcbl0vZztcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9yZV9odG1sID0gLzwuKj8+L2c7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBfcmVfZGF0ZV9zdGFydCA9IC9eW1xcd1xcK1xcLV0vO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3JlX2RhdGVfZW5kID0gL1tcXHdcXCtcXC1dJC87XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBFc2NhcGUgcmVndWxhciBleHByZXNzaW9uIHNwZWNpYWwgY2hhcmFjdGVyc1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3JlX2VzY2FwZV9yZWdleCA9IG5ldyBSZWdFeHAoJyhcXFxcJyArIFsnLycsICcuJywgJyonLCAnKycsICc/JywgJ3wnLCAnKCcsICcpJywgJ1snLCAnXScsICd7JywgJ30nLCAnXFxcXCcsICckJywgJ14nLCAnLSddLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvcmVpZ25fZXhjaGFuZ2VfbWFya2V0XHJcblx0ICAgICAgICAgICAgICAgIC8vIC0gXFx1MjBCRCAtIFJ1c3NpYW4gcnVibGUuXHJcblx0ICAgICAgICAgICAgICAgIC8vIC0gXFx1MjBhOSAtIFNvdXRoIEtvcmVhbiBXb25cclxuXHQgICAgICAgICAgICAgICAgLy8gLSBcXHUyMEJBIC0gVHVya2lzaCBMaXJhXHJcblx0ICAgICAgICAgICAgICAgIC8vIC0gXFx1MjBCOSAtIEluZGlhbiBSdXBlZVxyXG5cdCAgICAgICAgICAgICAgICAvLyAtIFIgLSBCcmF6aWwgKFIkKSBhbmQgU291dGggQWZyaWNhXHJcblx0ICAgICAgICAgICAgICAgIC8vIC0gZnIgLSBTd2lzcyBGcmFuY1xyXG5cdCAgICAgICAgICAgICAgICAvLyAtIGtyIC0gU3dlZGlzaCBrcm9uYSwgTm9yd2VnaWFuIGtyb25lIGFuZCBEYW5pc2gga3JvbmVcclxuXHQgICAgICAgICAgICAgICAgLy8gLSBcXHUyMDA5IGlzIHRoaW4gc3BhY2UgYW5kIFxcdTIwMkYgaXMgbmFycm93IG5vLWJyZWFrIHNwYWNlLCBib3RoIHVzZWQgaW4gbWFueVxyXG5cdCAgICAgICAgICAgICAgICAvLyAgIHN0YW5kYXJkcyBhcyB0aG91c2FuZHMgc2VwYXJhdG9ycy5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyA9IC9bJywkwqPigqzCpSVcXHUyMDA5XFx1MjAyRlxcdTIwQkRcXHUyMGE5XFx1MjBCQXJma10vZ2k7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9lbXB0eSA9IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWQgfHwgZCA9PT0gdHJ1ZSB8fCBkID09PSAnLScgPyB0cnVlIDogZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9pbnRWYWwgPSBmdW5jdGlvbiAocykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGludGVnZXIgPSBwYXJzZUludChzLCAxMCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKGludGVnZXIpICYmIGlzRmluaXRlKHMpID8gaW50ZWdlciA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGZyb20gYSBmb3JtYXR0ZWQgbnVtYmVyIHdpdGggY2hhcmFjdGVycyBvdGhlciB0aGFuIGAuYCBhcyB0aGVcclxuXHQgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwbGFjZSwgdG8gYSBKYXZhc2NyaXB0IG51bWJlclxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX251bVRvRGVjaW1hbCA9IGZ1bmN0aW9uIChudW0sIGRlY2ltYWxQb2ludCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgY3JlYXRlZCByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBzcGVlZCBhcyB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvZnRlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFfcmVfZGljW2RlY2ltYWxQb2ludF0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfcmVfZGljW2RlY2ltYWxQb2ludF0gPSBuZXcgUmVnRXhwKF9mbkVzY2FwZVJlZ2V4KGRlY2ltYWxQb2ludCksICdnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ3N0cmluZycgJiYgZGVjaW1hbFBvaW50ICE9PSAnLicgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bS5yZXBsYWNlKC9cXC4vZywgJycpLnJlcGxhY2UoX3JlX2RpY1tkZWNpbWFsUG9pbnRdLCAnLicpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW07XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9pc051bWJlciA9IGZ1bmN0aW9uIChkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0clR5cGUgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZyc7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgZW1wdHkgcmV0dXJuIGltbWVkaWF0ZWx5IHNvIHRoZXJlIG11c3QgYmUgYSBudW1iZXIgaWYgaXQgaXMgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9ybWF0dGVkIHN0cmluZyAodGhpcyBzdG9wcyB0aGUgc3RyaW5nIFwia1wiLCBvciBcImtyXCIsIGV0YyBiZWluZyBkZXRlY3RlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYXMgYSBmb3JtYXR0ZWQgbnVtYmVyIGZvciBjdXJyZW5jeVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKF9lbXB0eShkKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsUG9pbnQgJiYgc3RyVHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBfbnVtVG9EZWNpbWFsKGQsIGRlY2ltYWxQb2ludCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZCAmJiBzdHJUeXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZCA9IGQucmVwbGFjZShfcmVfZm9ybWF0dGVkX251bWVyaWMsICcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQoZCkpICYmIGlzRmluaXRlKGQpO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIEEgc3RyaW5nIHdpdGhvdXQgSFRNTCBpbiBpdCBjYW4gYmUgY29uc2lkZXJlZCB0byBiZSBIVE1MIHN0aWxsXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfaXNIdG1sID0gZnVuY3Rpb24gKGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoZCkgfHwgdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfaHRtbE51bWVyaWMgPSBmdW5jdGlvbiAoZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfZW1wdHkoZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaHRtbCA9IF9pc0h0bWwoZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWh0bWwgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9pc051bWJlcihfc3RyaXBIdG1sKGQpLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3BsdWNrID0gZnVuY3Rpb24gKGEsIHByb3AsIHByb3AyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGllbiA9IGEubGVuZ3RoO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvdWxkIGhhdmUgdGhlIHRlc3QgaW4gdGhlIGxvb3AgZm9yIHNsaWdodGx5IHNtYWxsZXIgY29kZSwgYnV0IHNwZWVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBpcyBlc3NlbnRpYWwgaGVyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AyICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtpXSAmJiBhW2ldW3Byb3BdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChhW2ldW3Byb3BdW3Byb3AyXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtpXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goYVtpXVtwcm9wXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgX3BsdWNrLCBidXQgcmF0aGVyIHRoYW4gbG9vcGluZyBvdmVyIGBhYCB3ZSB1c2UgYG9yZGVyYFxyXG5cdCAgICAgICAgICAgICAgICAvLyBhcyB0aGUgaW5kZXhlcyB0byBwaWNrIGZyb20gYGFgXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfcGx1Y2tfb3JkZXIgPSBmdW5jdGlvbiAoYSwgb3JkZXIsIHByb3AsIHByb3AyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGllbiA9IG9yZGVyLmxlbmd0aDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaXMgZXNzZW50aWFsIGhlcmVcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wMiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbb3JkZXJbaV1dW3Byb3BdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChhW29yZGVyW2ldXVtwcm9wXVtwcm9wMl0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goYVtvcmRlcltpXV1bcHJvcF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfcmFuZ2UgPSBmdW5jdGlvbiAobGVuLCBzdGFydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBsZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBzdGFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGxlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQgOyBpIDwgZW5kIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goaSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3JlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gYS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbaV0pIHsgLy8gY2FyZWZ1bCAtIHdpbGwgcmVtb3ZlIGFsbCBmYWxzeSB2YWx1ZXMhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGFbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfc3RyaXBIdG1sID0gZnVuY3Rpb24gKGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnJlcGxhY2UoX3JlX2h0bWwsICcnKTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRmluZCB0aGUgdW5pcXVlIGVsZW1lbnRzIGluIGEgc291cmNlIGFycmF5LlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHthcnJheX0gc3JjIFNvdXJjZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgdW5pcXVlIGl0ZW1zXHJcblx0ICAgICAgICAgICAgICAgICAqIEBpZ25vcmVcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfdW5pcXVlID0gZnVuY3Rpb24gKHNyYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQSBmYXN0ZXIgdW5pcXVlIG1ldGhvZCBpcyB0byB1c2Ugb2JqZWN0IGtleXMgdG8gaWRlbnRpZnkgdXNlZCB2YWx1ZXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBidXQgdGhpcyBkb2Vzbid0IHdvcmsgd2l0aCBhcnJheXMgb3Igb2JqZWN0cywgd2hpY2ggd2UgbXVzdCBhbHNvXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBjb25zaWRlci4gU2VlIGpzcGVyZi5jb20vY29tcGFyZS1hcnJheS11bmlxdWUtdmVyc2lvbnMvNCBmb3IgbW9yZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaW5mb3JtYXRpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBbXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSwgaWVuID0gc3JjLmxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqLCBrID0gMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBhZ2FpbjogZm9yIChpID0gMCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBzcmNbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAgOyBqIDwgayA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0W2pdID09PSB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGFnYWluO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ3JlYXRlIGEgbWFwcGluZyBvYmplY3QgdGhhdCBhbGxvd3MgY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIGJlIGxvb2tlZCB1cFxyXG5cdCAgICAgICAgICAgICAgICAgKiBmb3IgdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0cy4gVGhlIG1hcHBpbmcgaXMgc3RvcmVkIGluIGEgcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBwYXJhbWV0ZXIgY2FsbGVkIGBfaHVuZ2FyaWFuTWFwYCB3aGljaCBjYW4gYmUgYWNjZXNzZWQgb24gdGhlIHNvdXJjZSBvYmplY3QuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5IdW5nYXJpYW5NYXAobykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaHVuZ2FyaWFuID0gJ2EgYWEgYWkgYW8gYXMgYiBmbiBpIG0gbyBzICcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1hcCA9IHt9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICQuZWFjaChvLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGtleS5tYXRjaCgvXihbXkEtWl0rPykoW0EtWl0pLyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiBodW5nYXJpYW4uaW5kZXhPZihtYXRjaFsxXSArICcgJykgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0tleSA9IGtleS5yZXBsYWNlKG1hdGNoWzBdLCBtYXRjaFsyXS50b0xvd2VyQ2FzZSgpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwW25ld0tleV0gPSBrZXk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdvJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwKG9ba2V5XSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBvLl9odW5nYXJpYW5NYXAgPSBtYXA7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ29udmVydCBmcm9tIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBIdW5nYXJpYW4sIGJhc2VkIG9uIGEgSHVuZ2FyaWFuIG1hcFxyXG5cdCAgICAgICAgICAgICAgICAgKiBjcmVhdGVkIGJ5IF9mbkh1bmdhcmlhbk1hcC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBtYXBwZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gdXNlciBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHRvIEh1bmdhcmlhbi5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIEh1bmdhcmlhbiB2YWx1ZSBpbiB0aGUgYHVzZXJgIG9iamVjdCB3aWxsIGJlIG92ZXJ3cml0dGVuLiBPdGhlcndpc2UgdGhleVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICB3b24ndCBiZS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ2FtZWxUb0h1bmdhcmlhbihzcmMsIHVzZXIsIGZvcmNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNyYy5faHVuZ2FyaWFuTWFwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwKHNyYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGh1bmdhcmlhbktleTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAkLmVhY2godXNlciwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaHVuZ2FyaWFuS2V5ID0gc3JjLl9odW5nYXJpYW5NYXBba2V5XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh1bmdhcmlhbktleSAhPT0gdW5kZWZpbmVkICYmIChmb3JjZSB8fCB1c2VyW2h1bmdhcmlhbktleV0gPT09IHVuZGVmaW5lZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG9iamVjdHMsIHdlIG5lZWQgdG8gYnV6eiBkb3duIGludG8gdGhlIG9iamVjdCB0byBjb3B5IHBhcmFtZXRlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh1bmdhcmlhbktleS5jaGFyQXQoMCkgPT09ICdvJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgY2FtZWxDYXNlIG9wdGlvbnMgb3ZlciB0byB0aGUgaHVuZ2FyaWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJbaHVuZ2FyaWFuS2V5XSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgdXNlcltodW5nYXJpYW5LZXldLCB1c2VyW2tleV0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oc3JjW2h1bmdhcmlhbktleV0sIHVzZXJbaHVuZ2FyaWFuS2V5XSwgZm9yY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcltodW5nYXJpYW5LZXldID0gdXNlcltrZXldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogTGFuZ3VhZ2UgY29tcGF0aWJpbGl0eSAtIHdoZW4gY2VydGFpbiBvcHRpb25zIGFyZSBnaXZlbiwgYW5kIG90aGVycyBhcmVuJ3QsIHdlXHJcblx0ICAgICAgICAgICAgICAgICAqIG5lZWQgdG8gZHVwbGljYXRlIHRoZSB2YWx1ZXMgb3ZlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxyXG5cdCAgICAgICAgICAgICAgICAgKiB3aXRoIG9sZGVyIGxhbmd1YWdlIGZpbGVzLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5MYW5ndWFnZUNvbXBhdChsYW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHplcm9SZWNvcmRzID0gbGFuZy5zWmVyb1JlY29yZHM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgLSBpZiB0aGVyZSBpcyBubyBzRW1wdHlUYWJsZSBnaXZlbiwgdGhlbiB1c2UgdGhlIHNhbWUgYXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNaZXJvUmVjb3JkcyAtIGFzc3VtaW5nIHRoYXQgaXMgZ2l2ZW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbGFuZy5zRW1wdHlUYWJsZSAmJiB6ZXJvUmVjb3JkcyAmJlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzLnNFbXB0eVRhYmxlID09PSBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAobGFuZywgbGFuZywgJ3NaZXJvUmVjb3JkcycsICdzRW1wdHlUYWJsZScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIExpa2V3aXNlIHdpdGggbG9hZGluZyByZWNvcmRzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWxhbmcuc0xvYWRpbmdSZWNvcmRzICYmIHplcm9SZWNvcmRzICYmXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMuc0xvYWRpbmdSZWNvcmRzID09PSBcIkxvYWRpbmcuLi5cIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbk1hcChsYW5nLCBsYW5nLCAnc1plcm9SZWNvcmRzJywgJ3NMb2FkaW5nUmVjb3JkcycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE9sZCBwYXJhbWV0ZXIgbmFtZSBvZiB0aGUgdGhvdXNhbmRzIHNlcGFyYXRvciBtYXBwZWQgb250byB0aGUgbmV3XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGFuZy5zSW5mb1Rob3VzYW5kcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcuc1Rob3VzYW5kcyA9IGxhbmcuc0luZm9UaG91c2FuZHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2ltYWwgPSBsYW5nLnNEZWNpbWFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRlY2ltYWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYWRkTnVtZXJpY1NvcnQoZGVjaW1hbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogTWFwIG9uZSBwYXJhbWV0ZXIgb250byBhbm90aGVyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBPYmplY3QgdG8gbWFwXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0geyp9IGtuZXcgVGhlIG5ldyBwYXJhbWV0ZXIgbmFtZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSBvbGQgVGhlIG9sZCBwYXJhbWV0ZXIgbmFtZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9mbkNvbXBhdE1hcCA9IGZ1bmN0aW9uIChvLCBrbmV3LCBvbGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvW2tuZXddICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvW29sZF0gPSBvW2tuZXddO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgbWFpbiBEVCBvcHRpb25zLiBOb3RlIHRoYXQgdGhlIG5ld1xyXG5cdCAgICAgICAgICAgICAgICAgKiBvcHRpb25zIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqIGNoYW5nZSBvbmx5LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGluaXQgT2JqZWN0IHRvIG1hcFxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ29tcGF0T3B0cyhpbml0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyaW5nJywgJ2JTb3J0Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyTXVsdGknLCAnYlNvcnRNdWx0aScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlckNsYXNzZXMnLCAnYlNvcnRDbGFzc2VzJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyQ2VsbHNUb3AnLCAnYlNvcnRDZWxsc1RvcCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlcicsICdhYVNvcnRpbmcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJGaXhlZCcsICdhYVNvcnRpbmdGaXhlZCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdwYWdpbmcnLCAnYlBhZ2luYXRlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ3BhZ2luZ1R5cGUnLCAnc1BhZ2luYXRpb25UeXBlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ3BhZ2VMZW5ndGgnLCAnaURpc3BsYXlMZW5ndGgnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnc2VhcmNoaW5nJywgJ2JGaWx0ZXInKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb2x1bW4gc2VhcmNoIG9iamVjdHMgYXJlIGluIGFuIGFycmF5LCBzbyBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgYnkgZWxlbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlYXJjaENvbHMgPSBpbml0LmFvU2VhcmNoQ29scztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoQ29scykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBzZWFyY2hDb2xzLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaENvbHNbaV0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBQcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBjb2x1bW4gb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXcgb3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZSBjaGFuZ2VcclxuXHQgICAgICAgICAgICAgICAgICogb25seS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNvbXBhdENvbHMoaW5pdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlcmFibGUnLCAnYlNvcnRhYmxlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyRGF0YScsICdhRGF0YVNvcnQnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJTZXF1ZW5jZScsICdhc1NvcnRpbmcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJEYXRhVHlwZScsICdzb3J0RGF0YVR5cGUnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBvcmRlckRhdGEgY2FuIGJlIGdpdmVuIGFzIGFuIGludGVnZXJcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhU29ydCA9IGluaXQuYURhdGFTb3J0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFTb3J0ICYmICEkLmlzQXJyYXkoZGF0YVNvcnQpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5pdC5hRGF0YVNvcnQgPSBbZGF0YVNvcnRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEJyb3dzZXIgZmVhdHVyZSBkZXRlY3Rpb24gZm9yIGNhcGFiaWxpdGllcywgcXVpcmtzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQnJvd3NlckRldGVjdChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBzZXR0aW5ncy5vQnJvd3NlcjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTY3JvbGxpbmcgZmVhdHVyZSAvIHF1aXJrcyBkZXRlY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuID0gJCgnPGRpdi8+JylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8ZGl2Lz4nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAxLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEwMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzxkaXYgY2xhc3M9XCJ0ZXN0XCIvPicpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCdib2R5Jyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRlc3QgPSBuLmZpbmQoJy50ZXN0Jyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSUU2Lzcgd2lsbCBvdmVyc2l6ZSBhIHdpZHRoIDEwMCUgZWxlbWVudCBpbnNpZGUgYSBzY3JvbGxpbmcgZWxlbWVudCwgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGxiYXIsIHdoaWxlIG90aGVyIGJyb3dzZXJzIGVuc3VyZSB0aGUgaW5uZXJcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgY29udGFpbmVkIHdpdGhvdXQgZm9yY2luZyBzY3JvbGxpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplID0gdGVzdFswXS5vZmZzZXRXaWR0aCA9PT0gMTAwO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEluIHJ0bCB0ZXh0IGxheW91dCwgc29tZSBicm93c2VycyAobW9zdCwgYnV0IG5vdCBhbGwpIHdpbGwgcGxhY2UgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxiYXIgb24gdGhlIGxlZnQsIHJhdGhlciB0aGFuIHRoZSByaWdodC5cclxuXHQgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPSBNYXRoLnJvdW5kKHRlc3Qub2Zmc2V0KCkubGVmdCkgIT09IDE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgbi5yZW1vdmUoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBcnJheS5wcm90b3R5cGUgcmVkdWNlW1JpZ2h0XSBtZXRob2QsIHVzZWQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnRcclxuXHQgICAgICAgICAgICAgICAgICogSlMgMS42LiBEb25lIHRoaXMgd2F5IHRvIHJlZHVjZSBjb2RlIHNpemUsIHNpbmNlIHdlIGl0ZXJhdGUgZWl0aGVyIHdheVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblJlZHVjZSh0aGF0LCBmbiwgaW5pdCwgc3RhcnQsIGVuZCwgaW5jKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpID0gc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXQgPSBmYWxzZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlzU2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSAhPT0gZW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0Lmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpc1NldCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKHZhbHVlLCB0aGF0W2ldLCBpLCB0aGF0KSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlzU2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpICs9IGluYztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBZGQgYSBjb2x1bW4gdG8gdGhlIGxpc3QgdXNlZCBmb3IgdGhlIHRhYmxlIHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gblRoIFRoZSB0aCBlbGVtZW50IGZvciB0aGlzIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BZGRDb2x1bW4ob1NldHRpbmdzLCBuVGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBjb2x1bW4gdG8gYW9Db2x1bW5zIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb0RlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpQ29sID0gb1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb0NvbCA9ICQuZXh0ZW5kKHt9LCBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4sIG9EZWZhdWx0cywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiblRoXCI6IG5UaCA/IG5UaCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzVGl0bGVcIjogb0RlZmF1bHRzLnNUaXRsZSA/IG9EZWZhdWx0cy5zVGl0bGUgOiBuVGggPyBuVGguaW5uZXJIVE1MIDogJycsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJhRGF0YVNvcnRcIjogb0RlZmF1bHRzLmFEYXRhU29ydCA/IG9EZWZhdWx0cy5hRGF0YVNvcnQgOiBbaUNvbF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJtRGF0YVwiOiBvRGVmYXVsdHMubURhdGEgPyBvRGVmYXVsdHMubURhdGEgOiBpQ29sLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkeDogaUNvbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYW9Db2x1bW5zLnB1c2gob0NvbCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHNlYXJjaCBvYmplY3QgZm9yIGNvbHVtbiBzcGVjaWZpYyBzZWFyY2guIE5vdGUgdGhhdCB0aGUgYHNlYXJjaENvbHNbIGlDb2wgXWBcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHBhc3NlZCBpbnRvIGV4dGVuZCBjYW4gYmUgdW5kZWZpbmVkLiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBnaXZlIGEgZGVmYXVsdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgZGVmaW5lZCwgYW5kIGFsc28gbm90IGdpdmUgYSBkZWZhdWx0XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VhcmNoQ29scyA9IG9TZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb2xzW2lDb2xdID0gJC5leHRlbmQoe30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCwgc2VhcmNoQ29sc1tpQ29sXSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0IGNvbHVtbiBvcHRpb25zIGZ1bmN0aW9uIHRvIGluaXRpYWxpc2UgY2xhc3NlcyBldGNcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtbk9wdGlvbnMob1NldHRpbmdzLCBpQ29sLCAkKG5UaCkuZGF0YSgpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBcHBseSBvcHRpb25zIGZvciBhIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2wgY29sdW1uIGluZGV4IHRvIGNvbnNpZGVyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb09wdGlvbnMgb2JqZWN0IHdpdGggc1R5cGUsIGJWaXNpYmxlIGFuZCBiU2VhcmNoYWJsZSBldGNcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ29sdW1uT3B0aW9ucyhvU2V0dGluZ3MsIGlDb2wsIG9PcHRpb25zKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaUNvbF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGggPSAkKG9Db2wublRoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZ2V0IHdpZHRoIGluZm9ybWF0aW9uIGZyb20gdGhlIERPTS4gV2UgY2FuJ3QgZ2V0IGl0IGZyb20gQ1NTXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBhcyB3ZSdkIG5lZWQgdG8gcGFyc2UgdGhlIENTUyBzdHlsZXNoZWV0LiBgd2lkdGhgIG9wdGlvbiBjYW4gb3ZlcnJpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghb0NvbC5zV2lkdGhPcmlnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2lkdGggYXR0cmlidXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zV2lkdGhPcmlnID0gdGguYXR0cignd2lkdGgnKSB8fCBudWxsO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHlsZSBhdHRyaWJ1dGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9ICh0aC5hdHRyKCdzdHlsZScpIHx8ICcnKS5tYXRjaCgvd2lkdGg6XFxzKihcXGQrW3B4ZW0lXSspLyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zV2lkdGhPcmlnID0gdFsxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogVXNlciBzcGVjaWZpZWQgY29sdW1uIG9wdGlvbnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvT3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9PcHRpb25zICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRDb2xzKG9PcHRpb25zKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLCBvT3B0aW9ucyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBtRGF0YVByb3AgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob09wdGlvbnMubURhdGFQcm9wICE9PSB1bmRlZmluZWQgJiYgIW9PcHRpb25zLm1EYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9PcHRpb25zLm1EYXRhID0gb09wdGlvbnMubURhdGFQcm9wO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9PcHRpb25zLnNUeXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuX3NNYW51YWxUeXBlID0gb09wdGlvbnMuc1R5cGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBgY2xhc3NgIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKYXZhc2NyaXB0LCBzbyB3ZSBuZWVkIHRvIHByb3ZpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWJpbGl0eSB0byB1c2UgYSB2YWxpZCBuYW1lIGZvciB0aGUgY2FtZWwgY2FzZSBpbnB1dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvT3B0aW9ucy5jbGFzc05hbWUgJiYgIW9PcHRpb25zLnNDbGFzcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvT3B0aW9ucy5zQ2xhc3MgPSBvT3B0aW9ucy5jbGFzc05hbWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChvQ29sLCBvT3B0aW9ucyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKG9Db2wsIG9PcHRpb25zLCBcInNXaWR0aFwiLCBcInNXaWR0aE9yaWdcIik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlEYXRhU29ydCB0byBiZSBhcHBsaWVkIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSksIGJ1dCBhRGF0YVNvcnQgd2lsbCB0YWtlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogcHJpb3JpdHkgaWYgZGVmaW5lZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvT3B0aW9ucy5pRGF0YVNvcnQgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvQ29sLmFEYXRhU29ydCA9IFtvT3B0aW9ucy5pRGF0YVNvcnRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAob0NvbCwgb09wdGlvbnMsIFwiYURhdGFTb3J0XCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIENhY2hlIHRoZSBkYXRhIGdldCBhbmQgc2V0IGZ1bmN0aW9ucyBmb3Igc3BlZWQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtRGF0YVNyYyA9IG9Db2wubURhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbURhdGEgPSBfZm5HZXRPYmplY3REYXRhRm4obURhdGFTcmMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1SZW5kZXIgPSBvQ29sLm1SZW5kZXIgPyBfZm5HZXRPYmplY3REYXRhRm4ob0NvbC5tUmVuZGVyKSA6IG51bGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJUZXN0ID0gZnVuY3Rpb24gKHNyYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyAmJiBzcmMuaW5kZXhPZignQCcpICE9PSAtMTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBvQ29sLl9iQXR0clNyYyA9ICQuaXNQbGFpbk9iamVjdChtRGF0YVNyYykgJiYgKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJUZXN0KG1EYXRhU3JjLnNvcnQpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLnR5cGUpIHx8IGF0dHJUZXN0KG1EYXRhU3JjLmZpbHRlcilcclxuXHQgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgb0NvbC5mbkdldERhdGEgPSBmdW5jdGlvbiAocm93RGF0YSwgdHlwZSwgbWV0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lckRhdGEgPSBtRGF0YShyb3dEYXRhLCB0eXBlLCB1bmRlZmluZWQsIG1ldGEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVJlbmRlciAmJiB0eXBlID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbVJlbmRlcihpbm5lckRhdGEsIHR5cGUsIHJvd0RhdGEsIG1ldGEpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJEYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIG9Db2wuZm5TZXREYXRhID0gZnVuY3Rpb24gKHJvd0RhdGEsIHZhbCwgbWV0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5TZXRPYmplY3REYXRhRm4obURhdGFTcmMpKHJvd0RhdGEsIHZhbCwgbWV0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEluZGljYXRlIGlmIERhdGFUYWJsZXMgc2hvdWxkIHJlYWQgRE9NIGRhdGEgYXMgYW4gb2JqZWN0IG9yIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBVc2VkIGluIF9mbkdldFJvd0VsZW1lbnRzXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1EYXRhU3JjICE9PSAnbnVtYmVyJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5fcm93UmVhZE9iamVjdCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogRmVhdHVyZSBzb3J0aW5nIG92ZXJyaWRlcyBjb2x1bW4gc3BlY2lmaWMgd2hlbiBvZmYgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghb1NldHRpbmdzLm9GZWF0dXJlcy5iU29ydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuYlNvcnRhYmxlID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGguYWRkQ2xhc3Mob0NsYXNzZXMuc1NvcnRhYmxlTm9uZSk7IC8vIEhhdmUgdG8gYWRkIGNsYXNzIGhlcmUgYXMgb3JkZXIgZXZlbnQgaXNuJ3QgY2FsbGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgY2xhc3MgYXNzaWdubWVudCBpcyBjb3JyZWN0IGZvciBzb3J0aW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYkFzYyA9ICQuaW5BcnJheSgnYXNjJywgb0NvbC5hc1NvcnRpbmcpICE9PSAtMTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBiRGVzYyA9ICQuaW5BcnJheSgnZGVzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW9Db2wuYlNvcnRhYmxlIHx8ICghYkFzYyAmJiAhYkRlc2MpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlTm9uZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBcIlwiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYkFzYyAmJiAhYkRlc2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGVBc2M7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUlBc2NBbGxvd2VkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWJBc2MgJiYgYkRlc2MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGVEZXNjO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJRGVzY0FsbG93ZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWRqdXN0IHRoZSB0YWJsZSBjb2x1bW4gd2lkdGhzIGZvciBuZXcgZGF0YS4gTm90ZTogeW91IHdvdWxkIHByb2JhYmx5IHdhbnQgdG9cclxuXHQgICAgICAgICAgICAgICAgICogZG8gYSByZWRyYXcgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkFkanVzdENvbHVtblNpemluZyhzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogTm90IGludGVyZXN0ZWQgaW4gZG9pbmcgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uIGlmIGF1dG8td2lkdGggaXMgZGlzYWJsZWQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5vRmVhdHVyZXMuYkF1dG9XaWR0aCAhPT0gZmFsc2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNvbHVtbnMubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uc1tpXS5uVGguc3R5bGUud2lkdGggPSBjb2x1bW5zW2ldLnNXaWR0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsLnNZICE9PSAnJyB8fCBzY3JvbGwuc1ggIT09ICcnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU2Nyb2xsRHJhdyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXNpemluZycsIFtzZXR0aW5nc10pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENvdmVydCB0aGUgaW5kZXggb2YgYSB2aXNpYmxlIGNvbHVtbiB0byB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXkgKHRha2UgYWNjb3VudFxyXG5cdCAgICAgICAgICAgICAgICAgKiBvZiBoaWRkZW4gY29sdW1ucylcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBpTWF0Y2ggVmlzaWJsZSBjb2x1bW4gaW5kZXggdG8gbG9va3VwXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblZpc2libGVUb0NvbHVtbkluZGV4KG9TZXR0aW5ncywgaU1hdGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgJ2JWaXNpYmxlJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhaVZpc1tpTWF0Y2hdID09PSAnbnVtYmVyJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWlWaXNbaU1hdGNoXSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb3ZlcnQgdGhlIGluZGV4IG9mIGFuIGluZGV4IGluIHRoZSBkYXRhIGFycmF5IGFuZCBjb252ZXJ0IGl0IHRvIHRoZSB2aXNpYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgY29sdW1uIGluZGV4ICh0YWtlIGFjY291bnQgb2YgaGlkZGVuIGNvbHVtbnMpXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaU1hdGNoIENvbHVtbiBpbmRleCB0byBsb29rdXBcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIGRhdGEgaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUob1NldHRpbmdzLCBpTWF0Y2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhaVZpcyA9IF9mbkdldENvbHVtbnMob1NldHRpbmdzLCAnYlZpc2libGUnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpUG9zID0gJC5pbkFycmF5KGlNYXRjaCwgYWlWaXMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpUG9zICE9PSAtMSA/IGlQb3MgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2ludH0gaSB0aGUgbnVtYmVyIG9mIHZpc2libGUgY29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5WaXNibGVDb2x1bW5zKG9TZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mbkdldENvbHVtbnMob1NldHRpbmdzLCAnYlZpc2libGUnKS5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIHRoYXQgbWF0Y2ggYSBnaXZlbiBwcm9wZXJ0eVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNQYXJhbSBQYXJhbWV0ZXIgaW4gYW9Db2x1bW5zIHRvIGxvb2sgZm9yIC0gdHlwaWNhbGx5XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGJWaXNpYmxlIG9yIGJTZWFyY2hhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGluZGV4ZXMgd2l0aCBtYXRjaGVkIHByb3BlcnRpZXNcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuR2V0Q29sdW1ucyhvU2V0dGluZ3MsIHNQYXJhbSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAkLm1hcChvU2V0dGluZ3MuYW9Db2x1bW5zLCBmdW5jdGlvbiAodmFsLCBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbFtzUGFyYW1dKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDYWxjdWxhdGUgdGhlICd0eXBlJyBvZiBhIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNvbHVtblR5cGVzKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVzID0gRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpZW4sIGosIGplbiwgaywga2VuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCwgY2VsbCwgZGV0ZWN0ZWRUeXBlLCBjYWNoZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBjb2x1bW4sIHNwaW4gb3ZlciB0aGUgXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBjb2x1bW5zLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBjb2x1bW5zW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sLnNUeXBlICYmIGNvbC5fc01hbnVhbFR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLnNUeXBlID0gY29sLl9zTWFudWFsVHlwZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWNvbC5zVHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqZW4gPSB0eXBlcy5sZW5ndGggOyBqIDwgamVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBrZW4gPSBkYXRhLmxlbmd0aCA7IGsgPCBrZW4gOyBrKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBjYWNoZSBhcnJheSBzbyB3ZSBvbmx5IG5lZWQgdG8gZ2V0IHRoZSB0eXBlIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBmb3JtYXR0ZXIgb25jZSAod2hlbiB1c2luZyBtdWx0aXBsZSBkZXRlY3RvcnMpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlW2tdID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVba10gPSBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgaywgaSwgJ3R5cGUnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVjdGVkVHlwZSA9IHR5cGVzW2pdKGNhY2hlW2tdLCBzZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG51bGwsIHRoZW4gdGhpcyB0eXBlIGNhbid0IGFwcGx5IHRvIHRoaXMgY29sdW1uLCBzb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIHRlc3RpbmcgYWxsIGNlbGxzLCBicmVhayBvdXQuIFRoZXJlIGlzIGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGZvciB0aGUgbGFzdCB0eXBlIHdoaWNoIGlzIGBodG1sYC4gV2UgbmVlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjYW4gYWxsIHJvd3Mgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWl4IHN0cmluZyBhbmQgSFRNTFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXRlY3RlZFR5cGUgJiYgaiAhPT0gdHlwZXMubGVuZ3RoIC0gMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYSBzaW5nbGUgbWF0Y2ggaXMgbmVlZGVkIGZvciBodG1sIHR5cGUgc2luY2UgaXQgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gb2YgdGhlIHBpbGUgYW5kIHZlcnkgc2ltaWxhciB0byBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRUeXBlID09PSAnaHRtbCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFR5cGUgaXMgdmFsaWQgZm9yIGFsbCBkYXRhIHBvaW50cyBpbiB0aGUgY29sdW1uIC0gdXNlIHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXRlY3RlZFR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wuc1R5cGUgPSBkZXRlY3RlZFR5cGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayAtIGlmIG5vIHR5cGUgd2FzIGRldGVjdGVkLCBhbHdheXMgdXNlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbC5zVHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLnNUeXBlID0gJ3N0cmluZyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogVGFrZSB0aGUgY29sdW1uIGRlZmluaXRpb25zIGFuZCBzdGF0aWMgY29sdW1ucyBhcnJheXMgYW5kIGNhbGN1bGF0ZSBob3dcclxuXHQgICAgICAgICAgICAgICAgICogdGhleSByZWxhdGUgdG8gY29sdW1uIGluZGV4ZXMuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIHRoZW4gYXBwbHkgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIGRlZmluaXRpb24gZm91bmQgZm9yIGEgY29sdW1uIHRvIGEgc3VpdGFibGUgY29uZmlndXJhdGlvbiBvYmplY3QuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhb0NvbERlZnMgVGhlIGFvQ29sdW1uRGVmcyBhcnJheSB0aGF0IGlzIHRvIGJlIGFwcGxpZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGFvQ29scyBUaGUgYW9Db2x1bW5zIGFycmF5IHRoYXQgZGVmaW5lcyBjb2x1bW5zIGluZGl2aWR1YWxseVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gLSB0YWtlcyB0d28gcGFyYW1ldGVycywgdGhlIGNhbGN1bGF0ZWRcclxuXHQgICAgICAgICAgICAgICAgICogICAgY29sdW1uIGluZGV4IGFuZCB0aGUgZGVmaW5pdGlvbiBmb3IgdGhhdCBjb2x1bW4uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkFwcGx5Q29sdW1uRGVmcyhvU2V0dGluZ3MsIGFvQ29sRGVmcywgYW9Db2xzLCBmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGksIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sIGRlZjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb2x1bW4gZGVmaW5pdGlvbnMgd2l0aCBhVGFyZ2V0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFvQ29sRGVmcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIExvb3Agb3ZlciB0aGUgZGVmaW5pdGlvbnMgYXJyYXkgLSBsb29wIGluIHJldmVyc2Ugc28gZmlyc3QgaW5zdGFuY2UgaGFzIHByaW9yaXR5ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gYW9Db2xEZWZzLmxlbmd0aCAtIDEgOyBpID49IDAgOyBpLS0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmID0gYW9Db2xEZWZzW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogRWFjaCBkZWZpbml0aW9uIGNhbiB0YXJnZXQgbXVsdGlwbGUgY29sdW1ucywgYXMgaXQgaXMgYW4gYXJyYXkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFUYXJnZXRzID0gZGVmLnRhcmdldHMgIT09IHVuZGVmaW5lZCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYudGFyZ2V0cyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWYuYVRhcmdldHM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISQuaXNBcnJheShhVGFyZ2V0cykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFUYXJnZXRzID0gW2FUYXJnZXRzXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgakxlbiA9IGFUYXJnZXRzLmxlbmd0aCA7IGogPCBqTGVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA+PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQWRkIGNvbHVtbnMgdGhhdCB3ZSBkb24ndCB5ZXQga25vdyBhYm91dCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb2x1bW5zLmxlbmd0aCA8PSBhVGFyZ2V0c1tqXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGRDb2x1bW4ob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEludGVnZXIsIGJhc2ljIGluZGV4ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4oYVRhcmdldHNbal0sIGRlZik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYVRhcmdldHNbal0gPT09ICdudW1iZXInICYmIGFUYXJnZXRzW2pdIDwgMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE5lZ2F0aXZlIGludGVnZXIsIHJpZ2h0IHRvIGxlZnQgY29sdW1uIGNvdW50aW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4oY29sdW1ucy5sZW5ndGggKyBhVGFyZ2V0c1tqXSwgZGVmKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBDbGFzcyBuYW1lIG1hdGNoaW5nIG9uIFRIIGVsZW1lbnQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBrTGVuID0gY29sdW1ucy5sZW5ndGggOyBrIDwga0xlbiA7IGsrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVRhcmdldHNbal0gPT0gXCJfYWxsXCIgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGNvbHVtbnNba10ublRoKS5oYXNDbGFzcyhhVGFyZ2V0c1tqXSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGssIGRlZik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU3RhdGljYWxseSBkZWZpbmVkIGNvbHVtbnMgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhb0NvbHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gYW9Db2xzLmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGksIGFvQ29sc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWRkIGEgZGF0YSBhcnJheSB0byB0aGUgdGFibGUsIGNyZWF0aW5nIERPTSBub2RlIGV0Yy4gVGhpcyBpcyB0aGUgcGFyYWxsZWwgdG9cclxuXHQgICAgICAgICAgICAgICAgICogX2ZuR2F0aGVyRGF0YSwgYnV0IGZvciBhZGRpbmcgcm93cyBmcm9tIGEgSmF2YXNjcmlwdCBzb3VyY2UsIHJhdGhlciB0aGFuIGFcclxuXHQgICAgICAgICAgICAgICAgICogRE9NIHNvdXJjZS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGFEYXRhIGRhdGEgYXJyYXkgdG8gYmUgYWRkZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gW25Ucl0gVFIgZWxlbWVudCB0byBhZGQgdG8gdGhlIHRhYmxlIC0gb3B0aW9uYWwuIElmIG5vdCBnaXZlbixcclxuXHQgICAgICAgICAgICAgICAgICogICAgRGF0YVRhYmxlcyB3aWxsIGNyZWF0ZSBhIHJvdyBhdXRvbWF0aWNhbGx5XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBbYW5UZHNdIEFycmF5IG9mIFREfFRIIGVsZW1lbnRzIGZvciB0aGUgcm93IC0gbXVzdCBiZSBnaXZlblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBpZiBuVHIgaXMuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSA+PTAgaWYgc3VjY2Vzc2Z1bCAoaW5kZXggb2YgbmV3IGFvRGF0YSBlbnRyeSksIC0xIGlmIGZhaWxlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BZGREYXRhKG9TZXR0aW5ncywgYURhdGFJbiwgblRyLCBhblRkcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQ3JlYXRlIHRoZSBvYmplY3QgZm9yIHN0b3JpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBuZXcgcm93ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaVJvdyA9IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9EYXRhID0gJC5leHRlbmQodHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1Jvdywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogblRyID8gJ2RvbScgOiAnZGF0YSdcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIG9EYXRhLl9hRGF0YSA9IGFEYXRhSW47XHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYW9EYXRhLnB1c2gob0RhdGEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgY2VsbHMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuVGQsIHNUaGlzVHlwZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY29sdW1ucy5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gd29ya2luZyB3aXRoIGEgcm93LCB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0IG11c3QgYmUgcG9wdWxhdGVkLiBJblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciBjYXNlcywgdGhlIGRhdGEgc291cmNlIG9iamVjdCBpcyBhbHJlYWR5IHBvcHVsYXRlZCwgc28gd2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBvdmVyd3JpdGUgaXQsIHdoaWNoIG1pZ2h0IGJyZWFrIGJpbmRpbmdzIGV0Y1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuVHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU2V0Q2VsbERhdGEob1NldHRpbmdzLCBpUm93LCBpLCBfZm5HZXRDZWxsRGF0YShvU2V0dGluZ3MsIGlSb3csIGkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uc1tpXS5zVHlwZSA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQWRkIHRvIHRoZSBkaXNwbGF5IGFycmF5ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnB1c2goaVJvdyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQ3JlYXRlIHRoZSBET00gaW5mb3JtYXRpb24sIG9yIHJlZ2lzdGVyIGl0IGlmIGFscmVhZHkgcHJlc2VudCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5UciB8fCAhb1NldHRpbmdzLm9GZWF0dXJlcy5iRGVmZXJSZW5kZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DcmVhdGVUcihvU2V0dGluZ3MsIGlSb3csIG5UciwgYW5UZHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpUm93O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFkZCBvbmUgb3IgbW9yZSBUUiBlbGVtZW50cyB0byB0aGUgdGFibGUuIEdlbmVyYWxseSB3ZSdkIGV4cGVjdCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiB1c2UgdGhpcyBmb3IgcmVhZGluZyBkYXRhIGZyb20gYSBET00gc291cmNlZCB0YWJsZSwgYnV0IGl0IGNvdWxkIGJlXHJcblx0ICAgICAgICAgICAgICAgICAqIHVzZWQgZm9yIGFuIFRSIGVsZW1lbnQuIE5vdGUgdGhhdCBpZiBhIFRSIGlzIGdpdmVuLCBpdCBpcyB1c2VkIChpLmUuXHJcblx0ICAgICAgICAgICAgICAgICAqIGl0IGlzIG5vdCBjbG9uZWQpLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fG5vZGV8alF1ZXJ5fSB0cnMgVGhlIFRSIGVsZW1lbnQocykgdG8gYWRkIHRvIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBpbmRleGVzIGZvciB0aGUgYWRkZWQgcm93c1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BZGRUcihzZXR0aW5ncywgdHJzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFuIGluZGl2aWR1YWwgbm9kZSB0byBiZSBwYXNzZWQgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHRycyBpbnN0YW5jZW9mICQpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJzID0gJCh0cnMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnMubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IF9mbkdldFJvd0VsZW1lbnRzKHNldHRpbmdzLCBlbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mbkFkZERhdGEoc2V0dGluZ3MsIHJvdy5kYXRhLCBlbCwgcm93LmNlbGxzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFRha2UgYSBUUiBlbGVtZW50IGFuZCBjb252ZXJ0IGl0IHRvIGFuIGluZGV4IGluIGFvRGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuIHRoZSBUUiBlbGVtZW50IHRvIGZpbmRcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IGluZGV4IGlmIHRoZSBub2RlIGlzIGZvdW5kLCBudWxsIGlmIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Ob2RlVG9EYXRhSW5kZXgob1NldHRpbmdzLCBuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG4uX0RUX1Jvd0luZGV4ICE9PSB1bmRlZmluZWQpID8gbi5fRFRfUm93SW5kZXggOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFRha2UgYSBURCBlbGVtZW50IGFuZCBjb252ZXJ0IGl0IGludG8gYSBjb2x1bW4gZGF0YSBpbmRleCAobm90IHRoZSB2aXNpYmxlIGluZGV4KVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlSb3cgVGhlIHJvdyBudW1iZXIgdGhlIFREL1RIIGNhbiBiZSBmb3VuZCBpblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuIFRoZSBURC9USCBlbGVtZW50IHRvIGZpbmRcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IGluZGV4IGlmIHRoZSBub2RlIGlzIGZvdW5kLCAtMSBpZiBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuTm9kZVRvQ29sdW1uSW5kZXgob1NldHRpbmdzLCBpUm93LCBuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5pbkFycmF5KG4sIG9TZXR0aW5ncy5hb0RhdGFbaVJvd10uYW5DZWxscyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IHRoZSBkYXRhIGZvciBhIGdpdmVuIGNlbGwgZnJvbSB0aGUgaW50ZXJuYWwgY2FjaGUsIHRha2luZyBpbnRvIGFjY291bnQgZGF0YSBtYXBwaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBDb2x1bW4gaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGRhdGEgZ2V0IHR5cGUgKCdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0JylcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHsqfSBDZWxsIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZHJhdyA9IHNldHRpbmdzLmlEcmF3O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0RhdGEgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XS5fYURhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdENvbnRlbnQgPSBjb2wuc0RlZmF1bHRDb250ZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxEYXRhID0gY29sLmZuR2V0RGF0YShyb3dEYXRhLCB0eXBlLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93SWR4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogY29sSWR4XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbERhdGEgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pRHJhd0Vycm9yICE9IGRyYXcgJiYgZGVmYXVsdENvbnRlbnQgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKHNldHRpbmdzLCAwLCBcIlJlcXVlc3RlZCB1bmtub3duIHBhcmFtZXRlciBcIiArXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGNvbC5tRGF0YSA9PSAnZnVuY3Rpb24nID8gJ3tmdW5jdGlvbn0nIDogXCInXCIgKyBjb2wubURhdGEgKyBcIidcIikgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgZm9yIHJvdyBcIiArIHJvd0lkeCwgNCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmlEcmF3RXJyb3IgPSBkcmF3O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdENvbnRlbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogV2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbCwgd2UgY2FuIHVzZSBkZWZhdWx0IGNvbHVtbiBkYXRhICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoKGNlbGxEYXRhID09PSByb3dEYXRhIHx8IGNlbGxEYXRhID09PSBudWxsKSAmJiBkZWZhdWx0Q29udGVudCAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gZGVmYXVsdENvbnRlbnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2VsbERhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YSBzb3VyY2UgaXMgYSBmdW5jdGlvbiwgdGhlbiB3ZSBydW4gaXQgYW5kIHVzZSB0aGUgcmV0dXJuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4ZWN1dGluZyBpbiB0aGUgc2NvcGUgb2YgdGhlIGRhdGEgb2JqZWN0IChmb3IgaW5zdGFuY2VzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsRGF0YS5jYWxsKHJvd0RhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRGF0YSA9PT0gbnVsbCAmJiB0eXBlID09ICdkaXNwbGF5Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxsRGF0YTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNwZWNpZmljIGNlbGwsIGludG8gdGhlIGludGVybmFsIGRhdGEgY2FjaGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gc2V0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93RGF0YSA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2wuZm5TZXREYXRhKHJvd0RhdGEsIHZhbCwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvd0lkeCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbElkeFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBQcml2YXRlIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCB0byBtYXRjaCBhY3Rpb24gc3ludGF4IGluIHRoZSBkYXRhIHByb3BlcnR5IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19yZUFycmF5ID0gL1xcWy4qP1xcXSQvO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19yZUZuID0gL1xcKFxcKSQvO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFNwbGl0IHN0cmluZyBvbiBwZXJpb2RzLCB0YWtpbmcgaW50byBhY2NvdW50IGVzY2FwZWQgcGVyaW9kc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXRcclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybiB7YXJyYXl9IFNwbGl0IHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU3BsaXRPYmpOb3RhdGlvbihzdHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChzdHIubWF0Y2goLyhcXFxcLnxbXlxcLl0pKy9nKSwgZnVuY3Rpb24gKHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcLi9nLCAnLicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXHJcblx0ICAgICAgICAgICAgICAgICAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBnZXQgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuR2V0T2JqZWN0RGF0YUZuKG1Tb3VyY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QobVNvdXJjZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBCdWlsZCBhbiBvYmplY3Qgb2YgZ2V0IGZ1bmN0aW9ucywgYW5kIHdyYXAgdGhlbSBpbiBhIHNpbmdsZSBjYWxsICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB7fTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gobVNvdXJjZSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IF9mbkdldE9iamVjdERhdGFGbih2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gb1t0eXBlXSB8fCBvLl87XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICE9PSB1bmRlZmluZWQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdChkYXRhLCB0eXBlLCByb3csIG1ldGEpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1Tb3VyY2UgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBHaXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgcmVuZGVyaW5nIC8gc29ydGluZyBldGMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHsgLy8gdHlwZSwgcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtU291cmNlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlLCByb3csIG1ldGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1Tb3VyY2UoZGF0YSwgdHlwZSwgcm93LCBtZXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1Tb3VyY2UgPT09ICdzdHJpbmcnICYmIChtU291cmNlLmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZXJlIGlzIGEgLiBpbiB0aGUgc291cmNlIHN0cmluZyB0aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBpbiBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogbmVzdGVkIG9iamVjdCBzbyB3ZSBsb29wIG92ZXIgdGhlIGRhdGEgZm9yIGVhY2ggbGV2ZWwgdG8gZ2V0IHRoZSBuZXh0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogbGV2ZWwgZG93bi4gT24gZWFjaCBsb29wIHdlIHRlc3QgZm9yIHVuZGVmaW5lZCwgYW5kIGlmIGZvdW5kIGltbWVkaWF0ZWx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogcmV0dXJuLiBUaGlzIGFsbG93cyBlbnRpcmUgb2JqZWN0cyB0byBiZSBtaXNzaW5nIGFuZCBzRGVmYXVsdENvbnRlbnQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBiZSB1c2VkIGlmIGRlZmluZWQsIHJhdGhlciB0aGFuIHRocm93aW5nIGFuIGVycm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZldGNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB0eXBlLCBzcmMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5Tm90YXRpb24sIGZ1bmNOb3RhdGlvbiwgb3V0LCBpbm5lclNyYztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmMgIT09IFwiXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gX2ZuU3BsaXRPYmpOb3RhdGlvbihzcmMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gYS5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggc3BlY2lhbCBub3RhdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlOb3RhdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBub3RhdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ldID0gYVtpXS5yZXBsYWNlKF9fcmVBcnJheSwgJycpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGl0aW9uIGFsbG93cyBzaW1wbHkgW10gdG8gYmUgcGFzc2VkIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBcIlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIGdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnNwbGljZSgwLCBpICsgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyU3JjID0gYS5qb2luKCcuJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBnZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IGRhdGEubGVuZ3RoIDsgaiA8IGpMZW4gOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGZldGNoRGF0YShkYXRhW2pdLCB0eXBlLCBpbm5lclNyYykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHN0cmluZyBpcyBnaXZlbiBpbiBiZXR3ZWVuIHRoZSBhcnJheSBub3RhdGlvbiBpbmRpY2F0b3JzLCB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHVzZWQgdG8gam9pbiB0aGUgc3RyaW5ncyB0b2dldGhlciwgb3RoZXJ3aXNlIGFuIGFycmF5IGlzIHJldHVybmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqb2luID0gYXJyYXlOb3RhdGlvblswXS5zdWJzdHJpbmcoMSwgYXJyYXlOb3RhdGlvblswXS5sZW5ndGggLSAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IChqb2luID09PSBcIlwiKSA/IG91dCA6IG91dC5qb2luKGpvaW4pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlubmVyIGNhbGwgdG8gZmV0Y2hEYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSByZXF1ZXN0ZWQsIHNvIHdlIGV4aXQgZnJvbSB0aGUgbG9vcFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY05vdGF0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNhbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbYVtpXV0oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhW2FbaV1dID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbYVtpXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEYXRhKGRhdGEsIHR5cGUsIG1Tb3VyY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB0eXBlKSB7IC8vIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW21Tb3VyY2VdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXHJcblx0ICAgICAgICAgICAgICAgICAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBzZXQgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU2V0T2JqZWN0RGF0YUZuKG1Tb3VyY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QobVNvdXJjZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBVbmxpa2UgZ2V0LCBvbmx5IHRoZSB1bmRlcnNjb3JlIChnbG9iYWwpIG9wdGlvbiBpcyB1c2VkIGZvciBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBvcHRpb24gaXMgbm90IGRvY3VtZW50ZWQgZm9yIGBtRGF0YWAgKHdoaWNoIGlzIHJlYWQvd3JpdGUpLCBidXQgaXQgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBmb3IgYG1SZW5kZXJgIHdoaWNoIGlzIHJlYWQgb25seS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKG1Tb3VyY2UuXyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtU291cmNlID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogTm90aGluZyB0byBkbyB3aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtU291cmNlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwsIG1ldGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbVNvdXJjZShkYXRhLCAnc2V0JywgdmFsLCBtZXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1Tb3VyY2UgPT09ICdzdHJpbmcnICYmIChtU291cmNlLmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIExpa2UgdGhlIGdldCwgd2UgbmVlZCB0byBnZXQgZGF0YSBmcm9tIGEgbmVzdGVkIG9iamVjdCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXREYXRhID0gZnVuY3Rpb24gKGRhdGEsIHZhbCwgc3JjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gX2ZuU3BsaXRPYmpOb3RhdGlvbihzcmMpLCBiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYUxhc3QgPSBhW2EubGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG8sIGlubmVyU3JjO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBhLmxlbmd0aCAtIDEgOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhbiBhcnJheSBub3RhdGlvbiByZXF1ZXN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY05vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlRm4pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJheU5vdGF0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2FbaV1dID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIHNldCBzbyB3ZSBjYW4gcmVjdXJzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBhLnNsaWNlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5zcGxpY2UoMCwgaSArIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyU3JjID0gYi5qb2luKCcuJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYXZlcnNlIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5IHNldHRpbmcgdGhlIHByb3BlcnRpZXMgcmVxdWVzdGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSB2YWwubGVuZ3RoIDsgaiA8IGpMZW4gOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXREYXRhKG8sIHZhbFtqXSwgaW5uZXJTcmMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2FbaV1dLnB1c2gobyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaW5uZXIgY2FsbCB0byBzZXREYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIGFuZCBoYXMgc2V0IHRoZSBkYXRhLCB0aHVzIHdlIGNhbiBleGl0IGhlcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmdW5jTm90YXRpb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjYWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXSh2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXN0ZWQgb2JqZWN0IGRvZXNuJ3QgY3VycmVudGx5IGV4aXN0IC0gc2luY2Ugd2UgYXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgdG8gc2V0IHRoZSB2YWx1ZSAtIGNyZWF0ZSBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbYVtpXV0gPT09IG51bGwgfHwgZGF0YVthW2ldXSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVthW2ldXSA9IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbYVtpXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExhc3QgaXRlbSBpbiB0aGUgaW5wdXQgLSBpLmUsIHRoZSBhY3R1YWwgc2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhTGFzdC5tYXRjaChfX3JlRm4pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjYWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthTGFzdC5yZXBsYWNlKF9fcmVGbiwgJycpXSh2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYXJyYXkgbm90YXRpb24gaXMgdXNlZCwgd2UganVzdCB3YW50IHRvIHN0cmlwIGl0IGFuZCB1c2UgdGhlIHByb3BlcnR5IG5hbWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBhc3NpZ24gdGhlIHZhbHVlLiBJZiBpdCBpc24ndCB1c2VkLCB0aGVuIHdlIGdldCB0aGUgcmVzdWx0IHdlIHdhbnQgYW55d2F5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2FMYXN0LnJlcGxhY2UoX19yZUFycmF5LCAnJyldID0gdmFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXREYXRhKGRhdGEsIHZhbCwgbVNvdXJjZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVttU291cmNlXSA9IHZhbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBmdWxsIHRhYmxlIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIGFycmF5IHthcnJheX0gYURhdGEgTWFzdGVyIGRhdGEgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuR2V0RGF0YU1hc3RlcihzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wbHVjayhzZXR0aW5ncy5hb0RhdGEsICdfYURhdGEnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBOdWtlIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5DbGVhclRhYmxlKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hb0RhdGEubGVuZ3RoID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGggPSAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWlEaXNwbGF5Lmxlbmd0aCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgKiBUYWtlIGFuIGFycmF5IG9mIGludGVnZXJzIChpbmRleCBhcnJheSkgYW5kIHJlbW92ZSBhIHRhcmdldCBpbnRlZ2VyICh2YWx1ZSAtIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAqIHRoZSBrZXkhKVxyXG5cdCAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhIEluZGV4IGFycmF5IHRvIHRhcmdldFxyXG5cdCAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaVRhcmdldCB2YWx1ZSB0byBmaW5kXHJcblx0ICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5EZWxldGVJbmRleChhLCBpVGFyZ2V0LCBzcGxpY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpVGFyZ2V0SW5kZXggPSAtMTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGEubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtpXSA9PSBpVGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlUYXJnZXRJbmRleCA9IGk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFbaV0gPiBpVGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0tLTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlUYXJnZXRJbmRleCAhPSAtMSAmJiBzcGxpY2UgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGEuc3BsaWNlKGlUYXJnZXRJbmRleCwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogTWFyayBjYWNoZWQgZGF0YSBhcyBpbnZhbGlkIHN1Y2ggdGhhdCBhIHJlLXJlYWQgb2YgdGhlIGRhdGEgd2lsbCBvY2N1ciB3aGVuXHJcblx0ICAgICAgICAgICAgICAgICAqIHRoZSBjYWNoZWQgZGF0YSBpcyBuZXh0IHJlcXVlc3RlZC4gQWxzbyB1cGRhdGUgZnJvbSB0aGUgZGF0YSBzb3VyY2Ugb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtpbnR9ICAgIHJvd0lkeCAgIFJvdyBpbmRleCB0byBpbnZhbGlkYXRlXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSAgICBTb3VyY2UgdG8gaW52YWxpZGF0ZSBmcm9tOiB1bmRlZmluZWQsICdhdXRvJywgJ2RvbSdcclxuXHQgICAgICAgICAgICAgICAgICogICAgIG9yICdkYXRhJ1xyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2ludH0gICAgW2NvbElkeF0gQ29sdW1uIGluZGV4IHRvIGludmFsaWRhdGUuIElmIHVuZGVmaW5lZCB0aGUgd2hvbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAgIHJvdyB3aWxsIGJlIGludmFsaWRhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAdG9kbyBGb3IgdGhlIG1vZHVsYXJpc2F0aW9uIG9mIHYxLjExIHRoaXMgd2lsbCBuZWVkIHRvIGJlY29tZSBhIGNhbGxiYWNrLCBzb1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHRoZSBzb3J0IGFuZCBmaWx0ZXIgbWV0aG9kcyBjYW4gc3Vic2NyaWJlIHRvIGl0LiBUaGF0IHdpbGwgcmVxdWlyZWRcclxuXHQgICAgICAgICAgICAgICAgICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zIGZvciBzb3J0aW5nLCB3aGljaCBpcyB3aHkgaXQgaXMgbm90IGFscmVhZHkgYmFrZWQgaW5cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkludmFsaWRhdGUoc2V0dGluZ3MsIHJvd0lkeCwgc3JjLCBjb2xJZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbFdyaXRlID0gZnVuY3Rpb24gKGNlbGwsIGNvbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdmVyeSBmcnVzdHJhdGluZywgYnV0IGluIElFIGlmIHlvdSBqdXN0IHdyaXRlIGRpcmVjdGx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gaW5uZXJIVE1MLCBhbmQgZWxlbWVudHMgdGhhdCBhcmUgb3ZlcndyaXR0ZW4gYXJlIEdDJ2VkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgdGhlcmUgaXMgYSByZWZlcmVuY2UgdG8gdGhlbSBlbHNld2hlcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2VsbC5jaGlsZE5vZGVzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnJlbW92ZUNoaWxkKGNlbGwuZmlyc3RDaGlsZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmlubmVySFRNTCA9IF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIGNvbCwgJ2Rpc3BsYXknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQXJlIHdlIHJlYWRpbmcgbGFzdCBkYXRhIGZyb20gRE9NIG9yIHRoZSBkYXRhIG9iamVjdD9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzcmMgPT09ICdkb20nIHx8ICgoIXNyYyB8fCBzcmMgPT09ICdhdXRvJykgJiYgcm93LnNyYyA9PT0gJ2RvbScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgZGF0YSBmcm9tIHRoZSBET01cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3cuX2FEYXRhID0gX2ZuR2V0Um93RWxlbWVudHMoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncywgcm93LCBjb2xJZHgsIGNvbElkeCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcm93Ll9hRGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZGluZyBmcm9tIGRhdGEgb2JqZWN0LCB1cGRhdGUgdGhlIERPTVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IHJvdy5hbkNlbGxzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbElkeCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsV3JpdGUoY2VsbHNbY29sSWR4XSwgY29sSWR4KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNlbGxzLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsV3JpdGUoY2VsbHNbaV0sIGkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEZvciBib3RoIHJvdyBhbmQgY2VsbCBpbnZhbGlkYXRpb24sIHRoZSBjYWNoZWQgZGF0YSBmb3Igc29ydGluZyBhbmRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlcmluZyBpcyBudWxsZWQgb3V0XHJcblx0ICAgICAgICAgICAgICAgICAgICByb3cuX2FTb3J0RGF0YSA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICByb3cuX2FGaWx0ZXJEYXRhID0gbnVsbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSB0eXBlIGZvciBhIHNwZWNpZmljIGNvbHVtbiAoaWYgZ2l2ZW4pIG9yIGFsbCBjb2x1bW5zIHNpbmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZGF0YSBtaWdodCBoYXZlIGNoYW5nZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbElkeCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sc1tjb2xJZHhdLnNUeXBlID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNvbHMubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xzW2ldLnNUeXBlID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBEYXRhVGFibGVzIHNwZWNpYWwgYERUXypgIGF0dHJpYnV0ZXMgZm9yIHRoZSByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Sb3dBdHRyaWJ1dGVzKHJvdyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQnVpbGQgYSBkYXRhIHNvdXJjZSBvYmplY3QgZnJvbSBhbiBIVE1MIHJvdywgcmVhZGluZyB0aGUgY29udGVudHMgb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIGNlbGxzIHRoYXQgYXJlIGluIHRoZSByb3cuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge25vZGV8b2JqZWN0fSBUUiBlbGVtZW50IGZyb20gd2hpY2ggdG8gcmVhZCBkYXRhIG9yIGV4aXN0aW5nIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlLXJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgY2VsbHNcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtpbnR9IFtjb2xJZHhdIE9wdGlvbmFsIGNvbHVtbiBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2FycmF5fG9iamVjdH0gW2RdIERhdGEgc291cmNlIG9iamVjdC4gSWYgYGNvbElkeGAgaXMgZ2l2ZW4gdGhlbiB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAqICAgcGFyYW1ldGVyIHNob3VsZCBhbHNvIGJlIGdpdmVuIGFuZCB3aWxsIGJlIHVzZWQgdG8gd3JpdGUgdGhlIGRhdGEgaW50by5cclxuXHQgICAgICAgICAgICAgICAgICogICBPbmx5IHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gd2lsbCBiZSB3cml0dGVuXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCB3aXRoIHR3byBwYXJhbWV0ZXJzOiBgZGF0YWAgdGhlIGRhdGEgcmVhZCwgaW5cclxuXHQgICAgICAgICAgICAgICAgICogICBkb2N1bWVudCBvcmRlciwgYW5kIGBjZWxsc2AgYW5kIGFycmF5IG9mIG5vZGVzICh0aGV5IGNhbiBiZSB1c2VmdWwgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgY2FsbGVyLCBzbyByYXRoZXIgdGhhbiBuZWVkaW5nIGEgc2Vjb25kIHRyYXZlcnNhbCB0byBnZXQgdGhlbSwganVzdCByZXR1cm5cclxuXHQgICAgICAgICAgICAgICAgICogICB0aGVtIGZyb20gaGVyZSkuXHJcblx0ICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuR2V0Um93RWxlbWVudHMoc2V0dGluZ3MsIHJvdywgY29sSWR4LCBkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZHMgPSBbXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZCA9IHJvdy5maXJzdENoaWxkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsIGNvbCwgbywgaSA9IDAsIGNvbnRlbnRzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0UmVhZCA9IHNldHRpbmdzLl9yb3dSZWFkT2JqZWN0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBkYXRhIG9iamVjdCB0byBiZSBwYXNzZWQgaW4sIG9yIGNvbnN0cnVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZCA9IGQgfHwgb2JqZWN0UmVhZCA/IHt9IDogW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBmdW5jdGlvbiAoc3RyLCB0ZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoJ0AnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHN0ci5zdWJzdHJpbmcoaWR4ICsgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKHN0cik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoZCwgdGQuZ2V0QXR0cmlidXRlKGF0dHIpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBkYXRhIGZyb20gYSBjZWxsIGFuZCBzdG9yZSBpbnRvIHRoZSBkYXRhIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxQcm9jZXNzID0gZnVuY3Rpb24gKGNlbGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sSWR4ID09PSB1bmRlZmluZWQgfHwgY29sSWR4ID09PSBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IGNvbHVtbnNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gJC50cmltKGNlbGwuaW5uZXJIVE1MKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wgJiYgY29sLl9iQXR0clNyYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbihjb2wubURhdGEuXyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoZCwgY29udGVudHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIoY29sLm1EYXRhLnNvcnQsIGNlbGwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cihjb2wubURhdGEudHlwZSwgY2VsbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyKGNvbC5tRGF0YS5maWx0ZXIsIGNlbGwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBgZGF0YWAgb3B0aW9uIGZvciB0aGUgY29sdW1ucyB0aGUgZGF0YSBjYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIHJlYWQgdG8gZWl0aGVyIGFuIG9iamVjdCBvciBhbiBhcnJheS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RSZWFkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2wuX3NldHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgc2V0dGVyIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5fc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKGNvbC5tRGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5fc2V0dGVyKGQsIGNvbnRlbnRzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaV0gPSBjb250ZW50cztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBgdHJgIGVsZW1lbnQgd2FzIHBhc3NlZCBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gdGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiVERcIiB8fCBuYW1lID09IFwiVEhcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFByb2Nlc3ModGQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGRzLnB1c2godGQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZCA9IHRkLm5leHRTaWJsaW5nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4aXN0aW5nIHJvdyBvYmplY3QgcGFzc2VkIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGRzID0gcm93LmFuQ2VsbHM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqZW4gPSB0ZHMubGVuZ3RoIDsgaiA8IGplbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsUHJvY2Vzcyh0ZHNbal0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHM6IHRkc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ3JlYXRlIGEgbmV3IFRSIGVsZW1lbnQgKGFuZCBpdCdzIFREIGNoaWxkcmVuKSBmb3IgYSByb3dcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBpUm93IFJvdyB0byBjb25zaWRlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBbblRySW5dIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cclxuXHQgICAgICAgICAgICAgICAgICogICAgaWYgblRyIGlzLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5DcmVhdGVUcihvU2V0dGluZ3MsIGlSb3csIG5UckluLCBhblRkcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gb1NldHRpbmdzLmFvRGF0YVtpUm93XSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3dEYXRhID0gcm93Ll9hRGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjZWxscyA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5UciwgblRkLCBvQ29sLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGksIGlMZW47XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5uVHIgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuVHIgPSBuVHJJbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3cublRyID0gblRyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hbkNlbGxzID0gY2VsbHM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFVzZSBhIHByaXZhdGUgcHJvcGVydHkgb24gdGhlIG5vZGUgdG8gYWxsb3cgcmVzZXJ2ZSBtYXBwaW5nIGZyb20gdGhlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0byB0aGUgYW9EYXRhIGFycmF5IGZvciBmYXN0IGxvb2sgdXBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuVHIuX0RUX1Jvd0luZGV4ID0gaVJvdztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogU3BlY2lhbCBwYXJhbWV0ZXJzIGNhbiBiZSBnaXZlbiBieSB0aGUgZGF0YSBzb3VyY2UgdG8gYmUgdXNlZCBvbiB0aGUgcm93ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUm93QXR0cmlidXRlcyhyb3cpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBQcm9jZXNzIGVhY2ggY29sdW1uICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0NvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuVGQgPSBuVHJJbiA/IGFuVGRzW2ldIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChvQ29sLnNDZWxsVHlwZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goblRkKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gY3JlYXRlIHRoZSBIVE1MIGlmIG5ldywgb3IgaWYgYSByZW5kZXJpbmcgZnVuY3Rpb24gaXMgZGVmaW5lZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5UckluIHx8IG9Db2wubVJlbmRlciB8fCBvQ29sLm1EYXRhICE9PSBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuVGQuaW5uZXJIVE1MID0gX2ZuR2V0Q2VsbERhdGEob1NldHRpbmdzLCBpUm93LCBpLCAnZGlzcGxheScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBBZGQgdXNlciBkZWZpbmVkIGNsYXNzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvQ29sLnNDbGFzcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgblRkLmNsYXNzTmFtZSArPSAnICcgKyBvQ29sLnNDbGFzcztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmlzaWJpbGl0eSAtIGFkZCBvciByZW1vdmUgYXMgcmVxdWlyZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Db2wuYlZpc2libGUgJiYgIW5UckluKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuVHIuYXBwZW5kQ2hpbGQoblRkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb0NvbC5iVmlzaWJsZSAmJiBuVHJJbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgblRkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoblRkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Db2wuZm5DcmVhdGVkQ2VsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5mbkNyZWF0ZWRDZWxsLmNhbGwob1NldHRpbmdzLm9JbnN0YW5jZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuVGQsIF9mbkdldENlbGxEYXRhKG9TZXR0aW5ncywgaVJvdywgaSksIHJvd0RhdGEsIGlSb3csIGlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIG51bGwsIFtuVHIsIHJvd0RhdGEsIGlSb3ddKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb25jZSB3ZWJraXQgYnVnIDEzMTgxOSBhbmQgQ2hyb21pdW0gYnVnIDM2NTYxOSBoYXZlIGJlZW4gcmVzb2x2ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkZXBsb3llZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcm93Lm5Uci5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncm93Jyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWRkIGF0dHJpYnV0ZXMgdG8gYSByb3cgYmFzZWQgb24gdGhlIHNwZWNpYWwgYERUXypgIHBhcmFtZXRlcnMgaW4gYSBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAqIHNvdXJjZSBvYmplY3QuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gRGF0YVRhYmxlcyByb3cgb2JqZWN0IGZvciB0aGUgcm93IHRvIGJlIG1vZGlmaWVkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblJvd0F0dHJpYnV0ZXMocm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSByb3cublRyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByb3cuX2FEYXRhO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0cikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLkRUX1Jvd0lkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmlkID0gZGF0YS5EVF9Sb3dJZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLkRUX1Jvd0NsYXNzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgY2xhc3NlcyBhZGRlZCBieSBEVF9Sb3dDbGFzcyBiZWZvcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBkYXRhLkRUX1Jvd0NsYXNzLnNwbGl0KCcgJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fX3Jvd2MgPSByb3cuX19yb3djID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91bmlxdWUocm93Ll9fcm93Yy5jb25jYXQoYSkpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRyKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHJvdy5fX3Jvd2Muam9pbignICcpKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGRhdGEuRFRfUm93Q2xhc3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuRFRfUm93QXR0cikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRyKS5hdHRyKGRhdGEuRFRfUm93QXR0cik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5EVF9Sb3dEYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodHIpLmRhdGEoZGF0YS5EVF9Sb3dEYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ3JlYXRlIHRoZSBIVE1MIGhlYWRlciBmb3IgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkJ1aWxkSGVhZChvU2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpZW4sIGNlbGwsIHJvdywgY29sdW1uO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoZWFkID0gb1NldHRpbmdzLm5USGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0Zm9vdCA9IG9TZXR0aW5ncy5uVEZvb3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlSGVhZGVyID0gJCgndGgsIHRkJywgdGhlYWQpLmxlbmd0aCA9PT0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGVIZWFkZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSAkKCc8dHIvPicpLmFwcGVuZFRvKHRoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBjb2x1bW5zLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgPSAkKGNvbHVtbi5uVGgpLmFkZENsYXNzKGNvbHVtbi5zQ2xhc3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRlSGVhZGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuYXBwZW5kVG8ocm93KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEuMTEgbW92ZSBpbnRvIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLm9GZWF0dXJlcy5iU29ydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmFkZENsYXNzKGNvbHVtbi5zU29ydGluZ0NsYXNzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uYlNvcnRhYmxlICE9PSBmYWxzZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0YWJpbmRleCcsIG9TZXR0aW5ncy5pVGFiSW5kZXgpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBvU2V0dGluZ3Muc1RhYmxlSWQpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblNvcnRBdHRhY2hMaXN0ZW5lcihvU2V0dGluZ3MsIGNvbHVtbi5uVGgsIGkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNUaXRsZSAhPSBjZWxsLmh0bWwoKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmh0bWwoY29sdW1uLnNUaXRsZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5SZW5kZXJlcihvU2V0dGluZ3MsICdoZWFkZXInKShcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGVIZWFkZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5EZXRlY3RIZWFkZXIob1NldHRpbmdzLmFvSGVhZGVyLCB0aGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQVJJQSByb2xlIGZvciB0aGUgcm93cyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgJCh0aGVhZCkuZmluZCgnPnRyJykuYXR0cigncm9sZScsICdyb3cnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBEZWFsIHdpdGggdGhlIGZvb3RlciAtIGFkZCBjbGFzc2VzIGlmIHJlcXVpcmVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAkKHRoZWFkKS5maW5kKCc+dHI+dGgsID50cj50ZCcpLmFkZENsYXNzKGNsYXNzZXMuc0hlYWRlclRIKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICQodGZvb3QpLmZpbmQoJz50cj50aCwgPnRyPnRkJykuYWRkQ2xhc3MoY2xhc3Nlcy5zRm9vdGVyVEgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBmb290ZXIgY2VsbHMuIE5vdGUgdGhhdCB3ZSBvbmx5IHRha2UgdGhlIGNlbGxzIGZyb20gdGhlIGZpcnN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyByb3cgaW4gdGhlIGZvb3Rlci4gSWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSByb3cgdGhlIHVzZXIgd2FudHMgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGludGVyYWN0IHdpdGgsIHRoZXkgbmVlZCB0byB1c2UgdGhlIHRhYmxlKCkuZm9vdCgpIG1ldGhvZC4gTm90ZSBhbHNvIHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93cyBjZWxscyB0byBiZSB1c2VkIGZvciBtdWx0aXBsZSBjb2x1bW5zIHVzaW5nIGNvbHNwYW5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0Zm9vdCAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IG9TZXR0aW5ncy5hb0Zvb3RlclswXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY2VsbHMubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4ublRmID0gY2VsbHNbaV0uY2VsbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uc0NsYXNzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGNvbHVtbi5uVGYpLmFkZENsYXNzKGNvbHVtbi5zQ2xhc3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERyYXcgdGhlIGhlYWRlciAob3IgZm9vdGVyKSBlbGVtZW50IGJhc2VkIG9uIHRoZSBjb2x1bW4gdmlzaWJpbGl0eSBzdGF0ZXMuIFRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBtZXRob2RvbG9neSBoZXJlIGlzIHRvIHVzZSB0aGUgbGF5b3V0IGFycmF5IGZyb20gX2ZuRGV0ZWN0SGVhZGVyLCBtb2RpZmllZCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICogdGhlIGluc3RhbnRhbmVvdXMgY29sdW1uIHZpc2liaWxpdHksIHRvIGNvbnN0cnVjdCB0aGUgbmV3IGxheW91dC4gVGhlIGdyaWQgaXNcclxuXHQgICAgICAgICAgICAgICAgICogdHJhdmVyc2VkIG92ZXIgY2VsbCBhdCBhIHRpbWUgaW4gYSByb3dzIHggY29sdW1ucyBncmlkIGZhc2hpb24sIGFsdGhvdWdoIGVhY2hcclxuXHQgICAgICAgICAgICAgICAgICogY2VsbCBpbnNlcnQgY2FuIGNvdmVyIG11bHRpcGxlIGVsZW1lbnRzIGluIHRoZSBncmlkIC0gd2hpY2ggaXMgdHJhY2tzIHVzaW5nIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBhQXBwbGllZCBhcnJheS4gQ2VsbCBpbnNlcnRzIGluIHRoZSBncmlkIHdpbGwgb25seSBvY2N1ciB3aGVyZSB0aGVyZSBpc24ndFxyXG5cdCAgICAgICAgICAgICAgICAgKiBhbHJlYWR5IGEgY2VsbCBpbiB0aGF0IHBvc2l0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIGFycmF5IHtvYmplY3RzfSBhb1NvdXJjZSBMYXlvdXQgYXJyYXkgZnJvbSBfZm5EZXRlY3RIZWFkZXJcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gW2JJbmNsdWRlSGlkZGVuPWZhbHNlXSBJZiB0cnVlIHRoZW4gaW5jbHVkZSB0aGUgaGlkZGVuIGNvbHVtbnMgaW4gdGhlIGNhbGMsXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkRyYXdIZWFkKG9TZXR0aW5ncywgYW9Tb3VyY2UsIGJJbmNsdWRlSGlkZGVuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgbiwgbkxvY2FsVHI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYW9Mb2NhbCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFBcHBsaWVkID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaUNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpUm93c3BhbiwgaUNvbHNwYW47XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhb1NvdXJjZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYkluY2x1ZGVIaWRkZW4gPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJJbmNsdWRlSGlkZGVuID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogTWFrZSBhIGNvcHkgb2YgdGhlIG1hc3RlciBsYXlvdXQgYXJyYXksIGJ1dCB3aXRob3V0IHRoZSB2aXNpYmxlIGNvbHVtbnMgaW4gaXQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb1NvdXJjZS5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFvTG9jYWxbaV0gPSBhb1NvdXJjZVtpXS5zbGljZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFvTG9jYWxbaV0ublRyID0gYW9Tb3VyY2VbaV0ublRyO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBSZW1vdmUgYW55IGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBoaWRkZW4gKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBpQ29sdW1ucyAtIDEgOyBqID49IDAgOyBqLS0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvU2V0dGluZ3MuYW9Db2x1bW5zW2pdLmJWaXNpYmxlICYmICFiSW5jbHVkZUhpZGRlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW9Mb2NhbFtpXS5zcGxpY2UoaiwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFByZXAgdGhlIGFwcGxpZWQgYXJyYXkgLSBpdCBuZWVkcyBhbiBlbGVtZW50IGZvciBlYWNoIHJvdyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFBcHBsaWVkLnB1c2goW10pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb0xvY2FsLmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbkxvY2FsVHIgPSBhb0xvY2FsW2ldLm5UcjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQWxsIGNlbGxzIGFyZSBnb2luZyB0byBiZSByZXBsYWNlZCwgc28gZW1wdHkgb3V0IHRoZSByb3cgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobkxvY2FsVHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChuID0gbkxvY2FsVHIuZmlyc3RDaGlsZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5Mb2NhbFRyLnJlbW92ZUNoaWxkKG4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqTGVuID0gYW9Mb2NhbFtpXS5sZW5ndGggOyBqIDwgakxlbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUm93c3BhbiA9IDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDb2xzcGFuID0gMTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2VsbCAocm93L2NvbHNwYW4pIGNvdmVyaW5nIG91ciB0YXJnZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5zZXJ0IHBvaW50LiBJZiB0aGVyZSBpcywgdGhlbiB0aGVyZSBpcyBub3RoaW5nIHRvIGRvLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFBcHBsaWVkW2ldW2pdID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5Mb2NhbFRyLmFwcGVuZENoaWxkKGFvTG9jYWxbaV1bal0uY2VsbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQXBwbGllZFtpXVtqXSA9IDE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgcm93cyBhcyBuZWVkZWQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChhb0xvY2FsW2kgKyBpUm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb0xvY2FsW2ldW2pdLmNlbGwgPT0gYW9Mb2NhbFtpICsgaVJvd3NwYW5dW2pdLmNlbGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQXBwbGllZFtpICsgaVJvd3NwYW5dW2pdID0gMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUm93c3BhbisrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEV4cGFuZCB0aGUgY2VsbCB0byBjb3ZlciBhcyBtYW55IGNvbHVtbnMgYXMgbmVlZGVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW9Mb2NhbFtpXVtqICsgaUNvbHNwYW5dICE9PSB1bmRlZmluZWQgJiZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW9Mb2NhbFtpXVtqXS5jZWxsID09IGFvTG9jYWxbaV1baiArIGlDb2xzcGFuXS5jZWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogTXVzdCB1cGRhdGUgdGhlIGFwcGxpZWQgYXJyYXkgb3ZlciB0aGUgcm93cyBmb3IgdGhlIGNvbHVtbnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwIDsgayA8IGlSb3dzcGFuIDsgaysrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFBcHBsaWVkW2kgKyBrXVtqICsgaUNvbHNwYW5dID0gMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaUNvbHNwYW4rKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBEbyB0aGUgYWN0dWFsIGV4cGFuc2lvbiBpbiB0aGUgRE9NICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGFvTG9jYWxbaV1bal0uY2VsbClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncm93c3BhbicsIGlSb3dzcGFuKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjb2xzcGFuJywgaUNvbHNwYW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRHJhdyhvU2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFByb3ZpZGUgYSBwcmUtY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3IGlzIGZhbHNlIGlzIHJldHVybmVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYVByZURyYXcgPSBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCAnYW9QcmVEcmF3Q2FsbGJhY2snLCAncHJlRHJhdycsIFtvU2V0dGluZ3NdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoZmFsc2UsIGFQcmVEcmF3KSAhPT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShvU2V0dGluZ3MsIGZhbHNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGksIGlMZW4sIG47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYW5Sb3dzID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaVJvd0NvdW50ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhc1N0cmlwZUNsYXNzZXMgPSBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlTdHJpcGVzID0gYXNTdHJpcGVDbGFzc2VzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpT3BlblJvd3MgPSBvU2V0dGluZ3MuYW9PcGVuUm93cy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb0xhbmcgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlJbml0RGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJTZXJ2ZXJTaWRlID0gX2ZuRGF0YVNvdXJjZShvU2V0dGluZ3MpID09ICdzc3AnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmJEcmF3aW5nID0gdHJ1ZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBDaGVjayBhbmQgc2VlIGlmIHdlIGhhdmUgYW4gaW5pdGlhbCBkcmF3IHBvc2l0aW9uIGZyb20gc3RhdGUgc2F2aW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaUluaXREaXNwbGF5U3RhcnQgIT09IHVuZGVmaW5lZCAmJiBpSW5pdERpc3BsYXlTdGFydCAhPT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBiU2VydmVyU2lkZSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlJbml0RGlzcGxheVN0YXJ0IDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaUluaXREaXNwbGF5U3RhcnQgPj0gb1NldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlJbml0RGlzcGxheVN0YXJ0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSAtMTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaURpc3BsYXlTdGFydCA9IG9TZXR0aW5ncy5faURpc3BsYXlTdGFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpRGlzcGxheUVuZCA9IG9TZXR0aW5ncy5mbkRpc3BsYXlFbmQoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGRyYXcgaW50ZXJjZXB0ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLmJEZWZlckxvYWRpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYkRlZmVyTG9hZGluZyA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5pRHJhdysrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KG9TZXR0aW5ncywgZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWJTZXJ2ZXJTaWRlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmlEcmF3Kys7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb1NldHRpbmdzLmJEZXN0cm95aW5nICYmICFfZm5BamF4VXBkYXRlKG9TZXR0aW5ncykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFpRGlzcGxheS5sZW5ndGggIT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaVN0YXJ0ID0gYlNlcnZlclNpZGUgPyAwIDogaURpc3BsYXlTdGFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaUVuZCA9IGJTZXJ2ZXJTaWRlID8gb1NldHRpbmdzLmFvRGF0YS5sZW5ndGggOiBpRGlzcGxheUVuZDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGlTdGFydCA7IGogPCBpRW5kIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpRGF0YUluZGV4ID0gYWlEaXNwbGF5W2pdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YVtpRGF0YUluZGV4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFvRGF0YS5uVHIgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNyZWF0ZVRyKG9TZXR0aW5ncywgaURhdGFJbmRleCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuUm93ID0gYW9EYXRhLm5UcjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlbW92ZSB0aGUgb2xkIHN0cmlwaW5nIGNsYXNzZXMgYW5kIHRoZW4gYWRkIHRoZSBuZXcgb25lICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpU3RyaXBlcyAhPT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNTdHJpcGUgPSBhc1N0cmlwZUNsYXNzZXNbaVJvd0NvdW50ICUgaVN0cmlwZXNdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFvRGF0YS5fc1Jvd1N0cmlwZSAhPSBzU3RyaXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChuUm93KS5yZW1vdmVDbGFzcyhhb0RhdGEuX3NSb3dTdHJpcGUpLmFkZENsYXNzKHNTdHJpcGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFvRGF0YS5fc1Jvd1N0cmlwZSA9IHNTdHJpcGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdyBjYWxsYmFjayBmdW5jdGlvbnMgLSBtaWdodCB3YW50IHRvIG1hbmlwdWxhdGUgdGhlIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpUm93Q291bnQgYW5kIGogYXJlIG5vdCBjdXJyZW50bHkgZG9jdW1lbnRlZC4gQXJlIHRoZXkgYXQgYWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZWZ1bD9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25Sb3csIGFvRGF0YS5fYURhdGEsIGlSb3dDb3VudCwgal0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5Sb3dzLnB1c2goblJvdyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlSb3dDb3VudCsrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRhYmxlIGlzIGVtcHR5IC0gY3JlYXRlIGEgcm93IHdpdGggYW4gZW1wdHkgbWVzc2FnZSBpbiBpdCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzWmVybyA9IG9MYW5nLnNaZXJvUmVjb3JkcztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLmlEcmF3ID09IDEgJiYgX2ZuRGF0YVNvdXJjZShvU2V0dGluZ3MpID09ICdhamF4Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzWmVybyA9IG9MYW5nLnNMb2FkaW5nUmVjb3JkcztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob0xhbmcuc0VtcHR5VGFibGUgJiYgb1NldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCkgPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc1plcm8gPSBvTGFuZy5zRW1wdHlUYWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFuUm93c1swXSA9ICQoJzx0ci8+JywgeyAnY2xhc3MnOiBpU3RyaXBlcyA/IGFzU3RyaXBlQ2xhc3Nlc1swXSA6ICcnIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHRkIC8+Jywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbGlnbic6ICd0b3AnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbFNwYW4nOiBfZm5WaXNibGVDb2x1bW5zKG9TZXR0aW5ncyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBvU2V0dGluZ3Mub0NsYXNzZXMuc1Jvd0VtcHR5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmh0bWwoc1plcm8pKVswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBIZWFkZXIgYW5kIGZvb3RlciBjYWxsYmFja3MgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgJ2hlYWRlcicsIFskKG9TZXR0aW5ncy5uVEhlYWQpLmNoaWxkcmVuKCd0cicpWzBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkdldERhdGFNYXN0ZXIob1NldHRpbmdzKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheV0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgJ2Zvb3RlcicsIFskKG9TZXR0aW5ncy5uVEZvb3QpLmNoaWxkcmVuKCd0cicpWzBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkdldERhdGFNYXN0ZXIob1NldHRpbmdzKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheV0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gJChvU2V0dGluZ3MublRCb2R5KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgkKGFuUm93cykpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIENhbGwgYWxsIHJlcXVpcmVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGVuZCBvZiBhIGRyYXcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICdkcmF3JywgW29TZXR0aW5nc10pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIERyYXcgaXMgY29tcGxldGUsIHNvcnRpbmcgYW5kIGZpbHRlcmluZyBtdXN0IGJlIGFzIHdlbGwgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5iU29ydGVkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYkZpbHRlcmVkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYkRyYXdpbmcgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBSZWRyYXcgdGhlIHRhYmxlIC0gdGFraW5nIGFjY291bnQgb2YgdGhlIHZhcmlvdXMgZmVhdHVyZXMgd2hpY2ggYXJlIGVuYWJsZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gW2hvbGRQb3NpdGlvbl0gS2VlcCB0aGUgY3VycmVudCBwYWdpbmcgcG9zaXRpb24uIEJ5IGRlZmF1bHRcclxuXHQgICAgICAgICAgICAgICAgICogICAgdGhlIHBhZ2luZyBpcyByZXNldCB0byB0aGUgZmlyc3QgcGFnZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5SZURyYXcoc2V0dGluZ3MsIGhvbGRQb3NpdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydCA9IGZlYXR1cmVzLmJTb3J0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGZlYXR1cmVzLmJGaWx0ZXI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0KHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ29tcGxldGUoc2V0dGluZ3MsIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBmaWx0ZXJpbmcsIHNvIHdlIHdhbnQgdG8ganVzdCB1c2UgdGhlIGRpc3BsYXkgbWFzdGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWlEaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRQb3NpdGlvbiAhPT0gdHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBMZXQgYW55IG1vZHVsZXMga25vdyBhYm91dCB0aGUgZHJhdyBob2xkIHBvc2l0aW9uIHN0YXRlICh1c2VkIGJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxpbmcgaW50ZXJuYWxseSlcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9kcmF3SG9sZCA9IGhvbGRQb3NpdGlvbjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5fZHJhd0hvbGQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBZGQgdGhlIG9wdGlvbnMgdG8gdGhlIHBhZ2UgSFRNTCBmb3IgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkFkZE9wdGlvbnNIdG1sKG9TZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSAkKG9TZXR0aW5ncy5uVGFibGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhvbGRpbmcgPSAkKCc8ZGl2Lz4nKS5pbnNlcnRCZWZvcmUodGFibGUpOyAvLyBIb2xkaW5nIGVsZW1lbnQgZm9yIHNwZWVkXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBvU2V0dGluZ3Mub0ZlYXR1cmVzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBEYXRhVGFibGVzIGFyZSB3cmFwcGVkIGluIGEgZGl2XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gJCgnPGRpdi8+Jywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBvU2V0dGluZ3Muc1RhYmxlSWQgKyAnX3dyYXBwZXInLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IGNsYXNzZXMuc1dyYXBwZXIgKyAob1NldHRpbmdzLm5URm9vdCA/ICcnIDogJyAnICsgY2xhc3Nlcy5zTm9Gb290ZXIpXHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MubkhvbGRpbmcgPSBob2xkaW5nWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm5UYWJsZVdyYXBwZXIgPSBpbnNlcnRbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRhYmxlUmVpbnNlcnRCZWZvcmUgPSBvU2V0dGluZ3MublRhYmxlLm5leHRTaWJsaW5nO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIExvb3Agb3ZlciB0aGUgdXNlciBzZXQgcG9zaXRpb25pbmcgYW5kIHBsYWNlIHRoZSBlbGVtZW50cyBhcyBuZWVkZWQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhRG9tID0gb1NldHRpbmdzLnNEb20uc3BsaXQoJycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVOb2RlLCBjT3B0aW9uLCBuTmV3Tm9kZSwgY05leHQsIHNBdHRyLCBqO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYURvbS5sZW5ndGggOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY09wdGlvbiA9IGFEb21baV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjT3B0aW9uID09ICc8Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBOZXcgY29udGFpbmVyIGRpdiAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTmV3Tm9kZSA9ICQoJzxkaXYvPicpWzBdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBhcHBlbmQgYW4gaWQgYW5kL29yIGEgY2xhc3MgbmFtZSB0byB0aGUgY29udGFpbmVyICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNOZXh0ID0gYURvbVtpICsgMV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjTmV4dCA9PSBcIidcIiB8fCBjTmV4dCA9PSAnXCInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzQXR0ciA9IFwiXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChhRG9tW2kgKyBqXSAhPSBjTmV4dCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNBdHRyICs9IGFEb21baSArIGpdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBSZXBsYWNlIGpRdWVyeSBVSSBjb25zdGFudHMgQHRvZG8gZGVwcmVjaWF0ZWQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzQXR0ciA9PSBcIkhcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNBdHRyID0gY2xhc3Nlcy5zSlVJSGVhZGVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc0F0dHIgPT0gXCJGXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzQXR0ciA9IGNsYXNzZXMuc0pVSUZvb3RlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgYXR0cmlidXRlIGNhbiBiZSBpbiB0aGUgZm9ybWF0IG9mIFwiI2lkLmNsYXNzXCIsIFwiI2lkXCIgb3IgXCJjbGFzc1wiIFRoaXMgbG9naWNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGJyZWFrcyB0aGUgc3RyaW5nIGludG8gcGFydHMgYW5kIGFwcGxpZXMgdGhlbSBhcyBuZWVkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNBdHRyLmluZGV4T2YoJy4nKSAhPSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhU3BsaXQgPSBzQXR0ci5zcGxpdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5OZXdOb2RlLmlkID0gYVNwbGl0WzBdLnN1YnN0cigxLCBhU3BsaXRbMF0ubGVuZ3RoIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk5ld05vZGUuY2xhc3NOYW1lID0gYVNwbGl0WzFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc0F0dHIuY2hhckF0KDApID09IFwiI1wiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk5ld05vZGUuaWQgPSBzQXR0ci5zdWJzdHIoMSwgc0F0dHIubGVuZ3RoIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTmV3Tm9kZS5jbGFzc05hbWUgPSBzQXR0cjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IGo7IC8qIE1vdmUgYWxvbmcgdGhlIHBvc2l0aW9uIGFycmF5ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydC5hcHBlbmQobk5ld05vZGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSAkKG5OZXdOb2RlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAnPicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogRW5kIGNvbnRhaW5lciBkaXYgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gaW5zZXJ0LnBhcmVudCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gTW92ZSBvcHRpb25zIGludG8gdGhlaXIgb3duIHBsdWdpbnM/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAnbCcgJiYgZmVhdHVyZXMuYlBhZ2luYXRlICYmIGZlYXR1cmVzLmJMZW5ndGhDaGFuZ2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogTGVuZ3RoICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxMZW5ndGgob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAnZicgJiYgZmVhdHVyZXMuYkZpbHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBGaWx0ZXIgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbEZpbHRlcihvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICdyJyAmJiBmZWF0dXJlcy5iUHJvY2Vzc2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBwUm9jZXNzaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJ3QnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRhYmxlICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxUYWJsZShvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICdpJyAmJiBmZWF0dXJlcy5iSW5mbykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJbmZvICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxJbmZvKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJ3AnICYmIGZlYXR1cmVzLmJQYWdpbmF0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBQYWdpbmF0aW9uICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZShvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChEYXRhVGFibGUuZXh0LmZlYXR1cmUubGVuZ3RoICE9PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFBsdWctaW4gZmVhdHVyZXMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFvRmVhdHVyZXMgPSBEYXRhVGFibGUuZXh0LmZlYXR1cmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwLCBrTGVuID0gYW9GZWF0dXJlcy5sZW5ndGggOyBrIDwga0xlbiA7IGsrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNPcHRpb24gPT0gYW9GZWF0dXJlc1trXS5jRmVhdHVyZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gYW9GZWF0dXJlc1trXS5mbkluaXQob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQWRkIHRvIHRoZSAyRCBmZWF0dXJlcyBhcnJheSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTm9kZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWFuRmVhdHVyZXMgPSBvU2V0dGluZ3MuYWFuRmVhdHVyZXM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFhbkZlYXR1cmVzW2NPcHRpb25dKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYW5GZWF0dXJlc1tjT3B0aW9uXSA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYW5GZWF0dXJlc1tjT3B0aW9uXS5wdXNoKGZlYXR1cmVOb2RlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0LmFwcGVuZChmZWF0dXJlTm9kZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEJ1aWx0IG91ciBET00gc3RydWN0dXJlIC0gcmVwbGFjZSB0aGUgaG9sZGluZyBkaXYgd2l0aCB3aGF0IHdlIHdhbnQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGhvbGRpbmcucmVwbGFjZVdpdGgoaW5zZXJ0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBVc2UgdGhlIERPTSBzb3VyY2UgdG8gY3JlYXRlIHVwIGFuIGFycmF5IG9mIGhlYWRlciBjZWxscy4gVGhlIGlkZWEgaGVyZSBpcyB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiBjcmVhdGUgYSBsYXlvdXQgZ3JpZCAoYXJyYXkpIG9mIHJvd3MgeCBjb2x1bW5zLCB3aGljaCBjb250YWlucyBhIHJlZmVyZW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgKiB0byB0aGUgY2VsbCB0aGF0IHRoYXQgcG9pbnQgaW4gdGhlIGdyaWQgKHJlZ2FyZGxlc3Mgb2YgY29sL3Jvd3NwYW4pLCBzdWNoIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICogYW55IGNvbHVtbiAvIHJvdyBjb3VsZCBiZSByZW1vdmVkIGFuZCB0aGUgbmV3IGdyaWQgY29uc3RydWN0ZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSBhcnJheSB7b2JqZWN0fSBhTGF5b3V0IEFycmF5IHRvIHN0b3JlIHRoZSBjYWxjdWxhdGVkIGxheW91dCBpblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVGhlYWQgVGhlIGhlYWRlci9mb290ZXIgZWxlbWVudCBmb3IgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkRldGVjdEhlYWRlcihhTGF5b3V0LCBuVGhlYWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuVHJzID0gJChuVGhlYWQpLmNoaWxkcmVuKCd0cicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5UciwgbkNlbGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaywgbCwgaUxlbiwgakxlbiwgaUNvbFNoaWZ0ZWQsIGlDb2x1bW4sIGlDb2xzcGFuLCBpUm93c3BhbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBiVW5pcXVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZuU2hpZnRDb2wgPSBmdW5jdGlvbiAoYSwgaSwgaikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gYVtpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoa1tqXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBhTGF5b3V0LnNwbGljZSgwLCBhTGF5b3V0Lmxlbmd0aCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogV2Uga25vdyBob3cgbWFueSByb3dzIHRoZXJlIGFyZSBpbiB0aGUgbGF5b3V0IC0gc28gcHJlcCBpdCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IG5UcnMubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhTGF5b3V0LnB1c2goW10pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIENhbGN1bGF0ZSBhIGxheW91dCBhcnJheSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IG5UcnMubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuVHIgPSBuVHJzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlDb2x1bW4gPSAwO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBGb3IgZXZlcnkgY2VsbCBpbiB0aGUgcm93Li4uICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbkNlbGwgPSBuVHIuZmlyc3RDaGlsZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobkNlbGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJURFwiIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbkNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSBcIlRIXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEdldCB0aGUgY29sIGFuZCByb3dzcGFuIGF0dHJpYnV0ZXMgZnJvbSB0aGUgRE9NIGFuZCBzYW5pdGlzZSB0aGVtICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpQ29sc3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgnY29sc3BhbicpICogMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlSb3dzcGFuID0gbkNlbGwuZ2V0QXR0cmlidXRlKCdyb3dzcGFuJykgKiAxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaUNvbHNwYW4gPSAoIWlDb2xzcGFuIHx8IGlDb2xzcGFuID09PSAwIHx8IGlDb2xzcGFuID09PSAxKSA/IDEgOiBpQ29sc3BhbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlSb3dzcGFuID0gKCFpUm93c3BhbiB8fCBpUm93c3BhbiA9PT0gMCB8fCBpUm93c3BhbiA9PT0gMSkgPyAxIDogaVJvd3NwYW47XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlcmUgbWlnaHQgYmUgY29sc3BhbiBjZWxscyBhbHJlYWR5IGluIHRoaXMgcm93LCBzbyBzaGlmdCBvdXIgdGFyZ2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBhY2NvcmRpbmdseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpQ29sU2hpZnRlZCA9IGZuU2hpZnRDb2woYUxheW91dCwgaSwgaUNvbHVtbik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2FjaGUgY2FsY3VsYXRpb24gZm9yIHVuaXF1ZSBjb2x1bW5zICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiVW5pcXVlID0gaUNvbHNwYW4gPT09IDEgPyB0cnVlIDogZmFsc2U7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlcmUgaXMgY29sIC8gcm93c3BhbiwgY29weSB0aGUgaW5mb3JtYXRpb24gaW50byB0aGUgbGF5b3V0IGdyaWQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDAgOyBsIDwgaUNvbHNwYW4gOyBsKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwIDsgayA8IGlSb3dzcGFuIDsgaysrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFMYXlvdXRbaSArIGtdW2lDb2xTaGlmdGVkICsgbF0gPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNlbGxcIjogbkNlbGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVuaXF1ZVwiOiBiVW5pcXVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFMYXlvdXRbaSArIGtdLm5UciA9IG5UcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbkNlbGwgPSBuQ2VsbC5uZXh0U2libGluZztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IGFuIGFycmF5IG9mIHVuaXF1ZSB0aCBlbGVtZW50cywgb25lIGZvciBlYWNoIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuSGVhZGVyIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBsYXlvdXQgZnJvbSB0aGlzIG5vZGUgLSBvcHRpb25hbFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gYUxheW91dCB0aGVhZC90Zm9vdCBsYXlvdXQgZnJvbSBfZm5EZXRlY3RIZWFkZXIgLSBvcHRpb25hbFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMgYXJyYXkge25vZGV9IGFSZXR1cm4gbGlzdCBvZiB1bmlxdWUgdGgnc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5HZXRVbmlxdWVUaHMob1NldHRpbmdzLCBuSGVhZGVyLCBhTGF5b3V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYVJldHVybiA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhTGF5b3V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYUxheW91dCA9IG9TZXR0aW5ncy5hb0hlYWRlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobkhlYWRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTGF5b3V0ID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRldGVjdEhlYWRlcihhTGF5b3V0LCBuSGVhZGVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBhTGF5b3V0Lmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBhTGF5b3V0W2ldLmxlbmd0aCA7IGogPCBqTGVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhTGF5b3V0W2ldW2pdLnVuaXF1ZSAmJlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICghYVJldHVybltqXSB8fCAhb1NldHRpbmdzLmJTb3J0Q2VsbHNUb3ApKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhUmV0dXJuW2pdID0gYUxheW91dFtpXVtqXS5jZWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhUmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ3JlYXRlIGFuIEFqYXggY2FsbCBiYXNlZCBvbiB0aGUgdGFibGUncyBzZXR0aW5ncywgdGFraW5nIGludG8gYWNjb3VudCB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAqIHBhcmFtZXRlcnMgY2FuIGhhdmUgbXVsdGlwbGUgZm9ybXMsIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyLCByZXF1aXJlZCBieVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgRGF0YVRhYmxlcyAtIG1heSBiZSBhdWdtZW50ZWQgYnkgZGV2ZWxvcGVyIGNhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiBkYXRhIGlzIG9idGFpbmVkXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5CdWlsZEFqYXgob1NldHRpbmdzLCBkYXRhLCBmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGF0aWJpbGl0eSB3aXRoIDEuOS0sIGFsbG93IGZuU2VydmVyRGF0YSBhbmQgZXZlbnQgdG8gbWFuaXB1bGF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgJ2FvU2VydmVyUGFyYW1zJywgJ3NlcnZlclBhcmFtcycsIFtkYXRhXSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBvYmplY3QgYmFzZWQgZm9yIDEuMTArIGlmIHVzaW5nIHRoZSBvbGQgYXJyYXkgc2NoZW1lIHdoaWNoIGNhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gY29tZSBmcm9tIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgb3Igc2VydmVyUGFyYW1zXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiAkLmlzQXJyYXkoZGF0YSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0ge307XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJicmFja2V0ID0gLyguKj8pXFxbXFxdJC87XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdmFsLm5hbWUubWF0Y2gocmJyYWNrZXQpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGZvciBhcnJheXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbWF0Y2hbMF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0bXBbbmFtZV0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBbbmFtZV0gPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFtuYW1lXS5wdXNoKHZhbC52YWx1ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBbdmFsLm5hbWVdID0gdmFsLnZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRtcDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYWpheERhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYWpheCA9IG9TZXR0aW5ncy5hamF4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gb1NldHRpbmdzLm9JbnN0YW5jZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChqc29uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIGpzb24sIG9TZXR0aW5ncy5qcVhIUl0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZuKGpzb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGFqYXgpICYmIGFqYXguZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhEYXRhID0gYWpheC5kYXRhO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9ICQuaXNGdW5jdGlvbihhamF4RGF0YSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhamF4RGF0YShkYXRhLCBvU2V0dGluZ3MpIDogIC8vIGZuIGNhbiBtYW5pcHVsYXRlIGRhdGEgb3IgcmV0dXJuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhEYXRhOyAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBvYmplY3Qgb2JqZWN0IG9yIGFycmF5IHRvIG1lcmdlXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcsIHVzZSB0aGF0IGFsb25lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICQuaXNGdW5jdGlvbihhamF4RGF0YSkgJiYgbmV3RGF0YSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGEgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBkYXRhLCBuZXdEYXRhKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBkYXRhIHByb3BlcnR5IGFzIHdlJ3ZlIHJlc29sdmVkIGl0IGFscmVhZHkgYW5kIGRvbid0IHdhbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkgdG8gZG8gaXQgYWdhaW4gKGl0IGlzIHJlc3RvcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhamF4LmRhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VBamF4ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YVwiOiBkYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic3VjY2Vzc1wiOiBmdW5jdGlvbiAoanNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBqc29uLmVycm9yIHx8IGpzb24uc0Vycm9yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxvZyhvU2V0dGluZ3MsIDAsIGVycm9yKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmpzb24gPSBqc29uO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhqc29uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YVR5cGVcIjogXCJqc29uXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJjYWNoZVwiOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogb1NldHRpbmdzLnNTZXJ2ZXJNZXRob2QsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJlcnJvclwiOiBmdW5jdGlvbiAoeGhyLCBlcnJvciwgdGhyb3duKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCBudWxsLCAneGhyJywgW29TZXR0aW5ncywgbnVsbCwgb1NldHRpbmdzLmpxWEhSXSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KHRydWUsIHJldCkgPT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPT0gXCJwYXJzZXJlcnJvclwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKG9TZXR0aW5ncywgMCwgJ0ludmFsaWQgSlNPTiByZXNwb25zZScsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2cob1NldHRpbmdzLCAwLCAnQWpheCBlcnJvcicsIDcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShvU2V0dGluZ3MsIGZhbHNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBkYXRhIHN1Ym1pdHRlZCBmb3IgdGhlIEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm9BamF4RGF0YSA9IGRhdGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgcGx1Zy1pbnMgYW5kIGV4dGVybmFsIHByb2Nlc3NlcyB0byBtb2RpZnkgdGhlIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsIG51bGwsICdwcmVYaHInLCBbb1NldHRpbmdzLCBkYXRhXSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5mblNlcnZlckRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5mblNlcnZlckRhdGEuY2FsbChpbnN0YW5jZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLnNBamF4U291cmNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLm1hcChkYXRhLCBmdW5jdGlvbiAodmFsLCBrZXkpIHsgLy8gTmVlZCB0byBjb252ZXJ0IGJhY2sgdG8gMS45IHRyYWQgZm9ybWF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBrZXksIHZhbHVlOiB2YWwgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob1NldHRpbmdzLnNBamF4U291cmNlIHx8IHR5cGVvZiBhamF4ID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmlsaXR5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCQuZXh0ZW5kKGJhc2VBamF4LCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYWpheCB8fCBvU2V0dGluZ3Muc0FqYXhTb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgkLmlzRnVuY3Rpb24oYWpheCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyBhIGZ1bmN0aW9uIC0gbGV0IHRoZSBjYWxsZXIgZGVmaW5lIHdoYXQgbmVlZHMgdG8gYmUgZG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5qcVhIUiA9IGFqYXguY2FsbChpbnN0YW5jZSwgZGF0YSwgY2FsbGJhY2ssIG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3QgdG8gZXh0ZW5kIHRoZSBiYXNlIHNldHRpbmdzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCQuZXh0ZW5kKGJhc2VBamF4LCBhamF4KSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgZm9yIG5leHQgdGltZSBhcm91bmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhamF4LmRhdGEgPSBhamF4RGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBVcGRhdGUgdGhlIHRhYmxlIHVzaW5nIGFuIEFqYXggY2FsbFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gQmxvY2sgdGhlIHRhYmxlIGRyYXdpbmcgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGUoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5iQWpheERhdGFHZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5pRHJhdysrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCB0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQnVpbGRBamF4KFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWpheFBhcmFtZXRlcnMoc2V0dGluZ3MpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoanNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWpheFVwZGF0ZURyYXcoc2V0dGluZ3MsIGpzb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQnVpbGQgdXAgdGhlIHBhcmFtZXRlcnMgaW4gYW4gb2JqZWN0IG5lZWRlZCBmb3IgYSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqIHJlcXVlc3QuIE5vdGUgdGhhdCB0aGlzIGlzIGJhc2ljYWxseSBkb25lIHR3aWNlLCBpcyBkaWZmZXJlbnQgd2F5cyAtIGEgbW9kZXJuXHJcblx0ICAgICAgICAgICAgICAgICAqIG1ldGhvZCB3aGljaCBpcyB1c2VkIGJ5IGRlZmF1bHQgaW4gRGF0YVRhYmxlcyAxLjEwIHdoaWNoIHVzZXMgb2JqZWN0cyBhbmRcclxuXHQgICAgICAgICAgICAgICAgICogYXJyYXlzLCBvciB0aGUgMS45LSBtZXRob2Qgd2l0aCBpcyBuYW1lIC8gdmFsdWUgcGFpcnMuIDEuOSBtZXRob2QgaXMgdXNlZCBpZlxyXG5cdCAgICAgICAgICAgICAgICAgKiB0aGUgc0FqYXhTb3VyY2Ugb3B0aW9uIGlzIHVzZWQgaW4gdGhlIGluaXRpYWxpc2F0aW9uLCBvciB0aGUgbGVnYWN5QWpheFxyXG5cdCAgICAgICAgICAgICAgICAgKiBvcHRpb24gaXMgc2V0LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2x9IGJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BamF4UGFyYW1ldGVycyhzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByZVNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmVDb2xTZWFyY2ggPSBzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSwgZGF0YSA9IFtdLCBkYXRhUHJvcCwgY29sdW1uLCBjb2x1bW5TZWFyY2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydCA9IF9mblNvcnRGbGF0dGVuKHNldHRpbmdzKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5U3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TGVuZ3RoID0gZmVhdHVyZXMuYlBhZ2luYXRlICE9PSBmYWxzZSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaCh7ICduYW1lJzogbmFtZSwgJ3ZhbHVlJzogdmFsdWUgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmxlIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ3NFY2hvJywgc2V0dGluZ3MuaURyYXcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2lDb2x1bW5zJywgY29sdW1uQ291bnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ3NDb2x1bW5zJywgX3BsdWNrKGNvbHVtbnMsICdzTmFtZScpLmpvaW4oJywnKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbSgnaURpc3BsYXlTdGFydCcsIGRpc3BsYXlTdGFydCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbSgnaURpc3BsYXlMZW5ndGgnLCBkaXNwbGF5TGVuZ3RoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVzIDEuMTArIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZHJhdzogc2V0dGluZ3MuaURyYXcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uczogW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXI6IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkaXNwbGF5U3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBkaXNwbGF5TGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcHJlU2VhcmNoLnNTZWFyY2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBwcmVTZWFyY2guYlJlZ2V4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IGNvbHVtbkNvdW50IDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TZWFyY2ggPSBwcmVDb2xTZWFyY2hbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVByb3AgPSB0eXBlb2YgY29sdW1uLm1EYXRhID09IFwiZnVuY3Rpb25cIiA/ICdmdW5jdGlvbicgOiBjb2x1bW4ubURhdGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGQuY29sdW1ucy5wdXNoKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVByb3AsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbHVtbi5zTmFtZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoYWJsZTogY29sdW1uLmJTZWFyY2hhYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmFibGU6IGNvbHVtbi5iU29ydGFibGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaDoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbHVtblNlYXJjaC5zU2VhcmNoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXg6IGNvbHVtblNlYXJjaC5iUmVnZXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbShcIm1EYXRhUHJvcF9cIiArIGksIGRhdGFQcm9wKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJGaWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ3NTZWFyY2hfJyArIGksIGNvbHVtblNlYXJjaC5zU2VhcmNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2JSZWdleF8nICsgaSwgY29sdW1uU2VhcmNoLmJSZWdleCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtKCdiU2VhcmNoYWJsZV8nICsgaSwgY29sdW1uLmJTZWFyY2hhYmxlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iU29ydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSgnYlNvcnRhYmxlXycgKyBpLCBjb2x1bW4uYlNvcnRhYmxlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJGaWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSgnc1NlYXJjaCcsIHByZVNlYXJjaC5zU2VhcmNoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSgnYlJlZ2V4JywgcHJlU2VhcmNoLmJSZWdleCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJTb3J0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNvcnQsIGZ1bmN0aW9uIChpLCB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5vcmRlci5wdXNoKHsgY29sdW1uOiB2YWwuY29sLCBkaXI6IHZhbC5kaXIgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSgnaVNvcnRDb2xfJyArIGksIHZhbC5jb2wpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSgnc1NvcnREaXJfJyArIGksIHZhbC5kaXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSgnaVNvcnRpbmdDb2xzJywgc29ydC5sZW5ndGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsZWdhY3kuYWpheCBwYXJhbWV0ZXIgaXMgbnVsbCwgdGhlbiB3ZSBhdXRvbWF0aWNhbGx5IGRlY2lkZSB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9ybSB0byB1c2UsIGJhc2VkIG9uIHNBamF4U291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGVnYWN5ID0gRGF0YVRhYmxlLmV4dC5sZWdhY3kuYWpheDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChsZWdhY3kgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muc0FqYXhTb3VyY2UgPyBkYXRhIDogZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGxlZ2FjeSBoYXMgYmVlbiBzcGVjaWZpZWQgdGhlbiB3ZSB1c2UgdGhhdCB0byBkZWNpZGUgb24gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBmb3JtXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVnYWN5ID8gZGF0YSA6IGQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YSB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgKG51a2luZyB0aGUgb2xkKSBhbmQgcmVkcmF3IHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24ganNvbiBkYXRhIHJldHVybiBmcm9tIHRoZSBzZXJ2ZXIuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30ganNvbi5zRWNobyBUcmFja2luZyBmbGFnIGZvciBEYXRhVGFibGVzIHRvIG1hdGNoIHJlcXVlc3RzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgbm90IGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsRGlzcGxheVJlY29yZHMgTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc2V0LCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGpzb24uYWFEYXRhIFRoZSBkYXRhIHRvIGRpc3BsYXkgb24gdGhpcyBwYWdlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW2pzb24uc0NvbHVtbnNdIENvbHVtbiBvcmRlcmluZyAoc05hbWUsIGNvbW1hIHNlcGFyYXRlZClcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZURyYXcoc2V0dGluZ3MsIGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHYxLjEwIHVzZXMgY2FtZWxDYXNlIHZhcmlhYmxlcywgd2hpbGUgMS45IHVzZXMgSHVuZ2FyaWFuIG5vdGF0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBib3RoXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGF0ID0gZnVuY3Rpb24gKG9sZCwgbW9kZXJuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpzb25bb2xkXSAhPT0gdW5kZWZpbmVkID8ganNvbltvbGRdIDoganNvblttb2Rlcm5dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKHNldHRpbmdzLCBqc29uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkcmF3ID0gY29tcGF0KCdzRWNobycsICdkcmF3Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3Jkc1RvdGFsID0gY29tcGF0KCdpVG90YWxSZWNvcmRzJywgJ3JlY29yZHNUb3RhbCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZHNGaWx0ZXJlZCA9IGNvbXBhdCgnaVRvdGFsRGlzcGxheVJlY29yZHMnLCAncmVjb3Jkc0ZpbHRlcmVkJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3Qgb3V0IG9mIHNlcXVlbmNlIHJldHVybnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHJhdyAqIDEgPCBzZXR0aW5ncy5pRHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmlEcmF3ID0gZHJhdyAqIDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2xlYXJUYWJsZShzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faVJlY29yZHNUb3RhbCA9IHBhcnNlSW50KHJlY29yZHNUb3RhbCwgMTApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA9IHBhcnNlSW50KHJlY29yZHNGaWx0ZXJlZCwgMTApO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBkYXRhLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGREYXRhKHNldHRpbmdzLCBkYXRhW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmJBamF4RGF0YUdldCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRHJhdyhzZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkluaXRDb21wbGV0ZShzZXR0aW5ncywganNvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYkFqYXhEYXRhR2V0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCBmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IHRoZSBkYXRhIGZyb20gdGhlIEpTT04gZGF0YSBzb3VyY2UgdG8gdXNlIGZvciBkcmF3aW5nIGEgdGFibGUuIFVzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqIGBfZm5HZXRPYmplY3REYXRhRm5gIGFsbG93cyB0aGUgZGF0YSB0byBiZSBzb3VyY2VkIGZyb20gYSBwcm9wZXJ0eSBvZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogc291cmNlIG9iamVjdCwgb3IgZnJvbSBhIHByb2Nlc3NpbmcgZnVuY3Rpb24uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0gIHtvYmplY3R9IGpzb24gRGF0YSBzb3VyY2Ugb2JqZWN0IC8gYXJyYXkgZnJvbSB0aGUgc2VydmVyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgZGF0YSB0byB1c2VcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkFqYXhEYXRhU3JjKG9TZXR0aW5ncywganNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFTcmMgPSAkLmlzUGxhaW5PYmplY3Qob1NldHRpbmdzLmFqYXgpICYmIG9TZXR0aW5ncy5hamF4LmRhdGFTcmMgIT09IHVuZGVmaW5lZCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmFqYXguZGF0YVNyYyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLnNBamF4RGF0YVByb3A7IC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLlxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLiBJbiBvcmRlciB0byByZWFkIGZyb20gYWFEYXRhLCBjaGVjayBpZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgaGFzIGJlZW4gY2hhbmdlZCwgaWYgbm90LCBjaGVjayBmb3IgYWFEYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVNyYyA9PT0gJ2RhdGEnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpzb24uYWFEYXRhIHx8IGpzb25bZGF0YVNyY107XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFTcmMgIT09IFwiXCIgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkdldE9iamVjdERhdGFGbihkYXRhU3JjKShqc29uKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganNvbjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciBmaWx0ZXJpbmcgdGV4dFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IEZpbHRlciBjb250cm9sIGVsZW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVJZCA9IHNldHRpbmdzLnNUYWJsZUlkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gc2V0dGluZ3Mub0xhbmd1YWdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXQgPSAnPGlucHV0IHR5cGU9XCJzZWFyY2hcIiBjbGFzcz1cIicgKyBjbGFzc2VzLnNGaWx0ZXJJbnB1dCArICdcIi8+JztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gbGFuZ3VhZ2Uuc1NlYXJjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5tYXRjaCgvX0lOUFVUXy8pID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHIucmVwbGFjZSgnX0lOUFVUXycsIGlucHV0KSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyICsgaW5wdXQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9ICQoJzxkaXYvPicsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiAhZmVhdHVyZXMuZiA/IHRhYmxlSWQgKyAnX2ZpbHRlcicgOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IGNsYXNzZXMuc0ZpbHRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxsYWJlbC8+JykuYXBwZW5kKHN0cikpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hGbiA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBVcGRhdGUgYWxsIG90aGVyIGZpbHRlciBpbnB1dCBlbGVtZW50cyBmb3IgdGhlIG5ldyBkaXNwbGF5ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBmZWF0dXJlcy5mO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSAhdGhpcy52YWx1ZSA/IFwiXCIgOiB0aGlzLnZhbHVlOyAvLyBtZW50YWwgSUU4IGZpeCA6LShcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogTm93IGRvIHRoZSBmaWx0ZXIgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsICE9IHByZXZpb3VzU2VhcmNoLnNTZWFyY2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ29tcGxldGUoc2V0dGluZ3MsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic1NlYXJjaFwiOiB2YWwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJSZWdleFwiOiBwcmV2aW91c1NlYXJjaC5iUmVnZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJTbWFydFwiOiBwcmV2aW91c1NlYXJjaC5iU21hcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJDYXNlSW5zZW5zaXRpdmVcIjogcHJldmlvdXNTZWFyY2guYkNhc2VJbnNlbnNpdGl2ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gcmVkcmF3LCB3aXRob3V0IHJlc29ydGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlYXJjaERlbGF5ID0gc2V0dGluZ3Muc2VhcmNoRGVsYXkgIT09IG51bGwgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNlYXJjaERlbGF5IDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5EYXRhU291cmNlKHNldHRpbmdzKSA9PT0gJ3NzcCcgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICA0MDAgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBqcUZpbHRlciA9ICQoJ2lucHV0JywgZmlsdGVyKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC52YWwocHJldmlvdXNTZWFyY2guc1NlYXJjaClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncGxhY2Vob2xkZXInLCBsYW5ndWFnZS5zU2VhcmNoUGxhY2Vob2xkZXIpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmJpbmQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICdrZXl1cC5EVCBzZWFyY2guRFQgaW5wdXQuRFQgcGFzdGUuRFQgY3V0LkRUJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoRGVsYXkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuVGhyb3R0bGUoc2VhcmNoRm4sIHNlYXJjaERlbGF5KSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hGblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYmluZCgna2V5cHJlc3MuRFQnLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBQcmV2ZW50IGZvcm0gc3VibWlzc2lvbiAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgdGFibGVJZCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBlbGVtZW50cyB3aGVuZXZlciB0aGUgdGFibGUgaXMgZmlsdGVyZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS5vbignc2VhcmNoLmR0LkRUJywgZnVuY3Rpb24gKGV2LCBzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzID09PSBzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanFGaWx0ZXJbMF0gIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcUZpbHRlci52YWwocHJldmlvdXNTZWFyY2guc1NlYXJjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJbMF07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRmlsdGVyIHRoZSB0YWJsZSB1c2luZyBib3RoIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBjb2x1bW4gYmFzZWQgZmlsdGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NlYXJjaCBzZWFyY2ggaW5mb3JtYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBbaUZvcmNlXSBmb3JjZSBhIHJlc2VhcmNoIG9mIHRoZSBtYXN0ZXIgYXJyYXkgKDEpIG9yIG5vdCAodW5kZWZpbmVkIG9yIDApXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlckNvbXBsZXRlKG9TZXR0aW5ncywgb0lucHV0LCBpRm9yY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYW9QcmV2U2VhcmNoID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmblNhdmVGaWx0ZXIgPSBmdW5jdGlvbiAob0ZpbHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNhdmUgdGhlIGZpbHRlcmluZyB2YWx1ZXMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvUHJldlNlYXJjaC5zU2VhcmNoID0gb0ZpbHRlci5zU2VhcmNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9QcmV2U2VhcmNoLmJSZWdleCA9IG9GaWx0ZXIuYlJlZ2V4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9QcmV2U2VhcmNoLmJTbWFydCA9IG9GaWx0ZXIuYlNtYXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9QcmV2U2VhcmNoLmJDYXNlSW5zZW5zaXRpdmUgPSBvRmlsdGVyLmJDYXNlSW5zZW5zaXRpdmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZuUmVnZXggPSBmdW5jdGlvbiAobykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGJFc2NhcGVSZWdleCBvcHRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5iRXNjYXBlUmVnZXggIT09IHVuZGVmaW5lZCA/ICFvLmJFc2NhcGVSZWdleCA6IG8uYlJlZ2V4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIGFueSBjb2x1bW4gdHlwZXMgdGhhdCBhcmUgdW5rbm93biBkdWUgdG8gYWRkaXRpb24gb3IgaW52YWxpZGF0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbyBBcyBwZXIgc29ydCAtIGNhbiB0aGlzIGJlIG1vdmVkIGludG8gYW4gZXZlbnQgaGFuZGxlcj9cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtblR5cGVzKG9TZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBhbGwgZmlsdGVyaW5nIGlzIGRvbmUgYnkgdGhlIHNlcnZlciwgc28gbm8gcG9pbnQgaGFuZ2luZyBhcm91bmQgaGVyZSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSAhPSAnc3NwJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEdsb2JhbCBmaWx0ZXIgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXIob1NldHRpbmdzLCBvSW5wdXQuc1NlYXJjaCwgaUZvcmNlLCBmblJlZ2V4KG9JbnB1dCksIG9JbnB1dC5iU21hcnQsIG9JbnB1dC5iQ2FzZUluc2Vuc2l0aXZlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmblNhdmVGaWx0ZXIob0lucHV0KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogTm93IGRvIHRoZSBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXIgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBhb1ByZXZTZWFyY2gubGVuZ3RoIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckNvbHVtbihvU2V0dGluZ3MsIGFvUHJldlNlYXJjaFtpXS5zU2VhcmNoLCBpLCBmblJlZ2V4KGFvUHJldlNlYXJjaFtpXSksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb1ByZXZTZWFyY2hbaV0uYlNtYXJ0LCBhb1ByZXZTZWFyY2hbaV0uYkNhc2VJbnNlbnNpdGl2ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDdXN0b20gZmlsdGVyaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ3VzdG9tKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmblNhdmVGaWx0ZXIob0lucHV0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHdlIGhhdmUgYmVlbiBmaWx0ZXJpbmcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5iRmlsdGVyZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtvU2V0dGluZ3NdKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBcHBseSBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJDdXN0b20oc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJzID0gRGF0YVRhYmxlLmV4dC5zZWFyY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcGxheVJvd3MgPSBzZXR0aW5ncy5haURpc3BsYXk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93LCByb3dJZHg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGZpbHRlcnMubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb3Agb3ZlciBlYWNoIHJvdyBhbmQgc2VlIGlmIGl0IHNob3VsZCBiZSBpbmNsdWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqZW4gPSBkaXNwbGF5Um93cy5sZW5ndGggOyBqIDwgamVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd0lkeCA9IGRpc3BsYXlSb3dzW2pdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzW2ldKHNldHRpbmdzLCByb3cuX2FGaWx0ZXJEYXRhLCByb3dJZHgsIHJvdy5fYURhdGEsIGopKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2gocm93SWR4KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU28gdGhlIGFycmF5IHJlZmVyZW5jZSBkb2Vzbid0IGJyZWFrIHNldCB0aGUgcmVzdWx0cyBpbnRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVJvd3MubGVuZ3RoID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5Um93cy5wdXNoLmFwcGx5KGRpc3BsYXlSb3dzLCByb3dzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBGaWx0ZXIgdGhlIHRhYmxlIG9uIGEgcGVyLWNvbHVtbiBiYXNpc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNJbnB1dCBzdHJpbmcgdG8gZmlsdGVyIG9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaUNvbHVtbiBjb2x1bW4gdG8gZmlsdGVyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJSZWdleCB0cmVhdCBzZWFyY2ggc3RyaW5nIGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBiU21hcnQgdXNlIHNtYXJ0IGZpbHRlcmluZyBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYkNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc3RpdmUgbWF0Y2hpbmcgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlckNvbHVtbihzZXR0aW5ncywgc2VhcmNoU3RyLCBjb2xJZHgsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoU3RyID09PSAnJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKHNlYXJjaFN0ciwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBkaXNwbGF5Lmxlbmd0aCAtIDEgOyBpID49IDAgOyBpLS0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2V0dGluZ3MuYW9EYXRhW2Rpc3BsYXlbaV1dLl9hRmlsdGVyRGF0YVtjb2xJZHhdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJwU2VhcmNoLnRlc3QoZGF0YSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEZpbHRlciB0aGUgZGF0YSB0YWJsZSBiYXNlZCBvbiB1c2VyIGlucHV0IGFuZCBkcmF3IHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gaW5wdXQgc3RyaW5nIHRvIGZpbHRlciBvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGZvcmNlIG9wdGlvbmFsIC0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSByZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gc21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc3RpdmUgbWF0Y2hpbmcgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlcihzZXR0aW5ncywgaW5wdXQsIGZvcmNlLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcGxheSwgaW52YWxpZGF0ZWQsIGk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byB0YWtlIGFjY291bnQgb2YgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnMgLSBhbHdheXMgZmlsdGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoRGF0YVRhYmxlLmV4dC5zZWFyY2gubGVuZ3RoICE9PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgcm93cyB3ZXJlIGludmFsaWRhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlZCA9IF9mbkZpbHRlckRhdGEoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBibGFuayAtIHdlIGp1c3Qgd2FudCB0aGUgZnVsbCBkYXRhIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA8PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWlEaXNwbGF5ID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV3IHNlYXJjaCAtIHN0YXJ0IGZyb20gdGhlIG1hc3RlciBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkYXRlZCB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZTZWFyY2gubGVuZ3RoID4gaW5wdXQubGVuZ3RoIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5pbmRleE9mKHByZXZTZWFyY2gpICE9PSAwIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5iU29ydGVkIC8vIE9uIHJlc29ydCwgdGhlIGRpc3BsYXkgbWFzdGVyIG5lZWRzIHRvIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLWZpbHRlcmVkIHNpbmNlIGluZGV4ZXMgd2lsbCBoYXZlIGNoYW5nZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWlEaXNwbGF5ID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIHRoZSBkaXNwbGF5IGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gZGlzcGxheS5sZW5ndGggLSAxIDsgaSA+PSAwIDsgaS0tKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnBTZWFyY2gudGVzdChzZXR0aW5ncy5hb0RhdGFbZGlzcGxheVtpXV0uX3NGaWx0ZXJSb3cpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LnNwbGljZShpLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBCdWlsZCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3Qgc3VpdGFibGUgZm9yIHNlYXJjaGluZyBhIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc1NlYXJjaCBzdHJpbmcgdG8gc2VhcmNoIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBiUmVnZXggdHJlYXQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJTbWFydCBwZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYkNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge1JlZ0V4cH0gY29uc3RydWN0ZWQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlckNyZWF0ZVNlYXJjaChzZWFyY2gsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZWFyY2ggPSByZWdleCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Fc2NhcGVSZWdleChzZWFyY2gpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzbWFydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEZvciBzbWFydCBmaWx0ZXJpbmcgd2Ugd2FudCB0byBhbGxvdyB0aGUgc2VhcmNoIHRvIHdvcmsgcmVnYXJkbGVzcyBvZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHdvcmQgb3JkZXIuIFdlIGFsc28gd2FudCBkb3VibGUgcXVvdGVkIHRleHQgdG8gYmUgcHJlc2VydmVkLCBzbyB3b3JkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogb3JkZXIgaXMgaW1wb3J0YW50IC0gYSBsYSBnb29nbGUuIFNvIHRoaXMgaXMgd2hhdCB3ZSB3YW50IHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZ2VuZXJhdGU6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogXig/PS4qP1xcYm9uZVxcYikoPz0uKj9cXGJ0d28gdGhyZWVcXGIpKD89Lio/XFxiZm91clxcYikuKiRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9ICQubWFwKHNlYXJjaC5tYXRjaCgvXCJbXlwiXStcInxbXiBdKy9nKSB8fCBbJyddLCBmdW5jdGlvbiAod29yZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod29yZC5jaGFyQXQoMCkgPT09ICdcIicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gd29yZC5tYXRjaCgvXlwiKC4qKVwiJC8pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZCA9IG0gPyBtWzFdIDogd29yZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmQucmVwbGFjZSgnXCInLCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaCA9ICdeKD89Lio/JyArIGEuam9pbignKSg/PS4qPycpICsgJykuKiQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHNlYXJjaCwgY2FzZUluc2Vuc2l0aXZlID8gJ2knIDogJycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzVmFsIHN0cmluZyB0byBlc2NhcGVcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkVzY2FwZVJlZ2V4KHNWYWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzVmFsLnJlcGxhY2UoX3JlX2VzY2FwZV9yZWdleCwgJ1xcXFwkMScpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX2ZpbHRlcl9kaXYgPSAkKCc8ZGl2PicpWzBdO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID0gX19maWx0ZXJfZGl2LnRleHRDb250ZW50ICE9PSB1bmRlZmluZWQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGZpbHRlcmluZyBkYXRhIGZvciBlYWNoIHJvdyBpZiBuZWVkZWQgKGJ5IGludmFsaWRhdGlvbiBvciBmaXJzdCBydW4pXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlckRhdGEoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBqLCBpZW4sIGplbiwgZmlsdGVyRGF0YSwgY2VsbERhdGEsIHJvdztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmb21hdHRlcnMgPSBEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHdhc0ludmFsaWRhdGVkID0gZmFsc2U7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gc2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBzZXR0aW5ncy5hb0RhdGFbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm93Ll9hRmlsdGVyRGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJEYXRhID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqZW4gPSBjb2x1bW5zLmxlbmd0aCA7IGogPCBqZW4gOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbal07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5iU2VhcmNoYWJsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIGksIGosICdmaWx0ZXInKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvbWF0dGVyc1tjb2x1bW4uc1R5cGVdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gZm9tYXR0ZXJzW2NvbHVtbi5zVHlwZV0oY2VsbERhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGluIERhdGFUYWJsZXMgMS4xMCBpcyBzdHJpbmcgYmFzZWQuIEluIDEuMTEgdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhbHRlcmVkIHRvIGFsc28gYWxsb3cgc3RyaWN0IHR5cGUgY2hlY2tpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNlbGxEYXRhICE9PSAnc3RyaW5nJyAmJiBjZWxsRGF0YS50b1N0cmluZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IGNlbGxEYXRhLnRvU3RyaW5nKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBsb29rcyBsaWtlIHRoZXJlIGlzIGFuIEhUTUwgZW50aXR5IGluIHRoZSBzdHJpbmcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGRlY29kZSBpdCBzbyBzb3J0aW5nIHdvcmtzIGFzIGV4cGVjdGVkLiBOb3RlIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIHVzZSBhIHNpbmdsZSBsaW5lIG9mIGpRdWVyeSB0byBkbyB0aGlzLCBidXQgdGhlIERPTVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kIHVzZWQgaGVyZSBpcyBtdWNoIGZhc3RlciBodHRwOi8vanNwZXJmLmNvbS9odG1sLWRlY29kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhLmluZGV4T2YgJiYgY2VsbERhdGEuaW5kZXhPZignJicpICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZmlsdGVyX2Rpdi5pbm5lckhUTUwgPSBjZWxsRGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IF9fZmlsdGVyX2Rpdl90ZXh0Q29udGVudCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZmlsdGVyX2Rpdi5pbm5lclRleHQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhLnJlcGxhY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IGNlbGxEYXRhLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJEYXRhLnB1c2goY2VsbERhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuX2FGaWx0ZXJEYXRhID0gZmlsdGVyRGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9zRmlsdGVyUm93ID0gZmlsdGVyRGF0YS5qb2luKCcgICcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNJbnZhbGlkYXRlZCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YXNJbnZhbGlkYXRlZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb252ZXJ0IGZyb20gdGhlIGludGVybmFsIEh1bmdhcmlhbiBub3RhdGlvbiB0byBjYW1lbENhc2UgZm9yIGV4dGVybmFsXHJcblx0ICAgICAgICAgICAgICAgICAqIGludGVyYWN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU2VhcmNoVG9DYW1lbChvYmopIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoOiBvYmouc1NlYXJjaCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzbWFydDogb2JqLmJTbWFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWdleDogb2JqLmJSZWdleCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IG9iai5iQ2FzZUluc2Vuc2l0aXZlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb252ZXJ0IGZyb20gY2FtZWxDYXNlIG5vdGF0aW9uIHRvIHRoZSBpbnRlcm5hbCBIdW5nYXJpYW4uIFdlIGNvdWxkIHVzZSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogSHVuZ2FyaWFuIGNvbnZlcnQgZnVuY3Rpb24gaGVyZSwgYnV0IHRoaXMgaXMgY2xlYW5lclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgdG8gY29udmVydFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge29iamVjdH0gSW52ZXJ0ZWQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNlYXJjaFRvSHVuZyhvYmopIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc1NlYXJjaDogb2JqLnNlYXJjaCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBiU21hcnQ6IG9iai5zbWFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBiUmVnZXg6IG9iai5yZWdleCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBiQ2FzZUluc2Vuc2l0aXZlOiBvYmouY2FzZUluc2Vuc2l0aXZlXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHRoZSBpbmZvIGRpc3BsYXlcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBJbmZvcm1hdGlvbiBlbGVtZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sSW5mbyhzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGlkID0gc2V0dGluZ3Muc1RhYmxlSWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcy5pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAkKCc8ZGl2Lz4nLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLnNJbmZvLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiAhbm9kZXMgPyB0aWQgKyAnX2luZm8nIDogbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbm9kZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZGlzcGxheSBvbiBlYWNoIGRyYXdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hb0RyYXdDYWxsYmFjay5wdXNoKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmblwiOiBfZm5VcGRhdGVJbmZvLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNOYW1lXCI6IFwiaW5mb3JtYXRpb25cIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyb2xlJywgJ3N0YXR1cycpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIGlzIGRlc2NyaWJlZCBieSBvdXIgaW5mbyBkaXZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkuYXR0cignYXJpYS1kZXNjcmliZWRieScsIHRpZCArICdfaW5mbycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuWzBdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgaW5mb3JtYXRpb24gZWxlbWVudHMgaW4gdGhlIGRpc3BsYXlcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5VcGRhdGVJbmZvKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBTaG93IGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXMuaTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZyA9IHNldHRpbmdzLm9MYW5ndWFnZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICsgMSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IHRvdGFsID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZy5zSW5mbyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcuc0luZm9FbXB0eTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodG90YWwgIT09IG1heCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlY29yZCBzZXQgYWZ0ZXIgZmlsdGVyaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIGxhbmcuc0luZm9GaWx0ZXJlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBtYWNyb3NcclxuXHQgICAgICAgICAgICAgICAgICAgIG91dCArPSBsYW5nLnNJbmZvUG9zdEZpeDtcclxuXHQgICAgICAgICAgICAgICAgICAgIG91dCA9IF9mbkluZm9NYWNyb3Moc2V0dGluZ3MsIG91dCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gbGFuZy5mbkluZm9DYWxsYmFjaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IGNhbGxiYWNrLmNhbGwoc2V0dGluZ3Mub0luc3RhbmNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncywgc3RhcnQsIGVuZCwgbWF4LCB0b3RhbCwgb3V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAkKG5vZGVzKS5odG1sKG91dCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5JbmZvTWFjcm9zKHNldHRpbmdzLCBzdHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gaW5maW5pdGUgc2Nyb2xsaW5nLCB3ZSBhcmUgYWx3YXlzIHN0YXJ0aW5nIGF0IDEuIF9pRGlzcGxheVN0YXJ0IGlzIHVzZWQgb25seVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJuYWxseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyID0gc2V0dGluZ3MuZm5Gb3JtYXROdW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCArIDEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZpcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhbGwgPSBsZW4gPT09IC0xO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHIuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZSgvX1NUQVJUXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgc3RhcnQpKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9fRU5EXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCkpKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9fTUFYXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSkpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL19UT1RBTF8vZywgZm9ybWF0dGVyLmNhbGwoc2V0dGluZ3MsIHZpcykpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL19QQUdFXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgYWxsID8gMSA6IE1hdGguY2VpbChzdGFydCAvIGxlbikpKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9fUEFHRVNfL2csIGZvcm1hdHRlci5jYWxsKHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKHZpcyAvIGxlbikpKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuSW5pdGlhbGlzZShzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGksIGlMZW4sIGlBamF4U3RhcnQgPSBzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLCBjb2x1bW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogRW5zdXJlIHRoYXQgdGhlIHRhYmxlIGRhdGEgaXMgZnVsbHkgaW5pdGlhbGlzZWQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYkluaXRpYWxpc2VkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IF9mbkluaXRpYWxpc2Uoc2V0dGluZ3MpOyB9LCAyMDApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBTaG93IHRoZSBkaXNwbGF5IEhUTUwgb3B0aW9ucyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWRkT3B0aW9uc0h0bWwoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEJ1aWxkIGFuZCBkcmF3IHRoZSBoZWFkZXIgLyBmb290ZXIgZm9yIHRoZSB0YWJsZSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQnVpbGRIZWFkKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkRyYXdIZWFkKHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5EcmF3SGVhZChzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIE9rYXkgdG8gc2hvdyB0aGF0IHNvbWV0aGluZyBpcyBnb2luZyBvbiBub3cgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCB0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBDYWxjdWxhdGUgc2l6ZXMgZm9yIGNvbHVtbnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iQXV0b1dpZHRoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gY29sdW1ucy5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uc1dpZHRoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5uVGguc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyhjb2x1bW4uc1dpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgZGVmYXVsdCBzb3J0aW5nIHJlcXVpcmVkIC0gbGV0J3MgZG8gaXQuIFRoZSBzb3J0IGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGRvIHRoZSBkcmF3aW5nIGZvciB1cy4gT3RoZXJ3aXNlIHdlIGRyYXcgdGhlIHRhYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBamF4IHNvdXJjZSAtIHRoaXMgYWxsb3dzIHRoZSB0YWJsZSB0byBsb29rIGluaXRpYWxpc2VkIGZvciBBamF4IHNvdXJjaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIChzaG93ICdsb2FkaW5nJyBtZXNzYWdlIHBvc3NpYmx5KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGluaXQgY29tcGxldGUgaXMgZG9uZSBieSBfZm5BamF4VXBkYXRlRHJhd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFTcmMgPSBfZm5EYXRhU291cmNlKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhU3JjICE9ICdzc3AnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYWpheCBzb3VyY2UgbG9hZCB0aGUgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhU3JjID09ICdhamF4Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5CdWlsZEFqYXgoc2V0dGluZ3MsIFtdLCBmdW5jdGlvbiAoanNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFEYXRhID0gX2ZuQWpheERhdGFTcmMoc2V0dGluZ3MsIGpzb24pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvdCB0aGUgZGF0YSAtIGFkZCBpdCB0byB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgYURhdGEubGVuZ3RoIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkRGF0YShzZXR0aW5ncywgYURhdGFbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBpbml0IGRpc3BsYXkgZm9yIGNvb2tpZSBzYXZpbmcuIFdlJ3ZlIGFscmVhZHkgZG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBmaWx0ZXIsIGFuZCB0aGVyZWZvcmUgY2xlYXJlZCBpdCBiZWZvcmUuIFNvIHdlIG5lZWQgdG8gbWFrZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgYXBwZWFyICdmcmVzaCdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gaUFqYXhTdGFydDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5SZURyYXcoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCBmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Jbml0Q29tcGxldGUoc2V0dGluZ3MsIGpzb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Jbml0Q29tcGxldGUoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGZpcnN0IHRpbWUsIGFkZGluZyBhbGwgcmVxdWlyZWQgZmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBbanNvbl0gSlNPTiBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCBjb21wbGV0ZWQgdGhlIHRhYmxlLCBpZiB1c2luZyBBamF4IHNvdXJjZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICB3aXRoIGNsaWVudC1zaWRlIHByb2Nlc3NpbmcgKG9wdGlvbmFsKVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Jbml0Q29tcGxldGUoc2V0dGluZ3MsIGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9iSW5pdENvbXBsZXRlID0gdHJ1ZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBPbiBhbiBBamF4IGxvYWQgd2Ugbm93IGhhdmUgZGF0YSBhbmQgdGhlcmVmb3JlIHdhbnQgdG8gYXBwbHkgdGhlIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc2l6aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoanNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAnaW5pdCcsIFtzZXR0aW5ncywganNvbl0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuTGVuZ3RoQ2hhbmdlKHNldHRpbmdzLCB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXJzZUludCh2YWwsIDEwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA9IGxlbjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5MZW5ndGhPdmVyZmxvdyhzZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRmlyZSBsZW5ndGggY2hhbmdlIGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIG51bGwsICdsZW5ndGgnLCBbc2V0dGluZ3MsIGxlbl0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB1c2VyIGRpc3BsYXkgbGVuZ3RoIGNoYW5naW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBEaXNwbGF5IGxlbmd0aCBmZWF0dXJlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxMZW5ndGgoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3NlcyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUlkID0gc2V0dGluZ3Muc1RhYmxlSWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWVudSA9IHNldHRpbmdzLmFMZW5ndGhNZW51LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gJC5pc0FycmF5KG1lbnVbMF0pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHMgPSBkMiA/IG1lbnVbMF0gOiBtZW51LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlID0gZDIgPyBtZW51WzFdIDogbWVudTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICduYW1lJzogdGFibGVJZCArICdfbGVuZ3RoJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHRhYmxlSWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3Nlcy5zTGVuZ3RoU2VsZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gbGVuZ3Rocy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0WzBdW2ldID0gbmV3IE9wdGlvbihsYW5ndWFnZVtpXSwgbGVuZ3Roc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9ICQoJzxkaXY+PGxhYmVsLz48L2Rpdj4nKS5hZGRDbGFzcyhjbGFzc2VzLnNMZW5ndGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5hYW5GZWF0dXJlcy5sKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2WzBdLmlkID0gdGFibGVJZCArICdfbGVuZ3RoJztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBkaXYuY2hpbGRyZW4oKS5hcHBlbmQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub0xhbmd1YWdlLnNMZW5ndGhNZW51LnJlcGxhY2UoJ19NRU5VXycsIHNlbGVjdFswXS5vdXRlckhUTUwpXHJcblx0ICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENhbid0IHVzZSBgc2VsZWN0YCB2YXJpYWJsZSBhcyB1c2VyIG1pZ2h0IHByb3ZpZGUgdGhlaXIgb3duIGFuZCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBpcyBicm9rZW4gYnkgdGhlIHVzZSBvZiBvdXRlckhUTUxcclxuXHQgICAgICAgICAgICAgICAgICAgICQoJ3NlbGVjdCcsIGRpdilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAudmFsKHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYmluZCgnY2hhbmdlLkRUJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTGVuZ3RoQ2hhbmdlKHNldHRpbmdzLCAkKHRoaXMpLnZhbCgpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRHJhdyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIG5vZGUgdmFsdWUgd2hlbmV2ZXIgYW55dGhpbmcgY2hhbmdlcyB0aGUgdGFibGUncyBsZW5ndGhcclxuXHQgICAgICAgICAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS5iaW5kKCdsZW5ndGguZHQuRFQnLCBmdW5jdGlvbiAoZSwgcywgbGVuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzID09PSBzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJ3NlbGVjdCcsIGRpdikudmFsKGxlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdlswXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgbW9zdCBvZiB0aGUgcGFnaW5nIGxvZ2ljIGlzIGRvbmUgaW5cclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlLmV4dC5wYWdlclxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZGVmYXVsdCBwYWdpbmF0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gUGFnaW5hdGlvbiBmZWF0dXJlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZShzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHNldHRpbmdzLnNQYWdpbmF0aW9uVHlwZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4gPSBEYXRhVGFibGUuZXh0LnBhZ2VyW3R5cGVdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVybiA9IHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVkcmF3ID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9ICQoJzxkaXYvPicpLmFkZENsYXNzKHNldHRpbmdzLm9DbGFzc2VzLnNQYWdpbmcgKyB0eXBlKVswXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbW9kZXJuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmZuSW5pdChzZXR0aW5ncywgbm9kZSwgcmVkcmF3KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBBZGQgYSBkcmF3IGNhbGxiYWNrIGZvciB0aGUgcGFnaW5hdGlvbiBvbiBmaXJzdCBpbnN0YW5jZSwgdG8gdXBkYXRlIHRoZSBwYWdpbmcgZGlzcGxheSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmZWF0dXJlcy5wKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pZCA9IHNldHRpbmdzLnNUYWJsZUlkICsgJ19wYWdpbmF0ZSc7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZuXCI6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVybikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpc1JlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbCA9IGxlbiA9PT0gLTEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBhbGwgPyAwIDogTWF0aC5jZWlsKHN0YXJ0IC8gbGVuKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZXMgPSBhbGwgPyAxIDogTWF0aC5jZWlsKHZpc1JlY29yZHMgLyBsZW4pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gcGx1Z2luKHBhZ2UsIHBhZ2VzKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSwgaWVuO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBmZWF0dXJlcy5wLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUmVuZGVyZXIoc2V0dGluZ3MsICdwYWdlQnV0dG9uJykoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncywgZmVhdHVyZXMucFtpXSwgaSwgYnV0dG9ucywgcGFnZSwgcGFnZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4uZm5VcGRhdGUoc2V0dGluZ3MsIHJlZHJhdyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic05hbWVcIjogXCJwYWdpbmF0aW9uXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBbHRlciB0aGUgZGlzcGxheSBzZXR0aW5ncyB0byBjaGFuZ2UgdGhlIHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd8aW50fSBhY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIixcclxuXHQgICAgICAgICAgICAgICAgICogICAgXCJuZXh0XCIgb3IgXCJsYXN0XCIgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlcilcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSBbYm9vbF0gcmVkcmF3IEF1dG9tYXRpY2FsbHkgZHJhdyB0aGUgdXBkYXRlIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2x9IHRydWUgcGFnZSBoYXMgY2hhbmdlZCwgZmFsc2UgLSBubyBjaGFuZ2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuUGFnZUNoYW5nZShzZXR0aW5ncywgYWN0aW9uLCByZWRyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZHMgPT09IDAgfHwgbGVuID09PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09IFwibnVtYmVyXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGFjdGlvbiAqIGxlbjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcmVjb3Jkcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwiZmlyc3RcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PSBcInByZXZpb3VzXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGxlbiA+PSAwID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgLSBsZW4gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT0gXCJuZXh0XCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgKyBsZW4gPCByZWNvcmRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICs9IGxlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT0gXCJsYXN0XCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGguZmxvb3IoKHJlY29yZHMgLSAxKSAvIGxlbikgKiBsZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2coc2V0dGluZ3MsIDAsIFwiVW5rbm93biBwYWdpbmcgYWN0aW9uOiBcIiArIGFjdGlvbiwgNSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCAhPT0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAncGFnZScsIFtzZXR0aW5nc10pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlZDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIHRoZSBwcm9jZXNzaW5nIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IFByb2Nlc3NpbmcgZWxlbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmcoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKCc8ZGl2Lz4nLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogIXNldHRpbmdzLmFhbkZlYXR1cmVzLnIgPyBzZXR0aW5ncy5zVGFibGVJZCArICdfcHJvY2Vzc2luZycgOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLnNQcm9jZXNzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKHNldHRpbmdzLm9MYW5ndWFnZS5zUHJvY2Vzc2luZylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QmVmb3JlKHNldHRpbmdzLm5UYWJsZSlbMF07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRGlzcGxheSBvciBoaWRlIHRoZSBwcm9jZXNzaW5nIGluZGljYXRvclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IHNob3cgU2hvdyB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3IgKHRydWUpIG9yIG5vdCAoZmFsc2UpXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCBzaG93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJChzZXR0aW5ncy5hYW5GZWF0dXJlcy5yKS5jc3MoJ2Rpc3BsYXknLCBzaG93ID8gJ2Jsb2NrJyA6ICdub25lJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAncHJvY2Vzc2luZycsIFtzZXR0aW5ncywgc2hvd10pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWRkIGFueSBjb250cm9sIGVsZW1lbnRzIGZvciB0aGUgdGFibGUgLSBzcGVjaWZpY2FsbHkgc2Nyb2xsaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBOb2RlIHRvIGFkZCB0byB0aGUgRE9NXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sVGFibGUoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIEFSSUEgZ3JpZCByb2xlIHRvIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGFibGUuYXR0cigncm9sZScsICdncmlkJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2Nyb2xsaW5nIGZyb20gaGVyZSBvbiBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbC5zWCA9PT0gJycgJiYgc2Nyb2xsLnNZID09PSAnJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5uVGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFggPSBzY3JvbGwuc1g7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsWSA9IHNjcm9sbC5zWTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2FwdGlvbiA9IHRhYmxlLmNoaWxkcmVuKCdjYXB0aW9uJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2FwdGlvblNpZGUgPSBjYXB0aW9uLmxlbmd0aCA/IGNhcHRpb25bMF0uX2NhcHRpb25TaWRlIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJDbG9uZSA9ICQodGFibGVbMF0uY2xvbmVOb2RlKGZhbHNlKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZm9vdGVyQ2xvbmUgPSAkKHRhYmxlWzBdLmNsb25lTm9kZShmYWxzZSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZvb3RlciA9IHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9kaXYgPSAnPGRpdi8+JztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gZnVuY3Rpb24gKHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXMgPyBudWxsIDogX2ZuU3RyaW5nVG9Dc3Mocyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgZmFpcmx5IG1lc3N5LCBidXQgd2l0aCB4IHNjcm9sbGluZyBlbmFibGVkLCBpZiB0aGUgdGFibGUgaGFzIGFcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHdpZHRoIGF0dHJpYnV0ZSwgcmVnYXJkbGVzcyBvZiBhbnkgd2lkdGggYXBwbGllZCB1c2luZyB0aGUgY29sdW1uIHdpZHRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zLCB0aGUgYnJvd3NlciB3aWxsIHNocmluayBvciBncm93IHRoZSB0YWJsZSBhcyBuZWVkZWQgdG8gZml0IGludG9cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgMTAwJS4gVGhhdCB3b3VsZCBtYWtlIHRoZSB3aWR0aCBvcHRpb25zIHVzZWxlc3MuIFNvIHdlIHJlbW92ZSBpdC5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgb2theSwgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB3aWR0aDoxMDAlIGlzIGFwcGxpZWQgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB0YWJsZSBpbiBDU1MgKGl0IGlzIGluIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQpIHdoaWNoIHdpbGwgc2V0IHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gd2lkdGggYXMgYXBwcm9wcmlhdGUgKHRoZSBhdHRyaWJ1dGUgYW5kIGNzcyBiZWhhdmUgZGlmZmVyZW50bHkuLi4pXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsLnNYICYmIHRhYmxlLmF0dHIoJ3dpZHRoJykgPT09ICcxMDAlJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmb290ZXIubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIEhUTUwgc3RydWN0dXJlIHRoYXQgd2Ugd2FudCB0byBnZW5lcmF0ZSBpbiB0aGlzIGZ1bmN0aW9uIGlzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIGRpdiAtIHNjcm9sbGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBkaXYgLSBzY3JvbGwgaGVhZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBkaXYgLSBzY3JvbGwgaGVhZCBpbm5lclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGhlYWQgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHRoZWFkIC0gdGhlYWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGRpdiAtIHNjcm9sbCBib2R5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHRhYmxlIC0gdGFibGUgKG1hc3RlciB0YWJsZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB0aGVhZCAtIHRoZWFkIGNsb25lIGZvciBzaXppbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB0Ym9keSAtIHRib2R5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBkaXYgLSBzY3JvbGwgZm9vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBkaXYgLSBzY3JvbGwgZm9vdCBpbm5lclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGZvb3QgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHRmb290IC0gdGZvb3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGVyID0gJChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbFdyYXBwZXIgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZCB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxIZWFkSW5uZXIgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm94LXNpemluZyc6ICdjb250ZW50LWJveCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsLnNYSW5uZXIgfHwgJzEwMCUnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDbG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdpZCcpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygnbWFyZ2luLWxlZnQnLCAwKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoY2FwdGlvblNpZGUgPT09ICd0b3AnID8gY2FwdGlvbiA6IG51bGwpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuY2hpbGRyZW4oJ3RoZWFkJylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEJvZHkgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnYXV0bycsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplKHNjcm9sbFkpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplKHNjcm9sbFgpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0YWJsZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxlci5hcHBlbmQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290IH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAwLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzY3JvbGxYID8gc2l6ZShzY3JvbGxYKSA6ICcxMDAlJ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEZvb3RJbm5lciB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyQ2xvbmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignaWQnKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ21hcmdpbi1sZWZ0JywgMClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGNhcHRpb25TaWRlID09PSAnYm90dG9tJyA/IGNhcHRpb24gOiBudWxsKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBzY3JvbGxlci5jaGlsZHJlbigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEhlYWQgPSBjaGlsZHJlblswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxCb2R5ID0gY2hpbGRyZW5bMV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRm9vdCA9IGZvb3RlciA/IGNoaWxkcmVuWzJdIDogbnVsbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxYKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJChzY3JvbGxCb2R5KS5vbignc2Nyb2xsLkRUJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxIZWFkLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRm9vdC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxIZWFkID0gc2Nyb2xsSGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxCb2R5ID0gc2Nyb2xsQm9keTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBPbiByZWRyYXcgLSBhbGlnbiBjb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hb0RyYXdDYWxsYmFjay5wdXNoKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImZuXCI6IF9mblNjcm9sbERyYXcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzTmFtZVwiOiBcInNjcm9sbGluZ1wiXHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Nyb2xsZXJbMF07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgaGVhZGVyLCBmb290ZXIgYW5kIGJvZHkgdGFibGVzIGZvciByZXNpemluZyAtIGkuZS4gY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAqIGFsaWdubWVudC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogV2VsY29tZSB0byB0aGUgbW9zdCBob3JyaWJsZSBmdW5jdGlvbiBEYXRhVGFibGVzLiBUaGUgcHJvY2VzcyB0aGF0IHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICogZnVuY3Rpb24gZm9sbG93cyBpcyBiYXNpY2FsbHk6XHJcblx0ICAgICAgICAgICAgICAgICAqICAgMS4gUmUtY3JlYXRlIHRoZSB0YWJsZSBpbnNpZGUgdGhlIHNjcm9sbGluZyBkaXZcclxuXHQgICAgICAgICAgICAgICAgICogICAyLiBUYWtlIGxpdmUgbWVhc3VyZW1lbnRzIGZyb20gdGhlIERPTVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIDMuIEFwcGx5IHRoZSBtZWFzdXJlbWVudHMgdG8gYWxpZ24gdGhlIGNvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICogICA0LiBDbGVhbiB1cFxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNjcm9sbERyYXcoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEdpdmVuIHRoYXQgdGhpcyBpcyBzdWNoIGEgbW9uc3RlciBmdW5jdGlvbiwgYSBsb3Qgb2YgdmFyaWFibGVzIGFyZSB1c2VcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHRvIHRyeSBhbmQga2VlcCB0aGUgbWluaW1pc2VkIHNpemUgYXMgc21hbGwgYXMgcG9zc2libGVcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCA9IHNjcm9sbC5zWCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYSW5uZXIgPSBzY3JvbGwuc1hJbm5lcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxZID0gc2Nyb2xsLnNZLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJhcldpZHRoID0gc2Nyb2xsLmlCYXJXaWR0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZIZWFkZXIgPSAkKHNldHRpbmdzLm5TY3JvbGxIZWFkKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZIZWFkZXJTdHlsZSA9IGRpdkhlYWRlclswXS5zdHlsZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZIZWFkZXJJbm5lciA9IGRpdkhlYWRlci5jaGlsZHJlbignZGl2JyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2SGVhZGVySW5uZXJTdHlsZSA9IGRpdkhlYWRlcklubmVyWzBdLnN0eWxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkhlYWRlclRhYmxlID0gZGl2SGVhZGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Qm9keUVsID0gc2V0dGluZ3MublNjcm9sbEJvZHksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Qm9keSA9ICQoZGl2Qm9keUVsKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5U3R5bGUgPSBkaXZCb2R5RWwuc3R5bGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Rm9vdGVyID0gJChzZXR0aW5ncy5uU2Nyb2xsRm9vdCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Rm9vdGVySW5uZXIgPSBkaXZGb290ZXIuY2hpbGRyZW4oJ2RpdicpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkZvb3RlclRhYmxlID0gZGl2Rm9vdGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gJChzZXR0aW5ncy5uVEhlYWQpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlID0gJChzZXR0aW5ncy5uVGFibGUpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlRWwgPSB0YWJsZVswXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZVN0eWxlID0gdGFibGVFbC5zdHlsZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb290ZXIgPSBzZXR0aW5ncy5uVEZvb3QgPyAkKHNldHRpbmdzLm5URm9vdCkgOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIgPSBzZXR0aW5ncy5vQnJvd3NlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZTY3ID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyVHJnRWxzLCBmb290ZXJUcmdFbHMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyU3JjRWxzLCBmb290ZXJTcmNFbHMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyQ29weSwgZm9vdGVyQ29weSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJXaWR0aHMgPSBbXSwgZm9vdGVyV2lkdGhzID0gW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyQ29udGVudCA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkeCwgY29ycmVjdGlvbiwgc2FuaXR5V2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgemVyb091dCA9IGZ1bmN0aW9uIChuU2l6ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gblNpemVyLnN0eWxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjBcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBcIjBcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBcIjBcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgbWluaW1pc2VkIHRoZWFkIGFuZCB0Zm9vdCBlbGVtZW50cyBpbiB0aGUgaW5uZXIgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgIHRhYmxlLmNoaWxkcmVuKCd0aGVhZCwgdGZvb3QnKS5yZW1vdmUoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgY3VycmVudCBoZWFkZXIgYW5kIGZvb3RlciBlbGVtZW50cyBhbmQgdGhlbiBwbGFjZSBpdCBpbnRvIHRoZSBpbm5lciB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVhZGVyQ29weSA9IGhlYWRlci5jbG9uZSgpLnByZXBlbmRUbyh0YWJsZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoZWFkZXJUcmdFbHMgPSBoZWFkZXIuZmluZCgndHInKTsgLy8gb3JpZ2luYWwgaGVhZGVyIGlzIGluIGl0cyBvd24gdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgIGhlYWRlclNyY0VscyA9IGhlYWRlckNvcHkuZmluZCgndHInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhlYWRlckNvcHkuZmluZCgndGgsIHRkJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZm9vdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyQ29weSA9IGZvb3Rlci5jbG9uZSgpLnByZXBlbmRUbyh0YWJsZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyVHJnRWxzID0gZm9vdGVyLmZpbmQoJ3RyJyk7IC8vIHRoZSBvcmlnaW5hbCB0Zm9vdCBpcyBpbiBpdHMgb3duIHRhYmxlIGFuZCBtdXN0IGJlIHNpemVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyU3JjRWxzID0gZm9vdGVyQ29weS5maW5kKCd0cicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET00gLSBkbyBub3QgYWx0ZXIgdGhlIERPTSBpdHNlbGYhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHNpemluZyBhbmQgYXBwbHkgdGhlIGNhbGN1bGF0ZWQgY29sdW1uIHdpZHRoc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB1bmlxdWUgY29sdW1uIGhlYWRlcnMgaW4gdGhlIG5ld2x5IGNyZWF0ZWQgKGNsb25lZCkgaGVhZGVyLiBXZSB3YW50IHRvIGFwcGx5IHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlZCBzaXplcyB0byB0aGlzIGhlYWRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JvbGxYKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Qm9keVN0eWxlLndpZHRoID0gJzEwMCUnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkhlYWRlclswXS5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAkLmVhY2goX2ZuR2V0VW5pcXVlVGhzKHNldHRpbmdzLCBoZWFkZXJDb3B5KSwgZnVuY3Rpb24gKGksIGVsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoc2V0dGluZ3MsIGkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gc2V0dGluZ3MuYW9Db2x1bW5zW2lkeF0uc1dpZHRoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbihmdW5jdGlvbiAobikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLnN0eWxlLndpZHRoID0gXCJcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBmb290ZXJTcmNFbHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHNjcm9sbCBjb2xsYXBzZSBpcyBlbmFibGVkLCB3aGVuIHdlIHB1dCB0aGUgaGVhZGVycyBiYWNrIGludG8gdGhlIGJvZHkgZm9yIHNpemluZywgd2VcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHdpbGwgZW5kIHVwIGZvcmNpbmcgdGhlIHNjcm9sbGJhciB0byBhcHBlYXIsIG1ha2luZyBvdXIgbWVhc3VyZW1lbnRzIHdyb25nIGZvciB3aGVuIHdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGhpZGUgaXQgKGVuZCBvZiB0aGlzIGZ1bmN0aW9uKSwgc28gYWRkIHRoZSBoZWFkZXIgaGVpZ2h0IHRvIHRoZSBib2R5IHNjcm9sbGVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbC5iQ29sbGFwc2UgJiYgc2Nyb2xsWSAhPT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkJvZHlTdHlsZS5oZWlnaHQgPSAoZGl2Qm9keVswXS5vZmZzZXRIZWlnaHQgKyBoZWFkZXJbMF0ub2Zmc2V0SGVpZ2h0KSArIFwicHhcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTaXplIHRoZSB0YWJsZSBhcyBhIHdob2xlXHJcblx0ICAgICAgICAgICAgICAgICAgICBzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxYID09PSBcIlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8geCBzY3JvbGxpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZVN0eWxlLndpZHRoID0gXCIxMDAlXCI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFNyB3aWxsIG1ha2UgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSB3aGVuIDEwMCUgaW5jbHVkZSB0aGUgc2Nyb2xsYmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSB3aGljaCBpcyBzaG91bGRuJ3QuIFdoZW4gdGhlcmUgaXMgYSBzY3JvbGxiYXIgd2UgbmVlZCB0byB0YWtlIHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIGFjY291bnQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGllNjcgJiYgKHRhYmxlLmZpbmQoJ3Rib2R5JykuaGVpZ2h0KCkgPiBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHRhYmxlLm91dGVyV2lkdGgoKSAtIGJhcldpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB4IHNjcm9sbGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxYSW5uZXIgIT09IFwiXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8geCBzY3JvbGwgaW5uZXIgaGFzIGJlZW4gZ2l2ZW4gLSB1c2UgaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHNjcm9sbFhJbm5lcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNhbml0eVdpZHRoID09IGRpdkJvZHkud2lkdGgoKSAmJiBkaXZCb2R5LmhlaWdodCgpIDwgdGFibGUuaGVpZ2h0KCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgeS1zY3JvbGxpbmcgLSB0cnkgdG8gdGFrZSBhY2NvdW50IG9mIHRoZSB5IHNjcm9sbCBiYXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHNhbml0eVdpZHRoIC0gYmFyV2lkdGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFibGUub3V0ZXJXaWR0aCgpID4gc2FuaXR5V2lkdGggLSBiYXJXaWR0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IHBvc3NpYmxlIHRvIHRha2UgYWNjb3VudCBvZiBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHNhbml0eVdpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBhbGwgZWxzZSBmYWlsc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3Moc2FuaXR5V2lkdGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSB0aGUgc2FuaXR5IHdpZHRoIC0gbm93IHRoYXQgd2UndmUgYXBwbGllZCB0aGUgcmVxdWlyZWQgd2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBiZWZvcmUgaXQgd2FzIGEgdGVtcG9yYXJ5IHZhcmlhYmxlLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhlIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gd2lkdGggY2FsY3VsYXRpb24gaXMgZG9uZSBiZWZvcmUgdGhpcyB0YWJsZSBET00gaXMgY3JlYXRlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEhpZGRlbiBoZWFkZXIgc2hvdWxkIGhhdmUgemVybyBoZWlnaHQsIHNvIHJlbW92ZSBwYWRkaW5nIGFuZCBib3JkZXJzLiBUaGVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHdpZHRoIGJhc2VkIG9uIHRoZSByZWFsIGhlYWRlcnNcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBhbGwgc3R5bGVzIGluIG9uZSBwYXNzXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oemVyb091dCwgaGVhZGVyU3JjRWxzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIGFsbCB3aWR0aHMgaW4gbmV4dCBwYXNzXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG5TaXplcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckNvbnRlbnQucHVzaChuU2l6ZXIuaW5uZXJIVE1MKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJXaWR0aHMucHVzaChfZm5TdHJpbmdUb0NzcygkKG5TaXplcikuY3NzKCd3aWR0aCcpKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCBoZWFkZXJTcmNFbHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGFsbCB3aWR0aHMgaW4gZmluYWwgcGFzc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuVG9TaXplLCBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgblRvU2l6ZS5zdHlsZS53aWR0aCA9IGhlYWRlcldpZHRoc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIGhlYWRlclRyZ0Vscyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgJChoZWFkZXJTcmNFbHMpLmhlaWdodCgwKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBTYW1lIGFnYWluIHdpdGggdGhlIGZvb3RlciBpZiB3ZSBoYXZlIG9uZSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbih6ZXJvT3V0LCBmb290ZXJTcmNFbHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG5TaXplcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb290ZXJXaWR0aHMucHVzaChfZm5TdHJpbmdUb0NzcygkKG5TaXplcikuY3NzKCd3aWR0aCcpKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgZm9vdGVyU3JjRWxzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuVG9TaXplLCBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5Ub1NpemUuc3R5bGUud2lkdGggPSBmb290ZXJXaWR0aHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgZm9vdGVyVHJnRWxzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJChmb290ZXJTcmNFbHMpLmhlaWdodCgwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDMuIEFwcGx5IHRoZSBtZWFzdXJlbWVudHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFwiSGlkZVwiIHRoZSBoZWFkZXIgYW5kIGZvb3RlciB0aGF0IHdlIHVzZWQgZm9yIHRoZSBzaXppbmcuIFdlIG5lZWQgdG8ga2VlcFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNvbnRlbnQgb2YgdGhlIGNlbGwgc28gdGhhdCB0aGUgd2lkdGggYXBwbGllZCB0byB0aGUgaGVhZGVyIGFuZCBib2R5XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBib3RoIG1hdGNoLCBidXQgd2Ugd2FudCB0byBoaWRlIGl0IGNvbXBsZXRlbHkuIFdlIHdhbnQgdG8gYWxzbyBmaXggdGhlaXJcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHdpZHRoIHRvIHdoYXQgdGhleSBjdXJyZW50bHkgYXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG5TaXplciwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5TaXplci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImRhdGFUYWJsZXNfc2l6aW5nXCIgc3R5bGU9XCJoZWlnaHQ6MDtvdmVyZmxvdzpoaWRkZW47XCI+JyArIGhlYWRlckNvbnRlbnRbaV0gKyAnPC9kaXY+JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuU2l6ZXIuc3R5bGUud2lkdGggPSBoZWFkZXJXaWR0aHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCBoZWFkZXJTcmNFbHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG5TaXplciwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuU2l6ZXIuaW5uZXJIVE1MID0gXCJcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgblNpemVyLnN0eWxlLndpZHRoID0gZm9vdGVyV2lkdGhzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZvb3RlclNyY0Vscyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2FuaXR5IGNoZWNrIHRoYXQgdGhlIHRhYmxlIGlzIG9mIGEgc2Vuc2libGUgd2lkdGguIElmIG5vdCB0aGVuIHdlIGFyZSBnb2luZyB0byBnZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIG1pc2FsaWdubWVudCAtIHRyeSB0byBwcmV2ZW50IHRoaXMgYnkgbm90IGFsbG93aW5nIHRoZSB0YWJsZSB0byBzaHJpbmsgYmVsb3cgaXRzIG1pbiB3aWR0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlLm91dGVyV2lkdGgoKSA8IHNhbml0eVdpZHRoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1pbiB3aWR0aCBkZXBlbmRzIHVwb24gaWYgd2UgaGF2ZSBhIHZlcnRpY2FsIHNjcm9sbGJhciB2aXNpYmxlIG9yIG5vdCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvcnJlY3Rpb24gPSAoKGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPiBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIikpID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbml0eVdpZHRoICsgYmFyV2lkdGggOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FuaXR5V2lkdGg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFNi83IGFyZSBhIGxhdyB1bnRvIHRoZW1zZWx2ZXMuLi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWU2NyAmJiAoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZVN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoY29ycmVjdGlvbiAtIGJhcldpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCBnaXZlIHRoZSB1c2VyIGEgd2FybmluZyB0aGF0IHdlJ3ZlIHN0b3BwZWQgdGhlIHRhYmxlIGdldHRpbmcgdG9vIHNtYWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbFggPT09IFwiXCIgfHwgc2Nyb2xsWElubmVyICE9PSBcIlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxvZyhzZXR0aW5ncywgMSwgJ1Bvc3NpYmxlIGNvbHVtbiBtaXNhbGlnbm1lbnQnLCA2KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWN0aW9uID0gJzEwMCUnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRvIHRoZSBjb250YWluZXIgZWxlbWVudHNcclxuXHQgICAgICAgICAgICAgICAgICAgIGRpdkJvZHlTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGNvcnJlY3Rpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGl2SGVhZGVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyhjb3JyZWN0aW9uKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZm9vdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MublNjcm9sbEZvb3Quc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyhjb3JyZWN0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDQuIENsZWFuIHVwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2Nyb2xsWSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBzY3JvbGxiYXIgaGVpZ2h0IGZyb20gdGhlIHZpc2libGUgZGlzcGxheSwgcmF0aGVyIHRoYW4gYWRkaW5nIGl0IG9uLiBXZSBuZWVkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IHRoZSBoZWlnaHQgaW4gb3JkZXIgdG8gc29ydCB0aGlzLiBEb24ndCB3YW50IHRvIGRvIGl0IGluIGFueSBvdGhlciBicm93c2Vycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWU2Nykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5U3R5bGUuaGVpZ2h0ID0gX2ZuU3RyaW5nVG9Dc3ModGFibGVFbC5vZmZzZXRIZWlnaHQgKyBiYXJXaWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxZICYmIHNjcm9sbC5iQ29sbGFwc2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5U3R5bGUuaGVpZ2h0ID0gX2ZuU3RyaW5nVG9Dc3Moc2Nyb2xsWSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpRXh0cmEgPSAoc2Nyb2xsWCAmJiB0YWJsZUVsLm9mZnNldFdpZHRoID4gZGl2Qm9keUVsLm9mZnNldFdpZHRoKSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhcldpZHRoIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlRWwub2Zmc2V0SGVpZ2h0IDwgZGl2Qm9keUVsLm9mZnNldEhlaWdodCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5U3R5bGUuaGVpZ2h0ID0gX2ZuU3RyaW5nVG9Dc3ModGFibGVFbC5vZmZzZXRIZWlnaHQgKyBpRXh0cmEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBGaW5hbGx5IHNldCB0aGUgd2lkdGgncyBvZiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGFibGVzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaU91dGVyV2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkaXZIZWFkZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGlPdXRlcldpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGRpdkhlYWRlcklubmVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhpT3V0ZXJXaWR0aCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRmlndXJlIG91dCBpZiB0aGVyZSBhcmUgc2Nyb2xsYmFyIHByZXNlbnQgLSBpZiBzbyB0aGVuIHdlIG5lZWQgYSB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgYSBiaXQgbW9yZSBzcGFjZSB0byBhbGxvdyBcIm92ZXJmbG93XCIgc2Nyb2xsaW5nIChpLmUuIHBhc3QgdGhlIHNjcm9sbGJhcilcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBiU2Nyb2xsaW5nID0gdGFibGUuaGVpZ2h0KCkgPiBkaXZCb2R5RWwuY2xpZW50SGVpZ2h0IHx8IGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nID0gJ3BhZGRpbmcnICsgKGJyb3dzZXIuYlNjcm9sbGJhckxlZnQgPyAnTGVmdCcgOiAnUmlnaHQnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGRpdkhlYWRlcklubmVyU3R5bGVbcGFkZGluZ10gPSBiU2Nyb2xsaW5nID8gYmFyV2lkdGggKyBcInB4XCIgOiBcIjBweFwiO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZGb290ZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGlPdXRlcldpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZGb290ZXJJbm5lclswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGlPdXRlcldpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZGb290ZXJJbm5lclswXS5zdHlsZVtwYWRkaW5nXSA9IGJTY3JvbGxpbmcgPyBiYXJXaWR0aCArIFwicHhcIiA6IFwiMHB4XCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBkaXZCb2R5LnNjcm9sbCgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHNvcnRpbmcgb3IgZmlsdGVyaW5nIGhhcyBvY2N1cnJlZCwganVtcCB0aGUgc2Nyb2xsaW5nIGJhY2sgdG8gdGhlIHRvcFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gb25seSBpZiB3ZSBhcmVuJ3QgaG9sZGluZyB0aGUgcG9zaXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuYlNvcnRlZCB8fCBzZXR0aW5ncy5iRmlsdGVyZWQpICYmICFzZXR0aW5ncy5fZHJhd0hvbGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5RWwuc2Nyb2xsVG9wID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQXBwbHkgYSBnaXZlbiBmdW5jdGlvbiB0byB0aGUgZGlzcGxheSBjaGlsZCBub2RlcyBvZiBhbiBlbGVtZW50IGFycmF5ICh0eXBpY2FsbHlcclxuXHQgICAgICAgICAgICAgICAgICogVEQgY2hpbGRyZW4gb2YgVFIgcm93c1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gTWV0aG9kIHRvIGFwcGx5IHRvIHRoZSBvYmplY3RzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjEgTGlzdCBvZiBlbGVtZW50cyB0byBsb29rIHRocm91Z2ggZm9yIGRpc3BsYXkgY2hpbGRyZW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSBhcnJheSB7bm9kZXN9IGFuMiBBbm90aGVyIGxpc3QgKGlkZW50aWNhbCBzdHJ1Y3R1cmUgdG8gdGhlIGZpcnN0KSAtIG9wdGlvbmFsXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkFwcGx5VG9DaGlsZHJlbihmbiwgYW4xLCBhbjIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDAsIGkgPSAwLCBpTGVuID0gYW4xLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuTm9kZTEsIG5Ob2RlMjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlMZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuTm9kZTEgPSBhbjFbaV0uZmlyc3RDaGlsZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuTm9kZTIgPSBhbjIgPyBhbjJbaV0uZmlyc3RDaGlsZCA6IG51bGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuTm9kZTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5Ob2RlMS5ub2RlVHlwZSA9PT0gMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuMikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKG5Ob2RlMSwgbk5vZGUyLCBpbmRleCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbihuTm9kZTEsIGluZGV4KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTm9kZTEgPSBuTm9kZTEubmV4dFNpYmxpbmc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5Ob2RlMiA9IGFuMiA/IG5Ob2RlMi5uZXh0U2libGluZyA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpKys7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fcmVfaHRtbF9yZW1vdmUgPSAvPC4qPz4vZztcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlIHRoZSB3aWR0aCBvZiBjb2x1bW5zIGZvciB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzKG9TZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgPSBvU2V0dGluZ3MublRhYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbCA9IG9TZXR0aW5ncy5vU2Nyb2xsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFkgPSBzY3JvbGwuc1ksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCA9IHNjcm9sbC5zWCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxYSW5uZXIgPSBzY3JvbGwuc1hJbm5lcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGVDb2x1bW5zID0gX2ZuR2V0Q29sdW1ucyhvU2V0dGluZ3MsICdiVmlzaWJsZScpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckNlbGxzID0gJCgndGgnLCBvU2V0dGluZ3MublRIZWFkKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZVdpZHRoQXR0ciA9IHRhYmxlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSwgLy8gZnJvbSBET00gZWxlbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ29udGFpbmVyID0gdGFibGUucGFyZW50Tm9kZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1c2VySW5wdXRzID0gZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSwgY29sdW1uLCBjb2x1bW5JZHgsIHdpZHRoLCBvdXRlcldpZHRoO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVXaWR0aCAmJiBzdHlsZVdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZVdpZHRoQXR0ciA9IHN0eWxlV2lkdGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQ29udmVydCBhbnkgdXNlciBpbnB1dCBzaXplcyBpbnRvIHBpeGVsIHNpemVzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbdmlzaWJsZUNvbHVtbnNbaV1dO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNXaWR0aCAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1dpZHRoID0gX2ZuQ29udmVydFRvV2lkdGgoY29sdW1uLnNXaWR0aE9yaWcsIHRhYmxlQ29udGFpbmVyKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJbnB1dHMgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIERPTSBlcXVhbHMgdGhlIG51bWJlciB0aGF0IHdlIGhhdmUgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByb2Nlc3MgaW4gRGF0YVRhYmxlcywgdGhlbiB3ZSBjYW4gdXNlIHRoZSBvZmZzZXRzIHRoYXQgYXJlIGNyZWF0ZWQgYnlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSB3ZWItIGJyb3dzZXIuIE5vIGN1c3RvbSBzaXplcyBjYW4gYmUgc2V0IGluIG9yZGVyIGZvciB0aGlzIHRvIGhhcHBlbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG5vciBzY3JvbGxpbmcgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJJbnB1dHMgJiYgIXNjcm9sbFggJiYgIXNjcm9sbFkgJiZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db3VudCA9PSBfZm5WaXNibGVDb2x1bW5zKG9TZXR0aW5ncykgJiZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db3VudCA9PSBoZWFkZXJDZWxscy5sZW5ndGhcclxuXHQgICAgICAgICAgICAgICAgICAgICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgY29sdW1uQ291bnQgOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uc1tpXS5zV2lkdGggPSBfZm5TdHJpbmdUb0NzcyhoZWFkZXJDZWxscy5lcShpKS53aWR0aCgpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgY29uc3RydWN0IGEgc2luZ2xlIHJvdywgd29yc3QgY2FzZSwgdGFibGUgd2l0aCB0aGUgd2lkZXN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIERPTSBhbmQgYWxsb3cgdGhlIGJyb3dzZXIgdG8gZG8gYWxsIHRoZSBoYXJkIHdvcmsgb2YgY2FsY3VsYXRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWJsZSB3aWR0aHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wVGFibGUgPSAkKHRhYmxlKS5jbG9uZSgpIC8vIGRvbid0IHVzZSBjbG9uZU5vZGUgLSBJRTggd2lsbCByZW1vdmUgZXZlbnRzIG9uIHRoZSBtYWluIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2lkJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSB0YWJsZSBib2R5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUuZmluZCgndGJvZHkgdHInKS5yZW1vdmUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHIgPSAkKCc8dHIvPicpLmFwcGVuZFRvKHRtcFRhYmxlLmZpbmQoJ3Rib2R5JykpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IGFzc2lnbmVkIHdpZHRocyBmcm9tIHRoZSBmb290ZXIgKGZyb20gc2Nyb2xsaW5nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSBzaXppbmcgdG8gdGhlIGNsb25lZCBoZWFkZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDZWxscyA9IF9mbkdldFVuaXF1ZVRocyhvU2V0dGluZ3MsIHRtcFRhYmxlLmZpbmQoJ3RoZWFkJylbMF0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW3Zpc2libGVDb2x1bW5zW2ldXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckNlbGxzW2ldLnN0eWxlLndpZHRoID0gY29sdW1uLnNXaWR0aE9yaWcgIT09IG51bGwgJiYgY29sdW1uLnNXaWR0aE9yaWcgIT09ICcnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblN0cmluZ1RvQ3NzKGNvbHVtbi5zV2lkdGhPcmlnKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHdpZGVzdCBjZWxsIGZvciBlYWNoIGNvbHVtbiBhbmQgcHV0IGl0IGludG8gdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgdmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JZHggPSB2aXNpYmxlQ29sdW1uc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbY29sdW1uSWR4XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKF9mbkdldFdpZGVzdE5vZGUob1NldHRpbmdzLCBjb2x1bW5JZHgpKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jbG9uZShmYWxzZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGNvbHVtbi5zQ29udGVudFBhZGRpbmcpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFibGUgaGFzIGJlZW4gYnVpbHQsIGF0dGFjaCB0byB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIHdvcmsgd2l0aCBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLmFwcGVuZFRvKHRhYmxlQ29udGFpbmVyKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgKFggb3IgWSkgd2Ugd2FudCB0byBzZXQgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSBhcyBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcHByb3ByaWF0ZS4gSG93ZXZlciwgd2hlbiBub3Qgc2Nyb2xsaW5nIGxlYXZlIHRoZSB0YWJsZSB3aWR0aCBhcyBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxYICYmIHNjcm9sbFhJbm5lcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS53aWR0aChzY3JvbGxYSW5uZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxYKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLmNzcygnd2lkdGgnLCAnYXV0bycpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcFRhYmxlLndpZHRoKCkgPCB0YWJsZUNvbnRhaW5lci5vZmZzZXRXaWR0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUud2lkdGgodGFibGVDb250YWluZXIub2Zmc2V0V2lkdGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUud2lkdGgodGFibGVDb250YWluZXIub2Zmc2V0V2lkdGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0YWJsZVdpZHRoQXR0cikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS53aWR0aCh0YWJsZVdpZHRoQXR0cik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWtlIGludG8gYWNjb3VudCB0aGUgeSBzY3JvbGxiYXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5TY3JvbGxpbmdXaWR0aEFkanVzdChvU2V0dGluZ3MsIHRtcFRhYmxlWzBdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnJvd3NlcnMgbmVlZCBhIGJpdCBvZiBhIGhhbmQgd2hlbiBhIHdpZHRoIGlzIGFzc2lnbmVkIHRvIGFueSBjb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB4LXNjcm9sbGluZyBhcyB0aGV5IHRlbmQgdG8gY29sbGFwc2UgdGhlIHRhYmxlIHRvIHRoZSBtaW4td2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBpZiB3ZSBzZW50IHRoZSBjb2x1bW4gd2lkdGhzLiBTbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hhdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0YWJsZSB3aWR0aCBzaG91bGQgYmUgYnkgc3VtbWluZyB0aGUgdXNlciBnaXZlbiB2YWx1ZXMsIGFuZCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWMgdmFsdWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbFgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgdmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW3Zpc2libGVDb2x1bW5zW2ldXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyV2lkdGggPSAkKGhlYWRlckNlbGxzW2ldKS5vdXRlcldpZHRoKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gY29sdW1uLnNXaWR0aE9yaWcgPT09IG51bGwgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyV2lkdGggOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGNvbHVtbi5zV2lkdGgsIDEwKSArIG91dGVyV2lkdGggLSAkKGhlYWRlckNlbGxzW2ldKS53aWR0aCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS53aWR0aChfZm5TdHJpbmdUb0Nzcyh0b3RhbCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHRvdGFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIGNvbnN0cnVjdGVkIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCA7IGkgPCB2aXNpYmxlQ29sdW1ucy5sZW5ndGggOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1t2aXNpYmxlQ29sdW1uc1tpXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gJChoZWFkZXJDZWxsc1tpXSkud2lkdGgoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNXaWR0aCA9IF9mblN0cmluZ1RvQ3NzKHdpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyh0bXBUYWJsZS5jc3MoJ3dpZHRoJykpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZCB3aXRoIHRoZSB0YWJsZSAtIGRpdGNoIGl0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB3aWR0aCBhdHRyLCB3ZSB3YW50IHRvIGF0dGFjaCBhbiBldmVudCBsaXN0ZW5lciB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3dzIHRoZSB0YWJsZSBzaXppbmcgdG8gYXV0b21hdGljYWxseSBhZGp1c3Qgd2hlbiB0aGUgd2luZG93IGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyByZXNpemVkLiBVc2UgdGhlIHdpZHRoIGF0dHIgcmF0aGVyIHRoYW4gQ1NTLCBzaW5jZSB3ZSBjYW4ndCBrbm93IGlmIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ1NTIGlzIGEgcmVsYXRpdmUgdmFsdWUgb3IgYWJzb2x1dGUgLSBET00gcmVhZCBpcyBhbHdheXMgcHguXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGFibGVXaWR0aEF0dHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHRhYmxlV2lkdGhBdHRyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoKHRhYmxlV2lkdGhBdHRyIHx8IHNjcm9sbFgpICYmICFvU2V0dGluZ3MuX3Jlc3pFdnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmluZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZS5EVC0nICsgb1NldHRpbmdzLnNJbnN0YW5jZSwgX2ZuVGhyb3R0bGUoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRqdXN0Q29sdW1uU2l6aW5nKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTYvNyB3aWxsIGNyYXNoIGlmIHdlIGJpbmQgYSByZXNpemUgZXZlbnQgaGFuZGxlciBvbiBwYWdlIGxvYWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gYmUgcmVtb3ZlZCBpbiAxLjExIHdoaWNoIGRyb3BzIElFNi83IHN1cHBvcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLm9Ccm93c2VyLmJTY3JvbGxPdmVyc2l6ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGJpbmRSZXNpemUsIDEwMDApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZFJlc2l6ZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLl9yZXN6RXZ0ID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUaHJvdHRsZSB0aGUgY2FsbHMgdG8gYSBmdW5jdGlvbi4gQXJndW1lbnRzIGFuZCBjb250ZXh0IGFyZSBtYWludGFpbmVkIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgKiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBbZnJlcT0yMDBdIGNhbGwgZnJlcXVlbmN5IGluIG1TXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7ZnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuVGhyb3R0bGUoZm4sIGZyZXEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZyZXF1ZW5jeSA9IGZyZXEgIT09IHVuZGVmaW5lZCA/IGZyZXEgOiAyMDAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gK25ldyBEYXRlKCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIG5vdyA8IGxhc3QgKyBmcmVxdWVuY3kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZyZXF1ZW5jeSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gbm93O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENvbnZlcnQgYSBDU1MgdW5pdCB3aWR0aCB0byBwaXhlbHMgKGUuZy4gMmVtKVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHdpZHRoIHdpZHRoIHRvIGJlIGNvbnZlcnRlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBwYXJlbnQgcGFyZW50IHRvIGdldCB0aGUgd2l0aCBmb3IgKHJlcXVpcmVkIGZvciByZWxhdGl2ZSB3aWR0aHMpIC0gb3B0aW9uYWxcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IHdpZHRoIGluIHBpeGVsc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Db252ZXJ0VG9XaWR0aCh3aWR0aCwgcGFyZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXdpZHRoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSAkKCc8ZGl2Lz4nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgX2ZuU3RyaW5nVG9Dc3Mod2lkdGgpKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhwYXJlbnQgfHwgZG9jdW1lbnQuYm9keSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG5bMF0ub2Zmc2V0V2lkdGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBuLnJlbW92ZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWRqdXN0IGEgdGFibGUncyB3aWR0aCB0byB0YWtlIGFjY291bnQgb2YgdmVydGljYWwgc2Nyb2xsIGJhclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuIHRhYmxlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNjcm9sbGluZ1dpZHRoQWRqdXN0KHNldHRpbmdzLCBuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsLnNYIHx8IHNjcm9sbC5zWSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4geS1zY3JvbGxpbmcgb25seSwgd2Ugd2FudCB0byByZW1vdmUgdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGwgYmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhlIHRhYmxlICsgc2Nyb2xsIGJhciB3aWxsIGZpdCBpbnRvIHRoZSBhcmVhIGF2YWlsYWJsZSwgb3RoZXJ3aXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZml4IHRoZSB0YWJsZSBhdCBpdHMgY3VycmVudCBzaXplIHdpdGggbm8gYWRqdXN0bWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0aW9uID0gIXNjcm9sbC5zWCA/IHNjcm9sbC5pQmFyV2lkdGggOiAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG4uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcygkKG4pLm91dGVyV2lkdGgoKSAtIGNvcnJlY3Rpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdldCB0aGUgd2lkZXN0IG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSB3aWRlc3QgdGFibGUgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5HZXRXaWRlc3ROb2RlKHNldHRpbmdzLCBjb2xJZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBfZm5HZXRNYXhMZW5TdHJpbmcoc2V0dGluZ3MsIGNvbElkeCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhW2lkeF07XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRhdGEublRyID8gLy8gTWlnaHQgbm90IGhhdmUgYmVlbiBjcmVhdGVkIHdoZW4gZGVmZXJyZWQgcmVuZGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJCgnPHRkLz4nKS5odG1sKF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCBpZHgsIGNvbElkeCwgJ2Rpc3BsYXknKSlbMF0gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYW5DZWxsc1tjb2xJZHhdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdldCB0aGUgbWF4aW11bSBzdHJsZW4gZm9yIGVhY2ggZGF0YSBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gb2YgaW50ZXJlc3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IG1heCBzdHJpbmcgbGVuZ3RoIGZvciBlYWNoIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5HZXRNYXhMZW5TdHJpbmcoc2V0dGluZ3MsIGNvbElkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHMsIG1heCA9IC0xLCBtYXhJZHggPSAtMTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gc2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzID0gX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIGksIGNvbElkeCwgJ2Rpc3BsYXknKSArICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoX19yZV9odG1sX3JlbW92ZSwgJycpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5sZW5ndGggPiBtYXgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gcy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heElkeCA9IGk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXhJZHg7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQXBwZW5kIGEgQ1NTIHVuaXQgKG9ubHkgaWYgcmVxdWlyZWQpIHRvIGEgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdG8gY3NzLWlmeVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gdmFsdWUgd2l0aCBjc3MgdW5pdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5TdHJpbmdUb0NzcyhzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnMHB4JztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHMgPT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcyA8IDAgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAnMHB4JyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKyAncHgnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGl0IGhhcyBhIHVuaXQgY2hhcmFjdGVyIGFscmVhZHlcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLm1hdGNoKC9cXGQkLykgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHMgKyAncHgnIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdldCB0aGUgd2lkdGggb2YgYSBzY3JvbGwgYmFyIGluIHRoaXMgYnJvd3NlciBiZWluZyB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSB3aWR0aCBpbiBwaXhlbHNcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU2Nyb2xsQmFyV2lkdGgoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBPbiBmaXJzdCBydW4gYSBzdGF0aWMgdmFyaWFibGUgaXMgc2V0LCBzaW5jZSB0aGlzIGlzIG9ubHkgbmVlZGVkIG9uY2UuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTdWJzZXF1ZW50IHJ1bnMgd2lsbCBqdXN0IHVzZSB0aGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIHZhbHVlXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBEYXRhVGFibGUuX19zY3JvbGxiYXJXaWR0aDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplciA9ICQoJzxwLz4nKS5jc3Moe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDE1MCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdzY3JvbGwnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbygnYm9keScpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHNpemVyWzBdLm9mZnNldFdpZHRoIC0gc2l6ZXJbMF0uY2xpZW50V2lkdGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgRGF0YVRhYmxlLl9fc2Nyb2xsYmFyV2lkdGggPSB3aWR0aDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZXIucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNvcnRGbGF0dGVuKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpLCBpTGVuLCBrLCBrTGVuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFTb3J0ID0gW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWlPcmlnID0gW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYW9Db2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFEYXRhU29ydCwgaUNvbCwgc1R5cGUsIHNyY0NvbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXhlZCA9IHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpeGVkT2JqID0gJC5pc1BsYWluT2JqZWN0KGZpeGVkKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRTb3J0ID0gW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkID0gZnVuY3Rpb24gKGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoICYmICEkLmlzQXJyYXkoYVswXSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDFEIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRTb3J0LnB1c2goYSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyRCBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkU29ydC5wdXNoLmFwcGx5KG5lc3RlZFNvcnQsIGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgc29ydCBhcnJheSwgd2l0aCBwcmUtZml4IGFuZCBwb3N0LWZpeCBvcHRpb25zIGlmIHRoZXkgaGF2ZSBiZWVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoZml4ZWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGZpeGVkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZml4ZWRPYmogJiYgZml4ZWQucHJlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGZpeGVkLnByZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRkKHNldHRpbmdzLmFhU29ydGluZyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZpeGVkT2JqICYmIGZpeGVkLnBvc3QpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGQoZml4ZWQucG9zdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCA7IGkgPCBuZXN0ZWRTb3J0Lmxlbmd0aCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNyY0NvbCA9IG5lc3RlZFNvcnRbaV1bMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYURhdGFTb3J0ID0gYW9Db2x1bW5zW3NyY0NvbF0uYURhdGFTb3J0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBrTGVuID0gYURhdGFTb3J0Lmxlbmd0aCA7IGsgPCBrTGVuIDsgaysrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDb2wgPSBhRGF0YVNvcnRba107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNUeXBlID0gYW9Db2x1bW5zW2lDb2xdLnNUeXBlIHx8ICdzdHJpbmcnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lc3RlZFNvcnRbaV0uX2lkeCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRTb3J0W2ldLl9pZHggPSAkLmluQXJyYXkobmVzdGVkU29ydFtpXVsxXSwgYW9Db2x1bW5zW2lDb2xdLmFzU29ydGluZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFTb3J0LnB1c2goe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBzcmNDb2wsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGlDb2wsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXI6IG5lc3RlZFNvcnRbaV1bMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbmVzdGVkU29ydFtpXS5faWR4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogc1R5cGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IERhdGFUYWJsZS5leHQudHlwZS5vcmRlcltzVHlwZSArIFwiLXByZVwiXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFTb3J0O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHRvZG8gVGhpcyByZWFsbHkgbmVlZHMgc3BsaXQgdXAhXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0KG9TZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSwgaWVuLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNEYXRhVHlwZSwgblRoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFpT3JpZyA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9FeHRTb3J0ID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYW9Db2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhRGF0YVNvcnQsIGRhdGEsIGlDb2wsIHNUeXBlLCBvU29ydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJzID0gMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzb3J0Q29sLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYXN0ZXIgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFTb3J0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgYW55IGNvbHVtbiB0eXBlcyB0aGF0IGFyZSB1bmtub3duIGR1ZSB0byBhZGRpdGlvbiBvciBpbnZhbGlkYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIENhbiB0aGlzIGJlIG1vdmVkIGludG8gYSAnZGF0YS1yZWFkeScgaGFuZGxlciB3aGljaCBpcyBjYWxsZWQgd2hlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gICBkYXRhIGlzIGdvaW5nIHRvIGJlIHVzZWQgaW4gdGhlIHRhYmxlP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uVHlwZXMob1NldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBhU29ydCA9IF9mblNvcnRGbGF0dGVuKG9TZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gYVNvcnQubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRDb2wgPSBhU29ydFtpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgaWYgd2UgY2FuIHVzZSB0aGUgZmFzdCBzb3J0IGFsZ29yaXRobVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0Q29sLmZvcm1hdHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJzKys7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBkYXRhIG5lZWRlZCBmb3IgdGhlIHNvcnQsIGZvciBlYWNoIGNlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0RGF0YShvU2V0dGluZ3MsIHNvcnRDb2wuY29sKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBObyBzb3J0aW5nIHJlcXVpcmVkIGlmIHNlcnZlci1zaWRlIG9yIG5vIHNvcnRpbmcgYXJyYXkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfZm5EYXRhU291cmNlKG9TZXR0aW5ncykgIT0gJ3NzcCcgJiYgYVNvcnQubGVuZ3RoICE9PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdmFsdWUgLSBrZXkgYXJyYXkgb2YgdGhlIGN1cnJlbnQgcm93IHBvc2l0aW9ucyBzdWNoIHRoYXQgd2UgY2FuIHVzZSB0aGVpclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgcG9zaXRpb24gZHVyaW5nIHRoZSBzb3J0LCBpZiB2YWx1ZXMgbWF0Y2gsIGluIG9yZGVyIHRvIHBlcmZvcm0gc3RhYmxlIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gZGlzcGxheU1hc3Rlci5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhaU9yaWdbZGlzcGxheU1hc3RlcltpXV0gPSBpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogRG8gdGhlIHNvcnQgLSBoZXJlIHdlIHdhbnQgbXVsdGktY29sdW1uIHNvcnRpbmcgYmFzZWQgb24gYSBnaXZlbiBkYXRhIHNvdXJjZSAoY29sdW1uKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGFuZCBzb3J0aW5nIGZ1bmN0aW9uIChmcm9tIG9Tb3J0KSBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiBJdCdzIHJlYXNvbmFibHkgY29tcGxleCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZvbGxvdyBvbiBpdCdzIG93biwgYnV0IHRoaXMgaXMgd2hhdCB3ZSB3YW50IChleGFtcGxlIHR3byBjb2x1bW4gc29ydGluZyk6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIGZuTG9jYWxTb3J0aW5nID0gZnVuY3Rpb24oYSxiKXtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB2YXIgaVRlc3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgaVRlc3QgPSBvU29ydFsnc3RyaW5nLWFzYyddKCdkYXRhMTEnLCAnZGF0YTEyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICBpZiAoaVRlc3QgIT09IDApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiBpVGVzdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICBpVGVzdCA9IG9Tb3J0WydudW1lcmljLWRlc2MnXSgnZGF0YTIxJywgJ2RhdGEyMicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIGlmIChpVGVzdCAhPT0gMClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHJldHVybiBpVGVzdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICByZXR1cm4gb1NvcnRbJ251bWVyaWMtYXNjJ10oIGFpT3JpZ1thXSwgYWlPcmlnW2JdICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBCYXNpY2FsbHkgd2UgaGF2ZSBhIHRlc3QgZm9yIGVhY2ggc29ydGluZyBjb2x1bW4sIGlmIHRoZSBkYXRhIGluIHRoYXQgY29sdW1uIGlzIGVxdWFsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRlc3QgdGhlIG5leHQgY29sdW1uLiBJZiBhbGwgY29sdW1ucyBtYXRjaCwgdGhlbiB3ZSB1c2UgYSBudW1lcmljIHNvcnQgb24gdGhlIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHBvc2l0aW9ucyBpbiB0aGUgb3JpZ2luYWwgZGF0YSBhcnJheSB0byBwcm92aWRlIGEgc3RhYmxlIHNvcnQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIC0gSSBrbm93IGl0IHNlZW1zIGV4Y2Vzc2l2ZSB0byBoYXZlIHR3byBzb3J0aW5nIG1ldGhvZHMsIGJ1dCB0aGUgZmlyc3QgaXMgYXJvdW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogMTUlIGZhc3Rlciwgc28gdGhlIHNlY29uZCBpcyBvbmx5IG1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggc29ydGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIG1ldGhvZHMgd2hpY2ggZG8gbm90IGhhdmUgYSBwcmUtc29ydCBmb3JtYXR0aW5nIGZ1bmN0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZXJzID09PSBhU29ydC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIGZ1bmN0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TWFzdGVyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIGssIHRlc3QsIHNvcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gYVNvcnQubGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUIgPSBhb0RhdGFbYl0uX2FTb3J0RGF0YTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwIDsgayA8IGxlbiA7IGsrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQgPSBhU29ydFtrXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRhdGFBW3NvcnQuY29sXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gZGF0YUJbc29ydC5jb2xdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0ID0geCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3QgIT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvcnQuZGlyID09PSAnYXNjJyA/IHRlc3QgOiAtdGVzdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGFpT3JpZ1thXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBhaU9yaWdbYl07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwcmVjaWF0ZWQgLSByZW1vdmUgaW4gMS4xMSAocHJvdmlkaW5nIGEgcGx1Zy1pbiBvcHRpb24pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhbGwgc29ydCB0eXBlcyBoYXZlIGZvcm1hdHRpbmcgbWV0aG9kcywgc28gd2UgaGF2ZSB0byBjYWxsIHRoZWlyIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hc3Rlci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCBrLCBsLCB0ZXN0LCBzb3J0LCBmbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBhU29ydC5sZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDAgOyBrIDwgbGVuIDsgaysrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydCA9IGFTb3J0W2tdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZGF0YUFbc29ydC5jb2xdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkYXRhQltzb3J0LmNvbF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gb0V4dFNvcnRbc29ydC50eXBlICsgXCItXCIgKyBzb3J0LmRpcl0gfHwgb0V4dFNvcnRbXCJzdHJpbmctXCIgKyBzb3J0LmRpcl07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCA9IGZuKHgsIHkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0ICE9PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYWlPcmlnW2FdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGFpT3JpZ1tiXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4IDwgeSA/IC0xIDogeCA+IHkgPyAxIDogMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFRlbGwgdGhlIGRyYXcgZnVuY3Rpb24gdGhhdCB3ZSBoYXZlIHNvcnRlZCB0aGUgZGF0YSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmJTb3J0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU29ydEFyaWEoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U29ydDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4oc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9BcmlhID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9BcmlhO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFSSUEgYXR0cmlidXRlcyAtIG5lZWQgdG8gbG9vcCBhbGwgY29sdW1ucywgdG8gdXBkYXRlIGFsbCAocmVtb3Zpbmcgb2xkXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGFzIG5lZWRlZClcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY29sdW1ucy5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBjb2x1bW5zW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzVGl0bGUgPSBjb2wuc1RpdGxlLnJlcGxhY2UoLzwuKj8+L2csIFwiXCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aCA9IGNvbC5uVGg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFNyBpcyB0aHJvd2luZyBhbiBlcnJvciB3aGVuIHNldHRpbmcgdGhlc2UgcHJvcGVydGllcyB3aXRoIGpRdWVyeSdzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXR0cigpIGFuZCByZW1vdmVBdHRyKCkgbWV0aG9kcy4uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1zb3J0Jyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEluIEFSSUEgb25seSB0aGUgZmlyc3Qgc29ydGluZyBjb2x1bW4gY2FuIGJlIG1hcmtlZCBhcyBzb3J0aW5nIC0gbm8gbXVsdGktc29ydCBvcHRpb24gKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sLmJTb3J0YWJsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVNvcnQubGVuZ3RoID4gMCAmJiBhU29ydFswXS5jb2wgPT0gaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGguc2V0QXR0cmlidXRlKCdhcmlhLXNvcnQnLCBhU29ydFswXS5kaXIgPT0gXCJhc2NcIiA/IFwiYXNjZW5kaW5nXCIgOiBcImRlc2NlbmRpbmdcIik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U29ydCA9IGFzU29ydGluZ1thU29ydFswXS5pbmRleCArIDFdIHx8IGFzU29ydGluZ1swXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTb3J0ID0gYXNTb3J0aW5nWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHNUaXRsZSArIChuZXh0U29ydCA9PT0gXCJhc2NcIiA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvQXJpYS5zU29ydEFzY2VuZGluZyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvQXJpYS5zU29ydERlc2NlbmRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gc1RpdGxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGguc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9uIHRvIHJ1biBvbiB1c2VyIHNvcnQgcmVxdWVzdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IFthcHBlbmQ9ZmFsc2VdIEFwcGVuZCB0aGUgcmVxdWVzdGVkIHNvcnQgdG8gdGhlIGV4aXN0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIHNvcnQgaWYgdHJ1ZSAoaS5lLiBtdWx0aS1jb2x1bW4gc29ydClcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU29ydExpc3RlbmVyKHNldHRpbmdzLCBjb2xJZHgsIGFwcGVuZCwgY2FsbGJhY2spIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFzU29ydGluZyA9IGNvbC5hc1NvcnRpbmc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFNvcnRJZHg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChhLCBvdmVyZmxvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBhLl9pZHg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9ICQuaW5BcnJheShhWzFdLCBhc1NvcnRpbmcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeCArIDEgPCBhc1NvcnRpbmcubGVuZ3RoID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4ICsgMSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byAyRCBhcnJheSBpZiBuZWVkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc29ydGluZ1swXSA9PT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nID0gW3NvcnRpbmddO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIGFwcGVuZGluZyB0aGUgc29ydCB0aGVuIHdlIGFyZSBtdWx0aS1jb2x1bW4gc29ydGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFwcGVuZCAmJiBzZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnRNdWx0aSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZSB3ZSBhbHJlYWR5IGRvaW5nIHNvbWUga2luZCBvZiBzb3J0IG9uIHRoaXMgY29sdW1uP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0SWR4ID0gJC5pbkFycmF5KGNvbElkeCwgX3BsdWNrKHNvcnRpbmcsICcwJykpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydElkeCAhPT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWWVzLCBtb2RpZnkgdGhlIHNvcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNvcnRJZHggPSBuZXh0KHNvcnRpbmdbc29ydElkeF0sIHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTb3J0SWR4ID09PSBudWxsICYmIHNvcnRpbmcubGVuZ3RoID09PSAxKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U29ydElkeCA9IDA7IC8vIGNhbid0IHJlbW92ZSBzb3J0aW5nIGNvbXBsZXRlbHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTb3J0SWR4ID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nLnNwbGljZShzb3J0SWR4LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbc29ydElkeF1bMV0gPSBhc1NvcnRpbmdbbmV4dFNvcnRJZHhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZ1tzb3J0SWR4XS5faWR4ID0gbmV4dFNvcnRJZHg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHNvcnQgb24gdGhpcyBjb2x1bW4geWV0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmcucHVzaChbY29sSWR4LCBhc1NvcnRpbmdbMF0sIDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZ1tzb3J0aW5nLmxlbmd0aCAtIDFdLl9pZHggPSAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNvcnRpbmcubGVuZ3RoICYmIHNvcnRpbmdbMF1bMF0gPT0gY29sSWR4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luZ2xlIGNvbHVtbiAtIGFscmVhZHkgc29ydGluZyBvbiB0aGlzIGNvbHVtbiwgbW9kaWZ5IHRoZSBzb3J0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNvcnRJZHggPSBuZXh0KHNvcnRpbmdbMF0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nLmxlbmd0aCA9IDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZ1swXVsxXSA9IGFzU29ydGluZ1tuZXh0U29ydElkeF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZ1swXS5faWR4ID0gbmV4dFNvcnRJZHg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUgY29sdW1uIC0gc29ydCBvbmx5IG9uIHRoaXMgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZy5sZW5ndGggPSAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmcucHVzaChbY29sSWR4LCBhc1NvcnRpbmdbMF1dKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nWzBdLl9pZHggPSAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJ1biB0aGUgc29ydCBieSBjYWxsaW5nIGEgZnVsbCByZWRyYXdcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblJlRHJhdyhzZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgdXNlZCBmb3IgYXN5bmMgdXNlciBpbnRlcmFjdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEF0dGFjaCBhIHNvcnQgaGFuZGxlciAoY2xpY2spIHRvIGEgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNvcnRBdHRhY2hMaXN0ZW5lcihzZXR0aW5ncywgYXR0YWNoVG8sIGNvbElkeCwgY2FsbGJhY2spIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5CaW5kQWN0aW9uKGF0dGFjaFRvLCB7fSwgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGUgY29sdW1uIGlzIG5vdCBzb3J0YWJsZSAtIGRvbid0IHRvIGFueXRoaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5iU29ydGFibGUgPT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHByb2Nlc3NpbmcgaXMgZW5hYmxlZCB1c2UgYSB0aW1lb3V0IHRvIGFsbG93IHRoZSBwcm9jZXNzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcGxheSB0byBiZSBzaG93biAtIG90aGVyd2lzZSB0byBpdCBzeW5jaHJvbm91c2x5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9GZWF0dXJlcy5iUHJvY2Vzc2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblNvcnRMaXN0ZW5lcihzZXR0aW5ncywgY29sSWR4LCBlLnNoaWZ0S2V5LCBjYWxsYmFjayk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZywgdGhlIGRyYXcgY2FsbGJhY2sgd2lsbCByZW1vdmUgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9jZXNzaW5nIGRpc3BsYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZm5EYXRhU291cmNlKHNldHRpbmdzKSAhPT0gJ3NzcCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblNvcnRMaXN0ZW5lcihzZXR0aW5ncywgY29sSWR4LCBlLnNoaWZ0S2V5LCBjYWxsYmFjayk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogU2V0IHRoZSBzb3J0aW5nIGNsYXNzZXMgb24gdGFibGUncyBib2R5LCBOb3RlOiBpdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiB3aGVuIGJTb3J0IGFuZCBiU29ydENsYXNzZXMgYXJlIGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNvcnRpbmdDbGFzc2VzKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb2xkU29ydCA9IHNldHRpbmdzLmFMYXN0U29ydDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0Q2xhc3MgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5zU29ydENvbHVtbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGksIGllbiwgY29sSWR4O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iU29ydCAmJiBmZWF0dXJlcy5iU29ydENsYXNzZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2xkIHNvcnRpbmcgY2xhc3Nlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IG9sZFNvcnQubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xJZHggPSBvbGRTb3J0W2ldLnNyYztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjb2x1bW4gc29ydGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKF9wbHVjayhzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4KSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzb3J0Q2xhc3MgKyAoaSA8IDIgPyBpICsgMSA6IDMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgY29sdW1uIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBzb3J0Lmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sSWR4ID0gc29ydFtpXS5zcmM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKF9wbHVjayhzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4KSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhzb3J0Q2xhc3MgKyAoaSA8IDIgPyBpICsgMSA6IDMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYUxhc3RTb3J0ID0gc29ydDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0YSB0byBzb3J0IGEgY29sdW1uLCBiZSBpdCBmcm9tIGNhY2hlLCBmcmVzaCAocG9wdWxhdGluZyB0aGVcclxuXHQgICAgICAgICAgICAgICAgLy8gY2FjaGUpLCBvciBmcm9tIGEgc29ydCBmb3JtYXR0ZXJcclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU29ydERhdGEoc2V0dGluZ3MsIGlkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHNvcnRpbmcgZnVuY3Rpb24gLSBwcm92aWRlZCBieSB0aGUgc29ydCBkYXRhIHR5cGVcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW4gPSBzZXR0aW5ncy5hb0NvbHVtbnNbaWR4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdXN0b21Tb3J0ID0gRGF0YVRhYmxlLmV4dC5vcmRlcltjb2x1bW4uc1NvcnREYXRhVHlwZV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tRGF0YTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY3VzdG9tU29ydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURhdGEgPSBjdXN0b21Tb3J0LmNhbGwoc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgaWR4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZShzZXR0aW5ncywgaWR4KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVXNlIC8gcG9wdWxhdGUgY2FjaGVcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByb3csIGNlbGxEYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlciA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlcltjb2x1bW4uc1R5cGUgKyBcIi1wcmVcIl07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gc2V0dGluZ3MuYW9EYXRhW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdy5fYVNvcnREYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fYVNvcnREYXRhID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdy5fYVNvcnREYXRhW2lkeF0gfHwgY3VzdG9tU29ydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IGN1c3RvbVNvcnQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGF0YVtpXSA6IC8vIElmIHRoZXJlIHdhcyBhIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLCB1c2UgZGF0YSBmcm9tIHRoZXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgaSwgaWR4LCAnc29ydCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9hU29ydERhdGFbaWR4XSA9IGZvcm1hdHRlciA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIoY2VsbERhdGEpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogU2F2ZSB0aGUgc3RhdGUgb2YgYSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5TYXZlU3RhdGUoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub0ZlYXR1cmVzLmJTdGF0ZVNhdmUgfHwgc2V0dGluZ3MuYkRlc3Ryb3lpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogU3RvcmUgdGhlIGludGVyZXN0aW5nIHZhcmlhYmxlcyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogJC5leHRlbmQodHJ1ZSwgW10sIHNldHRpbmdzLmFhU29ydGluZyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoOiBfZm5TZWFyY2hUb0NhbWVsKHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uczogJC5tYXAoc2V0dGluZ3MuYW9Db2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBjb2wuYlZpc2libGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IF9mblNlYXJjaFRvQ2FtZWwoc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzW2ldKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgXCJhb1N0YXRlU2F2ZVBhcmFtc1wiLCAnc3RhdGVTYXZlUGFyYW1zJywgW3NldHRpbmdzLCBzdGF0ZV0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9TYXZlZFN0YXRlID0gc3RhdGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgc3RhdGUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEF0dGVtcHQgdG8gbG9hZCBhIHNhdmVkIHRhYmxlIHN0YXRlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb0luaXQgRGF0YVRhYmxlcyBpbml0IG9iamVjdCBzbyB3ZSBjYW4gb3ZlcnJpZGUgc2V0dGluZ3NcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuTG9hZFN0YXRlKHNldHRpbmdzLCBvSW5pdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGksIGllbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub0ZlYXR1cmVzLmJTdGF0ZVNhdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gc2V0dGluZ3MuZm5TdGF0ZUxvYWRDYWxsYmFjay5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUudGltZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBBbGxvdyBjdXN0b20gYW5kIHBsdWctaW4gbWFuaXB1bGF0aW9uIGZ1bmN0aW9ucyB0byBhbHRlciB0aGUgc2F2ZWQgZGF0YSBzZXQgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjYW5jZWxsaW5nIG9mIGxvYWRpbmcgYnkgcmV0dXJuaW5nIGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhYlN0YXRlTG9hZCA9IF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgJ2FvU3RhdGVMb2FkUGFyYW1zJywgJ3N0YXRlTG9hZFBhcmFtcycsIFtzZXR0aW5ncywgc3RhdGVdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmluQXJyYXkoZmFsc2UsIGFiU3RhdGVMb2FkKSAhPT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogUmVqZWN0IG9sZCBkYXRhICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+IDAgJiYgc3RhdGUudGltZSA8ICtuZXcgRGF0ZSgpIC0gKGR1cmF0aW9uICogMTAwMCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTnVtYmVyIG9mIGNvbHVtbnMgaGF2ZSBjaGFuZ2VkIC0gYWxsIGJldHMgYXJlIG9mZiwgbm8gcmVzdG9yZSBvZiBzZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoICE9PSBzdGF0ZS5jb2x1bW5zLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgc2F2ZWQgc3RhdGUgc28gaXQgbWlnaHQgYmUgYWNjZXNzZWQgYXQgYW55IHRpbWVcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9Mb2FkZWRTdGF0ZSA9ICQuZXh0ZW5kKHRydWUsIHt9LCBzdGF0ZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBrZXkgZmVhdHVyZXMgLSB0b2RvIC0gZm9yIDEuMTEgdGhpcyBuZWVkcyB0byBiZSBkb25lIGJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzdWJzY3JpYmVkIGV2ZW50c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXRlLnN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gc3RhdGUuc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggPSBzdGF0ZS5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gT3JkZXJcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vcmRlciAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHN0YXRlLm9yZGVyLCBmdW5jdGlvbiAoaSwgY29sKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFhU29ydGluZy5wdXNoKGNvbFswXSA+PSBjb2x1bW5zLmxlbmd0aCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMCwgY29sWzFdXSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2hcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgX2ZuU2VhcmNoVG9IdW5nKHN0YXRlLnNlYXJjaCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHN0YXRlLmNvbHVtbnMubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBzdGF0ZS5jb2x1bW5zW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBWaXNpYmlsaXR5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uc1tpXS5iVmlzaWJsZSA9IGNvbC52aXNpYmxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0sIF9mblNlYXJjaFRvSHVuZyhjb2wuc2VhcmNoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAnc3RhdGVMb2FkZWQnLCBbc2V0dGluZ3MsIHN0YXRlXSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUmV0dXJuIHRoZSBzZXR0aW5ncyBvYmplY3QgZm9yIGEgcGFydGljdWxhciB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSB0YWJsZSB0YWJsZSB3ZSBhcmUgdXNpbmcgYXMgYSBkYXRhVGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IFNldHRpbmdzIG9iamVjdCAtIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNldHRpbmdzRnJvbU5vZGUodGFibGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAkLmluQXJyYXkodGFibGUsIF9wbHVjayhzZXR0aW5ncywgJ25UYWJsZScpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4ICE9PSAtMSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NbaWR4XSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBMb2cgYW4gZXJyb3IgbWVzc2FnZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gbGV2ZWwgbG9nIGVycm9yIG1lc3NhZ2VzLCBvciBkaXNwbGF5IHRoZW0gdG8gdGhlIHVzZXJcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBtc2cgZXJyb3IgbWVzc2FnZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHRuIFRlY2huaWNhbCBub3RlIGlkIHRvIGdldCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuTG9nKHNldHRpbmdzLCBsZXZlbCwgbXNnLCB0bikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbXNnID0gJ0RhdGFUYWJsZXMgd2FybmluZzogJyArXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzICE9PSBudWxsID8gJ3RhYmxlIGlkPScgKyBzZXR0aW5ncy5zVGFibGVJZCArICcgLSAnIDogJycpICsgbXNnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0bikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1zZyArPSAnLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yLCBwbGVhc2Ugc2VlICcgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdodHRwOi8vZGF0YXRhYmxlcy5uZXQvdG4vJyArIHRuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbGV2ZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBwcmUgMS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBEYXRhVGFibGUuZXh0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZXh0LnNFcnJNb2RlIHx8IGV4dC5lcnJNb2RlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIG51bGwsICdlcnJvcicsIFtzZXR0aW5ncywgdG4sIG1zZ10pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSAnYWxlcnQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KG1zZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gJ3Rocm93Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlKHNldHRpbmdzLCB0biwgbXNnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogU2VlIGlmIGEgcHJvcGVydHkgaXMgZGVmaW5lZCBvbiBvbmUgb2JqZWN0LCBpZiBzbyBhc3NpZ24gaXQgdG8gdGhlIG90aGVyIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHJldCB0YXJnZXQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc3JjIHNvdXJjZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHByb3BlcnR5XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW21hcHBlZE5hbWVdIG5hbWUgdG8gbWFwIHRvbyAtIG9wdGlvbmFsLCBuYW1lIHVzZWQgaWYgbm90IGdpdmVuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbk1hcChyZXQsIHNyYywgbmFtZSwgbWFwcGVkTmFtZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChuYW1lLCBmdW5jdGlvbiAoaSwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkodmFsKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKHJldCwgc3JjLCB2YWxbMF0sIHZhbFsxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAocmV0LCBzcmMsIHZhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwZWROYW1lID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWROYW1lID0gbmFtZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3JjW25hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXRbbWFwcGVkTmFtZV0gPSBzcmNbbmFtZV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRXh0ZW5kIG9iamVjdHMgLSB2ZXJ5IHNpbWlsYXIgdG8galF1ZXJ5LmV4dGVuZCwgYnV0IGRlZXAgY29weSBvYmplY3RzLCBhbmRcclxuXHQgICAgICAgICAgICAgICAgICogc2hhbGxvdyBjb3B5IGFycmF5cy4gVGhlIHJlYXNvbiB3ZSBuZWVkIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiBkZWVwIGNvcHkgYXJyYXkgaW5pdCB2YWx1ZXMgKHN1Y2ggYXMgYWFTb3J0aW5nKSBzaW5jZSB0aGUgZGV2IHdvdWxkbid0IGJlXHJcblx0ICAgICAgICAgICAgICAgICAqIGFibGUgdG8gb3ZlcnJpZGUgdGhlbSwgYnV0IHdlIGRvIHdhbnQgdG8gZGVlcCBjb3B5IGFycmF5cy5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvdXQgT2JqZWN0IHRvIGV4dGVuZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGV4dGVuZGVyIE9iamVjdCBmcm9tIHdoaWNoIHRoZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYXBwbGllZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgIG91dFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBicmVha1JlZnMgSWYgdHJ1ZSwgdGhlbiBhcnJheXMgd2lsbCBiZSBzbGljZWQgdG8gdGFrZSBhblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgIGluZGVwZW5kZW50IGNvcHkgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBgZGF0YWAgb3IgYGFhRGF0YWAgcGFyYW1ldGVyc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgIGlmIHRoZXkgYXJlIHByZXNlbnQuIFRoaXMgaXMgc28geW91IGNhbiBwYXNzIGluIGEgY29sbGVjdGlvbiB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgIERhdGFUYWJsZXMgYW5kIGhhdmUgdGhhdCB1c2VkIGFzIHlvdXIgZGF0YSBzb3VyY2Ugd2l0aG91dCBicmVha2luZyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogICAgICByZWZlcmVuY2VzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7b2JqZWN0fSBvdXQgUmVmZXJlbmNlLCBqdXN0IGZvciBjb252ZW5pZW5jZSAtIG91dCA9PT0gdGhlIHJldHVybi5cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHRvZG8gVGhpcyBkb2Vzbid0IHRha2UgYWNjb3VudCBvZiBhcnJheXMgaW5zaWRlIHRoZSBkZWVwIGNvcGllZCBvYmplY3RzLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRXh0ZW5kKG91dCwgZXh0ZW5kZXIsIGJyZWFrUmVmcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHZhbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGV4dGVuZGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVyLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGV4dGVuZGVyW3Byb3BdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdCh2YWwpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISQuaXNQbGFpbk9iamVjdChvdXRbcHJvcF0pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W3Byb3BdID0ge307XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvdXRbcHJvcF0sIHZhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYnJlYWtSZWZzICYmIHByb3AgIT09ICdkYXRhJyAmJiBwcm9wICE9PSAnYWFEYXRhJyAmJiAkLmlzQXJyYXkodmFsKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W3Byb3BdID0gdmFsLnNsaWNlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRbcHJvcF0gPSB2YWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBCaW5kIGFuIGV2ZW50IGhhbmRlcnMgdG8gYWxsb3cgYSBjbGljayBvciByZXR1cm4ga2V5IHRvIGFjdGl2YXRlIHRoZSBjYWxsYmFjay5cclxuXHQgICAgICAgICAgICAgICAgICogVGhpcyBpcyBnb29kIGZvciBhY2Nlc3NpYmlsaXR5IHNpbmNlIGEgcmV0dXJuIG9uIHRoZSBrZXlib2FyZCB3aWxsIGhhdmUgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIHNhbWUgZWZmZWN0IGFzIGEgY2xpY2ssIGlmIHRoZSBlbGVtZW50IGhhcyBmb2N1cy5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZWxlbWVudH0gbiBFbGVtZW50IHRvIGJpbmQgdGhlIGFjdGlvbiB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9EYXRhIERhdGEgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIHRyaWdnZXJlZCBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5CaW5kQWN0aW9uKG4sIG9EYXRhLCBmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgJChuKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5iaW5kKCdjbGljay5EVCcsIG9EYXRhLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLmJsdXIoKTsgLy8gUmVtb3ZlIGZvY3VzIG91dGxpbmUgZm9yIG1vdXNlIHVzZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmJpbmQoJ2tleXByZXNzLkRUJywgb0RhdGEsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4oZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5iaW5kKCdzZWxlY3RzdGFydC5EVCcsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGFrZSB0aGUgYnJ1dGFsIGFwcHJvYWNoIHRvIGNhbmNlbGxpbmcgdGV4dCBzZWxlY3Rpb24gKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24uIEVhc2lseSBhbGxvd3MgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBhZGRlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiBhbiBhcnJheSBzdG9yZSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBjYW4gdGhlbiBhbGwgYmUgY2FsbGVkIHRvZ2V0aGVyLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNTdG9yZSBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluIG9TZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIGJhY2tcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzTmFtZSBJZGVudGlmeWluZyBuYW1lIGZvciB0aGUgY2FsbGJhY2sgKGkuZS4gYSBsYWJlbClcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCBzU3RvcmUsIGZuLCBzTmFtZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzW3NTdG9yZV0ucHVzaCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm5cIjogZm4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic05hbWVcIjogc05hbWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBGaXJlIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgdHJpZ2dlciBldmVudHMuIE5vdGUgdGhhdCB0aGUgbG9vcCBvdmVyIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBjYWxsYmFjayBhcnJheSBzdG9yZSBpcyBkb25lIGJhY2t3YXJkcyEgRnVydGhlciBub3RlIHRoYXQgeW91IGRvIG5vdCB3YW50IHRvXHJcblx0ICAgICAgICAgICAgICAgICAqIGZpcmUgb2ZmIHRyaWdnZXJzIGluIHRpbWUgc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyAoZm9yIGV4YW1wbGUgY2VsbCBjcmVhdGlvbilcclxuXHQgICAgICAgICAgICAgICAgICogYXMgaXRzIHNsb3cuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBjYWxsYmFja0FyciBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgb1NldHRpbmdzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgdGhlIGpRdWVyeSBjdXN0b20gZXZlbnQgdG8gdHJpZ2dlci4gSWZcclxuXHQgICAgICAgICAgICAgICAgICogICAgICBudWxsIG5vIHRyaWdnZXIgaXMgZmlyZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIC9cclxuXHQgICAgICAgICAgICAgICAgICogICAgICB0cmlnZ2VyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgY2FsbGJhY2tBcnIsIGV2ZW50TmFtZSwgYXJncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja0Fycikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9ICQubWFwKHNldHRpbmdzW2NhbGxiYWNrQXJyXS5zbGljZSgpLnJldmVyc2UoKSwgZnVuY3Rpb24gKHZhbCwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmZuLmFwcGx5KHNldHRpbmdzLm9JbnN0YW5jZSwgYXJncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlID0gJC5FdmVudChldmVudE5hbWUgKyAnLmR0Jyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS50cmlnZ2VyKGUsIGFyZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXQucHVzaChlLnJlc3VsdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkxlbmd0aE92ZXJmbG93KHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBJZiB3ZSBoYXZlIHNwYWNlIHRvIHNob3cgZXh0cmEgcm93cyAoYmFja2luZyB1cCBmcm9tIHRoZSBlbmQgcG9pbnQgLSB0aGVuIGRvIHNvICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgLSBsZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgc3RhcnQgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0IC09IChzdGFydCAlIGxlbik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA9PT0gLTEgfHwgc3RhcnQgPCAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5SZW5kZXJlcihzZXR0aW5ncywgdHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gc2V0dGluZ3MucmVuZGVyZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdCA9IERhdGFUYWJsZS5leHQucmVuZGVyZXJbdHlwZV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChyZW5kZXJlcikgJiYgcmVuZGVyZXJbdHlwZV0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWZpYyByZW5kZXJlciBmb3IgdGhpcyB0eXBlLiBJZiBhdmFpbGFibGUgdXNlIGl0LCBvdGhlcndpc2UgdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RbcmVuZGVyZXJbdHlwZV1dIHx8IGhvc3QuXztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZW5kZXJlciA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21tb24gcmVuZGVyZXIgLSBpZiB0aGVyZSBpcyBvbmUgYXZhaWxhYmxlIGZvciB0aGlzIHR5cGUgdXNlIGl0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG9zdFtyZW5kZXJlcl0gfHwgaG9zdC5fO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVmYXVsdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3QuXztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEZXRlY3QgdGhlIGRhdGEgc291cmNlIGJlaW5nIHVzZWQgZm9yIHRoZSB0YWJsZS4gVXNlZCB0byBzaW1wbGlmeSB0aGUgY29kZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBhIGxpdHRsZSAoYWpheCkgYW5kIHRvIG1ha2UgaXQgY29tcHJlc3MgYSBsaXR0bGUgc21hbGxlci5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gRGF0YSBzb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9GZWF0dXJlcy5iU2VydmVyU2lkZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnc3NwJztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLmFqYXggfHwgc2V0dGluZ3Muc0FqYXhTb3VyY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2FqYXgnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdkb20nO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUGVyZm9ybSBhIGpRdWVyeSBzZWxlY3RvciBhY3Rpb24gb24gdGhlIHRhYmxlJ3MgVFIgZWxlbWVudHMgKGZyb20gdGhlIHRib2R5KSBhbmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJldHVybiB0aGUgcmVzdWx0aW5nIGpRdWVyeSBvYmplY3QuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMuZmlsdGVyPW5vbmVdIFNlbGVjdCBUUiBlbGVtZW50cyB0aGF0IG1lZXQgdGhlIGN1cnJlbnQgZmlsdGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgVFIgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBUUiBlbGVtZW50cyBpbiB0aGUgcHJvY2Vzc2VkIGFycmF5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICdvcmlnaW5hbCcgd2hlcmVieSB0aGUgb3JpZ2luYWwgb3JkZXIgdGhlIGRhdGEgd2FzIHJlYWQgaW50byB0aGUgdGFibGUgaXMgdXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLnBhZ2U9YWxsXSBMaW1pdCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICdjdXJyZW50JyBhbmQgZmlsdGVyIGlzICdhcHBsaWVkJywgcmVnYXJkbGVzcyBvZiB3aGF0IHRoZXkgbWlnaHQgYmUgZ2l2ZW4gYXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge29iamVjdH0galF1ZXJ5IG9iamVjdCwgZmlsdGVyZWQgYnkgdGhlIGdpdmVuIHNlbGVjdG9yLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gSGlnaGxpZ2h0IGV2ZXJ5IHNlY29uZCByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLiQoJ3RyOm9kZCcpLmNzcygnYmFja2dyb3VuZENvbG9yJywgJ2JsdWUnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIEZpbHRlciB0byByb3dzIHdpdGggJ1dlYmtpdCcgaW4gdGhlbSwgYWRkIGEgYmFja2dyb3VuZCBjb2xvdXIgYW5kIHRoZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gcmVtb3ZlIHRoZSBmaWx0ZXIsIHRodXMgaGlnaGxpZ2h0aW5nIHRoZSAnV2Via2l0JyByb3dzIG9ubHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignV2Via2l0Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0cicsIHtcInNlYXJjaFwiOiBcImFwcGxpZWRcIn0pLmNzcygnYmFja2dyb3VuZENvbG9yJywgJ2JsdWUnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gZnVuY3Rpb24gKHNTZWxlY3Rvciwgb09wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcGkodHJ1ZSkuJChzU2VsZWN0b3IsIG9PcHRzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQWxtb3N0IGlkZW50aWNhbCB0byAkIGluIG9wZXJhdGlvbiwgYnV0IGluIHRoaXMgY2FzZSByZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgbWF0Y2hlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcm93cyAtIGFzIHN1Y2gsIHRoZSBqUXVlcnkgc2VsZWN0b3IgdXNlZCBzaG91bGQgbWF0Y2ggVFIgcm93IG5vZGVzIG9yIFREL1RIIGNlbGwgbm9kZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJhdGhlciB0aGFuIGFueSBkZXNjZW5kYW50cywgc28gdGhlIGRhdGEgY2FuIGJlIG9idGFpbmVkIGZvciB0aGUgcm93L2NlbGwuIElmIG1hdGNoaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByb3dzIGFyZSBmb3VuZCwgdGhlIGRhdGEgcmV0dXJuZWQgaXMgdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkvb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNyZWF0ZSB0aGUgcm93IChvciBhIGdlbmVyYXRlZCBhcnJheSBpZiBmcm9tIGEgRE9NIHNvdXJjZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2QgaXMgb2Z0ZW4gdXNlZnVsIGluLWNvbWJpbmF0aW9uIHdpdGggJCB3aGVyZSBib3RoIGZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzYW1lIHBhcmFtZXRlcnMgYW5kIHRoZSBhcnJheSBpbmRleGVzIHdpbGwgbWF0Y2ggaWRlbnRpY2FsbHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMuZmlsdGVyPW5vbmVdIFNlbGVjdCBlbGVtZW50cyB0aGF0IG1lZXQgdGhlIGN1cnJlbnQgZmlsdGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBkYXRhIGluIHRoZSBwcm9jZXNzZWQgYXJyYXkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJ29yaWdpbmFsJyB3aGVyZWJ5IHRoZSBvcmlnaW5hbCBvcmRlciB0aGUgZGF0YSB3YXMgcmVhZCBpbnRvIHRoZSB0YWJsZSBpcyB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMucGFnZT1hbGxdIExpbWl0IHRoZSBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgcGFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJ2N1cnJlbnQnIGFuZCBmaWx0ZXIgaXMgJ2FwcGxpZWQnLCByZWdhcmRsZXNzIG9mIHdoYXQgdGhleSBtaWdodCBiZSBnaXZlbiBhcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IERhdGEgZm9yIHRoZSBtYXRjaGVkIGVsZW1lbnRzLiBJZiBhbnkgZWxlbWVudHMsIGFzIGEgcmVzdWx0IG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgc2VsZWN0b3IsIHdlcmUgbm90IFRSLCBURCBvciBUSCBlbGVtZW50cyBpbiB0aGUgRGF0YVRhYmxlLCB0aGV5IHdpbGwgaGF2ZSBhIG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGVudHJ5IGluIHRoZSBhcnJheS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBmaXJzdCByb3cgaW4gdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBkYXRhID0gb1RhYmxlLl8oJ3RyOmZpcnN0Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBEbyBzb21ldGhpbmcgdXNlZnVsIHdpdGggdGhlIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYWxlcnQoIFwiRmlyc3QgY2VsbCBpczogXCIrZGF0YVswXSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gRmlsdGVyIHRvICdXZWJraXQnIGFuZCBnZXQgYWxsIGRhdGEgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignV2Via2l0Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBkYXRhID0gb1RhYmxlLl8oJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBhbGVydCggZGF0YS5sZW5ndGgrXCIgcm93cyBtYXRjaGVkIHRoZSBzZWFyY2hcIiApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl8gPSBmdW5jdGlvbiAoc1NlbGVjdG9yLCBvT3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaSh0cnVlKS5yb3dzKHNTZWxlY3Rvciwgb09wdHMpLmRhdGEoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ3JlYXRlIGEgRGF0YVRhYmxlcyBBcGkgaW5zdGFuY2UsIHdpdGggdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0YWJsZXMgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgQXBpJ3MgY29udGV4dC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyYWRpdGlvbmFsPWZhbHNlXSBTZXQgdGhlIEFQSSBpbnN0YW5jZSdzIGNvbnRleHQgdG8gYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgb25seSB0aGUgdGFibGUgcmVmZXJyZWQgdG8gYnkgdGhlIGBEYXRhVGFibGUuZXh0LmlBcGlJbmRleGAgb3B0aW9uLCBhcyB3YXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgdXNlZCBpbiB0aGUgQVBJIHByZXNlbnRlZCBieSBEYXRhVGFibGVzIDEuOS0gKGkuZS4gdGhlIHRyYWRpdGlvbmFsIG1vZGUpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBvciBpZiBhbGwgdGFibGVzIGNhcHR1cmVkIGluIHRoZSBqUXVlcnkgb2JqZWN0IHNob3VsZCBiZSB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7RGF0YVRhYmxlcy5BcGl9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBpID0gZnVuY3Rpb24gKHRyYWRpdGlvbmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWRpdGlvbmFsID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5TZXR0aW5nc0Zyb21Ob2RlKHRoaXNbX2V4dC5pQXBpSW5kZXhdKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICApIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkodGhpcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFkZCBhIHNpbmdsZSBuZXcgcm93IG9yIG11bHRpcGxlIHJvd3Mgb2YgZGF0YSB0byB0aGUgdGFibGUuIFBsZWFzZSBub3RlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHRoaXMgaXMgc3VpdGFibGUgZm9yIGNsaWVudC1zaWRlIHByb2Nlc3Npbmcgb25seSAtIGlmIHlvdSBhcmUgdXNpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgKGkuZS4gXCJiU2VydmVyU2lkZVwiOiB0cnVlKSwgdGhlbiB0byBhZGQgZGF0YSwgeW91XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBtdXN0IGFkZCBpdCB0byB0aGUgZGF0YSBzb3VyY2UsIGkuZS4gdGhlIHNlcnZlci1zaWRlLCB0aHJvdWdoIGFuIEFqYXggY2FsbC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gZGF0YSBUaGUgZGF0YSB0byBiZSBhZGRlZCB0byB0aGUgdGFibGUuIFRoaXMgY2FuIGJlOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgPHVsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICA8bGk+MUQgYXJyYXkgb2YgZGF0YSAtIGFkZCBhIHNpbmdsZSByb3cgd2l0aCB0aGUgZGF0YSBwcm92aWRlZDwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxsaT4yRCBhcnJheSBvZiBhcnJheXMgLSBhZGQgbXVsdGlwbGUgcm93cyBpbiBhIHNpbmdsZSBjYWxsPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgPGxpPm9iamVjdCAtIGRhdGEgb2JqZWN0IHdoZW4gdXNpbmcgPGk+bURhdGE8L2k+PC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgPGxpPmFycmF5IG9mIG9iamVjdHMgLSBtdWx0aXBsZSBkYXRhIG9iamVjdHMgd2hlbiB1c2luZyA8aT5tRGF0YTwvaT48L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgPC91bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtyZWRyYXc9dHJ1ZV0gcmVkcmF3IHRoZSB0YWJsZSBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IEFuIGFycmF5IG9mIGludGVnZXJzLCByZXByZXNlbnRpbmcgdGhlIGxpc3Qgb2YgaW5kZXhlcyBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgPGk+YW9EYXRhPC9pPiAoe0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfSkgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHRoZSB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIEdsb2JhbCB2YXIgZm9yIGNvdW50ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHZhciBnaUNvdW50ID0gMjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBmdW5jdGlvbiBmbkNsaWNrQWRkUm93KCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmZuQWRkRGF0YSggW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGdpQ291bnQrXCIuMVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGdpQ291bnQrXCIuMlwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGdpQ291bnQrXCIuM1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGdpQ291bnQrXCIuNFwiIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGdpQ291bnQrKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mbkFkZERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgcmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDaGVjayBpZiB3ZSB3YW50IHRvIGFkZCBtdWx0aXBsZSByb3dzIG9yIG5vdCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gJC5pc0FycmF5KGRhdGEpICYmICgkLmlzQXJyYXkoZGF0YVswXSkgfHwgJC5pc1BsYWluT2JqZWN0KGRhdGFbMF0pKSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5yb3dzLmFkZChkYXRhKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5yb3cuYWRkKGRhdGEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5kcmF3KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93cy5mbGF0dGVuKCkudG9BcnJheSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgbWFrZSBEYXRhVGFibGVzIHJlY2FsY3VsYXRlIHRoZSBjb2x1bW4gc2l6ZXMsIGJhc2VkIG9uIHRoZSBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjb250YWluZWQgaW4gdGhlIHRhYmxlIGFuZCB0aGUgc2l6ZXMgYXBwbGllZCB0byB0aGUgY29sdW1ucyAoaW4gdGhlIERPTSwgQ1NTIG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aHJvdWdoIHRoZSBzV2lkdGggcGFyYW1ldGVyKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gdGhlIHdpZHRoIG9mIHRoZSB0YWJsZSdzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwYXJlbnQgZWxlbWVudCBjaGFuZ2VzIChmb3IgZXhhbXBsZSBhIHdpbmRvdyByZXNpemUpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3QsIHlvdSB3aWxsIHR5cGljYWxseSB3YW50IHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzU2Nyb2xsWVwiOiBcIjIwMHB4XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJiUGFnaW5hdGVcIjogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCh3aW5kb3cpLmJpbmQoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBvVGFibGUuZm5BZGp1c3RDb2x1bW5TaXppbmcoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuQWRqdXN0Q29sdW1uU2l6aW5nID0gZnVuY3Rpb24gKGJSZWRyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSkuY29sdW1ucy5hZGp1c3QoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBhcGkuc2V0dGluZ3MoKVswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5kcmF3KGZhbHNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsLnNYICE9PSBcIlwiIHx8IHNjcm9sbC5zWSAhPT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiBub3QgcmVkcmF3aW5nLCBidXQgc2Nyb2xsaW5nLCB3ZSB3YW50IHRvIGFwcGx5IHRoZSBuZXcgY29sdW1uIHNpemVzIGFueXdheSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5TY3JvbGxEcmF3KHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFF1aWNrbHkgYW5kIHNpbXBseSBjbGVhciBhIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSByZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gSW1tZWRpYXRlbHkgJ251a2UnIHRoZSBjdXJyZW50IHJvd3MgKHBlcmhhcHMgd2FpdGluZyBmb3IgYW4gQWpheCBjYWxsYmFjay4uLilcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuQ2xlYXJUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuQ2xlYXJUYWJsZSA9IGZ1bmN0aW9uIChiUmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpLmNsZWFyKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGV4YWN0IG9wcG9zaXRlIG9mICdvcGVuaW5nJyBhIHJvdywgdGhpcyBmdW5jdGlvbiB3aWxsIGNsb3NlIGFueSByb3dzIHdoaWNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhcmUgY3VycmVudGx5ICdvcGVuJy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5UciB0aGUgdGFibGUgcm93IHRvICdjbG9zZSdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSAwIG9uIHN1Y2Nlc3MsIG9yIDEgaWYgZmFpbGVkIChjYW4ndCBmaW5kIHRoZSByb3cpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuQ2xvc2UgPSBmdW5jdGlvbiAoblRyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcGkodHJ1ZSkucm93KG5UcikuY2hpbGQuaGlkZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBSZW1vdmUgYSByb3cgZm9yIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bWl4ZWR9IHRhcmdldCBUaGUgaW5kZXggb2YgdGhlIHJvdyBmcm9tIGFvRGF0YSB0byBiZSBkZWxldGVkLCBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgdGhlIFRSIGVsZW1lbnQgeW91IHdhbnQgdG8gZGVsZXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbnxudWxsfSBbY2FsbEJhY2tdIENhbGxiYWNrIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBUaGUgcm93IHRoYXQgd2FzIGRlbGV0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgZmlyc3Qgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkRlbGV0ZVJvdyggMCApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuRGVsZXRlUm93ID0gZnVuY3Rpb24gKHRhcmdldCwgY2FsbGJhY2ssIHJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IGFwaS5yb3dzKHRhcmdldCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gcm93cy5zZXR0aW5ncygpWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd3NbMF1bMF1dO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3dzLnJlbW92ZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncywgZGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVkcmF3ID09PSB1bmRlZmluZWQgfHwgcmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5kcmF3KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUmVzdG9yZSB0aGUgdGFibGUgdG8gaXQncyBvcmlnaW5hbCBzdGF0ZSBpbiB0aGUgRE9NIGJ5IHJlbW92aW5nIGFsbCBvZiBEYXRhVGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlbmhhbmNlbWVudHMsIGFsdGVyYXRpb25zIHRvIHRoZSBET00gc3RydWN0dXJlIG9mIHRoZSB0YWJsZSBhbmQgZXZlbnQgbGlzdGVuZXJzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZT1mYWxzZV0gQ29tcGxldGVseSByZW1vdmUgdGhlIHRhYmxlIGZyb20gdGhlIERPTVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIFRoaXMgZXhhbXBsZSBpcyBmYWlybHkgcG9pbnRsZXNzIGluIHJlYWxpdHksIGJ1dCBzaG93cyBob3cgZm5EZXN0cm95IGNhbiBiZSB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5EZXN0cm95KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5EZXN0cm95ID0gZnVuY3Rpb24gKHJlbW92ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBpKHRydWUpLmRlc3Ryb3kocmVtb3ZlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUmVkcmF3IHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2NvbXBsZXRlPXRydWVdIFJlLWZpbHRlciBhbmQgcmVzb3J0IChpZiBlbmFibGVkKSB0aGUgdGFibGUgYmVmb3JlIHRoZSBkcmF3LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gUmUtZHJhdyB0aGUgdGFibGUgLSB5b3Ugd291bGRuJ3Qgd2FudCB0byBkbyBpdCBoZXJlLCBidXQgaXQncyBhbiBleGFtcGxlIDotKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5EcmF3KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5EcmF3ID0gZnVuY3Rpb24gKGNvbXBsZXRlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXNuJ3QgYW4gZXhhY3QgbWF0Y2ggdG8gdGhlIG9sZCBjYWxsIHRvIF9mbkRyYXcgLSBpdCB0YWtlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludG8gYWNjb3VudCB0aGUgbmV3IGRhdGEsIGJ1dCBjYW4gaG9sZCBwb3NpdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwaSh0cnVlKS5kcmF3KGNvbXBsZXRlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRmlsdGVyIHRoZSBpbnB1dCBiYXNlZCBvbiBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNJbnB1dCBTdHJpbmcgdG8gZmlsdGVyIHRoZSB0YWJsZSBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fG51bGx9IFtpQ29sdW1uXSBDb2x1bW4gdG8gbGltaXQgZmlsdGVyaW5nIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlJlZ2V4PWZhbHNlXSBUcmVhdCBhcyByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlNtYXJ0PXRydWVdIFBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JTaG93R2xvYmFsPXRydWVdIFNob3cgdGhlIGlucHV0IGdsb2JhbCBmaWx0ZXIgaW4gaXQncyBpbnB1dCBib3goZXMpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYkNhc2VJbnNlbnNpdGl2ZT10cnVlXSBEbyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gU29tZXRpbWUgbGF0ZXIgLSBmaWx0ZXIuLi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCAndGVzdCBzdHJpbmcnICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5GaWx0ZXIgPSBmdW5jdGlvbiAoc0lucHV0LCBpQ29sdW1uLCBiUmVnZXgsIGJTbWFydCwgYlNob3dHbG9iYWwsIGJDYXNlSW5zZW5zaXRpdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpQ29sdW1uID09PSBudWxsIHx8IGlDb2x1bW4gPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2VhcmNoKHNJbnB1dCwgYlJlZ2V4LCBiU21hcnQsIGJDYXNlSW5zZW5zaXRpdmUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmNvbHVtbihpQ29sdW1uKS5zZWFyY2goc0lucHV0LCBiUmVnZXgsIGJTbWFydCwgYkNhc2VJbnNlbnNpdGl2ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGRhdGEgZm9yIHRoZSB3aG9sZSB0YWJsZSwgYW4gaW5kaXZpZHVhbCByb3cgb3IgYW4gaW5kaXZpZHVhbCBjZWxsIGJhc2VkIG9uIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcHJvdmlkZWQgcGFyYW1ldGVycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludHxub2RlfSBbc3JjXSBBIFRSIHJvdyBub2RlLCBURC9USCBjZWxsIG5vZGUgb3IgYW4gaW50ZWdlci4gSWYgZ2l2ZW4gYXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGEgVFIgbm9kZSB0aGVuIHRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHdob2xlIHJvdyB3aWxsIGJlIHJldHVybmVkLiBJZiBnaXZlbiBhcyBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBURC9USCBjZWxsIG5vZGUgdGhlbiBpQ29sIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB0aGUgZGF0YSBmb3IgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBjZWxsIHJldHVybmVkLiBJZiBnaXZlbiBhcyBhbiBpbnRlZ2VyLCB0aGVuIHRoaXMgaXMgdHJlYXRlZCBhcyB0aGUgYW9EYXRhIGludGVybmFsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBkYXRhIGluZGV4IGZvciB0aGUgcm93IChzZWUgZm5HZXRQb3NpdGlvbikgYW5kIHRoZSBkYXRhIGZvciB0aGF0IHJvdyB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBbY29sXSBPcHRpb25hbCBjb2x1bW4gaW5kZXggdGhhdCB5b3Ugd2FudCB0aGUgZGF0YSBvZi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl8b2JqZWN0fHN0cmluZ30gSWYgbVJvdyBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIGRhdGEgZm9yIGFsbCByb3dzIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICByZXR1cm5lZC4gSWYgbVJvdyBpcyBkZWZpbmVkLCBqdXN0IGRhdGEgZm9yIHRoYXQgcm93LCBhbmQgaXMgaUNvbCBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGVmaW5lZCwgb25seSBkYXRhIGZvciB0aGUgZGVzaWduYXRlZCBjZWxsIGlzIHJldHVybmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gUm93IGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLiQoJ3RyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB2YXIgZGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIHRoaXMgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAvLyAuLi4gZG8gc29tZXRoaW5nIHdpdGggdGhlIGFycmF5IC8gb2JqZWN0IG9mIGRhdGEgZm9yIHRoZSByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gSW5kaXZpZHVhbCBjZWxsIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLiQoJ3RkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB2YXIgc0RhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgYWxlcnQoICdUaGUgY2VsbCBjbGlja2VkIG9uIGhhZCB0aGUgdmFsdWUgb2YgJytzRGF0YSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5HZXREYXRhID0gZnVuY3Rpb24gKHNyYywgY29sKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3JjICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBzcmMubm9kZU5hbWUgPyBzcmMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6ICcnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbCAhPT0gdW5kZWZpbmVkIHx8IHR5cGUgPT0gJ3RkJyB8fCB0eXBlID09ICd0aCcgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmNlbGwoc3JjLCBjb2wpLmRhdGEoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkucm93KHNyYykuZGF0YSgpIHx8IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpLmRhdGEoKS50b0FycmF5KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEdldCBhbiBhcnJheSBvZiB0aGUgVFIgbm9kZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUncyBib2R5LiBOb3RlIHRoYXQgeW91IHdpbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHR5cGljYWxseSB3YW50IHRvIHVzZSB0aGUgJyQnIEFQSSBtZXRob2QgaW4gcHJlZmVyZW5jZSB0byB0aGlzIGFzIGl0IGlzIG1vcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZsZXhpYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBbaVJvd10gT3B0aW9uYWwgcm93IGluZGV4IGZvciB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHthcnJheXxub2RlfSBJZiBpUm93IGlzIHVuZGVmaW5lZCwgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgVFIgZWxlbWVudHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGluIHRoZSB0YWJsZSdzIGJvZHksIG9yIGlSb3cgaXMgZGVmaW5lZCwganVzdCB0aGUgVFIgZWxlbWVudCByZXF1ZXN0ZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBHZXQgdGhlIG5vZGVzIGZyb20gdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBuTm9kZXMgPSBvVGFibGUuZm5HZXROb2RlcyggKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mbkdldE5vZGVzID0gZnVuY3Rpb24gKGlSb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpUm93ICE9PSB1bmRlZmluZWQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkucm93KGlSb3cpLm5vZGUoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5yb3dzKCkubm9kZXMoKS5mbGF0dGVuKCkudG9BcnJheSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGFycmF5IGluZGV4ZXMgb2YgYSBwYXJ0aWN1bGFyIGNlbGwgZnJvbSBpdCdzIERPTSBlbGVtZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbmQgY29sdW1uIGluZGV4IGluY2x1ZGluZyBoaWRkZW4gY29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbm9kZSB0aGlzIGNhbiBlaXRoZXIgYmUgYSBUUiwgVEQgb3IgVEggaW4gdGhlIHRhYmxlJ3MgYm9keVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IElmIG5Ob2RlIGlzIGdpdmVuIGFzIGEgVFIsIHRoZW4gYSBzaW5nbGUgaW5kZXggaXMgcmV0dXJuZWQsIG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBpZiBnaXZlbiBhcyBhIGNlbGwsIGFuIGFycmF5IG9mIFtyb3cgaW5kZXgsIGNvbHVtbiBpbmRleCAodmlzaWJsZSksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBjb2x1bW4gaW5kZXggKGFsbCldIGlzIGdpdmVuLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGRhdGEgZnJvbSB0aGUgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHZhciBhUG9zID0gb1RhYmxlLmZuR2V0UG9zaXRpb24oIHRoaXMgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHZhciBhRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIGFQb3NbMF0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgLy8gVXBkYXRlIHRoZSBkYXRhIGFycmF5IGFuZCByZXR1cm4gdGhlIHZhbHVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgYURhdGFbIGFQb3NbMV0gXSA9ICdjbGlja2VkJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB0aGlzLmlubmVySFRNTCA9ICdjbGlja2VkJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gSW5pdCBEYXRhVGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5HZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09ICdUUicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5yb3cobm9kZSkuaW5kZXgoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gJ1REJyB8fCBub2RlTmFtZSA9PSAnVEgnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gYXBpLmNlbGwobm9kZSkuaW5kZXgoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnJvdyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY29sdW1uVmlzaWJsZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDaGVjayB0byBzZWUgaWYgYSByb3cgaXMgJ29wZW4nIG9yIG5vdC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5UciB0aGUgdGFibGUgcm93IHRvIGNoZWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHJvdyBpcyBjdXJyZW50bHkgb3BlbiwgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuSXNPcGVuID0gZnVuY3Rpb24gKG5Ucikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaSh0cnVlKS5yb3coblRyKS5jaGlsZC5pc1Nob3duKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwbGFjZSBhIG5ldyByb3cgZGlyZWN0bHkgYWZ0ZXIgYSByb3cgd2hpY2ggaXMgY3VycmVudGx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLCB3aXRoIHRoZSBIVE1MIGNvbnRlbnRzIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGFzayBmb3IgY29uZmlybWF0aW9uIHRoYXQgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcGFydGljdWxhciByZWNvcmQgc2hvdWxkIGJlIGRlbGV0ZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVHIgVGhlIHRhYmxlIHJvdyB0byAnb3BlbidcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gbUh0bWwgVGhlIEhUTUwgdG8gcHV0IGludG8gdGhlIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzQ2xhc3MgQ2xhc3MgdG8gZ2l2ZSB0aGUgbmV3IFREIGNlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gVGhlIHJvdyBvcGVuZWQuIE5vdGUgdGhhdCBpZiB0aGUgdGFibGUgcm93IHBhc3NlZCBpbiBhcyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGZpcnN0IHBhcmFtZXRlciwgaXMgbm90IGZvdW5kIGluIHRoZSB0YWJsZSwgdGhpcyBtZXRob2Qgd2lsbCBzaWxlbnRseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgcmV0dXJuLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mbk9wZW4gPSBmdW5jdGlvbiAoblRyLCBtSHRtbCwgc0NsYXNzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpKHRydWUpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yb3coblRyKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2hpbGQobUh0bWwsIHNDbGFzcylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNob3coKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2hpbGQoKVswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2hhbmdlIHRoZSBwYWdpbmF0aW9uIC0gcHJvdmlkZXMgdGhlIGludGVybmFsIGxvZ2ljIGZvciBwYWdpbmF0aW9uIGluIGEgc2ltcGxlIEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZnVuY3Rpb24uIFdpdGggdGhpcyBmdW5jdGlvbiB5b3UgY2FuIGhhdmUgYSBEYXRhVGFibGVzIHRhYmxlIGdvIHRvIHRoZSBuZXh0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcHJldmlvdXMsIGZpcnN0IG9yIGxhc3QgcGFnZXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd8aW50fSBtQWN0aW9uIFBhZ2luZyBhY3Rpb24gdG8gdGFrZTogXCJmaXJzdFwiLCBcInByZXZpb3VzXCIsIFwibmV4dFwiIG9yIFwibGFzdFwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBvciBwYWdlIG51bWJlciB0byBqdW1wIHRvIChpbnRlZ2VyKSwgbm90ZSB0aGF0IHBhZ2UgMCBpcyB0aGUgZmlyc3QgcGFnZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblBhZ2VDaGFuZ2UoICduZXh0JyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuUGFnZUNoYW5nZSA9IGZ1bmN0aW9uIChtQWN0aW9uLCBiUmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpLnBhZ2UobUFjdGlvbik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdyhmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTaG93IGEgcGFydGljdWxhciBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaUNvbCBUaGUgY29sdW1uIHdob3NlIGRpc3BsYXkgc2hvdWxkIGJlIGNoYW5nZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJTaG93IFNob3cgKHRydWUpIG9yIGhpZGUgKGZhbHNlKSB0aGUgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gSGlkZSB0aGUgc2Vjb25kIGNvbHVtbiBhZnRlciBpbml0aWFsaXNhdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5TZXRDb2x1bW5WaXMoIDEsIGZhbHNlICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5TZXRDb2x1bW5WaXMgPSBmdW5jdGlvbiAoaUNvbCwgYlNob3csIGJSZWRyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSkuY29sdW1uKGlDb2wpLnZpc2libGUoYlNob3cpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmNvbHVtbnMuYWRqdXN0KCkuZHJhdygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogR2V0IHRoZSBzZXR0aW5ncyBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlIGZvciBleHRlcm5hbCBtYW5pcHVsYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7b2JqZWN0fSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdC4gU2VlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvU2V0dGluZ3MgPSBvVGFibGUuZm5TZXR0aW5ncygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gU2hvdyBhbiBleGFtcGxlIHBhcmFtZXRlciBmcm9tIHRoZSBzZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBhbGVydCggb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5TZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuU2V0dGluZ3NGcm9tTm9kZSh0aGlzW19leHQuaUFwaUluZGV4XSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNvcnQgdGhlIHRhYmxlIGJ5IGEgcGFydGljdWxhciBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaUNvbCB0aGUgZGF0YSBpbmRleCB0byBzb3J0IG9uLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBtYXRjaCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICdkaXNwbGF5IGluZGV4JyBpZiB5b3UgaGF2ZSBoaWRkZW4gZGF0YSBlbnRyaWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBTb3J0IGltbWVkaWF0ZWx5IHdpdGggY29sdW1ucyAwIGFuZCAxXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblNvcnQoIFsgWzAsJ2FzYyddLCBbMSwnYXNjJ10gXSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuU29ydCA9IGZ1bmN0aW9uIChhYVNvcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwaSh0cnVlKS5vcmRlcihhYVNvcnQpLmRyYXcoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbk5vZGUgdGhlIGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBzb3J0IGxpc3RlbmVyIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2x1bW4gdGhlIGNvbHVtbiB0aGF0IGEgY2xpY2sgb24gdGhpcyBub2RlIHdpbGwgc29ydCBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IFtmbkNhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBTb3J0IG9uIGNvbHVtbiAxLCB3aGVuICdzb3J0ZXInIGlzIGNsaWNrZWQgb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuU29ydExpc3RlbmVyKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc29ydGVyJyksIDEgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mblNvcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjaykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBpKHRydWUpLm9yZGVyLmxpc3RlbmVyKG5Ob2RlLCBpQ29sdW1uLCBmbkNhbGxiYWNrKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVXBkYXRlIGEgdGFibGUgY2VsbCBvciByb3cgLSB0aGlzIG1ldGhvZCB3aWxsIGFjY2VwdCBlaXRoZXIgYSBzaW5nbGUgdmFsdWUgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHVwZGF0ZSB0aGUgY2VsbCB3aXRoLCBhbiBhcnJheSBvZiB2YWx1ZXMgd2l0aCBvbmUgZWxlbWVudCBmb3IgZWFjaCBjb2x1bW4gb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFuIG9iamVjdCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlLiBUaGUgZnVuY3Rpb24gaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNlbGYtcmVmZXJlbmNpbmcgaW4gb3JkZXIgdG8gbWFrZSB0aGUgbXVsdGkgY29sdW1uIHVwZGF0ZXMgZWFzaWVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fGFycmF5fHN0cmluZ30gbURhdGEgRGF0YSB0byB1cGRhdGUgdGhlIGNlbGwvcm93IHdpdGhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV8aW50fSBtUm93IFRSIGVsZW1lbnQgeW91IHdhbnQgdG8gdXBkYXRlIG9yIHRoZSBhb0RhdGEgaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gW2lDb2x1bW5dIFRoZSBjb2x1bW4gdG8gdXBkYXRlLCBnaXZlIGFzIG51bGwgb3IgdW5kZWZpbmVkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB1cGRhdGUgYSB3aG9sZSByb3cuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JBY3Rpb249dHJ1ZV0gUGVyZm9ybSBwcmUtZHJhdyBhY3Rpb25zIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IDAgb24gc3VjY2VzcywgMSBvbiBlcnJvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5VcGRhdGUoICdFeGFtcGxlIHVwZGF0ZScsIDAsIDAgKTsgLy8gU2luZ2xlIGNlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuVXBkYXRlKCBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddLCAkKCd0Ym9keSB0cicpWzBdICk7IC8vIFJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuVXBkYXRlID0gZnVuY3Rpb24gKG1EYXRhLCBtUm93LCBpQ29sdW1uLCBiUmVkcmF3LCBiQWN0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaUNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IGlDb2x1bW4gPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnJvdyhtUm93KS5kYXRhKG1EYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5jZWxsKG1Sb3csIGlDb2x1bW4pLmRhdGEobURhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJBY3Rpb24gPT09IHVuZGVmaW5lZCB8fCBiQWN0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5jb2x1bW5zLmFkanVzdCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5kcmF3KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQcm92aWRlIGEgY29tbW9uIG1ldGhvZCBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgdGhlIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBiZWluZyB1c2VkLCBpbiBvcmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNWZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuIE5vdGUgdGhhdCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvIHRoZSByZXF1aXJlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3Qgc3VpdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbWV0aG9kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGFsZXJ0KCBvVGFibGUuZm5WZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuVmVyc2lvbkNoZWNrID0gX2V4dC5mblZlcnNpb25DaGVjaztcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF90aGF0ID0gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbXB0eUluaXQgPSBvcHRpb25zID09PSB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5SW5pdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm9BcGkgPSB0aGlzLmludGVybmFsID0gX2V4dC5pbnRlcm5hbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmQgd2l0aCBvbGQgc3R5bGUgcGx1Zy1pbiBBUEkgbWV0aG9kc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZm4gaW4gRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZuXSA9IF9mbkV4dGVybkFwaUZ1bmMoZm4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIGluaXRpYWxpc2F0aW9uIHdlIHdhbnQgdG8gZ2l2ZSBpdCBhIGNsZWFuIGluaXRpYWxpc2F0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0IHRoYXQgY2FuIGJlIGJhc2hlZCBhcm91bmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvSW5pdCA9IGxlbiA+IDEgPyAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSB0YWJsZSBjYXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkV4dGVuZChvLCBvcHRpb25zLCB0cnVlKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qZ2xvYmFsIG9Jbml0LF90aGF0LGVtcHR5SW5pdCovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYkluaXRIYW5kZWRPZmYgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNhbml0eSBjaGVjayAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ3RhYmxlJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2cobnVsbCwgMCwgJ05vbi10YWJsZSBub2RlIGluaXRpYWxpc2F0aW9uICgnICsgdGhpcy5ub2RlTmFtZSArICcpJywgMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgZGVmYXVsdHMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRPcHRzKGRlZmF1bHRzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRDb2xzKGRlZmF1bHRzLmNvbHVtbik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIENvbnZlcnQgdGhlIGNhbWVsLWNhc2UgZGVmYXVsdHMgdG8gSHVuZ2FyaWFuICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihkZWZhdWx0cywgZGVmYXVsdHMsIHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oZGVmYXVsdHMuY29sdW1uLCBkZWZhdWx0cy5jb2x1bW4sIHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBTZXR0aW5nIHVwIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuKGRlZmF1bHRzLCAkLmV4dGVuZChvSW5pdCwgJHRoaXMuZGF0YSgpKSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHdlIGFyZSByZS1pbml0aWFsaXNpbmcgYSB0YWJsZSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbGxTZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gYWxsU2V0dGluZ3MubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBhbGxTZXR0aW5nc1tpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEJhc2UgY2hlY2sgb24gdGFibGUgbm9kZSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5uVGFibGUgPT0gdGhpcyB8fCBzLm5USGVhZC5wYXJlbnROb2RlID09IHRoaXMgfHwgKHMublRGb290ICYmIHMublRGb290LnBhcmVudE5vZGUgPT0gdGhpcykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiUmV0cmlldmUgPSBvSW5pdC5iUmV0cmlldmUgIT09IHVuZGVmaW5lZCA/IG9Jbml0LmJSZXRyaWV2ZSA6IGRlZmF1bHRzLmJSZXRyaWV2ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiRGVzdHJveSA9IG9Jbml0LmJEZXN0cm95ICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iRGVzdHJveSA6IGRlZmF1bHRzLmJEZXN0cm95O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eUluaXQgfHwgYlJldHJpZXZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMub0luc3RhbmNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYkRlc3Ryb3kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm9JbnN0YW5jZS5mbkRlc3Ryb3koKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxvZyhzLCAwLCAnQ2Fubm90IHJlaW5pdGlhbGlzZSBEYXRhVGFibGUnLCAzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZSBlbGVtZW50IHdlIGFyZSBpbml0aWFsaXNpbmcgaGFzIHRoZSBzYW1lIElEIGFzIGEgdGFibGUgd2hpY2ggd2FzIHByZXZpb3VzbHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5pdGlhbGlzZWQsIGJ1dCB0aGUgdGFibGUgbm9kZXMgZG9uJ3QgbWF0Y2ggKGZyb20gYmVmb3JlKSB0aGVuIHdlIGRlc3Ryb3kgdGhlIG9sZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbnN0YW5jZSBieSBzaW1wbHkgZGVsZXRpbmcgaXQuIFRoaXMgaXMgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGUgdGFibGUgaGFzIGJlZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZGVzdHJveWVkIGJ5IG90aGVyIG1ldGhvZHMuIEFueW9uZSB1c2luZyBub24taWQgc2VsZWN0b3JzIHdpbGwgbmVlZCB0byBkbyB0aGlzIG1hbnVhbGx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zVGFibGVJZCA9PSB0aGlzLmlkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxTZXR0aW5ncy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogRW5zdXJlIHRoZSB0YWJsZSBoYXMgYW4gSUQgLSByZXF1aXJlZCBmb3IgYWNjZXNzaWJpbGl0eSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzSWQgPT09IG51bGwgfHwgc0lkID09PSBcIlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNJZCA9IFwiRGF0YVRhYmxlc19UYWJsZV9cIiArIChEYXRhVGFibGUuZXh0Ll91bmlxdWUrKyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBzSWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDcmVhdGUgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgdGhpcyB0YWJsZSBhbmQgc2V0IHNvbWUgb2YgdGhlIGRlZmF1bHQgcGFyYW1ldGVycyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvU2V0dGluZ3MgPSAkLmV4dGVuZCh0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzRGVzdHJveVdpZHRoXCI6ICR0aGlzWzBdLnN0eWxlLndpZHRoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNJbnN0YW5jZVwiOiBzSWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic1RhYmxlSWRcIjogc0lkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm5UYWJsZSA9IHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm9BcGkgPSBfdGhhdC5pbnRlcm5hbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3Mub0luaXQgPSBvSW5pdDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWxsU2V0dGluZ3MucHVzaChvU2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGFkZCB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIGluc3RhbmNlIGFmdGVyIHRoZSBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gYWRkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgc2V0dGluZ3MgYXJyYXksIHNvIHdlIGNhbiBzZWxmIHJlZmVyZW5jZSB0aGUgdGFibGUgaW5zdGFuY2UgaWYgbW9yZSB0aGFuIG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5vSW5zdGFuY2UgPSAoX3RoYXQubGVuZ3RoID09PSAxKSA/IF90aGF0IDogJHRoaXMuZGF0YVRhYmxlKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBiZWZvcmUgd2UgYXBwbHkgYWxsIHRoZSBkZWZhdWx0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE9wdHMob0luaXQpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0luaXQub0xhbmd1YWdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxhbmd1YWdlQ29tcGF0KG9Jbml0Lm9MYW5ndWFnZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGVuZ3RoIG1lbnUgaXMgZ2l2ZW4sIGJ1dCB0aGUgaW5pdCBkaXNwbGF5IGxlbmd0aCBpcyBub3QsIHVzZSB0aGUgbGVuZ3RoIG1lbnVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0luaXQuYUxlbmd0aE1lbnUgJiYgIW9Jbml0LmlEaXNwbGF5TGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9Jbml0LmlEaXNwbGF5TGVuZ3RoID0gJC5pc0FycmF5KG9Jbml0LmFMZW5ndGhNZW51WzBdKSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvSW5pdC5hTGVuZ3RoTWVudVswXVswXSA6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGRlZmF1bHRzIGFuZCBpbml0IG9wdGlvbnMgdG8gbWFrZSBhIHNpbmdsZSBpbml0IG9iamVjdCB3aWxsIGFsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbnMgZGVmaW5lZCBmcm9tIGRlZmF1bHRzIGFuZCBpbnN0YW5jZSBvcHRpb25zLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9Jbml0ID0gX2ZuRXh0ZW5kKCQuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cyksIG9Jbml0KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBvbnRvIHRoZSBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAob1NldHRpbmdzLm9GZWF0dXJlcywgb0luaXQsIFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiUGFnaW5hdGVcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiTGVuZ3RoQ2hhbmdlXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYkZpbHRlclwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJTb3J0XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRNdWx0aVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJJbmZvXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlByb2Nlc3NpbmdcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiQXV0b1dpZHRoXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRDbGFzc2VzXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNlcnZlclNpZGVcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiRGVmZXJSZW5kZXJcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbk1hcChvU2V0dGluZ3MsIG9Jbml0LCBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXNTdHJpcGVDbGFzc2VzXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWpheFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZuU2VydmVyRGF0YVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZuRm9ybWF0TnVtYmVyXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic1NlcnZlck1ldGhvZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFhU29ydGluZ1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFhU29ydGluZ0ZpeGVkXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYUxlbmd0aE1lbnVcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzUGFnaW5hdGlvblR5cGVcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzQWpheFNvdXJjZVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNBamF4RGF0YVByb3BcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpU3RhdGVEdXJhdGlvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNEb21cIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiU29ydENlbGxzVG9wXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaVRhYkluZGV4XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZuU3RhdGVTYXZlQ2FsbGJhY2tcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZW5kZXJlclwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNlYXJjaERlbGF5XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImlDb29raWVEdXJhdGlvblwiLCBcImlTdGF0ZUR1cmF0aW9uXCJdLCAvLyBiYWNrd2FyZHMgY29tcGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm9TZWFyY2hcIiwgXCJvUHJldmlvdXNTZWFyY2hcIl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImFvU2VhcmNoQ29sc1wiLCBcImFvUHJlU2VhcmNoQ29sc1wiXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaURpc3BsYXlMZW5ndGhcIiwgXCJfaURpc3BsYXlMZW5ndGhcIl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImJKUXVlcnlVSVwiLCBcImJKVUlcIl1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAob1NldHRpbmdzLm9TY3JvbGwsIG9Jbml0LCBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNTY3JvbGxYXCIsIFwic1hcIl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNTY3JvbGxYSW5uZXJcIiwgXCJzWElubmVyXCJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzU2Nyb2xsWVwiLCBcInNZXCJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJiU2Nyb2xsQ29sbGFwc2VcIiwgXCJiQ29sbGFwc2VcIl1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAob1NldHRpbmdzLm9MYW5ndWFnZSwgb0luaXQsIFwiZm5JbmZvQ2FsbGJhY2tcIik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBvSW5pdC5mbkRyYXdDYWxsYmFjaywgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsIG9Jbml0LmZuU2VydmVyUGFyYW1zLCAndXNlcicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMsICd1c2VyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCBvSW5pdC5mblN0YXRlTG9hZFBhcmFtcywgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgb0luaXQuZm5TdGF0ZUxvYWRlZCwgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgb0luaXQuZm5Sb3dDYWxsYmFjaywgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIG9Jbml0LmZuQ3JlYXRlZFJvdywgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgb0luaXQuZm5IZWFkZXJDYWxsYmFjaywgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgb0luaXQuZm5Gb290ZXJDYWxsYmFjaywgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0luaXRDb21wbGV0ZScsIG9Jbml0LmZuSW5pdENvbXBsZXRlLCAndXNlcicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvUHJlRHJhd0NhbGxiYWNrJywgb0luaXQuZm5QcmVEcmF3Q2FsbGJhY2ssICd1c2VyJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvQ2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3NlcztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gUmVtb3ZlIGluIDEuMTFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0luaXQuYkpRdWVyeVVJKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFVzZSB0aGUgSlVJIGNsYXNzZXMgb2JqZWN0IGZvciBkaXNwbGF5LiBZb3UgY291bGQgY2xvbmUgdGhlIG9TdGRDbGFzc2VzIG9iamVjdCBpZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB5b3Ugd2FudCB0byBoYXZlIG11bHRpcGxlIHRhYmxlcyB3aXRoIG11bHRpcGxlIGluZGVwZW5kZW50IGNsYXNzZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKG9DbGFzc2VzLCBEYXRhVGFibGUuZXh0Lm9KVUlDbGFzc2VzLCBvSW5pdC5vQ2xhc3Nlcyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0luaXQuc0RvbSA9PT0gZGVmYXVsdHMuc0RvbSAmJiBkZWZhdWx0cy5zRG9tID09PSBcImxmcnRpcFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBTZXQgdGhlIERPTSB0byB1c2UgYSBsYXlvdXQgc3VpdGFibGUgZm9yIGpRdWVyeSBVSSdzIHRoZW1pbmcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5zRG9tID0gJzxcIkhcImxmcj50PFwiRlwiaXA+JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvU2V0dGluZ3MucmVuZGVyZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5yZW5kZXJlciA9ICdqcXVlcnl1aSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KG9TZXR0aW5ncy5yZW5kZXJlcikgJiYgIW9TZXR0aW5ncy5yZW5kZXJlci5oZWFkZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5yZW5kZXJlci5oZWFkZXIgPSAnanF1ZXJ5dWknO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChvQ2xhc3NlcywgRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCBvSW5pdC5vQ2xhc3Nlcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKG9DbGFzc2VzLnNUYWJsZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIENhbGN1bGF0ZSB0aGUgc2Nyb2xsIGJhciB3aWR0aCBhbmQgY2FjaGUgaXQgZm9yIHVzZSBsYXRlciBvbiAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3Mub1Njcm9sbC5zWCAhPT0gXCJcIiB8fCBvU2V0dGluZ3Mub1Njcm9sbC5zWSAhPT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3Mub1Njcm9sbC5pQmFyV2lkdGggPSBfZm5TY3JvbGxCYXJXaWR0aCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLm9TY3JvbGwuc1ggPT09IHRydWUpIHsgLy8gRWFzeSBpbml0aWFsaXNhdGlvbiBvZiB4LXNjcm9sbGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3Mub1Njcm9sbC5zWCA9ICcxMDAlJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBEaXNwbGF5IHN0YXJ0IHBvaW50LCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBzYXZlIHNhdmluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBvSW5pdC5pRGlzcGxheVN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBvSW5pdC5pRGlzcGxheVN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmlEZWZlckxvYWRpbmcgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gJC5pc0FycmF5KG9Jbml0LmlEZWZlckxvYWRpbmcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA9IHRtcCA/IG9Jbml0LmlEZWZlckxvYWRpbmdbMF0gOiBvSW5pdC5pRGVmZXJMb2FkaW5nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzFdIDogb0luaXQuaURlZmVyTG9hZGluZztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIExhbmd1YWdlIGRlZmluaXRpb25zICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9MYW5ndWFnZSA9IG9TZXR0aW5ncy5vTGFuZ3VhZ2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb0xhbmd1YWdlLCBvSW5pdC5vTGFuZ3VhZ2UpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0xhbmd1YWdlLnNVcmwgIT09IFwiXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogR2V0IHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyBmcm9tIGEgZmlsZSAtIGJlY2F1c2UgdGhpcyBBamF4IGNhbGwgbWFrZXMgdGhlIGxhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldCBhc3luYyB0byB0aGUgcmVtYWluZGVyIG9mIHRoaXMgZnVuY3Rpb24gd2UgdXNlIGJJbml0SGFuZGVkT2ZmIHRvIGluZGljYXRlIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogX2ZuSW5pdGlhbGlzZSB3aWxsIGJlIGZpcmVkIGJ5IHRoZSByZXR1cm5lZCBBamF4IGhhbmRsZXIsIHJhdGhlciB0aGFuIHRoZSBjb25zdHJ1Y3RvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IG9MYW5ndWFnZS5zVXJsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5MYW5ndWFnZUNvbXBhdChqc29uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuKGRlZmF1bHRzLm9MYW5ndWFnZSwganNvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb0xhbmd1YWdlLCBqc29uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Jbml0aWFsaXNlKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFcnJvciBvY2N1cnJlZCBsb2FkaW5nIGxhbmd1YWdlIGZpbGUsIGNvbnRpbnVlIG9uIGFzIGJlc3Qgd2UgY2FuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdGlhbGlzZShvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYkluaXRIYW5kZWRPZmYgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBTdHJpcGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFzU3RyaXBlQ2xhc3NlcyA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYXNTdHJpcGVDbGFzc2VzID0gW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0NsYXNzZXMuc1N0cmlwZU9kZCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9DbGFzc2VzLnNTdHJpcGVFdmVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBSZW1vdmUgcm93IHN0cmlwZSBjbGFzc2VzIGlmIHRoZXkgYXJlIGFscmVhZHkgb24gdGhlIHRhYmxlIHJvdyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93T25lID0gJHRoaXMuY2hpbGRyZW4oJ3Rib2R5JykuZmluZCgndHInKS5lcSgwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KHRydWUsICQubWFwKHN0cmlwZUNsYXNzZXMsIGZ1bmN0aW9uIChlbCwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93T25lLmhhc0NsYXNzKGVsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJ3Rib2R5IHRyJywgdGhpcykucmVtb3ZlQ2xhc3Moc3RyaXBlQ2xhc3Nlcy5qb2luKCcgJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlcyA9IHN0cmlwZUNsYXNzZXMuc2xpY2UoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFNlZSBpZiB3ZSBzaG91bGQgbG9hZCBjb2x1bW5zIGF1dG9tYXRpY2FsbHkgb3IgdXNlIGRlZmluZWQgb25lc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhblRocyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhb0NvbHVtbnNJbml0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuVGhlYWQgPSB0aGlzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aGVhZCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuVGhlYWQubGVuZ3RoICE9PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRldGVjdEhlYWRlcihvU2V0dGluZ3MuYW9IZWFkZXIsIG5UaGVhZFswXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuVGhzID0gX2ZuR2V0VW5pcXVlVGhzKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiBub3QgZ2l2ZW4gYSBjb2x1bW4gYXJyYXksIGdlbmVyYXRlIG9uZSB3aXRoIG51bGxzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFvQ29sdW1ucyA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb0NvbHVtbnNJbml0ID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhblRocy5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW9Db2x1bW5zSW5pdC5wdXNoKG51bGwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb0NvbHVtbnNJbml0ID0gb0luaXQuYW9Db2x1bW5zO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQWRkIHRoZSBjb2x1bW5zICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGFvQ29sdW1uc0luaXQubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkQ29sdW1uKG9TZXR0aW5ncywgYW5UaHMgPyBhblRoc1tpXSA6IG51bGwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQXBwbHkgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFwcGx5Q29sdW1uRGVmcyhvU2V0dGluZ3MsIG9Jbml0LmFvQ29sdW1uRGVmcywgYW9Db2x1bW5zSW5pdCwgZnVuY3Rpb24gKGlDb2wsIG9EZWYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uT3B0aW9ucyhvU2V0dGluZ3MsIGlDb2wsIG9EZWYpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBIVE1MNSBhdHRyaWJ1dGUgZGV0ZWN0aW9uIC0gYnVpbGQgYW4gbURhdGEgb2JqZWN0IGF1dG9tYXRpY2FsbHkgaWYgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYXR0cmlidXRlcyBhcmUgZm91bmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93T25lLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGZ1bmN0aW9uIChjZWxsLCBuYW1lKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIG5hbWUpICE9PSBudWxsID8gbmFtZSA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goX2ZuR2V0Um93RWxlbWVudHMob1NldHRpbmdzLCByb3dPbmVbMF0pLmNlbGxzLCBmdW5jdGlvbiAoaSwgY2VsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5tRGF0YSA9PT0gaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0ID0gYShjZWxsLCAnc29ydCcpIHx8IGEoY2VsbCwgJ29yZGVyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IGEoY2VsbCwgJ2ZpbHRlcicpIHx8IGEoY2VsbCwgJ3NlYXJjaCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydCAhPT0gbnVsbCB8fCBmaWx0ZXIgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLm1EYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXzogaSArICcuZGlzcGxheScsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0OiBzb3J0ICE9PSBudWxsID8gaSArICcuQGRhdGEtJyArIHNvcnQgOiB1bmRlZmluZWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBzb3J0ICE9PSBudWxsID8gaSArICcuQGRhdGEtJyArIHNvcnQgOiB1bmRlZmluZWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IGZpbHRlciAhPT0gbnVsbCA/IGkgKyAnLkBkYXRhLScgKyBmaWx0ZXIgOiB1bmRlZmluZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtbk9wdGlvbnMob1NldHRpbmdzLCBpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogTXVzdCBiZSBkb25lIGFmdGVyIGV2ZXJ5dGhpbmcgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN0YXRlIHNhdmluZyEgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0luaXQuYlN0YXRlU2F2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5iU3RhdGVTYXZlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9hZFN0YXRlKG9TZXR0aW5ncywgb0luaXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIF9mblNhdmVTdGF0ZSwgJ3N0YXRlX3NhdmUnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdG9kbyBGb3IgbW9kdWxhcmlzYXRpb24gKDEuMTEpIHRoaXMgbmVlZHMgdG8gZG8gaW50byBhIHNvcnQgc3RhcnQgdXAgaGFuZGxlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhYVNvcnRpbmcgaXMgbm90IGRlZmluZWQsIHRoZW4gd2UgdXNlIHRoZSBmaXJzdCBpbmRpY2F0b3IgaW4gYXNTb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGF0IGhhcyBiZWVuIGFsdGVyZWQsIHNvIHRoZSBkZWZhdWx0IHNvcnQgcmVmbGVjdHMgdGhhdCBvcHRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0luaXQuYWFTb3J0aW5nID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnRpbmcgPSBvU2V0dGluZ3MuYWFTb3J0aW5nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gc29ydGluZy5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZ1tpXVsxXSA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV0uYXNTb3J0aW5nWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBEbyBhIGZpcnN0IHBhc3Mgb24gdGhlIHNvcnRpbmcgY2xhc3NlcyAoYWxsb3dzIGFueSBzaXplIGNoYW5nZXMgdG8gYmUgdGFrZW4gaW50b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGFjY291bnQsIGFuZCBhbHNvIHdpbGwgYXBwbHkgc29ydGluZyBkaXNhYmxlZCBjbGFzc2VzIGlmIGRpc2FibGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydGluZ0NsYXNzZXMob1NldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJTb3J0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5iU29ydGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFTb3J0ID0gX2ZuU29ydEZsYXR0ZW4ob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29ydGVkQ29sdW1ucyA9IHt9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goYVNvcnQsIGZ1bmN0aW9uIChpLCB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkQ29sdW1uc1t2YWwuc3JjXSA9IHZhbC5kaXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsIG51bGwsICdvcmRlcicsIFtvU2V0dGluZ3MsIGFTb3J0LCBzb3J0ZWRDb2x1bW5zXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydEFyaWEob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5iU29ydGVkIHx8IF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PT0gJ3NzcCcgfHwgZmVhdHVyZXMuYkRlZmVyUmVuZGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0aW5nQ2xhc3NlcyhvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgJ3NjJyk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEZpbmFsIGluaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBDYWNoZSB0aGUgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIgYXMgcmVxdWlyZWQsIGNyZWF0aW5nIHRoZW0gaWYgbmVlZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEJyb3dzZXIgc3VwcG9ydCBkZXRlY3Rpb24gKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Ccm93c2VyRGV0ZWN0KG9TZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGZvciBXZWJraXQgYnVnIDgzODY3IC0gc3RvcmUgdGhlIGNhcHRpb24tc2lkZSBiZWZvcmUgcmVtb3ZpbmcgZnJvbSBkb2NcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FwdGlvbnMgPSAkdGhpcy5jaGlsZHJlbignY2FwdGlvbicpLmVhY2goZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXB0aW9uU2lkZSA9ICR0aGlzLmNzcygnY2FwdGlvbi1zaWRlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVhZCA9ICR0aGlzLmNoaWxkcmVuKCd0aGVhZCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGVhZC5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlYWQgPSAkKCc8dGhlYWQvPicpLmFwcGVuZFRvKHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRIZWFkID0gdGhlYWRbMF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0Ym9keSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Ym9keS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGJvZHkgPSAkKCc8dGJvZHkvPicpLmFwcGVuZFRvKHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRCb2R5ID0gdGJvZHlbMF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0Zm9vdCA9ICR0aGlzLmNoaWxkcmVuKCd0Zm9vdCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Zm9vdC5sZW5ndGggPT09IDAgJiYgY2FwdGlvbnMubGVuZ3RoID4gMCAmJiAob1NldHRpbmdzLm9TY3JvbGwuc1ggIT09IFwiXCIgfHwgb1NldHRpbmdzLm9TY3JvbGwuc1kgIT09IFwiXCIpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhIHNjcm9sbGluZyB0YWJsZSwgYW5kIG5vIGZvb3RlciBoYXMgYmVlbiBnaXZlbiwgdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHRmb290IGVsZW1lbnQgZm9yIHRoZSBjYXB0aW9uIGVsZW1lbnQgdG8gYmUgYXBwZW5kZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGZvb3QgPSAkKCc8dGZvb3QvPicpLmFwcGVuZFRvKHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRmb290Lmxlbmd0aCA9PT0gMCB8fCB0Zm9vdC5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyhvQ2xhc3Nlcy5zTm9Gb290ZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0Zm9vdC5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5uVEZvb3QgPSB0Zm9vdFswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRGV0ZWN0SGVhZGVyKG9TZXR0aW5ncy5hb0Zvb3Rlciwgb1NldHRpbmdzLm5URm9vdCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDaGVjayBpZiB0aGVyZSBpcyBkYXRhIHBhc3NpbmcgaW50byB0aGUgY29uc3RydWN0b3IgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0luaXQuYWFEYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgb0luaXQuYWFEYXRhLmxlbmd0aCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkRGF0YShvU2V0dGluZ3MsIG9Jbml0LmFhRGF0YVtpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob1NldHRpbmdzLmJEZWZlckxvYWRpbmcgfHwgX2ZuRGF0YVNvdXJjZShvU2V0dGluZ3MpID09ICdkb20nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEdyYWIgdGhlIGRhdGEgZnJvbSB0aGUgcGFnZSAtIG9ubHkgZG8gdGhpcyB3aGVuIGRlZmVycmVkIGxvYWRpbmcgb3Igbm8gQWpheFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzb3VyY2Ugc2luY2UgdGhlcmUgaXMgbm8gcG9pbnQgaW4gcmVhZGluZyB0aGUgRE9NIGRhdGEgaWYgd2UgYXJlIHRoZW4gZ29pbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdG8gcmVwbGFjZSBpdCB3aXRoIEFqYXggZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkVHIob1NldHRpbmdzLCAkKG9TZXR0aW5ncy5uVEJvZHkpLmNoaWxkcmVuKCd0cicpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIENvcHkgdGhlIGRhdGEgaW5kZXggYXJyYXkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYWlEaXNwbGF5ID0gb1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBJbml0aWFsaXNhdGlvbiBjb21wbGV0ZSAtIHRhYmxlIGNhbiBiZSBkcmF3biAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5iSW5pdGlhbGlzZWQgPSB0cnVlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDaGVjayBpZiB3ZSBuZWVkIHRvIGluaXRpYWxpc2UgdGhlIHRhYmxlIChpdCBtaWdodCBub3QgaGF2ZSBiZWVuIGhhbmRlZCBvZmYgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogbGFuZ3VhZ2UgcHJvY2Vzc29yKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiSW5pdEhhbmRlZE9mZiA9PT0gZmFsc2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdGlhbGlzZShvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX3RoYXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb21wdXRlZCBzdHJ1Y3R1cmUgb2YgdGhlIERhdGFUYWJsZXMgQVBJLCBkZWZpbmVkIGJ5IHRoZSBvcHRpb25zIHBhc3NlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiBgRGF0YVRhYmxlLkFwaS5yZWdpc3RlcigpYCB3aGVuIGJ1aWxkaW5nIHRoZSBBUEkuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoZSBzdHJ1Y3R1cmUgaXMgYnVpbHQgaW4gb3JkZXIgdG8gc3BlZWQgY3JlYXRpb24gYW5kIGV4dGVuc2lvbiBvZiB0aGUgQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqIG9iamVjdHMgc2luY2UgdGhlIGV4dGVuc2lvbnMgYXJlIGVmZmVjdGl2ZWx5IHByZS1wYXJzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoZSBhcnJheSBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUsIHdoZXJlIHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICogYmFzZSBhcnJheSByZXByZXNlbnRzIHRoZSBBcGkgcHJvdG90eXBlIGJhc2U6XHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICBbXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgICBuYW1lOiAgICAgICdkYXRhJyAgICAgICAgICAgICAgICAtLSBzdHJpbmcgICAtIFByb3BlcnR5IG5hbWVcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LCAgICAgICAtLSBmdW5jdGlvbiAtIEFwaSBtZXRob2QgKG9yIHVuZGVmaW5lZCBpZiBqdXN0IGFuIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSwgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIG1ldGhvZCByZXN1bHRcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF0gICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0eVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgbmFtZTogICAgICdyb3cnXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgdmFsOiAgICAgICB7fSxcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgcHJvcEV4dDogICBbXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgLi4uXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cclxuXHQgICAgICAgICAgICAgICAgICogQGlnbm9yZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fYXBpU3RydWN0ID0gW107XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIGBBcnJheS5wcm90b3R5cGVgIHJlZmVyZW5jZS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqIEBpZ25vcmVcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX2FycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFic3RyYWN0aW9uIGZvciBgY29udGV4dGAgcGFyYW1ldGVyIG9mIHRoZSBgQXBpYCBjb25zdHJ1Y3RvciB0byBhbGxvdyBpdCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiB0YWtlIHNldmVyYWwgZGlmZmVyZW50IGZvcm1zIGZvciBlYXNlIG9mIHVzZS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogRWFjaCBvZiB0aGUgaW5wdXQgcGFyYW1ldGVyIHR5cGVzIHdpbGwgYmUgY29udmVydGVkIHRvIGEgRGF0YVRhYmxlcyBzZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBvYmplY3Qgd2hlcmUgcG9zc2libGUuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xub2RlfGpRdWVyeXxvYmplY3R9IG1peGVkIERhdGFUYWJsZSBpZGVudGlmaWVyLiBDYW4gYmUgb25lXHJcblx0ICAgICAgICAgICAgICAgICAqICAgb2Y6XHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBub2RlYCAtIGBUQUJMRWAgbm9kZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGZvcm1lZCBpbnRvIGEgRGF0YVRhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBEYXRhVGFibGVzLkFwaWAgLSBBUEkgaW5zdGFuY2VcclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybiB7YXJyYXl8bnVsbH0gTWF0Y2hpbmcgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLiBgbnVsbGAgb3JcclxuXHQgICAgICAgICAgICAgICAgICogICBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCBpZiBubyBtYXRjaGluZyBEYXRhVGFibGUgaXMgZm91bmQuXHJcblx0ICAgICAgICAgICAgICAgICAqIEBpZ25vcmVcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfdG9TZXR0aW5ncyA9IGZ1bmN0aW9uIChtaXhlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCwganE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVzID0gJC5tYXAoc2V0dGluZ3MsIGZ1bmN0aW9uIChlbCwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uVGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1peGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWl4ZWQublRhYmxlICYmIG1peGVkLm9BcGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWl4ZWRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWl4ZWQubm9kZU5hbWUgJiYgbWl4ZWQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RhYmxlJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSAkLmluQXJyYXkobWl4ZWQsIHRhYmxlcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgPyBbc2V0dGluZ3NbaWR4XV0gOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWl4ZWQgJiYgdHlwZW9mIG1peGVkLnNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1peGVkLnNldHRpbmdzKCkudG9BcnJheSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBzZWxlY3RvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpxID0gJChtaXhlZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mICQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkgb2JqZWN0IChhbHNvIERhdGFUYWJsZXMgaW5zdGFuY2UpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganEgPSBtaXhlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoanEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganEubWFwKGZ1bmN0aW9uIChpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9ICQuaW5BcnJheSh0aGlzLCB0YWJsZXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4ICE9PSAtMSA/IHNldHRpbmdzW2lkeF0gOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRvQXJyYXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBBUEkgY2xhc3MgLSB1c2VkIHRvIGNvbnRyb2wgYW5kIGludGVyZmFjZSB3aXRoICBvbmUgb3IgbW9yZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcy5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogVGhlIEFQSSBjbGFzcyBpcyBoZWF2aWx5IGJhc2VkIG9uIGpRdWVyeSwgcHJlc2VudGluZyBhIGNoYWluYWJsZSBpbnRlcmZhY2VcclxuXHQgICAgICAgICAgICAgICAgICogdGhhdCB5b3UgY2FuIHVzZSB0byBpbnRlcmFjdCB3aXRoIHRhYmxlcy4gRWFjaCBpbnN0YW5jZSBvZiB0aGUgQVBJIGNsYXNzIGhhc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBhIFwiY29udGV4dFwiIC0gaS5lLiB0aGUgdGFibGVzIHRoYXQgaXQgd2lsbCBvcGVyYXRlIG9uLiBUaGlzIGNvdWxkIGJlIGEgc2luZ2xlXHJcblx0ICAgICAgICAgICAgICAgICAqIHRhYmxlLCBhbGwgdGFibGVzIG9uIGEgcGFnZSBvciBhIHN1Yi1zZXQgdGhlcmVvZi5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQWRkaXRpb25hbGx5IHRoZSBBUEkgaXMgZGVzaWduZWQgdG8gYWxsb3cgeW91IHRvIGVhc2lseSB3b3JrIHdpdGggdGhlIGRhdGEgaW5cclxuXHQgICAgICAgICAgICAgICAgICogdGhlIHRhYmxlcywgcmV0cmlldmluZyBhbmQgbWFuaXB1bGF0aW5nIGl0IGFzIHJlcXVpcmVkLiBUaGlzIGlzIGRvbmUgYnlcclxuXHQgICAgICAgICAgICAgICAgICogcHJlc2VudGluZyB0aGUgQVBJIGNsYXNzIGFzIGFuIGFycmF5IGxpa2UgaW50ZXJmYWNlLiBUaGUgY29udGVudHMgb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIGFycmF5IGRlcGVuZCB1cG9uIHRoZSBhY3Rpb25zIHJlcXVlc3RlZCBieSBlYWNoIG1ldGhvZCAoZm9yIGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogYHJvd3MoKS5ub2RlcygpYCB3aWxsIHJldHVybiBhbiBhcnJheSBvZiBub2Rlcywgd2hpbGUgYHJvd3MoKS5kYXRhKClgIHdpbGxcclxuXHQgICAgICAgICAgICAgICAgICogcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgYXJyYXlzIGRlcGVuZGluZyB1cG9uIHlvdXIgdGFibGUnc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBjb25maWd1cmF0aW9uKS4gVGhlIEFQSSBvYmplY3QgaGFzIGEgbnVtYmVyIG9mIGFycmF5IGxpa2UgbWV0aG9kcyAoYHB1c2hgLFxyXG5cdCAgICAgICAgICAgICAgICAgKiBgcG9wYCwgYHJldmVyc2VgIGV0YykgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIGhlbHBlciBtZXRob2RzIChgZWFjaGAsIGBwbHVja2AsXHJcblx0ICAgICAgICAgICAgICAgICAqIGB1bmlxdWVgIGV0YykgdG8gYXNzaXN0IHlvdXIgd29ya2luZyB3aXRoIHRoZSBkYXRhIGhlbGQgaW4gYSB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogTW9zdCBtZXRob2RzICh0aG9zZSB3aGljaCByZXR1cm4gYW4gQXBpIGluc3RhbmNlKSBhcmUgY2hhaW5hYmxlLCB3aGljaCBtZWFuc1xyXG5cdCAgICAgICAgICAgICAgICAgKiB0aGUgcmV0dXJuIGZyb20gYSBtZXRob2QgY2FsbCBhbHNvIGhhcyBhbGwgb2YgdGhlIG1ldGhvZHMgYXZhaWxhYmxlIHRoYXQgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIHRvcCBsZXZlbCBvYmplY3QgaGFkLiBGb3IgZXhhbXBsZSwgdGhlc2UgdHdvIGNhbGxzIGFyZSBlcXVpdmFsZW50OlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgLy8gTm90IGNoYWluZWRcclxuXHQgICAgICAgICAgICAgICAgICogICAgIGFwaS5yb3cuYWRkKCB7Li4ufSApO1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgYXBpLmRyYXcoKTtcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogICAgIC8vIENoYWluZWRcclxuXHQgICAgICAgICAgICAgICAgICogICAgIGFwaS5yb3cuYWRkKCB7Li4ufSApLmRyYXcoKTtcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQGNsYXNzIERhdGFUYWJsZS5BcGlcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHthcnJheXxvYmplY3R8c3RyaW5nfGpRdWVyeX0gY29udGV4dCBEYXRhVGFibGUgaWRlbnRpZmllci4gVGhpcyBpc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHVzZWQgdG8gZGVmaW5lIHdoaWNoIERhdGFUYWJsZXMgZW5oYW5jZWQgdGFibGVzIHRoaXMgQVBJIHdpbGwgb3BlcmF0ZSBvbi5cclxuXHQgICAgICAgICAgICAgICAgICogICBDYW4gYmUgb25lIG9mOlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICogYHN0cmluZ2AgLSBqUXVlcnkgc2VsZWN0b3IuIEFueSBEYXRhVGFibGVzJyBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgbm9kZWAgLSBgVEFCTEVgIG5vZGUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBmb3JtZWQgaW50byBhIERhdGFUYWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBqUXVlcnlgIC0gQSBqUXVlcnkgb2JqZWN0IG9mIGBUQUJMRWAgbm9kZXMuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IFtkYXRhXSBEYXRhIHRvIGluaXRpYWxpc2UgdGhlIEFwaSBpbnN0YW5jZSB3aXRoLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIC8vIERpcmVjdCBpbml0aWFsaXNhdGlvbiBkdXJpbmcgRGF0YVRhYmxlcyBjb25zdHJ1Y3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5EYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAvLyBJbml0aWFsaXNhdGlvbiB1c2luZyBhIERhdGFUYWJsZXMgalF1ZXJ5IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHZhciBhcGkgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpLmFwaSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIC8vIEluaXRpYWxpc2F0aW9uIGFzIGEgY29uc3RydWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICogICB2YXIgYXBpID0gbmV3ICQuZm4uRGF0YVRhYmxlLkFwaSggJ3RhYmxlLmRhdGFUYWJsZScgKTtcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9BcGkgPSBmdW5jdGlvbiAoY29udGV4dCwgZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9BcGkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXBpKGNvbnRleHQsIGRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eFNldHRpbmdzID0gZnVuY3Rpb24gKG8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IF90b1NldHRpbmdzKG8pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnB1c2guYXBwbHkoc2V0dGluZ3MsIGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShjb250ZXh0KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBjb250ZXh0Lmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4U2V0dGluZ3MoY29udGV4dFtpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4U2V0dGluZ3MoY29udGV4dCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IF91bmlxdWUoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWwgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2guYXBwbHkodGhpcywgZGF0YS50b0FycmF5ID8gZGF0YS50b0FycmF5KCkgOiBkYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3dzOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHM6IG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBfQXBpLmV4dGVuZCh0aGlzLCB0aGlzLCBfX2FwaVN0cnVjdCk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUuQXBpID0gX0FwaTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9BcGkucHJvdG90eXBlID0gLyoqIEBsZW5kcyBEYXRhVGFibGVzLkFwaSAqL3tcclxuXHQgICAgICAgICAgICAgICAgICAgIGFueTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKS5sZW5ndGggIT09IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb25jYXQ6IF9fYXJyYXlQcm90by5jb25jYXQsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IFtdLCAvLyBhcnJheSBvZiB0YWJsZSBzZXR0aW5ncyBvYmplY3RzXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGVhY2g6IGZ1bmN0aW9uIChmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSB0aGlzLmxlbmd0aCA7IGkgPCBpZW47IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHRoaXMsIHRoaXNbaV0sIGksIHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBlcTogZnVuY3Rpb24gKGlkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoID4gaWR4ID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkoY3R4W2lkeF0sIHRoaXNbaWR4XSkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19hcnJheVByb3RvLmZpbHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gX19hcnJheVByb3RvLmZpbHRlci5jYWxsKHRoaXMsIGZuLCB0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhdGliaWxpdHkgZm9yIGJyb3dzZXJzIHdpdGhvdXQgRU1DQS0yNTItNSAoSlMgMS42KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gdGhpcy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm4uY2FsbCh0aGlzLCB0aGlzW2ldLCBpLCB0aGlzKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaCh0aGlzW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXBpKHRoaXMuY29udGV4dCwgYSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmbGF0dGVuOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9BcGkodGhpcy5jb250ZXh0LCBhLmNvbmNhdC5hcHBseShhLCB0aGlzLnRvQXJyYXkoKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgam9pbjogX19hcnJheVByb3RvLmpvaW4sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4T2Y6IF9fYXJyYXlQcm90by5pbmRleE9mIHx8IGZ1bmN0aW9uIChvYmosIHN0YXJ0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IChzdGFydCB8fCAwKSwgaWVuID0gdGhpcy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvYmopIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3I6IGZ1bmN0aW9uIChmbGF0dGVuLCB0eXBlLCBmbiwgYWx3YXlzTmV3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBbXSwgcmV0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLCBpZW4sIGosIGplbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cywgaXRlbXMsIGl0ZW0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJndW1lbnQgc2hpZnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsYXR0ZW4gPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c05ldyA9IGZuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA9IHR5cGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBmbGF0dGVuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBjb250ZXh0Lmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaUluc3QgPSBuZXcgX0FwaShjb250ZXh0W2ldKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndGFibGUnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChyZXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdjb2x1bW5zJyB8fCB0eXBlID09PSAncm93cycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaGFzIHNhbWUgbGVuZ3RoIGFzIGNvbnRleHQgLSBvbmUgZW50cnkgZm9yIGVhY2ggdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGZuLmNhbGwoYXBpSW5zdCwgY29udGV4dFtpXSwgdGhpc1tpXSwgaSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHJldCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2NvbHVtbicgfHwgdHlwZSA9PT0gJ2NvbHVtbi1yb3dzJyB8fCB0eXBlID09PSAncm93JyB8fCB0eXBlID09PSAnY2VsbCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbHVtbnMgYW5kIHJvd3Mgc2hhcmUgdGhlIHNhbWUgc3RydWN0dXJlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ3RoaXMnIGlzIGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIGZvciBlYWNoIGNvbnRleHRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gdGhpc1tpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbHVtbi1yb3dzJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoY29udGV4dFtpXSwgc2VsZWN0b3Iub3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamVuID0gaXRlbXMubGVuZ3RoIDsgaiA8IGplbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tqXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjZWxsJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0ucm93LCBpdGVtLmNvbHVtbiwgaSwgaik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0sIGksIGosIHJvd3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChyZXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEubGVuZ3RoIHx8IGFsd2F5c05ldykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gbmV3IF9BcGkoY29udGV4dCwgZmxhdHRlbiA/IGEuY29uY2F0LmFwcGx5KFtdLCBhKSA6IGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpU2VsZWN0b3IgPSBhcGkuc2VsZWN0b3I7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVNlbGVjdG9yLnJvd3MgPSBzZWxlY3Rvci5yb3dzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlTZWxlY3Rvci5jb2xzID0gc2VsZWN0b3IuY29scztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpU2VsZWN0b3Iub3B0cyA9IHNlbGVjdG9yLm9wdHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcGk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4T2Y6IF9fYXJyYXlQcm90by5sYXN0SW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJpdCBjaGVla3kuLi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleE9mLmFwcGx5KHRoaXMudG9BcnJheS5yZXZlcnNlKCksIGFyZ3VtZW50cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IDAsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIG1hcDogZnVuY3Rpb24gKGZuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fYXJyYXlQcm90by5tYXApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF9fYXJyYXlQcm90by5tYXAuY2FsbCh0aGlzLCBmbiwgdGhpcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB3aXRob3V0IEVNQ0EtMjUyLTUgKEpTIDEuNilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHRoaXMubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGZuLmNhbGwodGhpcywgdGhpc1tpXSwgaSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9BcGkodGhpcy5jb250ZXh0LCBhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHBsdWNrOiBmdW5jdGlvbiAocHJvcCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsW3Byb3BdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBwb3A6IF9fYXJyYXlQcm90by5wb3AsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHB1c2g6IF9fYXJyYXlQcm90by5wdXNoLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBEb2VzIG5vdCByZXR1cm4gYW4gQVBJIGluc3RhbmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICByZWR1Y2U6IF9fYXJyYXlQcm90by5yZWR1Y2UgfHwgZnVuY3Rpb24gKGZuLCBpbml0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mblJlZHVjZSh0aGlzLCBmbiwgaW5pdCwgMCwgdGhpcy5sZW5ndGgsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVkdWNlUmlnaHQ6IF9fYXJyYXlQcm90by5yZWR1Y2VSaWdodCB8fCBmdW5jdGlvbiAoZm4sIGluaXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuUmVkdWNlKHRoaXMsIGZuLCBpbml0LCB0aGlzLmxlbmd0aCAtIDEsIC0xLCAtMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiBfX2FycmF5UHJvdG8ucmV2ZXJzZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IHdpdGggcm93cywgY29sdW1ucyBhbmQgb3B0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNoaWZ0OiBfX2FycmF5UHJvdG8uc2hpZnQsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNvcnQ6IF9fYXJyYXlQcm90by5zb3J0LCAvLyA/IG5hbWUgLSBvcmRlcj9cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3BsaWNlOiBfX2FycmF5UHJvdG8uc3BsaWNlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXJyYXlQcm90by5zbGljZS5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdG8kOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB0b0pRdWVyeTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdW5pcXVlOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXBpKHRoaXMuY29udGV4dCwgX3VuaXF1ZSh0aGlzKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB1bnNoaWZ0OiBfX2FycmF5UHJvdG8udW5zaGlmdFxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9BcGkuZXh0ZW5kID0gZnVuY3Rpb24gKHNjb3BlLCBvYmosIGV4dCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gT25seSBleHRlbmQgQVBJIGluc3RhbmNlcyBhbmQgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFleHQubGVuZ3RoIHx8ICFvYmogfHwgKCEob2JqIGluc3RhbmNlb2YgX0FwaSkgJiYgIW9iai5fX2R0X3dyYXBwZXIpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGksIGllbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqLCBqZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0LCBpbm5lcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RTY29waW5nID0gZnVuY3Rpb24gKHNjb3BlLCBmbiwgc3RydWMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNZXRob2QgZXh0ZW5zaW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfQXBpLmV4dGVuZChyZXQsIHJldCwgc3RydWMubWV0aG9kRXh0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBleHQubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdCA9IGV4dFtpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsdWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmpbc3RydWN0Lm5hbWVdID0gdHlwZW9mIHN0cnVjdC52YWwgPT09ICdmdW5jdGlvbicgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RTY29waW5nKHNjb3BlLCBzdHJ1Y3QudmFsLCBzdHJ1Y3QpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5pc1BsYWluT2JqZWN0KHN0cnVjdC52YWwpID9cclxuXHRcdFx0XHRcdFx0e30gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0LnZhbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3N0cnVjdC5uYW1lXS5fX2R0X3dyYXBwZXIgPSB0cnVlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0eSBleHRlbnNpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfQXBpLmV4dGVuZChzY29wZSwgb2JqW3N0cnVjdC5uYW1lXSwgc3RydWN0LnByb3BFeHQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIEB0b2RvIC0gSXMgdGhlcmUgbmVlZCBmb3IgYW4gYXVnbWVudCBmdW5jdGlvbj9cclxuXHQgICAgICAgICAgICAgICAgLy8gX0FwaS5hdWdtZW50ID0gZnVuY3Rpb24gKCBpbnN0LCBuYW1lIClcclxuXHQgICAgICAgICAgICAgICAgLy8ge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBcdC8vIEZpbmQgc3JjIG9iamVjdCBpbiB0aGUgc3RydWN0dXJlIGZyb20gdGhlIG5hbWVcclxuXHQgICAgICAgICAgICAgICAgLy8gXHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBcdF9BcGkuZXh0ZW5kKCBpbnN0LCBvYmogKTtcclxuXHQgICAgICAgICAgICAgICAgLy8gfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgW1xyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgIG5hbWU6ICAgICAncm93J1xyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgIHZhbDogICAgICAge30sXHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgIHByb3BFeHQ6ICAgW1xyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIC4uLlxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgXVxyXG5cclxuXHQgICAgICAgICAgICAgICAgX0FwaS5yZWdpc3RlciA9IF9hcGlfcmVnaXN0ZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KG5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGplbiA9IG5hbWUubGVuZ3RoIDsgaiA8IGplbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfQXBpLnJlZ2lzdGVyKG5hbWVbal0sIHZhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpLCBpZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVpciA9IG5hbWUuc3BsaXQoJy4nKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3QgPSBfX2FwaVN0cnVjdCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrZXksIG1ldGhvZDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmluZCA9IGZ1bmN0aW9uIChzcmMsIG5hbWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gc3JjLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1tpXS5uYW1lID09PSBuYW1lKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3JjW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBoZWlyLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBoZWlyW2ldLmluZGV4T2YoJygpJykgIT09IC0xO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG1ldGhvZCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaXJbaV0ucmVwbGFjZSgnKCknLCAnJykgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlyW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjID0gZmluZChzdHJ1Y3QsIGtleSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzcmMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiB7fSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZEV4dDogW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wRXh0OiBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3QucHVzaChzcmMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGllbiAtIDEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjLnZhbCA9IHZhbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdCA9IG1ldGhvZCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmMubWV0aG9kRXh0IDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYy5wcm9wRXh0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfQXBpLnJlZ2lzdGVyUGx1cmFsID0gX2FwaV9yZWdpc3RlclBsdXJhbCA9IGZ1bmN0aW9uIChwbHVyYWxOYW1lLCBzaW5ndWxhck5hbWUsIHZhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX0FwaS5yZWdpc3RlcihwbHVyYWxOYW1lLCB2YWwpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9BcGkucmVnaXN0ZXIoc2luZ3VsYXJOYW1lLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHZhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSB0aGlzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybmVkIGl0ZW0gaXMgdGhlIEFQSSBpbnN0YW5jZSB0aGF0IHdhcyBwYXNzZWQgaW4sIHJldHVybiBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmV0IGluc3RhbmNlb2YgX0FwaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXcgQVBJIGluc3RhbmNlIHJldHVybmVkLCB3YW50IHRoZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVtXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSByZXR1cm5lZCBhcnJheSBmb3IgdGhlIHNpbmd1bGFyIHJlc3VsdC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldC5sZW5ndGggP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5pc0FycmF5KHJldFswXSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBfQXBpKHJldC5jb250ZXh0LCByZXRbMF0pIDogLy8gQXJyYXkgcmVzdWx0cyBhcmUgJ2VuaGFuY2VkJ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldFswXSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb24tQVBJIHJldHVybiAtIGp1c3QgZmlyZSBpdCBiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBTZWxlY3RvciBmb3IgSFRNTCB0YWJsZXMuIEFwcGx5IHRoZSBnaXZlbiBzZWxlY3RvciB0byB0aGUgZ2l2ZSBhcnJheSBvZlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0galF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBvciBpbnRlZ2VyXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSAge2FycmF5fSBBcnJheSBvZiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdHMgdG8gYmUgZmlsdGVyZWRcclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybiB7YXJyYXl9XHJcblx0ICAgICAgICAgICAgICAgICAqIEBpZ25vcmVcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX3RhYmxlX3NlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJbnRlZ2VyIGlzIHVzZWQgdG8gcGljayBvdXQgYSB0YWJsZSBieSBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fbc2VsZWN0b3JdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGEgalF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSB0YWJsZSBub2Rlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gJC5tYXAoYSwgZnVuY3Rpb24gKGVsLCBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5UYWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKG5vZGVzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoc2VsZWN0b3IpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHRyYW5zbGF0ZSBiYWNrIGZyb20gdGhlIHRhYmxlIG5vZGUgdG8gdGhlIHNldHRpbmdzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSAkLmluQXJyYXkodGhpcywgbm9kZXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVtpZHhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENvbnRleHQgc2VsZWN0b3IgZm9yIHRoZSBBUEkncyBjb250ZXh0IChpLmUuIHRoZSB0YWJsZXMgdGhlIEFQSSBpbnN0YW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgKiByZWZlcnMgdG8uXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBuYW1lICAgIERhdGFUYWJsZS5BcGkjdGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0gU2VsZWN0b3IgdG8gcGljayB3aGljaCB0YWJsZXMgdGhlIGl0ZXJhdG9yXHJcblx0ICAgICAgICAgICAgICAgICAqICAgc2hvdWxkIG9wZXJhdGUgb24uIElmIG5vdCBnaXZlbiwgYWxsIHRhYmxlcyBpbiB0aGUgY3VycmVudCBjb250ZXh0IGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHVzZWQuIFRoaXMgY2FuIGJlIGdpdmVuIGFzIGEgalF1ZXJ5IHNlbGVjdG9yIChmb3IgZXhhbXBsZSBgJzpndCgwKSdgKSB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHNlbGVjdCBtdWx0aXBsZSB0YWJsZXMgb3IgYXMgYW4gaW50ZWdlciB0byBzZWxlY3QgYSBzaW5nbGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGUuQXBpfSBSZXR1cm5zIGEgbmV3IEFQSSBpbnN0YW5jZSBpZiBhIHNlbGVjdG9yIGlzIGdpdmVuLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcigndGFibGVzKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQgaWYgdGhlcmUgd2FzIGEgc2VsZWN0b3Igc3BlY2lmaWVkXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0b3IgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBfQXBpKF9fdGFibGVfc2VsZWN0b3Ioc2VsZWN0b3IsIHRoaXMuY29udGV4dCkpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCd0YWJsZSgpJywgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVzID0gdGhpcy50YWJsZXMoc2VsZWN0b3IpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRhYmxlcy5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkoY3R4WzBdKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVzO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5ub2RlcygpJywgJ3RhYmxlKCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgublRhYmxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3RhYmxlcygpLmJvZHkoKScsICd0YWJsZSgpLmJvZHkoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lm5UQm9keTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5oZWFkZXIoKScsICd0YWJsZSgpLmhlYWRlcigpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgublRIZWFkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3RhYmxlcygpLmZvb3RlcigpJywgJ3RhYmxlKCkuZm9vdGVyKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5uVEZvb3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgndGFibGVzKCkuY29udGFpbmVycygpJywgJ3RhYmxlKCkuY29udGFpbmVyKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5uVGFibGVXcmFwcGVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUmVkcmF3IHRoZSB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9dHJ1ZV0gUmVzZXQgKGRlZmF1bHQpIG9yIGhvbGQgdGhlIGN1cnJlbnQgcGFnaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICAgcG9zaXRpb24uIEEgZnVsbCByZS1zb3J0IGFuZCByZS1maWx0ZXIgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBtZXRob2QgaXNcclxuXHQgICAgICAgICAgICAgICAgICogICBjYWxsZWQsIHdoaWNoIGlzIHdoeSB0aGUgcGFnaW5hdGlvbiByZXNldCBpcyB0aGUgZGVmYXVsdCBhY3Rpb24uXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignZHJhdygpJywgZnVuY3Rpb24gKHJlc2V0UGFnaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5SZURyYXcoc2V0dGluZ3MsIHJlc2V0UGFnaW5nID09PSBmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBpbmRleC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkKVxyXG5cdCAgICAgICAgICAgICAgICAgKi8vKipcclxuXHRcdCAqIFNldCB0aGUgY3VycmVudCBwYWdlLlxyXG5cdFx0ICpcclxuXHRcdCAqIE5vdGUgdGhhdCBpZiB5b3UgYXR0ZW1wdCB0byBzaG93IGEgcGFnZSB3aGljaCBkb2VzIG5vdCBleGlzdCwgRGF0YVRhYmxlcyB3aWxsXHJcblx0XHQgKiBub3QgdGhyb3cgYW4gZXJyb3IsIGJ1dCByYXRoZXIgcmVzZXQgdGhlIHBhZ2luZy5cclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge2ludGVnZXJ8c3RyaW5nfSBhY3Rpb24gVGhlIHBhZ2luZyBhY3Rpb24gdG8gdGFrZS4gVGhpcyBjYW4gYmUgb25lIG9mOlxyXG5cdFx0ICogICogYGludGVnZXJgIC0gVGhlIHBhZ2UgaW5kZXggdG8ganVtcCB0b1xyXG5cdFx0ICogICogYHN0cmluZ2AgLSBBbiBhY3Rpb24gdG8gdGFrZTpcclxuXHRcdCAqICAgICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZS5cclxuXHRcdCAqICAgICogYG5leHRgIC0gSnVtcCB0byB0aGUgbmV4dCBwYWdlXHJcblx0XHQgKiAgICAqIGBwcmV2aW91c2AgLSBKdW1wIHRvIHByZXZpb3VzIHBhZ2VcclxuXHRcdCAqICAgICogYGxhc3RgIC0gSnVtcCB0byB0aGUgbGFzdCBwYWdlLlxyXG5cdFx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcblx0XHQgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcigncGFnZSgpJywgZnVuY3Rpb24gKGFjdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFnZS5pbmZvKCkucGFnZTsgLy8gbm90IGFuIGV4cGVuc2l2ZSBjYWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSwgaGF2ZSBhbiBhY3Rpb24gdG8gdGFrZSBvbiBhbGwgdGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5QYWdlQ2hhbmdlKHNldHRpbmdzLCBhY3Rpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBQYWdpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBJZiB5b3UgcmVxdWlyZSBwYWdpbmcgaW5mb3JtYXRpb24gZm9yIGFub3RoZXIgdGFibGUsIHVzZSB0aGUgYHRhYmxlKClgIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgKiB3aXRoIGEgc3VpdGFibGUgc2VsZWN0b3IuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHNldDpcclxuXHQgICAgICAgICAgICAgICAgICogICogYHBhZ2VgIC0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkIC0gaS5lLiB0aGUgZmlyc3QgcGFnZSBpcyBgMGApXHJcblx0ICAgICAgICAgICAgICAgICAqICAqIGBwYWdlc2AgLSBUb3RhbCBudW1iZXIgb2YgcGFnZXNcclxuXHQgICAgICAgICAgICAgICAgICogICogYHN0YXJ0YCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBmaXJzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgKiBgZW5kYCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBsYXN0IHJlY29yZCBzaG93biBvbiB0aGUgY3VycmVudCBwYWdlXHJcblx0ICAgICAgICAgICAgICAgICAqICAqIGBsZW5ndGhgIC0gRGlzcGxheSBsZW5ndGggKG51bWJlciBvZiByZWNvcmRzKS4gTm90ZSB0aGF0IGdlbmVyYWxseSBgc3RhcnRcclxuXHQgICAgICAgICAgICAgICAgICogICAgKyBsZW5ndGggPSBlbmRgLCBidXQgdGhpcyBpcyBub3QgYWx3YXlzIHRydWUsIGZvciBleGFtcGxlIGlmIHRoZXJlIGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBvbmx5IDIgcmVjb3JkcyB0byBzaG93IG9uIHRoZSBmaW5hbCBwYWdlLCB3aXRoIGEgbGVuZ3RoIG9mIDEwLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgKiBgcmVjb3Jkc1RvdGFsYCAtIEZ1bGwgZGF0YSBzZXQgbGVuZ3RoXHJcblx0ICAgICAgICAgICAgICAgICAqICAqIGByZWNvcmRzRGlzcGxheWAgLSBEYXRhIHNldCBsZW5ndGggb25jZSB0aGUgY3VycmVudCBmaWx0ZXJpbmcgY3JpdGVyaW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGFyZSBhcHBsaWVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcigncGFnZS5pbmZvKCknLCBmdW5jdGlvbiAoYWN0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLmNvbnRleHRbMF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhbGwgPSBsZW4gPT09IC0xO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWdlXCI6IGFsbCA/IDAgOiBNYXRoLmZsb29yKHN0YXJ0IC8gbGVuKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInBhZ2VzXCI6IGFsbCA/IDEgOiBNYXRoLmNlaWwodmlzUmVjb3JkcyAvIGxlbiksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzdGFydFwiOiBzdGFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImVuZFwiOiBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImxlbmd0aFwiOiBsZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWNvcmRzVG90YWxcIjogc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInJlY29yZHNEaXNwbGF5XCI6IHZpc1JlY29yZHNcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2ludGVnZXJ9IEN1cnJlbnQgcGFnZSBsZW5ndGguIE5vdGUgYC0xYCBpbmRpY2F0ZXMgdGhhdCBhbGwgcmVjb3Jkc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIGFyZSB0byBiZSBzaG93bi5cclxuXHQgICAgICAgICAgICAgICAgICovLyoqXHJcblx0XHQgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHtpbnRlZ2VyfSBQYWdlIGxlbmd0aCB0byBzZXQuIFVzZSBgLTFgIHRvIHNob3cgYWxsIHJlY29yZHMuXHJcblx0XHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuXHRcdCAqL1xyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdwYWdlLmxlbigpJywgZnVuY3Rpb24gKGxlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbid0IGNhbGwgdGhpcyBmdW5jdGlvbiAnbGVuZ3RoKCknIGJlY2F1c2UgYGxlbmd0aGBcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGlzIGEgSmF2YXNjcmlwdCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgd2hpY2ggZGVmaW5lcyBob3cgbWFueSBhcmd1bWVudHNcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmdW5jdGlvbiBleHBlY3RzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggIT09IDAgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRbMF0uX2lEaXNwbGF5TGVuZ3RoIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UsIHNldCB0aGUgcGFnZSBsZW5ndGhcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxlbmd0aENoYW5nZShzZXR0aW5ncywgbGVuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fcmVsb2FkID0gZnVuY3Rpb24gKHNldHRpbmdzLCBob2xkUG9zaXRpb24sIGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRyYXcgZXZlbnQgdG8gdHJpZ2dlciBhIGNhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gbmV3IF9BcGkoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcGkub25lKCdkcmF3JywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhhcGkuYWpheC5qc29uKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfZm5EYXRhU291cmNlKHNldHRpbmdzKSA9PSAnc3NwJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mblJlRHJhdyhzZXR0aW5ncywgaG9sZFBvc2l0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgeGhyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5CdWlsZEFqYXgoc2V0dGluZ3MsIFtdLCBmdW5jdGlvbiAoanNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DbGVhclRhYmxlKHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX2ZuQWpheERhdGFTcmMoc2V0dGluZ3MsIGpzb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gZGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGREYXRhKHNldHRpbmdzLCBkYXRhW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzLCBob2xkUG9zaXRpb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIEpTT04gcmVzcG9uc2UgZnJvbSB0aGUgbGFzdCBBamF4IHJlcXVlc3QgdGhhdCBEYXRhVGFibGVzIG1hZGUgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIHNlcnZlci4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgSlNPTiBmcm9tIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiBjb250ZXh0LlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEpTT04gcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC5qc29uKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhbMF0uanNvbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHJldHVybiB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGRhdGEgc3VibWl0dGVkIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC5wYXJhbXMoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eFswXS5vQWpheERhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUmVsb2FkIHRhYmxlcyBmcm9tIHRoZSBBamF4IGRhdGEgc291cmNlLiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsXHJcblx0ICAgICAgICAgICAgICAgICAqIGF1dG9tYXRpY2FsbHkgcmUtZHJhdyB0aGUgdGFibGUgd2hlbiB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNldD10cnVlXSBSZXNldCAoZGVmYXVsdCkgb3IgaG9sZCB0aGUgY3VycmVudCBwYWdpbmdcclxuXHQgICAgICAgICAgICAgICAgICogICBwb3NpdGlvbi4gQSBmdWxsIHJlLXNvcnQgYW5kIHJlLWZpbHRlciBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIG1ldGhvZCBpc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIGNhbGxlZCwgd2hpY2ggaXMgd2h5IHRoZSBwYWdpbmF0aW9uIHJlc2V0IGlzIHRoZSBkZWZhdWx0IGFjdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdhamF4LnJlbG9hZCgpJywgZnVuY3Rpb24gKGNhbGxiYWNrLCByZXNldFBhZ2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX19yZWxvYWQoc2V0dGluZ3MsIHJlc2V0UGFnaW5nID09PSBmYWxzZSwgY2FsbGJhY2spO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgdGhlIFVSTCBmcm9tIHRoZSBmaXJzdFxyXG5cdCAgICAgICAgICAgICAgICAgKiB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEN1cnJlbnQgQWpheCBzb3VyY2UgVVJMXHJcblx0ICAgICAgICAgICAgICAgICAqLy8qKlxyXG5cdFx0ICogU2V0IHRoZSBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgd2lsbCBzZXQgdGhlIFVSTCBmb3IgYWxsIHRhYmxlcyBpbiB0aGVcclxuXHRcdCAqIGN1cnJlbnQgY29udGV4dC5cclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCB0byBzZXQuXHJcblx0XHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuXHRcdCAqL1xyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdhamF4LnVybCgpJywgZnVuY3Rpb24gKHVybCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdHggPSBjdHhbMF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHguYWpheCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuaXNQbGFpbk9iamVjdChjdHguYWpheCkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFqYXgudXJsIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hamF4IDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNBamF4U291cmNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChzZXR0aW5ncy5hamF4KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hamF4LnVybCA9IHVybDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFqYXggPSB1cmw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY29uc2lkZXIgc0FqYXhTb3VyY2UgaGVyZSBzaW5jZSBEYXRhVGFibGVzIGdpdmVzIHByaW9yaXR5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYGFqYXhgIG92ZXIgYHNBamF4U291cmNlYC4gU28gc2V0dGluZyBgYWpheGAgaGVyZSwgcmVuZGVycyBhbnlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBvZiBgc0FqYXhTb3VyY2VgIHJlZHVuZGFudC5cclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogTG9hZCBkYXRhIGZyb20gdGhlIG5ld2x5IHNldCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHlcclxuXHQgICAgICAgICAgICAgICAgICogYXZhaWxhYmxlIHdoZW4gYGFqYXgudXJsKClgIGlzIHVzZWQgdG8gc2V0IGEgVVJMLiBBZGRpdGlvbmFsbHksIHRoaXMgbWV0aG9kXHJcblx0ICAgICAgICAgICAgICAgICAqIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgY2FsbGluZyBgYWpheC5yZWxvYWQoKWAgYnV0IGlzIHByb3ZpZGVkIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgKiBjb252ZW5pZW5jZSB3aGVuIHNldHRpbmcgYSBuZXcgVVJMLiBMaWtlIGBhamF4LnJlbG9hZCgpYCBpdCB3aWxsXHJcblx0ICAgICAgICAgICAgICAgICAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IHRoZSB0YWJsZSBvbmNlIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC51cmwoKS5sb2FkKCknLCBmdW5jdGlvbiAoY2FsbGJhY2ssIHJlc2V0UGFnaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTYW1lIGFzIGEgcmVsb2FkLCBidXQgbWFrZXMgc2Vuc2UgdG8gcHJlc2VudCBpdCBmb3IgZWFzeSBhY2Nlc3MgYWZ0ZXIgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdXJsIGNoYW5nZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9fcmVsb2FkKGN0eCwgcmVzZXRQYWdpbmcgPT09IGZhbHNlLCBjYWxsYmFjayk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3NlbGVjdG9yX3J1biA9IGZ1bmN0aW9uICh0eXBlLCBzZWxlY3Rvciwgc2VsZWN0Rm4sIHNldHRpbmdzLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBbXSwgcmVzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGEsIGksIGllbiwgaiwgamVuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yVHlwZSA9IHR5cGVvZiBzZWxlY3RvcjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCBqdXN0IGNoZWNrIGZvciBpc0FycmF5IGhlcmUsIGFzIGFuIEFQSSBvciBqUXVlcnkgaW5zdGFuY2UgbWlnaHQgYmVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGdpdmVuIHdpdGggdGhlaXIgYXJyYXkgbGlrZSBsb29rXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yVHlwZSA9PT0gJ3N0cmluZycgfHwgc2VsZWN0b3JUeXBlID09PSAnZnVuY3Rpb24nIHx8IHNlbGVjdG9yLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBbc2VsZWN0b3JdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHNlbGVjdG9yLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhID0gc2VsZWN0b3JbaV0gJiYgc2VsZWN0b3JbaV0uc3BsaXQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcltpXS5zcGxpdCgnLCcpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdG9yW2ldXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamVuID0gYS5sZW5ndGggOyBqIDwgamVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHNlbGVjdEZuKHR5cGVvZiBhW2pdID09PSAnc3RyaW5nJyA/ICQudHJpbShhW2pdKSA6IGFbal0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyAmJiByZXMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaC5hcHBseShvdXQsIHJlcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0b3IgZXh0ZW5zaW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGV4dCA9IF9leHQuc2VsZWN0b3JbdHlwZV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXh0Lmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGV4dC5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCA9IGV4dFtpXShzZXR0aW5ncywgb3B0cywgb3V0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3NlbGVjdG9yX29wdHMgPSBmdW5jdGlvbiAob3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciAxLjktIHdoaWNoIHVzZWQgdGhlIHRlcm1pbm9sb2d5IGZpbHRlciByYXRoZXJcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHRoYW4gc2VhcmNoXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5maWx0ZXIgJiYgb3B0cy5zZWFyY2ggPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuc2VhcmNoID0gb3B0cy5maWx0ZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2g6ICdub25lJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogJ2N1cnJlbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6ICdhbGwnXHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCBvcHRzKTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3NlbGVjdG9yX2ZpcnN0ID0gZnVuY3Rpb24gKGluc3QpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJlZHVjZSB0aGUgQVBJIGluc3RhbmNlIHRvIHRoZSBmaXJzdCBpdGVtIGZvdW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gaW5zdC5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RbaV0ubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ24gdGhlIGZpcnN0IGVsZW1lbnQgdG8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGluc3RhbmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0cnVuY2F0ZSB0aGUgaW5zdGFuY2UgYW5kIGNvbnRleHRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdFswXSA9IGluc3RbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RbMF0ubGVuZ3RoID0gMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC5sZW5ndGggPSAxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0LmNvbnRleHQgPSBbaW5zdC5jb250ZXh0W2ldXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZm91bmQgLSByZXR1cm4gYW4gZW1wdHkgaW5zdGFuY2VcclxuXHQgICAgICAgICAgICAgICAgICAgIGluc3QubGVuZ3RoID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfc2VsZWN0b3Jfcm93X2luZGV4ZXMgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGksIGllbiwgdG1wLCBhID0gW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUZpbHRlcmVkID0gc2V0dGluZ3MuYWlEaXNwbGF5LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoID0gb3B0cy5zZWFyY2gsICAvLyBub25lLCBhcHBsaWVkLCByZW1vdmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIgPSBvcHRzLm9yZGVyLCAgIC8vIGFwcGxpZWQsIGN1cnJlbnQsIGluZGV4IChvcmlnaW5hbCAtIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFnZSA9IG9wdHMucGFnZTsgICAgLy8gYWxsLCBjdXJyZW50XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKF9mbkRhdGFTb3VyY2Uoc2V0dGluZ3MpID09ICdzc3AnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBtb2RlLCBtb3N0IG9wdGlvbnMgYXJlIGlycmVsZXZhbnQgc2luY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyByb3dzIG5vdCBzaG93biBkb24ndCBleGlzdCBhbmQgdGhlIGluZGV4IG9yZGVyIGlzIHRoZSBhcHBsaWVkIG9yZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlZCBpcyBhIHNwZWNpYWwgY2FzZSAtIGZvciBjb25zaXN0ZW5jeSBqdXN0IHJldHVybiBhbiBlbXB0eVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaCA9PT0gJ3JlbW92ZWQnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmFuZ2UoMCwgZGlzcGxheU1hc3Rlci5sZW5ndGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFnZSA9PSAnY3VycmVudCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50IHBhZ2UgaW1wbGllcyB0aGF0IG9yZGVyPWN1cnJlbnQgYW5kIGZpdGxlcj1hcHBsaWVkLCBzaW5jZSBpdCBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhaXJseSBzZW5zZWxlc3Mgb3RoZXJ3aXNlLCByZWdhcmRsZXNzIG9mIHdoYXQgb3JkZXIgYW5kIHNlYXJjaCBhY3R1YWxseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LCBpZW4gPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGRpc3BsYXlGaWx0ZXJlZFtpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3JkZXIgPT0gJ2N1cnJlbnQnIHx8IG9yZGVyID09ICdhcHBsaWVkJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBzZWFyY2ggPT0gJ25vbmUnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hc3Rlci5zbGljZSgpIDogICAgICAgICAgICAgICAgICAgICAgLy8gbm8gc2VhcmNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaCA9PSAnYXBwbGllZCcgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUZpbHRlcmVkLnNsaWNlKCkgOiAgICAgICAgICAgICAgICAvLyBhcHBsaWVkIHNlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5tYXAoZGlzcGxheU1hc3RlciwgZnVuY3Rpb24gKGVsLCBpKSB7IC8vIHJlbW92ZWQgc2VhcmNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuaW5BcnJheShlbCwgZGlzcGxheUZpbHRlcmVkKSA9PT0gLTEgPyBlbCA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yZGVyID09ICdpbmRleCcgfHwgb3JkZXIgPT0gJ29yaWdpbmFsJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gJ25vbmUnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goaSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGFwcGxpZWQgfCByZW1vdmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSAkLmluQXJyYXkoaSwgZGlzcGxheUZpbHRlcmVkKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG1wID49IDAgJiYgc2VhcmNoID09ICdhcHBsaWVkJykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goaSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXHJcblx0ICAgICAgICAgICAgICAgICAqIFJvd3NcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICoge30gICAgICAgICAgLSBubyBzZWxlY3RvciAtIHVzZSBhbGwgYXZhaWxhYmxlIHJvd3NcclxuXHQgICAgICAgICAgICAgICAgICoge2ludGVnZXJ9ICAgLSByb3cgYW9EYXRhIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAqIHtub2RlfSAgICAgIC0gVFIgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgKiB7c3RyaW5nfSAgICAtIGpRdWVyeSBzZWxlY3RvciB0byBhcHBseSB0byB0aGUgVFIgZWxlbWVudHNcclxuXHQgICAgICAgICAgICAgICAgICoge2FycmF5fSAgICAgLSBqUXVlcnkgYXJyYXkgb2Ygbm9kZXMsIG9yIHNpbXBseSBhbiBhcnJheSBvZiBUUiBub2Rlc1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19yb3dfc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHNlbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxJbnQgPSBfaW50VmFsKHNlbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGllbjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnQgY3V0IC0gc2VsZWN0b3IgaXMgYSBudW1iZXIgYW5kIG5vIG9wdGlvbnMgcHJvdmlkZWQgKGRlZmF1bHQgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgcmVjb3Jkcywgc28gbm8gbmVlZCB0byBjaGVjayBpZiB0aGUgaW5kZXggaXMgaW4gdGhlcmUsIHNpbmNlIGl0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbXVzdCBiZSAtIGRldiBlcnJvciBpZiB0aGUgaW5kZXggZG9lc24ndCBleGlzdCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbEludCAhPT0gbnVsbCAmJiAhb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NlbEludF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyhzZXR0aW5ncywgb3B0cyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxJbnQgIT09IG51bGwgJiYgJC5pbkFycmF5KHNlbEludCwgcm93cykgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gaW50ZWdlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NlbEludF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBub25lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3dzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChyb3dzLCBmdW5jdGlvbiAoaWR4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gc2V0dGluZ3MuYW9EYXRhW2lkeF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsKGlkeCwgcm93Ll9hRGF0YSwgcm93Lm5UcikgPyBpZHggOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBub2RlcyBpbiB0aGUgb3JkZXIgZnJvbSB0aGUgYHJvd3NgIGFycmF5IHdpdGggbnVsbCB2YWx1ZXMgcmVtb3ZlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IF9yZW1vdmVFbXB0eShcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BsdWNrX29yZGVyKHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ25UcicpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbC5ub2RlTmFtZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KHNlbCwgbm9kZXMpICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWwuX0RUX1Jvd0luZGV4XTsgLy8gc2VsIGlzIGEgVFIgbm9kZSB0aGF0IGlzIGluIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIERhdGFUYWJsZXMgYWRkcyBhIHByb3AgZm9yIGZhc3QgbG9va3VwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0galF1ZXJ5IHNlbGVjdG9yIHN0cmluZywgYXJyYXkgb2Ygbm9kZXMgb3IgalF1ZXJ5IG9iamVjdC9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyBqUXVlcnkncyAuZmlsdGVyKCkgYWxsb3dzIGpRdWVyeSBvYmplY3RzIHRvIGJlIHBhc3NlZCBpbiBmaWx0ZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgYWxzbyBhbGxvd3MgYXJyYXlzLCBzbyB0aGlzIHdpbGwgY29wZSB3aXRoIGFsbCB0aHJlZSBvcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQobm9kZXMpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoc2VsKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9EVF9Sb3dJbmRleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZWxlY3Rvcl9ydW4oJ3JvdycsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzKTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3dzKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50IHNoaWZ0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3Qoc2VsZWN0b3IpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IHNlbGVjdG9yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgb3B0cyA9IF9zZWxlY3Rvcl9vcHRzKG9wdHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19yb3dfc2VsZWN0b3Ioc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX19yb3dfc2VsZWN0b3I/XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbnN0LnNlbGVjdG9yLnJvd3MgPSBzZWxlY3RvcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluc3Quc2VsZWN0b3Iub3B0cyA9IG9wdHM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3Q7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93cygpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9EYXRhW3Jvd10ublRyIHx8IHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3Jvd3MoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcih0cnVlLCAncm93cycsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcGx1Y2tfb3JkZXIoc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnX2FEYXRhJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdyb3dzKCkuY2FjaGUoKScsICdyb3coKS5jYWNoZSgpJywgZnVuY3Rpb24gKHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gc2V0dGluZ3MuYW9EYXRhW3Jvd107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdzZWFyY2gnID8gci5fYUZpbHRlckRhdGEgOiByLl9hU29ydERhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdyb3dzKCkuaW52YWxpZGF0ZSgpJywgJ3JvdygpLmludmFsaWRhdGUoKScsIGZ1bmN0aW9uIChzcmMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkludmFsaWRhdGUoc2V0dGluZ3MsIHJvdywgc3JjKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3Jvd3MoKS5pbmRleGVzKCknLCAncm93KCkuaW5kZXgoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3c7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdyb3dzKCkucmVtb3ZlKCknLCAncm93KCkucmVtb3ZlKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3JvdycsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCB0aGF0SWR4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKHJvdywgMSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgX0RUX1Jvd0luZGV4IHBhcmFtZXRlciBvbiBhbGwgcm93cyBpbiB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gZGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLm5UciAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXS5uVHIuX0RUX1Jvd0luZGV4ID0gaTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YXJnZXQgcm93IGZyb20gdGhlIHNlYXJjaCBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5SW5kZXggPSAkLmluQXJyYXkocm93LCBzZXR0aW5ncy5haURpc3BsYXkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5EZWxldGVJbmRleChzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsIHJvdyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRGVsZXRlSW5kZXgoc2V0dGluZ3MuYWlEaXNwbGF5LCByb3cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRlbGV0ZUluZGV4KHRoYXRbdGhhdElkeF0sIHJvdywgZmFsc2UpOyAvLyBtYWludGFpbiBsb2NhbCBpbmRleGVzXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbiAnb3ZlcmZsb3cnIHRoZXkgY2FzZSBmb3IgZGlzcGxheWluZyB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5MZW5ndGhPdmVyZmxvdyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93cy5hZGQoKScsIGZ1bmN0aW9uIChyb3dzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Um93cyA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdywgaSwgaWVuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gcm93cy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvd3NbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93Lm5vZGVOYW1lICYmIHJvdy5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnVFInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChfZm5BZGRUcihzZXR0aW5ncywgcm93KVswXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChfZm5BZGREYXRhKHNldHRpbmdzLCByb3cpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCBzbyByb3dzKCkubm9kZXMoKSBldGMgY2FuIGJlIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKC0xKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1vZFJvd3MucG9wKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBtb2RSb3dzLnB1c2guYXBwbHkobW9kUm93cywgbmV3Um93cy50b0FycmF5KCkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBtb2RSb3dzO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3JvdygpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KHRoaXMucm93cyhzZWxlY3Rvciwgb3B0cykpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3coKS5kYXRhKCknLCBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLl9hRGF0YSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIGN0eFswXS5hb0RhdGFbdGhpc1swXV0uX2FEYXRhID0gZGF0YTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IGludmFsaWRhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkludmFsaWRhdGUoY3R4WzBdLCB0aGlzWzBdLCAnZGF0YScpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3coKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLm5UciB8fCBudWxsIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3cuYWRkKCknLCBmdW5jdGlvbiAocm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhIGpRdWVyeSBvYmplY3QgdG8gYmUgcGFzc2VkIGluIC0gb25seSBhIHNpbmdsZSByb3cgaXMgYWRkZWQgZnJvbVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaXQgdGhvdWdoIC0gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvdyBpbnN0YW5jZW9mICQgJiYgcm93Lmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvd1swXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuQWRkVHIoc2V0dGluZ3MsIHJvdylbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5BZGREYXRhKHNldHRpbmdzLCByb3cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFuIEFwaS5yb3dzKCkgZXh0ZW5kZWQgaW5zdGFuY2UsIHdpdGggdGhlIG5ld2x5IGFkZGVkIHJvdyBzZWxlY3RlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93KHJvd3NbMF0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fZGV0YWlsc19hZGQgPSBmdW5jdGlvbiAoY3R4LCByb3csIGRhdGEsIGtsYXNzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRvIGFycmF5IG9mIFRSIGVsZW1lbnRzXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFkZFJvdyA9IGZ1bmN0aW9uIChyLCBrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaW9uIHRvIGFsbG93IGZvciBhcnJheXMgb2YgalF1ZXJ5IG9iamVjdHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KHIpIHx8IHIgaW5zdGFuY2VvZiAkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSByLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJvdyhyW2ldLCBrKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnZXQgYSBUUiBlbGVtZW50LCB0aGVuIGp1c3QgYWRkIGl0IGRpcmVjdGx5IC0gdXAgdG8gdGhlIGRldlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGFkZCB0aGUgY29ycmVjdCBudW1iZXIgb2YgY29sdW1ucyBldGNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoci5ub2RlTmFtZSAmJiByLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0cicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNyZWF0ZSBhIHJvdyB3aXRoIGEgd3JhcHBlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZCA9ICQoJzx0cj48dGQvPjwvdHI+JykuYWRkQ2xhc3Moayk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJ3RkJywgY3JlYXRlZClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhrKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwocilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFswXS5jb2xTcGFuID0gX2ZuVmlzYmxlQ29sdW1ucyhjdHgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKGNyZWF0ZWRbMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWRkUm93KGRhdGEsIGtsYXNzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm93Ll9kZXRhaWxzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLnJlbW92ZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscyA9ICQocm93cyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNoaWxkcmVuIHdlcmUgYWxyZWFkeSBzaG93biwgdGhhdCBzdGF0ZSBzaG91bGQgYmUgcmV0YWluZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHNTaG93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKHJvdy5uVHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX2RldGFpbHNfcmVtb3ZlID0gZnVuY3Rpb24gKGFwaSwgaWR4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVtpZHggIT09IHVuZGVmaW5lZCA/IGlkeCA6IGFwaVswXV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLnJlbW92ZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzU2hvdyA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19kZXRhaWxzX2Rpc3BsYXkgPSBmdW5jdGlvbiAoYXBpLCBzaG93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggJiYgYXBpLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBjdHhbMF0uYW9EYXRhW2FwaVswXV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzU2hvdyA9IHNob3c7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKHJvdy5uVHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmRldGFjaCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RldGFpbHNfZXZlbnRzKGN0eFswXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX2RldGFpbHNfZXZlbnRzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gbmV3IF9BcGkoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9ICcuZHQuRFRfZGV0YWlscyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZHJhd0V2ZW50ID0gJ2RyYXcnICsgbmFtZXNwYWNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHZpc0V2ZW50ID0gJ2NvbHVtbi12aXNpYmlsaXR5JyArIG5hbWVzcGFjZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZXN0cm95RXZlbnQgPSAnZGVzdHJveScgKyBuYW1lc3BhY2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBhcGkub2ZmKGRyYXdFdmVudCArICcgJyArIGNvbHZpc0V2ZW50ICsgJyAnICsgZGVzdHJveUV2ZW50KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX3BsdWNrKGRhdGEsICdfZGV0YWlscycpLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiBlYWNoIGRyYXcsIGluc2VydCB0aGUgcmVxdWlyZWQgZWxlbWVudHMgaW50byB0aGUgZG9jdW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcGkub24oZHJhd0V2ZW50LCBmdW5jdGlvbiAoZSwgY3R4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncyAhPT0gY3R4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5yb3dzKHsgcGFnZTogJ2N1cnJlbnQnIH0pLmVxKDApLmVhY2goZnVuY3Rpb24gKGlkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJuYWwgZGF0YSBncmFiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gZGF0YVtpZHhdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHNTaG93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKHJvdy5uVHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sdW1uIHZpc2liaWxpdHkgY2hhbmdlIC0gdXBkYXRlIHRoZSBjb2xzcGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXBpLm9uKGNvbHZpc0V2ZW50LCBmdW5jdGlvbiAoZSwgY3R4LCBpZHgsIHZpcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbHNwYW4gZm9yIHRoZSBkZXRhaWxzIHJvd3MgKG5vdGUsIG9ubHkgaWYgaXQgYWxyZWFkeSBoYXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBjb2xzcGFuKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93LCB2aXNpYmxlID0gX2ZuVmlzYmxlQ29sdW1ucyhjdHgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gZGF0YVtpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93Ll9kZXRhaWxzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmNoaWxkcmVuKCd0ZFtjb2xzcGFuXScpLmF0dHIoJ2NvbHNwYW4nLCB2aXNpYmxlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWJsZSBkZXN0cm95ZWQgLSBudWtlIGFueSBjaGlsZCByb3dzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXBpLm9uKGRlc3Ryb3lFdmVudCwgZnVuY3Rpb24gKGUsIGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gZGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5fZGV0YWlscykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fZGV0YWlsc19yZW1vdmUoYXBpLCBpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX2VtcCA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX2NoaWxkX29iaiA9IF9lbXAgKyAncm93KCkuY2hpbGQnO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX2NoaWxkX210aCA9IF9jaGlsZF9vYmogKyAnKCknO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gZGF0YSBjYW4gYmU6XHJcblx0ICAgICAgICAgICAgICAgIC8vICB0clxyXG5cdCAgICAgICAgICAgICAgICAvLyAgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgIC8vICBqUXVlcnkgb3IgYXJyYXkgb2YgYW55IG9mIHRoZSBhYm92ZVxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKF9jaGlsZF9tdGgsIGZ1bmN0aW9uIChkYXRhLCBrbGFzcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLl9kZXRhaWxzIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLnNob3coKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX19kZXRhaWxzX3JlbW92ZSh0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfX2RldGFpbHNfYWRkKGN0eFswXSwgY3R4WzBdLmFvRGF0YVt0aGlzWzBdXSwgZGF0YSwga2xhc3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKFtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9jaGlsZF9vYmogKyAnLnNob3coKScsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfY2hpbGRfbXRoICsgJy5zaG93KCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcclxuXHQgICAgICAgICAgICAgICAgXSwgZnVuY3Rpb24gKHNob3cpIHsgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgX19kZXRhaWxzX2Rpc3BsYXkodGhpcywgdHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcihbXHJcblx0ICAgICAgICAgICAgICAgICAgICBfY2hpbGRfb2JqICsgJy5oaWRlKCknLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2NoaWxkX210aCArICcuaGlkZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XHJcblx0ICAgICAgICAgICAgICAgIF0sIGZ1bmN0aW9uICgpIHsgICAgICAgICAvLyBpdCByZXR1cm5zIGFuIG9iamVjdCBhbmQgdGhpcyBtZXRob2QgaXMgbm90IGV4ZWN1dGVkKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgX19kZXRhaWxzX2Rpc3BsYXkodGhpcywgZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2NoaWxkX29iaiArICcucmVtb3ZlKCknLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2NoaWxkX210aCArICcucmVtb3ZlKCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcclxuXHQgICAgICAgICAgICAgICAgXSwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcclxuXHQgICAgICAgICAgICAgICAgICAgIF9fZGV0YWlsc19yZW1vdmUodGhpcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcihfY2hpbGRfb2JqICsgJy5pc1Nob3duKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gX2RldGFpbHNTaG93biBhcyBmYWxzZSBvciB1bmRlZmluZWQgd2lsbCBmYWxsIHRocm91Z2ggdG8gcmV0dXJuIGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eFswXS5hb0RhdGFbdGhpc1swXV0uX2RldGFpbHNTaG93IHx8IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXHJcblx0ICAgICAgICAgICAgICAgICAqIENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICoge2ludGVnZXJ9ICAgICAgICAgICAtIGNvbHVtbiBpbmRleCAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcclxuXHQgICAgICAgICAgICAgICAgICogXCJ7aW50ZWdlcn06dmlzSWR4XCIgIC0gdmlzaWJsZSBjb2x1bW4gaW5kZXggKGkuZS4gdHJhbnNsYXRlIHRvIGNvbHVtbiBpbmRleCkgICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxyXG5cdCAgICAgICAgICAgICAgICAgKiBcIntpbnRlZ2VyfTp2aXNpYmxlXCIgLSBhbGlhcyBmb3Ige2ludGVnZXJ9OnZpc0lkeCAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXHJcblx0ICAgICAgICAgICAgICAgICAqIFwie3N0cmluZ306bmFtZVwiICAgICAtIGNvbHVtbiBuYW1lXHJcblx0ICAgICAgICAgICAgICAgICAqIFwie3N0cmluZ31cIiAgICAgICAgICAtIGpRdWVyeSBzZWxlY3RvciBvbiBjb2x1bW4gaGVhZGVyIG5vZGVzXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gY2FuIGJlIGFuIGFycmF5IG9mIHRoZXNlIGl0ZW1zLCBjb21tYSBzZXBhcmF0ZWQgbGlzdCwgb3IgYW4gYXJyYXkgb2YgY29tbWFcclxuXHQgICAgICAgICAgICAgICAgLy8gc2VwYXJhdGVkIGxpc3RzXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19yZV9jb2x1bW5fc2VsZWN0b3IgPSAvXiguKyk6KG5hbWV8dmlzSWR4fHZpc2libGUpJC87XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gcjEgYW5kIHIyIGFyZSByZWR1bmRhbnQgLSBidXQgaXQgbWVhbnMgdGhhdCB0aGUgcGFyYW1ldGVycyBtYXRjaCBmb3IgdGhlXHJcblx0ICAgICAgICAgICAgICAgIC8vIGl0ZXJhdG9yIGNhbGxiYWNrIGluIGNvbHVtbnMoKS5kYXRhKClcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fY29sdW1uRGF0YSA9IGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCByMSwgcjIsIHJvd3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciByb3cgPSAwLCBpZW4gPSByb3dzLmxlbmd0aCA7IHJvdyA8IGllbiA7IHJvdysrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dzW3Jvd10sIGNvbHVtbikpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fY29sdW1uX3NlbGVjdG9yID0gZnVuY3Rpb24gKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lcyA9IF9wbHVjayhjb2x1bW5zLCAnc05hbWUnKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlcyA9IF9wbHVjayhjb2x1bW5zLCAnblRoJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlbEludCA9IF9pbnRWYWwocyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gYWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmFuZ2UoY29sdW1ucy5sZW5ndGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxJbnQgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWxJbnQgPj0gMCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxJbnQgOiAvLyBDb3VudCBmcm9tIGxlZnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMubGVuZ3RoICsgc2VsSW50IC8vIENvdW50IGZyb20gcmlnaHQgKCsgYmVjYXVzZSBpdHMgYSBuZWdhdGl2ZSB2YWx1ZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yID0gZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHMgPT09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoc2V0dGluZ3MsIG9wdHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGlkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19jb2x1bW5EYXRhKHNldHRpbmdzLCBpZHgsIDAsIDAsIHJvd3MpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpZHhdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSA/IGlkeCA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8galF1ZXJ5IG9yIHN0cmluZyBzZWxlY3RvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHR5cGVvZiBzID09PSAnc3RyaW5nJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2goX19yZV9jb2x1bW5fc2VsZWN0b3IpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzJdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2aXNJZHgnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlzaWJsZSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmlzaWJsZSBpbmRleCBnaXZlbiwgY29udmVydCB0byBjb2x1bW4gaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4IDwgMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudGluZyBmcm9tIHRoZSByaWdodFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlzQ29sdW1ucyA9ICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2wuYlZpc2libGUgPyBpIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbdmlzQ29sdW1uc1t2aXNDb2x1bW5zLmxlbmd0aCArIGlkeF1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudGluZyBmcm9tIHRoZSBsZWZ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChzZXR0aW5ncywgaWR4KV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbmFtZSc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggYnkgbmFtZS4gYG5hbWVzYCBpcyBjb2x1bW4gaW5kZXggY29tcGxldGUgYW5kIGluIG9yZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQubWFwKG5hbWVzLCBmdW5jdGlvbiAobmFtZSwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gbWF0Y2hbMV0gPyBpIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8galF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSBUSCBlbGVtZW50cyBmb3IgdGhlIGNvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQobm9kZXMpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHMpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5pbkFycmF5KHRoaXMsIG5vZGVzKTsgLy8gYG5vZGVzYCBpcyBjb2x1bW4gaW5kZXggY29tcGxldGUgYW5kIGluIG9yZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2VsZWN0b3JfcnVuKCdjb2x1bW4nLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fc2V0Q29sdW1uVmlzID0gZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4sIHZpcywgcmVjYWxjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IGNvbHNbY29sdW1uXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2V0dGluZ3MuYW9EYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdywgY2VsbHMsIGksIGllbiwgdHI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gR2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodmlzID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sLmJWaXNpYmxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29sLmJWaXNpYmxlID09PSB2aXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZpcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgdXNlIGFwcGVuZENoaWxkIG9yIGluc2VydEJlZm9yZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnNlcnRCZWZvcmUgPSAkLmluQXJyYXkodHJ1ZSwgX3BsdWNrKGNvbHMsICdiVmlzaWJsZScpLCBjb2x1bW4gKyAxKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gZGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyID0gZGF0YVtpXS5uVHI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzID0gZGF0YVtpXS5hbkNlbGxzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlcnRCZWZvcmUgY2FuIGFjdCBsaWtlIGFwcGVuZENoaWxkIGlmIDJuZCBhcmcgaXMgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0QmVmb3JlKGNlbGxzW2NvbHVtbl0sIGNlbGxzW2luc2VydEJlZm9yZV0gfHwgbnVsbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJChfcGx1Y2soc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbHVtbikpLmRldGFjaCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvbW1vbiBhY3Rpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb2wuYlZpc2libGUgPSB2aXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5EcmF3SGVhZChzZXR0aW5ncywgc2V0dGluZ3MuYW9IZWFkZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRHJhd0hlYWQoc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVjYWxjID09PSB1bmRlZmluZWQgfHwgcmVjYWxjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSBhZGp1c3QgY29sdW1uIHNpemluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZyhzZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWxpZ24gY29sdW1ucyBmb3Igc2Nyb2xsaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9TY3JvbGwuc1ggfHwgc2V0dGluZ3Mub1Njcm9sbC5zWSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5TY3JvbGxEcmF3KHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXZpc2liaWxpdHknLCBbc2V0dGluZ3MsIGNvbHVtbiwgdmlzXSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuU2F2ZVN0YXRlKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW5zKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50IHNoaWZ0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3Qoc2VsZWN0b3IpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IHNlbGVjdG9yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgb3B0cyA9IF9zZWxlY3Rvcl9vcHRzKG9wdHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19jb2x1bW5fc2VsZWN0b3Ioc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX3Jvd19zZWxlY3Rvcj9cclxuXHQgICAgICAgICAgICAgICAgICAgIGluc3Quc2VsZWN0b3IuY29scyA9IHNlbGVjdG9yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuaGVhZGVyKCknLCAnY29sdW1uKCkuaGVhZGVyKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5uVGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuZm9vdGVyKCknLCAnY29sdW1uKCkuZm9vdGVyKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5uVGY7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuZGF0YSgpJywgJ2NvbHVtbigpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4tcm93cycsIF9fY29sdW1uRGF0YSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmRhdGFTcmMoKScsICdjb2x1bW4oKS5kYXRhU3JjKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ubURhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuY2FjaGUoKScsICdjb2x1bW4oKS5jYWNoZSgpJywgZnVuY3Rpb24gKHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4tcm93cycsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wbHVja19vcmRlcihzZXR0aW5ncy5hb0RhdGEsIHJvd3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YScsIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkubm9kZXMoKScsICdjb2x1bW4oKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NvbHVtbi1yb3dzJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3BsdWNrX29yZGVyKHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ2FuQ2VsbHMnLCBjb2x1bW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLnZpc2libGUoKScsICdjb2x1bW4oKS52aXNpYmxlKCknLCBmdW5jdGlvbiAodmlzLCBjYWxjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLmJWaXNpYmxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9fc2V0Q29sdW1uVmlzKHNldHRpbmdzLCBjb2x1bW4sIHZpcywgY2FsYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuaW5kZXhlcygpJywgJ2NvbHVtbigpLmluZGV4KCknLCBmdW5jdGlvbiAodHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NvbHVtbicsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICd2aXNpYmxlJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKHNldHRpbmdzLCBjb2x1bW4pIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY29sdW1ucy5hZGp1c3QoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW4uaW5kZXgoKScsIGZ1bmN0aW9uICh0eXBlLCBpZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmcm9tVmlzaWJsZScgfHwgdHlwZSA9PT0gJ3RvRGF0YScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mblZpc2libGVUb0NvbHVtbkluZGV4KGN0eCwgaWR4KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Zyb21EYXRhJyB8fCB0eXBlID09PSAndG9WaXNpYmxlJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoY3R4LCBpZHgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW4oKScsIGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZWxlY3Rvcl9maXJzdCh0aGlzLmNvbHVtbnMoc2VsZWN0b3IsIG9wdHMpKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19jZWxsX3NlbGVjdG9yID0gZnVuY3Rpb24gKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyhzZXR0aW5ncywgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbHMgPSBfcmVtb3ZlRW1wdHkoX3BsdWNrX29yZGVyKGRhdGEsIHJvd3MsICdhbkNlbGxzJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFsbENlbGxzID0gJChbXS5jb25jYXQuYXBwbHkoW10sIGNlbGxzKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGEsIGksIGllbiwgaiwgbywgaG9zdDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5TZWxlY3RvciA9IHR5cGVvZiBzID09PSAnZnVuY3Rpb24nO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQgfHwgZm5TZWxlY3Rvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgY2VsbHMgYW5kIGZ1bmN0aW9uIHNlbGVjdG9yc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSByb3dzLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvd3NbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCA7IGogPCBjb2x1bW5zIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogalxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmblNlbGVjdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdCA9IHNldHRpbmdzLmFvRGF0YVtyb3ddO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMobywgX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvdywgaiksIGhvc3QuYW5DZWxscyA/IGhvc3QuYW5DZWxsc1tqXSA6IG51bGwpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gYWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChvKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QocykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0galF1ZXJ5IGZpbHRlcmVkIGNlbGxzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbENlbGxzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaSwgZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGVsLnBhcmVudE5vZGUuX0RUX1Jvd0luZGV4O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3csXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAkLmluQXJyYXkoZWwsIGRhdGFbcm93XS5hbkNlbGxzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZWxlY3Rvcl9ydW4oJ2NlbGwnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjZWxscygpJywgZnVuY3Rpb24gKHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQXJndW1lbnQgc2hpZnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3Qocm93U2VsZWN0b3IpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5kZXhlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciBvcHRpb25zIGluIGZpcnN0IHBhcmFtZXRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzID0gcm93U2VsZWN0b3I7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd1NlbGVjdG9yID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENlbGwgaW5kZXggb2JqZWN0cyBpbiBmaXJzdCBwYXJhbWV0ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IGNvbHVtblNlbGVjdG9yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TZWxlY3RvciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChjb2x1bW5TZWxlY3RvcikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRzID0gY29sdW1uU2VsZWN0b3I7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2VsZWN0b3IgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENlbGwgc2VsZWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW5TZWxlY3RvciA9PT0gbnVsbCB8fCBjb2x1bW5TZWxlY3RvciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2NlbGxfc2VsZWN0b3Ioc2V0dGluZ3MsIHJvd1NlbGVjdG9yLCBfc2VsZWN0b3Jfb3B0cyhvcHRzKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUm93ICsgY29sdW1uIHNlbGVjdG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucyhjb2x1bW5TZWxlY3Rvciwgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMucm93cyhyb3dTZWxlY3Rvciwgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYSwgaSwgaWVuLCBqLCBqZW47XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGlkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gcm93c1tpZHhdLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamVuID0gY29sdW1uc1tpZHhdLmxlbmd0aCA7IGogPCBqZW4gOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3dzW2lkeF1baV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW5zW2lkeF1bal1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKGNlbGxzLnNlbGVjdG9yLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sczogY29sdW1uU2VsZWN0b3IsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93czogcm93U2VsZWN0b3IsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogb3B0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxzO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLm5vZGVzKCknLCAnY2VsbCgpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IHNldHRpbmdzLmFvRGF0YVtyb3ddLmFuQ2VsbHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxzID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHNbY29sdW1uXSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjZWxscygpLmRhdGEoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93LCBjb2x1bW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NlbGxzKCkuY2FjaGUoKScsICdjZWxsKCkuY2FjaGUoKScsIGZ1bmN0aW9uICh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSA9PT0gJ3NlYXJjaCcgPyAnX2FGaWx0ZXJEYXRhJyA6ICdfYVNvcnREYXRhJztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9EYXRhW3Jvd11bdHlwZV1bY29sdW1uXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLnJlbmRlcigpJywgJ2NlbGwoKS5yZW5kZXIoKScsIGZ1bmN0aW9uICh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvdywgY29sdW1uLCB0eXBlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLmluZGV4ZXMoKScsICdjZWxsKCkuaW5kZXgoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uVmlzaWJsZTogX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoc2V0dGluZ3MsIGNvbHVtbilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NlbGxzKCkuaW52YWxpZGF0ZSgpJywgJ2NlbGwoKS5pbnZhbGlkYXRlKCknLCBmdW5jdGlvbiAoc3JjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5JbnZhbGlkYXRlKHNldHRpbmdzLCByb3csIHNyYywgY29sdW1uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY2VsbCgpJywgZnVuY3Rpb24gKHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZWxlY3Rvcl9maXJzdCh0aGlzLmNlbGxzKHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cykpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjZWxsKCkuZGF0YSgpJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXNbMF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICYmIGNlbGwubGVuZ3RoID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuR2V0Q2VsbERhdGEoY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4pIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuU2V0Q2VsbERhdGEoY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4sIGRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuSW52YWxpZGF0ZShjdHhbMF0sIGNlbGxbMF0ucm93LCAnZGF0YScsIGNlbGxbMF0uY29sdW1uKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgY3VycmVudCBvcmRlcmluZyAoc29ydGluZykgdGhhdCBoYXMgYmVlbiBhcHBsaWVkIHRvIHRoZSB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybnMge2FycmF5fSAyRCBhcnJheSBjb250YWluaW5nIHRoZSBzb3J0aW5nIGluZm9ybWF0aW9uIGZvciB0aGUgZmlyc3RcclxuXHQgICAgICAgICAgICAgICAgICogICB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LiBFYWNoIGVsZW1lbnQgaW4gdGhlIHBhcmVudCBhcnJheSByZXByZXNlbnRzXHJcblx0ICAgICAgICAgICAgICAgICAqICAgYSBjb2x1bW4gYmVpbmcgc29ydGVkIHVwb24gKGkuZS4gbXVsdGktc29ydGluZyB3aXRoIHR3byBjb2x1bW5zIHdvdWxkIGhhdmVcclxuXHQgICAgICAgICAgICAgICAgICogICAyIGlubmVyIGFycmF5cykuIFRoZSBpbm5lciBhcnJheXMgbWF5IGhhdmUgMiBvciAzIGVsZW1lbnRzLiBUaGUgZmlyc3QgaXNcclxuXHQgICAgICAgICAgICAgICAgICogICB0aGUgY29sdW1uIGluZGV4IHRoYXQgdGhlIHNvcnRpbmcgY29uZGl0aW9uIGFwcGxpZXMgdG8sIHRoZSBzZWNvbmQgaXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgZGlyZWN0aW9uIG9mIHRoZSBzb3J0IChgZGVzY2Agb3IgYGFzY2ApIGFuZCwgb3B0aW9uYWxseSwgdGhlIHRoaXJkIGlzIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIGluZGV4IG9mIHRoZSBzb3J0aW5nIG9yZGVyIGZyb20gdGhlIGBjb2x1bW4uc29ydGluZ2AgaW5pdGlhbGlzYXRpb24gYXJyYXkuXHJcblx0ICAgICAgICAgICAgICAgICAqLy8qKlxyXG5cdFx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gb3JkZXIgQ29sdW1uIGluZGV4IHRvIHNvcnQgdXBvbi5cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHRoZSBzb3J0IHRvIGJlIGFwcGxpZWQgKGBhc2NgIG9yIGBkZXNjYClcclxuXHRcdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG5cdFx0ICovLyoqXHJcblx0XHQgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHthcnJheX0gb3JkZXIgMUQgYXJyYXkgb2Ygc29ydGluZyBpbmZvcm1hdGlvbiB0byBiZSBhcHBsaWVkLlxyXG5cdFx0ICogQHBhcmFtIHthcnJheX0gWy4uLl0gT3B0aW9uYWwgYWRkaXRpb25hbCBzb3J0aW5nIGNvbmRpdGlvbnNcclxuXHRcdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG5cdFx0ICovLyoqXHJcblx0XHQgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHthcnJheX0gb3JkZXIgMkQgYXJyYXkgb2Ygc29ydGluZyBpbmZvcm1hdGlvbiB0byBiZSBhcHBsaWVkLlxyXG5cdFx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcblx0XHQgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcignb3JkZXIoKScsIGZ1bmN0aW9uIChvcmRlciwgZGlyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlciA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggIT09IDAgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHhbMF0uYWFTb3J0aW5nIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGUgY29sdW1uIC8gZGlyZWN0aW9uIHBhc3NlZCBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyID0gW1tvcmRlciwgZGlyXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghJC5pc0FycmF5KG9yZGVyWzBdKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZ3VtZW50cyBwYXNzZWQgaW4gKGxpc3Qgb2YgMUQgYXJyYXlzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhIDJEIGFycmF5IHdhcyBwYXNzZWQgaW5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hYVNvcnRpbmcgPSBvcmRlci5zbGljZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIGFuIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bm9kZXxqUXVlcnl8c3RyaW5nfSBub2RlIElkZW50aWZpZXIgZm9yIHRoZSBlbGVtZW50KHMpIHRvIGF0dGFjaCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogICBsaXN0ZW5lciB0by4gVGhpcyBjYW4gdGFrZSB0aGUgZm9ybSBvZiBhIHNpbmdsZSBET00gbm9kZSwgYSBqUXVlcnlcclxuXHQgICAgICAgICAgICAgICAgICogICBjb2xsZWN0aW9uIG9mIG5vZGVzIG9yIGEgalF1ZXJ5IHNlbGVjdG9yIHdoaWNoIHdpbGwgaWRlbnRpZnkgdGhlIG5vZGUocykuXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gY29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcignb3JkZXIubGlzdGVuZXIoKScsIGZ1bmN0aW9uIChub2RlLCBjb2x1bW4sIGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoc2V0dGluZ3MsIG5vZGUsIGNvbHVtbiwgY2FsbGJhY2spO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIE9yZGVyIGJ5IHRoZSBzZWxlY3RlZCBjb2x1bW4ocylcclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcihbXHJcblx0ICAgICAgICAgICAgICAgICAgICAnY29sdW1ucygpLm9yZGVyKCknLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbigpLm9yZGVyKCknXHJcblx0ICAgICAgICAgICAgICAgIF0sIGZ1bmN0aW9uIChkaXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29ydCA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2godGhhdFtpXSwgZnVuY3Rpb24gKGosIGNvbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0LnB1c2goW2NvbCwgZGlyXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFhU29ydGluZyA9IHNvcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3NlYXJjaCgpJywgZnVuY3Rpb24gKGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4WzBdLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDb21wbGV0ZShzZXR0aW5ncywgJC5leHRlbmQoe30sIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogaW5wdXQgKyBcIlwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJSZWdleFwiOiByZWdleCA9PT0gbnVsbCA/IGZhbHNlIDogcmVnZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNtYXJ0XCI6IHNtYXJ0ID09PSBudWxsID8gdHJ1ZSA6IHNtYXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbnMoKS5zZWFyY2goKScsXHJcblx0ICAgICAgICAgICAgICAgICAgICAnY29sdW1uKCkuc2VhcmNoKCknLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZVNlYXJjaFtjb2x1bW5dLnNTZWFyY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHByZVNlYXJjaFtjb2x1bW5dLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogaW5wdXQgKyBcIlwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiUmVnZXhcIjogcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiU21hcnRcIjogc21hcnQgPT09IG51bGwgPyB0cnVlIDogc21hcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckNvbXBsZXRlKHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICApO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICogU3RhdGUgQVBJIG1ldGhvZHNcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzdGF0ZSgpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dFswXS5vU2F2ZWRTdGF0ZSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcignc3RhdGUuY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgYW4gZW1wdHkgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHt9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzdGF0ZS5sb2FkZWQoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRbMF0ub0xvYWRlZFN0YXRlIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzdGF0ZS5zYXZlKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5TYXZlU3RhdGUoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUHJvdmlkZSBhIGNvbW1vbiBtZXRob2QgZm9yIHBsdWctaW5zIHRvIGNoZWNrIHRoZSB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgYmVpbmdcclxuXHQgICAgICAgICAgICAgICAgICogdXNlZCwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiBWZXJzaW9uIHN0cmluZyB0byBjaGVjayBmb3IsIGluIHRoZSBmb3JtYXQgXCJYLlkuWlwiLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBOb3RlIHRoYXQgdGhlIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG9cclxuXHQgICAgICAgICAgICAgICAgICogICAgdGhlIHJlcXVpcmVkIHZlcnNpb24sIG9yIGZhbHNlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFsZXMgaXMgbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIHN1aXRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAc3RhdGljXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJLVN0YXRpY1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAgYWxlcnQoICQuZm4uZGF0YVRhYmxlLnZlcnNpb25DaGVjayggJzEuOS4wJyApICk7XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUudmVyc2lvbkNoZWNrID0gRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhVGhpcyA9IERhdGFUYWJsZS52ZXJzaW9uLnNwbGl0KCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYVRoYXQgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaVRoaXMsIGlUaGF0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gYVRoYXQubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpVGhpcyA9IHBhcnNlSW50KGFUaGlzW2ldLCAxMCkgfHwgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpVGhhdCA9IHBhcnNlSW50KGFUaGF0W2ldLCAxMCkgfHwgMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFydHMgYXJlIHRoZSBzYW1lLCBrZWVwIGNvbXBhcmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpVGhpcyA9PT0gaVRoYXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJ0cyBhcmUgZGlmZmVyZW50LCByZXR1cm4gaW1tZWRpYXRlbHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVRoaXMgPiBpVGhhdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ2hlY2sgaWYgYSBgPHRhYmxlPmAgbm9kZSBpcyBhIERhdGFUYWJsZSB0YWJsZSBhbHJlYWR5IG9yIG5vdC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZXxqcXVlcnl8c3RyaW5nfSB0YWJsZSBUYWJsZSBub2RlLCBqUXVlcnkgb2JqZWN0IG9yIGpRdWVyeVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgIHNlbGVjdG9yIGZvciB0aGUgdGFibGUgdG8gdGVzdC4gTm90ZSB0aGF0IGlmIG1vcmUgdGhhbiBtb3JlIHRoYW4gb25lXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgdGFibGUgaXMgcGFzc2VkIG9uLCBvbmx5IHRoZSBmaXJzdCB3aWxsIGJlIGNoZWNrZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIHRoZSB0YWJsZSBnaXZlbiBpcyBhIERhdGFUYWJsZSwgb3IgZmFsc2Ugb3RoZXJ3aXNlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAc3RhdGljXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJLVN0YXRpY1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAgaWYgKCAhICQuZm4uRGF0YVRhYmxlLmlzRGF0YVRhYmxlKCAnI2V4YW1wbGUnICkgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICogICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLmlzRGF0YVRhYmxlID0gRGF0YVRhYmxlLmZuSXNEYXRhVGFibGUgPSBmdW5jdGlvbiAodGFibGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gJCh0YWJsZSkuZ2V0KDApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlzID0gZmFsc2U7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgJC5lYWNoKERhdGFUYWJsZS5zZXR0aW5ncywgZnVuY3Rpb24gKGksIG8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZCA9IG8ublNjcm9sbEhlYWQgPyAkKCd0YWJsZScsIG8ublNjcm9sbEhlYWQpWzBdIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9vdCA9IG8ublNjcm9sbEZvb3QgPyAkKCd0YWJsZScsIG8ublNjcm9sbEZvb3QpWzBdIDogbnVsbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgYWxsIERhdGFUYWJsZSB0YWJsZXMgdGhhdCBoYXZlIGJlZW4gaW5pdGlhbGlzZWQgLSBvcHRpb25hbGx5IHlvdSBjYW5cclxuXHQgICAgICAgICAgICAgICAgICogc2VsZWN0IHRvIGdldCBvbmx5IGN1cnJlbnRseSB2aXNpYmxlIHRhYmxlcy5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gW3Zpc2libGU9ZmFsc2VdIEZsYWcgdG8gaW5kaWNhdGUgaWYgeW91IHdhbnQgYWxsIChkZWZhdWx0KVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBvciB2aXNpYmxlIHRhYmxlcyBvbmx5LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIERhdGFUYWJsZXNcclxuXHQgICAgICAgICAgICAgICAgICogIEBzdGF0aWNcclxuXHQgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUEktU3RhdGljXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICQodGFibGUpLkRhdGFUYWJsZSgpLmNvbHVtbnMuYWRqdXN0KCk7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIERhdGFUYWJsZS50YWJsZXMgPSBEYXRhVGFibGUuZm5UYWJsZXMgPSBmdW5jdGlvbiAodmlzaWJsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQubWFwKERhdGFUYWJsZS5zZXR0aW5ncywgZnVuY3Rpb24gKG8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZpc2libGUgfHwgKHZpc2libGUgJiYgJChvLm5UYWJsZSkuaXMoJzp2aXNpYmxlJykpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvLm5UYWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyB1dGlsaXR5IG1ldGhvZHNcclxuXHQgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoaXMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBtZXRob2RzIHRoYXQgRGF0YVRhYmxlcyB1c2VzIGludGVybmFsbHkgdG9cclxuXHQgICAgICAgICAgICAgICAgICogY3JlYXRlIGEgRGF0YVRhYmxlLCBidXQgd2hpY2ggYXJlIG5vdCBleGNsdXNpdmVseSB1c2VkIG9ubHkgZm9yIERhdGFUYWJsZXMuXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2ZcclxuXHQgICAgICAgICAgICAgICAgICogY29kZS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIERhdGFUYWJsZS51dGlsID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaHJvdHRsZSB0aGUgY2FsbHMgdG8gYSBmdW5jdGlvbi4gQXJndW1lbnRzIGFuZCBjb250ZXh0IGFyZSBtYWludGFpbmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gZnJlcSBDYWxsIGZyZXF1ZW5jeSBpbiBtU1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb259IFdyYXBwZWQgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGU6IF9mblRocm90dGxlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNWYWwgc3RyaW5nIHRvIGVzY2FwZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGVzY2FwZVJlZ2V4OiBfZm5Fc2NhcGVSZWdleFxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiBub3RhdGlvbi4gVGhpcyBpcyBtYWRlIHB1YmxpY1xyXG5cdCAgICAgICAgICAgICAgICAgKiBmb3IgdGhlIGV4dGVuc2lvbnMgdG8gcHJvdmlkZSB0aGUgc2FtZSBhYmlsaXR5IGFzIERhdGFUYWJsZXMgY29yZSB0byBhY2NlcHRcclxuXHQgICAgICAgICAgICAgICAgICogZWl0aGVyIHRoZSAxLjkgc3R5bGUgSHVuZ2FyaWFuIG5vdGF0aW9uLCBvciB0aGUgMS4xMCsgc3R5bGUgY2FtZWxDYXNlXHJcblx0ICAgICAgICAgICAgICAgICAqIHBhcmFtZXRlcnMuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcclxuXHQgICAgICAgICAgICAgICAgICogICAgbWFwcGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcclxuXHQgICAgICAgICAgICAgICAgICogICAgd29uJ3QgYmUuXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUuY2FtZWxUb0h1bmdhcmlhbiA9IF9mbkNhbWVsVG9IdW5nYXJpYW47XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignJCgpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3dzID0gdGhpcy5yb3dzKG9wdHMpLm5vZGVzKCksIC8vIEdldCBhbGwgcm93c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpxUm93cyA9ICQocm93cyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoW10uY29uY2F0KFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpxUm93cy5maWx0ZXIoc2VsZWN0b3IpLnRvQXJyYXkoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqcVJvd3MuZmluZChzZWxlY3RvcikudG9BcnJheSgpXHJcblx0ICAgICAgICAgICAgICAgICAgICApKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8galF1ZXJ5IGZ1bmN0aW9ucyB0byBvcGVyYXRlIG9uIHRoZSB0YWJsZXNcclxuXHQgICAgICAgICAgICAgICAgJC5lYWNoKFsnb24nLCAnb25lJywgJ29mZiddLCBmdW5jdGlvbiAoaSwga2V5KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKGtleSArICcoKScsIGZ1bmN0aW9uICggLyogZXZlbnQsIGhhbmRsZXIgKi8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgYGR0YCBuYW1lc3BhY2UgYXV0b21hdGljYWxseSBpZiBpdCBpc24ndCBhbHJlYWR5IHByZXNlbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3NbMF0ubWF0Y2goL1xcLmR0XFxiLykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1swXSArPSAnLmR0JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gJCh0aGlzLnRhYmxlcygpLm5vZGVzKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluc3Rba2V5XS5hcHBseShpbnN0LCBhcmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjbGVhcigpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2xlYXJUYWJsZShzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcignc2V0dGluZ3MoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaSh0aGlzLmNvbnRleHQsIHRoaXMuY29udGV4dCk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2luaXQoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5vSW5pdCA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2RhdGEoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcGx1Y2soc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KS5mbGF0dGVuKCk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2Rlc3Ryb3koKScsIGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IHJlbW92ZSB8fCBmYWxzZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZyA9IHNldHRpbmdzLm5UYWJsZVdyYXBwZXIucGFyZW50Tm9kZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWJsZSA9IHNldHRpbmdzLm5UYWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGJvZHkgPSBzZXR0aW5ncy5uVEJvZHk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoZWFkID0gc2V0dGluZ3MublRIZWFkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0Zm9vdCA9IHNldHRpbmdzLm5URm9vdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIganFUYWJsZSA9ICQodGFibGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqcVRib2R5ID0gJCh0Ym9keSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpxV3JhcHBlciA9ICQoc2V0dGluZ3MublRhYmxlV3JhcHBlcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSAkLm1hcChzZXR0aW5ncy5hb0RhdGEsIGZ1bmN0aW9uIChyKSB7IHJldHVybiByLm5UcjsgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGllbjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyB0byBub3RlIHRoYXQgdGhlIHRhYmxlIGlzIGN1cnJlbnRseSBiZWluZyBkZXN0cm95ZWQgLSBubyBhY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgdGFrZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5iRGVzdHJveWluZyA9IHRydWU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgb2ZmIHRoZSBkZXN0cm95IGNhbGxiYWNrcyBmb3IgcGx1Zy1pbnMgZXRjXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBcImFvRGVzdHJveUNhbGxiYWNrXCIsIFwiZGVzdHJveVwiLCBbc2V0dGluZ3NdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQsIG1ha2UgYWxsIGNvbHVtbnMgdmlzaWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVtb3ZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBfQXBpKHNldHRpbmdzKS5jb2x1bW5zKCkudmlzaWJsZSh0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsaXR6IGFsbCBgRFRgIG5hbWVzcGFjZWQgZXZlbnRzICh0aGVzZSBhcmUgaW50ZXJuYWwgZXZlbnRzLCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb3dlcmNhc2UsIGBkdGAgZXZlbnRzIGFyZSB1c2VyIHN1YnNjcmliZWQgYW5kIHRoZXkgYXJlIHJlc3BvbnNpYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHJlbW92aW5nIHRoZW1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqcVdyYXBwZXIudW5iaW5kKCcuRFQnKS5maW5kKCc6bm90KHRib2R5ICopJykudW5iaW5kKCcuRFQnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkKHdpbmRvdykudW5iaW5kKCcuRFQtJyArIHNldHRpbmdzLnNJbnN0YW5jZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIHdlIGhhZCB0byBicmVhayB0aGUgdGFibGUgdXAgLSByZXN0b3JlIGl0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlICE9IHRoZWFkLnBhcmVudE5vZGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganFUYWJsZS5jaGlsZHJlbigndGhlYWQnKS5kZXRhY2goKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganFUYWJsZS5hcHBlbmQodGhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRmb290ICYmIHRhYmxlICE9IHRmb290LnBhcmVudE5vZGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganFUYWJsZS5jaGlsZHJlbigndGZvb3QnKS5kZXRhY2goKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganFUYWJsZS5hcHBlbmQodGZvb3QpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBEYXRhVGFibGVzIGdlbmVyYXRlZCBub2RlcywgZXZlbnRzIGFuZCBjbGFzc2VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganFUYWJsZS5kZXRhY2goKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqcVdyYXBwZXIuZGV0YWNoKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydGluZ0NsYXNzZXMoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkKHJvd3MpLnJlbW92ZUNsYXNzKHNldHRpbmdzLmFzU3RyaXBlQ2xhc3Nlcy5qb2luKCcgJykpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkKCd0aCwgdGQnLCB0aGVhZCkucmVtb3ZlQ2xhc3MoY2xhc3Nlcy5zU29ydGFibGUgKyAnICcgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0YWJsZUFzYyArICcgJyArIGNsYXNzZXMuc1NvcnRhYmxlRGVzYyArICcgJyArIGNsYXNzZXMuc1NvcnRhYmxlTm9uZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5iSlVJKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJ3RoIHNwYW4uJyArIGNsYXNzZXMuc1NvcnRJY29uICsgJywgdGQgc3Bhbi4nICsgY2xhc3Nlcy5zU29ydEljb24sIHRoZWFkKS5kZXRhY2goKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgndGgsIHRkJywgdGhlYWQpLmVhY2goZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSAkKCdkaXYuJyArIGNsYXNzZXMuc1NvcnRKVUlXcmFwcGVyLCB0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYXBwZW5kKHdyYXBwZXIuY29udGVudHMoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmRldGFjaCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVtb3ZlICYmIG9yaWcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0QmVmb3JlIGFjdHMgbGlrZSBhcHBlbmRDaGlsZCBpZiAhYXJnWzFdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWcuaW5zZXJ0QmVmb3JlKHRhYmxlLCBzZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIFRSIGVsZW1lbnRzIGJhY2sgaW50byB0aGUgdGFibGUgaW4gdGhlaXIgb3JpZ2luYWwgb3JkZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqcVRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganFUYm9keS5hcHBlbmQocm93cyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHdpZHRoIG9mIHRoZSBvcmlnaW5hbCB0YWJsZSAtIHdhcyByZWFkIGZyb20gdGhlIHN0eWxlIHByb3BlcnR5LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbiByZXN0b3JlIGRpcmVjdGx5IHRvIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqcVRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ3dpZHRoJywgc2V0dGluZ3Muc0Rlc3Ryb3lXaWR0aClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKGNsYXNzZXMuc1RhYmxlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHdlcmUgb3JpZ2luYWxseSBzdHJpcGUgY2xhc3NlcyAtIHRoZW4gd2UgYWRkIHRoZW0gYmFjayBoZXJlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhpcyBpcyBub3QgZm9vbCBwcm9vZiAoZm9yIGV4YW1wbGUgaWYgbm90IGFsbCByb3dzIGhhZCBzdHJpcGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGFzc2VzIC0gYnV0IGl0J3MgYSBnb29kIGVmZm9ydCB3aXRob3V0IGdldHRpbmcgY2FycmllZCBhd2F5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWVuID0gc2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlcy5sZW5ndGg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAganFUYm9keS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3Moc2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlc1tpICUgaWVuXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVtb3ZlIHRoZSBzZXR0aW5ncyBvYmplY3QgZnJvbSB0aGUgc2V0dGluZ3MgYXJyYXkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gJC5pbkFycmF5KHNldHRpbmdzLCBEYXRhVGFibGUuc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIERhdGFUYWJsZS5zZXR0aW5ncy5zcGxpY2UoaWR4LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxyXG5cdCAgICAgICAgICAgICAgICAkLmVhY2goWydjb2x1bW4nLCAncm93JywgJ2NlbGwnXSwgZnVuY3Rpb24gKGksIHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIodHlwZSArICdzKCkuZXZlcnkoKScsIGZ1bmN0aW9uIChmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKHR5cGUsIGZ1bmN0aW9uIChzZXR0aW5ncywgaWR4LCBpZHgyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkeDIgaXMgdW5kZWZpbmVkIGZvciByb3dzIGFuZCBjb2x1bW5zLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKG5ldyBfQXBpKHNldHRpbmdzKVt0eXBlXShpZHgsIGlkeDIpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBpMThuIG1ldGhvZCBmb3IgZXh0ZW5zaW9ucyB0byBiZSBhYmxlIHRvIHVzZSB0aGUgbGFuZ3VhZ2Ugb2JqZWN0IGZyb20gdGhlXHJcblx0ICAgICAgICAgICAgICAgIC8vIERhdGFUYWJsZVxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdpMThuKCknLCBmdW5jdGlvbiAodG9rZW4sIGRlZiwgcGx1cmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gX2ZuR2V0T2JqZWN0RGF0YUZuKHRva2VuKShjdHgub0xhbmd1YWdlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gZGVmO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwbHVyYWwgIT09IHVuZGVmaW5lZCAmJiAkLmlzUGxhaW5PYmplY3QocmVzb2x2ZWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSByZXNvbHZlZFtwbHVyYWxdICE9PSB1bmRlZmluZWQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFtwbHVyYWxdIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQuXztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQucmVwbGFjZSgnJWQnLCBwbHVyYWwpOyAvLyBuYjogcGx1cmFsIG1pZ2h0IGJlIHVuZGVmaW5lZCxcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogVmVyc2lvbiBzdHJpbmcgZm9yIHBsdWctaW5zIHRvIGNoZWNrIGNvbXBhdGliaWxpdHkuIEFsbG93ZWQgZm9ybWF0IGlzXHJcblx0ICAgICAgICAgICAgICAgICAqIGBhLmIuYy1kYCB3aGVyZTogYTppbnQsIGI6aW50LCBjOmludCwgZDpzdHJpbmcoZGV2fGJldGF8YWxwaGEpLiBgZGAgaXMgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBvbmx5IGZvciBub24tcmVsZWFzZSBidWlsZHMuIFNlZSBodHRwOi8vc2VtdmVyLm9yZy8gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFZlcnNpb24gbnVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUudmVyc2lvbiA9IFwiMS4xMC43XCI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUHJpdmF0ZSBkYXRhIHN0b3JlLCBjb250YWluaW5nIGFsbCBvZiB0aGUgc2V0dGluZ3Mgb2JqZWN0cyB0aGF0IGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBjcmVhdGVkIGZvciB0aGUgdGFibGVzIG9uIGEgZ2l2ZW4gcGFnZS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoZSBgRGF0YVRhYmxlLnNldHRpbmdzYCBvYmplY3QgaXMgYWxpYXNlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgdGhyb3VnaCB3aGljaCBpdCBtYXkgYmUgYWNjZXNzZWQgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAqIG1hbmlwdWxhdGVkLCBvciBgalF1ZXJ5LmZuLmRhdGFUYWJsZS5zZXR0aW5nc2AuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICogIEBwcml2YXRlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUuc2V0dGluZ3MgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBPYmplY3QgbW9kZWxzIGNvbnRhaW5lciwgZm9yIHRoZSB2YXJpb3VzIG1vZGVscyB0aGF0IERhdGFUYWJsZXMgaGFzXHJcblx0ICAgICAgICAgICAgICAgICAqIGF2YWlsYWJsZSB0byBpdC4gVGhlc2UgbW9kZWxzIGRlZmluZSB0aGUgb2JqZWN0cyB0aGF0IGFyZSB1c2VkIHRvIGhvbGRcclxuXHQgICAgICAgICAgICAgICAgICogdGhlIGFjdGl2ZSBzdGF0ZSBhbmQgY29uZmlndXJhdGlvbiBvZiB0aGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUubW9kZWxzID0ge307XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSB3YXkgaW4gd2hpY2ggRGF0YVRhYmxlcyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dFxyXG5cdCAgICAgICAgICAgICAgICAgKiBzZWFyY2ggaW5mb3JtYXRpb24gZm9yIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXJzLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBmaWx0ZXJpbmcgc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmUgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiQ2FzZUluc2Vuc2l0aXZlXCI6IHRydWUsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBcHBsaWVkIHNlYXJjaCB0ZXJtXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogXCJcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIHNlYXJjaCB0ZXJtIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByZWd1bGFyIGV4cHJlc3Npb24gKHRydWUpIG9yIG5vdCAoZmFsc2UpIGFuZCB0aGVyZWZvcmUgYW5kIHNwZWNpYWxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlZ2V4IGNoYXJhY3RlcnMgZXNjYXBlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiUmVnZXhcIjogZmFsc2UsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIERhdGFUYWJsZXMgaXMgdG8gdXNlIGl0cyBzbWFydCBmaWx0ZXJpbmcgb3Igbm90LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNtYXJ0XCI6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSB3YXkgaW4gd2hpY2ggRGF0YVRhYmxlcyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dFxyXG5cdCAgICAgICAgICAgICAgICAgKiBlYWNoIGluZGl2aWR1YWwgcm93LiBUaGlzIGlzIHRoZSBvYmplY3QgZm9ybWF0IHVzZWQgZm9yIHRoZSBzZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBhb0RhdGEgYXJyYXkuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUubW9kZWxzLm9Sb3cgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRSIGVsZW1lbnQgZm9yIHRoZSByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm5UclwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXJyYXkgb2YgVEQgZWxlbWVudHMgZm9yIGVhY2ggcm93LiBUaGlzIGlzIG51bGwgdW50aWwgdGhlIHJvdyBoYXMgYmVlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY3JlYXRlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheSBub2Rlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW5DZWxsc1wiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YSBvYmplY3QgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cuIFRoaXMgaXMgZWl0aGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbiBhcnJheSBpZiB1c2luZyB0aGUgdHJhZGl0aW9uYWwgZm9ybSBvZiBEYXRhVGFibGVzLCBvciBhbiBvYmplY3QgaWZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHVzaW5nIG1EYXRhIG9wdGlvbnMuIFRoZSBleGFjdCB0eXBlIHdpbGwgZGVwZW5kIG9uIHRoZSBwYXNzZWQgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRhdGEgZnJvbSB0aGUgZGF0YSBzb3VyY2UsIG9yIHdpbGwgYmUgYW4gYXJyYXkgaWYgdXNpbmcgRE9NIGEgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc291cmNlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5fG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiX2FEYXRhXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU29ydGluZyBkYXRhIGNhY2hlIC0gdGhpcyBhcnJheSBpcyBvc3RlbnNpYmx5IHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG51bWJlciBvZiBjb2x1bW5zIChhbHRob3VnaCBlYWNoIGluZGV4IGlzIGdlbmVyYXRlZCBvbmx5IGFzIGl0IGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBuZWVkZWQpLCBhbmQgaG9sZHMgdGhlIGRhdGEgdGhhdCBpcyB1c2VkIGZvciBzb3J0aW5nIGVhY2ggY29sdW1uIGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcm93LiBXZSBkbyB0aGlzIGNhY2hlIGdlbmVyYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3J0IGluIG9yZGVyIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBmb3JtYXR0aW5nIG9mIHRoZSBzb3J0IGRhdGEgbmVlZCBiZSBkb25lIG9ubHkgb25jZSBmb3IgZWFjaCBjZWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwZXIgc29ydC4gVGhpcyBhcnJheSBzaG91bGQgbm90IGJlIHJlYWQgZnJvbSBvciB3cml0dGVuIHRvIGJ5IGFueXRoaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvdGhlciB0aGFuIHRoZSBtYXN0ZXIgc29ydGluZyBtZXRob2RzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwcml2YXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiX2FTb3J0RGF0YVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUGVyIGNlbGwgZmlsdGVyaW5nIGRhdGEgY2FjaGUuIEFzIHBlciB0aGUgc29ydCBkYXRhIGNhY2hlLCB1c2VkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbmNyZWFzZSB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIGZpbHRlcmluZyBpbiBEYXRhVGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHByaXZhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJfYUZpbHRlckRhdGFcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZpbHRlcmluZyBkYXRhIGNhY2hlLiBUaGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBjZWxsIGZpbHRlcmluZyBjYWNoZSwgYnV0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbiB0aGlzIGNhc2UgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYW4gYXJyYXkuIFRoaXMgaXMgZWFzaWx5IGNvbXB1dGVkIHdpdGhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGEgam9pbiBvbiBgX2FGaWx0ZXJEYXRhYCwgYnV0IGlzIHByb3ZpZGVkIGFzIGEgY2FjaGUgc28gdGhlIGpvaW4gaXNuJ3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG5lZWRlZCBvbiBldmVyeSBzZWFyY2ggKG1lbW9yeSB0cmFkZWQgZm9yIHBlcmZvcm1hbmNlKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwcml2YXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiX3NGaWx0ZXJSb3dcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhY2hlIG9mIHRoZSBjbGFzcyBuYW1lIHRoYXQgRGF0YVRhYmxlcyBoYXMgYXBwbGllZCB0byB0aGUgcm93LCBzbyB3ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2FuIHF1aWNrbHkgbG9vayBhdCB0aGlzIHZhcmlhYmxlIHJhdGhlciB0aGFuIG5lZWRpbmcgdG8gZG8gYSBET00gY2hlY2tcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9uIGNsYXNzTmFtZSBmb3IgdGhlIG5UciBwcm9wZXJ0eS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHByaXZhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJfc1Jvd1N0cmlwZVwiOiBcIlwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGVub3RlIGlmIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSB3YXMgZnJvbSB0aGUgRE9NLCBvciB0aGUgZGF0YSBzb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9iamVjdC4gVGhpcyBpcyB1c2VkIGZvciBpbnZhbGlkYXRpbmcgZGF0YSwgc28gRGF0YVRhYmxlcyBjYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGF1dG9tYXRpY2FsbHkgcmVhZCBkYXRhIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSwgdW5sZXNzIHVuaW5zdHJ1Y3RlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3RoZXJ3aXNlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNyY1wiOiBudWxsXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIGNvbHVtbiBpbmZvcm1hdGlvbiBvYmplY3QgaW4gRGF0YVRhYmxlcy4gVGhpcyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogaXMgaGVsZCBpbiB0aGUgc2V0dGluZ3MgYW9Db2x1bW5zIGFycmF5IGFuZCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn1cclxuXHQgICAgICAgICAgICAgICAgICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cclxuXHQgICAgICAgICAgICAgICAgICogSXQgc2hvdWxkIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBiZSBkb25lIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4gPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENvbHVtbiBpbmRleC4gVGhpcyBjb3VsZCBiZSB3b3JrZWQgb3V0IG9uLXRoZS1mbHkgd2l0aCAkLmluQXJyYXksIGJ1dCBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgZmFzdGVyIHRvIGp1c3QgaG9sZCBpdCBhcyBhIHZhcmlhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50ZWdlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJpZHhcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEEgbGlzdCBvZiB0aGUgY29sdW1ucyB0aGF0IHNvcnRpbmcgc2hvdWxkIG9jY3VyIG9uIHdoZW4gdGhpcyBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIHNvcnRlZC4gVGhhdCB0aGlzIHByb3BlcnR5IGlzIGFuIGFycmF5IGFsbG93cyBtdWx0aS1jb2x1bW4gc29ydGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdG8gYmUgZGVmaW5lZCBmb3IgYSBjb2x1bW4gKGZvciBleGFtcGxlIGZpcnN0IG5hbWUgLyBsYXN0IG5hbWUgY29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd291bGQgYmVuZWZpdCBmcm9tIHRoaXMpLiBUaGUgdmFsdWVzIGFyZSBpbnRlZ2VycyBwb2ludGluZyB0byB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNvbHVtbnMgdG8gYmUgc29ydGVkIG9uICh0eXBpY2FsbHkgaXQgd2lsbCBiZSBhIHNpbmdsZSBpbnRlZ2VyIHBvaW50aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhdCBpdHNlbGYsIGJ1dCB0aGF0IGRvZXNuJ3QgbmVlZCB0byBiZSB0aGUgY2FzZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhRGF0YVNvcnRcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERlZmluZSB0aGUgc29ydGluZyBkaXJlY3Rpb25zIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGNvbHVtbiwgaW4gc2VxdWVuY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFzIHRoZSBjb2x1bW4gaXMgcmVwZWF0ZWRseSBzb3J0ZWQgdXBvbiAtIGkuZS4gdGhlIGZpcnN0IHZhbHVlIGlzIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFzIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiB3aGVuIHRoZSBjb2x1bW4gaWYgZmlyc3Qgc29ydGVkIChjbGlja2VkIG9uKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNvcnQgaXQgYWdhaW4gKGNsaWNrIGFnYWluKSBhbmQgaXQgd2lsbCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGluZGV4LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUmVwZWF0IHVudGlsIGxvb3AuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhc1NvcnRpbmdcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzZWFyY2hhYmxlLCBhbmQgdGh1cyBzaG91bGQgYmUgaW5jbHVkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluIHRoZSBmaWx0ZXJpbmcgb3Igbm90LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU2VhcmNoYWJsZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIHNvcnRhYmxlIG9yIG5vdC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRhYmxlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHRhYmxlIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiVmlzaWJsZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU3RvcmUgZm9yIG1hbnVhbCB0eXBlIGFzc2lnbm1lbnQgdXNpbmcgdGhlIGBjb2x1bW4udHlwZWAgb3B0aW9uLiBUaGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9zTWFudWFsVHlwZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRmxhZyB0byBpbmRpY2F0ZSBpZiBIVE1MNSBkYXRhIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNvdXJjZSBmb3IgZmlsdGVyaW5nIG9yIHNvcnRpbmcuIFRydWUgaXMgZWl0aGVyIGFyZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9iQXR0clNyY1wiOiBmYWxzZSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWxsb3dpbmcgeW91IHRvIG1vZGlmeSB0aGUgRE9NIGVsZW1lbnQgKGFkZCBiYWNrZ3JvdW5kIGNvbG91ciBmb3IgZXhhbXBsZSkgd2hlbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtlbGVtZW50fSBuVGQgVGhlIFREIG5vZGUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSBzRGF0YSBUaGUgRGF0YSBmb3IgdGhlIGNlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgZm9yIHRoZSB3aG9sZSByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaVJvdyBUaGUgcm93IGluZGV4IGZvciB0aGUgYW9EYXRhIGRhdGEgc3RvcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRnVuY3Rpb24gdG8gZ2V0IGRhdGEgZnJvbSBhIGNlbGwgaW4gYSBjb2x1bW4uIFlvdSBzaG91bGQgPGI+bmV2ZXI8L2I+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhY2Nlc3MgZGF0YSBkaXJlY3RseSB0aHJvdWdoIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgbWV0aG9kIGF0dGFjaGVkIHRvIHRoaXMgcHJvcGVydHkuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcmVxdWlyZWQuIFRoaXMgZnVuY3Rpb24gaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbml0aWFsaXNhdGlvbiBtZXRob2RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvRGF0YSBUaGUgZGF0YSBhcnJheS9vYmplY3QgZm9yIHRoZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKGkuZS4gYW9EYXRhW10uX2FEYXRhKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzU3BlY2lmaWMgVGhlIHNwZWNpZmljIGRhdGEgdHlwZSB5b3Ugd2FudCB0byBnZXQgLVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcicgJ3NvcnQnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMgeyp9IFRoZSBkYXRhIGZvciB0aGUgY2VsbCBmcm9tIHRoZSBnaXZlbiByb3cncyBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuR2V0RGF0YVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRnVuY3Rpb24gdG8gc2V0IGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IHRoZSBkYXRhIGRpcmVjdGx5IHRvIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIG1ldGhvZC4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIGJ5IHRoZSBjb2x1bW4gaW5pdGlhbGlzYXRpb24gbWV0aG9kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIChpLmUuIGFvRGF0YVtdLl9hRGF0YSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0geyp9IHNWYWx1ZSBWYWx1ZSB0byBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5TZXREYXRhXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0eSB0byByZWFkIHRoZSB2YWx1ZSBmb3IgdGhlIGNlbGxzIGluIHRoZSBjb2x1bW4gZnJvbSB0aGUgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc291cmNlIGFycmF5IC8gb2JqZWN0LiBJZiBudWxsLCB0aGVuIHRoZSBkZWZhdWx0IGNvbnRlbnQgaXMgdXNlZCwgaWYgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlbiB0aGUgcmV0dXJuIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHVzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb258aW50fHN0cmluZ3xudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm1EYXRhXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQYXJ0bmVyIHByb3BlcnR5IHRvIG1EYXRhIHdoaWNoIGlzIHVzZWQgKG9ubHkgd2hlbiBkZWZpbmVkKSB0byBnZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBkYXRhIC0gaS5lLiBpdCBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYXMgbURhdGEsIGJ1dCB3aXRob3V0IHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogJ3NldCcgb3B0aW9uLCBhbmQgYWxzbyB0aGUgZGF0YSBmZWQgdG8gaXQgaXMgdGhlIHJlc3VsdCBmcm9tIG1EYXRhLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgcmVuZGVyaW5nIG1ldGhvZCB0byBtYXRjaCB0aGUgZGF0YSBtZXRob2Qgb2YgbURhdGEuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb258aW50fHN0cmluZ3xudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm1SZW5kZXJcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFVuaXF1ZSBoZWFkZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gLSB0aGlzIGlzIHdoYXQgdGhlIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIChpZiBzb3J0aW5nIGlzIGVuYWJsZWQuKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiblRoXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBVbmlxdWUgZm9vdGVyIFRIL1REIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uIChpZiB0aGVyZSBpcyBvbmUpLiBOb3QgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW4gRGF0YVRhYmxlcyBhcyBzdWNoLCBidXQgY2FuIGJlIHVzZWQgZm9yIHBsdWctaW5zIHRvIHJlZmVyZW5jZSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZvb3RlciBmb3IgZWFjaCBjb2x1bW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJuVGZcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0NsYXNzXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpdCBmaW5kcyB0aGUgbG9uZ2VzdCBzdHJpbmcgaW4gZWFjaCBjb2x1bW4gYW5kIHRoZW4gY29uc3RydWN0cyBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0ZW1wb3JhcnkgdGFibGUgYW5kIHJlYWRzIHRoZSB3aWR0aHMgZnJvbSB0aGF0LiBUaGUgcHJvYmxlbSB3aXRoIHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzdHJpbmcgLSB0aHVzIHRoZSBjYWxjdWxhdGlvbiBjYW4gZ28gd3JvbmcgKGRvaW5nIGl0IHByb3Blcmx5IGFuZCBwdXR0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpdCBpbnRvIGFuIERPTSBvYmplY3QgYW5kIG1lYXN1cmluZyB0aGF0IGlzIGhvcnJpYmx5KCEpIHNsb3cpLiBUaHVzIGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0ZXh0IHRoYXQgaXMgZm91bmQgdG8gYmUgdGhlIGxvbmdlc3Qgc3RyaW5nIGZvciB0aGUgY29sdW1uIC0gaS5lLiBwYWRkaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNDb250ZW50UGFkZGluZ1wiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgbURhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIHNldCB0byBudWxsLCBvciBiZWNhdXNlIHRoZSBkYXRhIHNvdXJjZSBpdHNlbGYgaXMgbnVsbCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTmFtZSBmb3IgdGhlIGNvbHVtbiwgYWxsb3dpbmcgcmVmZXJlbmNlIHRvIHRoZSBjb2x1bW4gYnkgbmFtZSBhcyB3ZWxsIGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzTmFtZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ3VzdG9tIHNvcnRpbmcgZGF0YSB0eXBlIC0gZGVmaW5lcyB3aGljaCBvZiB0aGUgYXZhaWxhYmxlIHBsdWctaW5zIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhZm5Tb3J0RGF0YSB0aGUgY3VzdG9tIHNvcnRpbmcgd2lsbCB1c2UgLSBpZiBhbnkgaXMgZGVmaW5lZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBzdGRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydERhdGFUeXBlXCI6ICdzdGQnLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0aW5nQ2xhc3NcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtbiAtXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIGpRdWVyeSBVSSB0aGVtaW5nIGlzIHVzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0aW5nQ2xhc3NKVUlcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRpdGxlIG9mIHRoZSBjb2x1bW4gLSB3aGF0IGlzIHNlZW4gaW4gdGhlIFRIIGVsZW1lbnQgKG5UaCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1RpdGxlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDb2x1bW4gc29ydGluZyBhbmQgZmlsdGVyaW5nIHR5cGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1R5cGVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1dpZHRoXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBXaWR0aCBvZiB0aGUgY29sdW1uIHdoZW4gaXQgd2FzIGZpcnN0IFwiZW5jb3VudGVyZWRcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzV2lkdGhPcmlnXCI6IG51bGxcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEZXZlbG9wZXIgbm90ZTogVGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBiZWxvdyBhcmUgZ2l2ZW4gaW4gSHVuZ2FyaWFuXHJcblx0ICAgICAgICAgICAgICAgICAqIG5vdGF0aW9uLCB0aGF0IHdhcyB1c2VkIGFzIHRoZSBpbnRlcmZhY2UgZm9yIERhdGFUYWJsZXMgcHJpb3IgdG8gdjEuMTAsIGhvd2V2ZXJcclxuXHQgICAgICAgICAgICAgICAgICogZnJvbSB2MS4xMCBvbndhcmRzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBpcyBjYW1lbCBjYXNlLiBJbiBvcmRlciB0byBhdm9pZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBicmVha2luZyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB1dHRlcmx5IHdpdGggdGhpcyBjaGFuZ2UsIHRoZSBIdW5nYXJpYW5cclxuXHQgICAgICAgICAgICAgICAgICogdmVyc2lvbiBpcyBzdGlsbCwgaW50ZXJuYWxseSB0aGUgcHJpbWFyeSBpbnRlcmZhY2UsIGJ1dCBpcyBpcyBub3QgZG9jdW1lbnRlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAtIGhlbmNlIHRoZSBAbmFtZSB0YWdzIGluIGVhY2ggZG9jIGNvbW1lbnQuIFRoaXMgYWxsb3dzIGEgSmF2YXNjcmlwdCBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiB0byBjcmVhdGUgYSBtYXAgZnJvbSBIdW5nYXJpYW4gbm90YXRpb24gdG8gY2FtZWwgY2FzZSAoZ29pbmcgdGhlIG90aGVyIGRpcmVjdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiB3b3VsZCByZXF1aXJlIGVhY2ggcHJvcGVydHkgdG8gYmUgbGlzdGVkLCB3aGljaCB3b3VsZCBhdCBhcm91bmQgM0sgdG8gdGhlIHNpemVcclxuXHQgICAgICAgICAgICAgICAgICogb2YgRGF0YVRhYmxlcywgd2hpbGUgdGhpcyBtZXRob2QgaXMgYWJvdXQgYSAwLjVLIGhpdC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogVWx0aW1hdGVseSB0aGlzIGRvZXMgcGF2ZSB0aGUgd2F5IGZvciBIdW5nYXJpYW4gbm90YXRpb24gdG8gYmUgZHJvcHBlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBjb21wbGV0ZWx5LCBidXQgdGhhdCBpcyBhIG1hc3NpdmUgYW1vdW50IG9mIHdvcmsgYW5kIHdpbGwgYnJlYWsgY3VycmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiBpbnN0YWxscyAodGhlcmVmb3JlIGlzIG9uLWhvbGQgdW50aWwgdjIpLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBJbml0aWFsaXNhdGlvbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICogdGltZS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIERhdGFUYWJsZS5kZWZhdWx0cyA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQW4gYXJyYXkgb2YgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWJsZSwgcGFzc2VkIGluIGF0IGluaXRpYWxpc2F0aW9uIHdoaWNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aWxsIGJlIHVzZWQgaW4gcHJlZmVyZW5jZSB0byBhbnkgZGF0YSB3aGljaCBpcyBhbHJlYWR5IGluIHRoZSBET00uIFRoaXMgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGNvbnN0cnVjdGluZyB0YWJsZXMgcHVyZWx5IGluIEphdmFzY3JpcHQsIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZXhhbXBsZSB3aXRoIGEgY3VzdG9tIEFqYXggY2FsbC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBhIDJEIGFycmF5IGRhdGEgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZGF0YVwiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBbJ1RyaWRlbnQnLCAnSW50ZXJuZXQgRXhwbG9yZXIgNC4wJywgJ1dpbiA5NSsnLCA0LCAnWCddLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgWydUcmlkZW50JywgJ0ludGVybmV0IEV4cGxvcmVyIDUuMCcsICdXaW4gOTUrJywgNSwgJ0MnXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiQnJvd3NlclwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJQbGF0Zm9ybVwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkdyYWRlXCIgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhcyBhIGRhdGEgc291cmNlIChgZGF0YWApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZGF0YVwiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZW5naW5lXCI6ICAgXCJUcmlkZW50XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiYnJvd3NlclwiOiAgXCJJbnRlcm5ldCBFeHBsb3JlciA0LjBcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJwbGF0Zm9ybVwiOiBcIldpbiA5NStcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6ICA0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImdyYWRlXCI6ICAgIFwiWFwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImVuZ2luZVwiOiAgIFwiVHJpZGVudFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNS4wXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwicGxhdGZvcm1cIjogXCJXaW4gOTUrXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwidmVyc2lvblwiOiAgNSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIkNcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkVuZ2luZVwiLCAgIFwiZGF0YVwiOiBcImVuZ2luZVwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJCcm93c2VyXCIsICBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIsIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlZlcnNpb25cIiwgIFwiZGF0YVwiOiBcInZlcnNpb25cIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiR3JhZGVcIiwgICAgXCJkYXRhXCI6IFwiZ3JhZGVcIiB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYWFEYXRhXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSWYgb3JkZXJpbmcgaXMgZW5hYmxlZCwgdGhlbiBEYXRhVGFibGVzIHdpbGwgcGVyZm9ybSBhIGZpcnN0IHBhc3Mgc29ydCBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW5pdGlhbGlzYXRpb24uIFlvdSBjYW4gZGVmaW5lIHdoaWNoIGNvbHVtbihzKSB0aGUgc29ydCBpcyBwZXJmb3JtZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHVwb24sIGFuZCB0aGUgc29ydGluZyBkaXJlY3Rpb24sIHdpdGggdGhpcyB2YXJpYWJsZS4gVGhlIGBzb3J0aW5nYCBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2hvdWxkIGNvbnRhaW4gYW4gYXJyYXkgZm9yIGVhY2ggY29sdW1uIHRvIGJlIHNvcnRlZCBpbml0aWFsbHkgY29udGFpbmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIGNvbHVtbidzIGluZGV4IGFuZCBhIGRpcmVjdGlvbiBzdHJpbmcgKCdhc2MnIG9yICdkZXNjJykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbWzAsJ2FzYyddXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBTb3J0IGJ5IDNyZCBjb2x1bW4gZmlyc3QsIGFuZCB0aGVuIDR0aCBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyXCI6IFtbMiwnYXNjJ10sIFszLCdkZXNjJ11dXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBObyBpbml0aWFsIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyXCI6IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhYVNvcnRpbmdcIjogW1swLCAnYXNjJ11dLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGlzIGJhc2ljYWxseSBpZGVudGljYWwgdG8gdGhlIGBzb3J0aW5nYCBwYXJhbWV0ZXIsIGJ1dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2Fubm90IGJlIG92ZXJyaWRkZW4gYnkgdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0YWJsZS4gV2hhdCB0aGlzIG1lYW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyB0aGF0IHlvdSBjb3VsZCBoYXZlIGEgY29sdW1uICh2aXNpYmxlIG9yIGhpZGRlbikgd2hpY2ggdGhlIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHdpbGwgYWx3YXlzIGJlIGZvcmNlZCBvbiBmaXJzdCAtIGFueSBzb3J0aW5nIGFmdGVyIHRoYXQgKGZyb20gdGhlIHVzZXIpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aWxsIHRoZW4gYmUgcGVyZm9ybWVkIGFzIHJlcXVpcmVkLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGdyb3VwaW5nIHJvd3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvZ2V0aGVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyRml4ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyRml4ZWRcIjogW1swLCdhc2MnXV1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBjYW4gYmUgaW5zdHJ1Y3RlZCB0byBsb2FkIGRhdGEgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUgZnJvbSBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBamF4IHNvdXJjZS4gVGhpcyBvcHRpb24gZGVmaW5lcyBob3cgdGhhdCBBamF4IGNhbGwgaXMgbWFkZSBhbmQgd2hlcmUgdG8uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGBhamF4YCBwcm9wZXJ0eSBoYXMgdGhyZWUgZGlmZmVyZW50IG1vZGVzIG9mIG9wZXJhdGlvbiwgZGVwZW5kaW5nIG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBob3cgaXQgaXMgZGVmaW5lZC4gVGhlc2UgYXJlOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYHN0cmluZ2AgLSBTZXQgdGhlIFVSTCBmcm9tIHdoZXJlIHRoZSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgZnJvbS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYG9iamVjdGAgLSBEZWZpbmUgcHJvcGVydGllcyBmb3IgYGpRdWVyeS5hamF4YC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGZ1bmN0aW9uYCAtIEN1c3RvbSBkYXRhIGdldCBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGBzdHJpbmdgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAtLS0tLS0tLVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFzIGEgc3RyaW5nLCB0aGUgYGFqYXhgIHByb3BlcnR5IHNpbXBseSBkZWZpbmVzIHRoZSBVUkwgZnJvbSB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyB3aWxsIGxvYWQgZGF0YS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBgb2JqZWN0YFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogLS0tLS0tLS1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBcyBhbiBvYmplY3QsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBvYmplY3QgYXJlIHBhc3NlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogW2pRdWVyeS5hamF4XShodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LmFqYXgvKSBhbGxvd2luZyBmaW5lIGNvbnRyb2xcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9mIHRoZSBBamF4IHJlcXVlc3QuIERhdGFUYWJsZXMgaGFzIGEgbnVtYmVyIG9mIGRlZmF1bHQgcGFyYW1ldGVycyB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRvY3VtZW50YXRpb24gZm9yIGEgZnVsbCBkZXNjcmlwdGlvbiBvZiB0aGUgb3B0aW9ucyBhdmFpbGFibGUsIGFsdGhvdWdoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnMgcHJvdmlkZSBhZGRpdGlvbmFsIG9wdGlvbnMgaW4gRGF0YVRhYmxlcyBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgZGF0YWAgLSBBcyB3aXRoIGpRdWVyeSwgYGRhdGFgIGNhbiBiZSBwcm92aWRlZCBhcyBhbiBvYmplY3QsIGJ1dCBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIHRvIHRoZSBzZXJ2ZXIuIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsIGFuIG9iamVjdCBvZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBwYXJhbWV0ZXJzIHdpdGggdGhlIHZhbHVlcyB0aGF0IERhdGFUYWJsZXMgaGFzIHJlYWRpZWQgZm9yIHNlbmRpbmcuIEFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBkZWZhdWx0cywgb3IgeW91IGNhbiBhZGQgdGhlIGl0ZW1zIHRvIHRoZSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGluIGFuZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBub3QgcmV0dXJuIGFueXRoaW5nIGZyb20gdGhlIGZ1bmN0aW9uLiBUaGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyUGFyYW1zYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBkYXRhU3JjYCAtIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eSBgZGF0YWAgKG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGZyb20gYW4gQWpheCBzb3VyY2Ugb3IgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSB0aGlzIHBhcmFtZXRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBhbGxvd3MgdGhhdCBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkLiBZb3UgY2FuIHVzZSBKYXZhc2NyaXB0IGRvdHRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBpdCBteSBiZSB1c2VkIGFzIGEgZnVuY3Rpb24uIEFzIGEgZnVuY3Rpb24gaXQgdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB0aGUgSlNPTiByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIsIHdoaWNoIGNhbiBiZSBtYW5pcHVsYXRlZCBhc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGRhdGEgc291cmNlIGZvciB0aGUgdGFibGUuIFRoaXMgc3VwZXJzZWRlcyBgc0FqYXhEYXRhUHJvcGAgZnJvbVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBEYXRhVGFibGVzIDEuOS0uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgc3VjY2Vzc2AgLSBTaG91bGQgbm90IGJlIG92ZXJyaWRkZW4gaXQgaXMgdXNlZCBpbnRlcm5hbGx5IGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIERhdGFUYWJsZXMuIFRvIG1hbmlwdWxhdGUgLyB0cmFuc2Zvcm0gdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHNlcnZlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB1c2UgYGFqYXguZGF0YVNyY2AsIG9yIHVzZSBgYWpheGAgYXMgYSBmdW5jdGlvbiAoc2VlIGJlbG93KS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBgZnVuY3Rpb25gXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAtLS0tLS0tLS0tXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXMgYSBmdW5jdGlvbiwgbWFraW5nIHRoZSBBamF4IGNhbGwgaXMgbGVmdCB1cCB0byB5b3Vyc2VsZiBhbGxvd2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29tcGxldGUgY29udHJvbCBvZiB0aGUgQWpheCByZXF1ZXN0LiBJbmRlZWQsIGlmIGRlc2lyZWQsIGEgbWV0aG9kIG90aGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGFuIEFqYXggY291bGQgYmUgdXNlZCB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEsIHN1Y2ggYXMgV2ViIHN0b3JhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9yIGFuIEFJUiBkYXRhYmFzZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gaXMgZ2l2ZW4gZm91ciBwYXJhbWV0ZXJzIGFuZCBubyByZXR1cm4gaXMgcmVxdWlyZWQuIFRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcGFyYW1ldGVycyBhcmU6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMS4gX29iamVjdF8gLSBEYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMi4gX2Z1bmN0aW9uXyAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgbXVzdCBiZSBleGVjdXRlZCB3aGVuIHRoZSByZXF1aXJlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGF0YSBoYXMgYmVlbiBvYnRhaW5lZC4gVGhhdCBkYXRhIHNob3VsZCBiZSBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGFzIHRoZSBvbmx5IHBhcmFtZXRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMy4gX29iamVjdF8gLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgc3VwZXJzZWRlcyBgZm5TZXJ2ZXJEYXRhYCBmcm9tIERhdGFUYWJsZXMgMS45LS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nfG9iamVjdHxmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hamF4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHNpbmNlIDEuMTAuMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXguXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIE5vdGUgRGF0YVRhYmxlcyBleHBlY3RzIGRhdGEgaW4gdGhlIGZvcm0gYHsgZGF0YTogWyAuLi5kYXRhLi4uIF0gfWAgYnkgZGVmYXVsdCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IFwiZGF0YS5qc29uXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byBjaGFuZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgLy8gYGRhdGFgIHRvIGB0YWJsZURhdGFgIChpLmUuIGB7IHRhYmxlRGF0YTogWyAuLi5kYXRhLi4uIF0gfWApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBcImRhdGFTcmNcIjogXCJ0YWJsZURhdGFcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byByZWFkIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgLy8gZnJvbSBhIHBsYWluIGFycmF5IHJhdGhlciB0aGFuIGFuIGFycmF5IGluIGFuIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgXCJkYXRhU3JjXCI6IFwiXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBNYW5pcHVsYXRlIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciAtIGFkZCBhIGxpbmsgdG8gZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyAobm90ZSB0aGlzIGNhbiwgc2hvdWxkLCBiZSBkb25lIHVzaW5nIGByZW5kZXJgIGZvciB0aGUgY29sdW1uIC0gdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBpcyBqdXN0IGEgc2ltcGxlIGV4YW1wbGUgb2YgaG93IHRoZSBkYXRhIGNhbiBiZSBtYW5pcHVsYXRlZCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBcImRhdGFTcmNcIjogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICBqc29uW2ldWzBdID0gJzxhIGhyZWY9XCIvbWVzc2FnZS8nK2pzb25baV1bMF0rJz5WaWV3IG1lc3NhZ2U8L2E+JztcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICByZXR1cm4ganNvbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBBZGQgZGF0YSB0byB0aGUgcmVxdWVzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgXCJkYXRhXCI6IGZ1bmN0aW9uICggZCApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICBcImV4dHJhX3NlYXJjaFwiOiAkKCcjZXh0cmEnKS52YWwoKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIFNlbmQgcmVxdWVzdCBhcyBQT1NUXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBcInR5cGVcIjogXCJQT1NUXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBHZXQgdGhlIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UgKGNvdWxkIGludGVyZmFjZSB3aXRoIGEgZm9ybSBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgLy8gYWRkaW5nLCBlZGl0aW5nIGFuZCByZW1vdmluZyByb3dzKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICBcImFqYXhcIjogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrLCBzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgY2FsbGJhY2soXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIEpTT04ucGFyc2UoIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkYXRhVGFibGVzRGF0YScpIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYWpheFwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gcmVhZGlseSBzcGVjaWZ5IHRoZSBlbnRyaWVzIGluIHRoZSBsZW5ndGggZHJvcFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZG93biBtZW51IHRoYXQgRGF0YVRhYmxlcyBzaG93cyB3aGVuIHBhZ2luYXRpb24gaXMgZW5hYmxlZC4gSXQgY2FuIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlaXRoZXIgYSAxRCBhcnJheSBvZiBvcHRpb25zIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgYm90aCB0aGUgZGlzcGxheWVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvcHRpb24gYW5kIHRoZSB2YWx1ZSwgb3IgYSAyRCBhcnJheSB3aGljaCB3aWxsIHVzZSB0aGUgYXJyYXkgaW4gdGhlIGZpcnN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwb3NpdGlvbiBhcyB0aGUgdmFsdWUsIGFuZCB0aGUgYXJyYXkgaW4gdGhlIHNlY29uZCBwb3NpdGlvbiBhcyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRpc3BsYXllZCBvcHRpb25zICh1c2VmdWwgZm9yIGxhbmd1YWdlIHN0cmluZ3Mgc3VjaCBhcyAnQWxsJykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoZSBgcGFnZUxlbmd0aGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZpcnN0IHZhbHVlIGdpdmVuIGluIHRoaXMgYXJyYXksIHVubGVzcyBgcGFnZUxlbmd0aGAgaXMgYWxzbyBwcm92aWRlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFsgMTAsIDI1LCA1MCwgMTAwIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhNZW51XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsZW5ndGhNZW51XCI6IFtbMTAsIDI1LCA1MCwgLTFdLCBbMTAsIDI1LCA1MCwgXCJBbGxcIl1dXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhTGVuZ3RoTWVudVwiOiBbMTAsIDI1LCA1MCwgMTAwXSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgYGNvbHVtbnNgIG9wdGlvbiBpbiB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gZGVmaW5lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkZXRhaWxzIGFib3V0IHRoZSB3YXkgaW5kaXZpZHVhbCBjb2x1bW5zIGJlaGF2ZS4gRm9yIGEgZnVsbCBsaXN0IG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQsIHBsZWFzZSBzZWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufS4gTm90ZSB0aGF0IGlmIHlvdSB1c2UgYGNvbHVtbnNgIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkZWZpbmUgeW91ciBjb2x1bW5zLCB5b3UgbXVzdCBoYXZlIGFuIGVudHJ5IGluIHRoZSBhcnJheSBmb3IgZXZlcnkgc2luZ2xlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjb2x1bW4gdGhhdCB5b3UgaGF2ZSBpbiB5b3VyIHRhYmxlICh0aGVzZSBjYW4gYmUgbnVsbCBpZiB5b3UgZG9uJ3Qgd2hpY2hcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvIHNwZWNpZnkgYW55IG9wdGlvbnMpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBtZW1iZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvQ29sdW1uc1wiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVmVyeSBzaW1pbGFyIHRvIGBjb2x1bW5zYCwgYGNvbHVtbkRlZnNgIGFsbG93cyB5b3UgdG8gdGFyZ2V0IGEgc3BlY2lmaWNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNvbHVtbiwgbXVsdGlwbGUgY29sdW1ucywgb3IgYWxsIGNvbHVtbnMsIHVzaW5nIHRoZSBgdGFyZ2V0c2AgcHJvcGVydHkgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheS4gVGhpcyBhbGxvd3MgZ3JlYXQgZmxleGliaWxpdHkgd2hlbiBjcmVhdGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGFibGVzLCBhcyB0aGUgYGNvbHVtbkRlZnNgIGFycmF5cyBjYW4gYmUgb2YgYW55IGxlbmd0aCwgdGFyZ2V0aW5nIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29sdW1ucyB5b3Ugc3BlY2lmaWNhbGx5IHdhbnQuIGBjb2x1bW5EZWZzYCBtYXkgdXNlIGFueSBvZiB0aGUgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvcHRpb25zIGF2YWlsYWJsZToge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LCBidXQgaXQgX211c3RfXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBoYXZlIGB0YXJnZXRzYCBkZWZpbmVkIGluIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheS4gVmFsdWVzIGluIHRoZSBgdGFyZ2V0c2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFycmF5IG1heSBiZTpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPHVsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT5hIHN0cmluZyAtIGNsYXNzIG5hbWUgd2lsbCBiZSBtYXRjaGVkIG9uIHRoZSBUSCBmb3IgdGhlIGNvbHVtbjwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPGxpPjAgb3IgYSBwb3NpdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIGxlZnQ8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT5hIG5lZ2F0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgcmlnaHQ8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT50aGUgc3RyaW5nIFwiX2FsbFwiIC0gYWxsIGNvbHVtbnMgKGkuZS4gYXNzaWduIGEgZGVmYXVsdCk8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICA8L3VsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBtZW1iZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbkRlZnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb0NvbHVtbkRlZnNcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBCYXNpY2FsbHkgdGhlIHNhbWUgYXMgYHNlYXJjaGAsIHRoaXMgcGFyYW1ldGVyIGRlZmluZXMgdGhlIGluZGl2aWR1YWwgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmaWx0ZXJpbmcgc3RhdGUgYXQgaW5pdGlhbGlzYXRpb24gdGltZS4gVGhlIGFycmF5IG11c3QgYmUgb2YgdGhlIHNhbWUgc2l6ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYXMgdGhlIG51bWJlciBvZiBjb2x1bW5zLCBhbmQgZWFjaCBlbGVtZW50IGJlIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJhbWV0ZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBgc2VhcmNoYCBhbmQgYGVzY2FwZVJlZ2V4YCAodGhlIGxhdHRlciBpcyBvcHRpb25hbCkuICdudWxsJyBpcyBhbHNvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhY2NlcHRlZCBhbmQgdGhlIGRlZmF1bHQgd2lsbCBiZSB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hDb2xzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzZWFyY2hDb2xzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwic2VhcmNoXCI6IFwiTXkgZmlsdGVyXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwic2VhcmNoXCI6IFwiXlswLTldXCIsIFwiZXNjYXBlUmVnZXhcIjogZmFsc2UgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9TZWFyY2hDb2xzXCI6IFtdLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFuIGFycmF5IG9mIENTUyBjbGFzc2VzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gZGlzcGxheWVkIHJvd3MuIFRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFycmF5IG1heSBiZSBvZiBhbnkgbGVuZ3RoLCBhbmQgRGF0YVRhYmxlcyB3aWxsIGFwcGx5IGVhY2ggY2xhc3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNlcXVlbnRpYWxseSwgbG9vcGluZyB3aGVuIHJlcXVpcmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5XaWxsIHRha2UgdGhlIHZhbHVlcyBkZXRlcm1pbmVkIGJ5IHRoZSBgb0NsYXNzZXMuc3RyaXBlKmBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIG9wdGlvbnM8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RyaXBlQ2xhc3Nlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RyaXBlQ2xhc3Nlc1wiOiBbICdzdHJpcDEnLCAnc3RyaXAyJywgJ3N0cmlwMycgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9IClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhdXRvbWF0aWMgY29sdW1uIHdpZHRoIGNhbGN1bGF0aW9uLiBUaGlzIGNhbiBiZSBkaXNhYmxlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYXMgYW4gb3B0aW1pc2F0aW9uIChpdCB0YWtlcyBzb21lIHRpbWUgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aHMpIGlmIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGFibGVzIHdpZHRocyBhcmUgcGFzc2VkIGluIHVzaW5nIGBjb2x1bW5zYC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYXV0b1dpZHRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiYXV0b1dpZHRoXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiQXV0b1dpZHRoXCI6IHRydWUsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGVmZXJyZWQgcmVuZGVyaW5nIGNhbiBwcm92aWRlIERhdGFUYWJsZXMgd2l0aCBhIGh1Z2Ugc3BlZWQgYm9vc3Qgd2hlbiB5b3VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFyZSB1c2luZyBhbiBBamF4IG9yIEpTIGRhdGEgc291cmNlIGZvciB0aGUgdGFibGUuIFRoaXMgb3B0aW9uLCB3aGVuIHNldCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdHJ1ZSwgd2lsbCBjYXVzZSBEYXRhVGFibGVzIHRvIGRlZmVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgdGFibGUgZWxlbWVudHMgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlYWNoIHJvdyB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgZm9yIGEgZHJhdyAtIHNhdmluZyBhIHNpZ25pZmljYW50IGFtb3VudCBvZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGltZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyUmVuZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJhamF4XCI6IFwic291cmNlcy9hcnJheXMudHh0XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJkZWZlclJlbmRlclwiOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiRGVmZXJSZW5kZXJcIjogZmFsc2UsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUmVwbGFjZSBhIERhdGFUYWJsZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgcmVwbGFjZSBpdCB3aXRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvbmUgd2hpY2ggaGFzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBuZXcgaW5pdGlhbGlzYXRpb24gb2JqZWN0IHBhc3NlZC4gSWYgbm9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRhYmxlIG1hdGNoZXMgdGhlIHNlbGVjdG9yLCB0aGVuIHRoZSBuZXcgRGF0YVRhYmxlIHdpbGwgYmUgY29uc3RydWN0ZWQgYXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBlciBub3JtYWwuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlc3Ryb3lcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNyb2xsWVwiOiBcIjIwMHB4XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBTb21lIHRpbWUgbGF0ZXIuLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJmaWx0ZXJcIjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJkZXN0cm95XCI6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJEZXN0cm95XCI6IGZhbHNlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbHRlcmluZyBvZiBkYXRhLiBGaWx0ZXJpbmcgaW4gRGF0YVRhYmxlcyBpcyBcInNtYXJ0XCIgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgaXQgYWxsb3dzIHRoZSBlbmQgdXNlciB0byBpbnB1dCBtdWx0aXBsZSB3b3JkcyAoc3BhY2Ugc2VwYXJhdGVkKSBhbmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHdpbGwgbWF0Y2ggYSByb3cgY29udGFpbmluZyB0aG9zZSB3b3JkcywgZXZlbiBpZiBub3QgaW4gdGhlIG9yZGVyIHRoYXQgd2FzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzcGVjaWZpZWQgKHRoaXMgYWxsb3cgbWF0Y2hpbmcgYWNyb3NzIG11bHRpcGxlIGNvbHVtbnMpLiBOb3RlIHRoYXQgaWYgeW91XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aXNoIHRvIHVzZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlcyB0aGlzIG11c3QgcmVtYWluICd0cnVlJyAtIHRvIHJlbW92ZSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRlZmF1bHQgZmlsdGVyaW5nIGlucHV0IGJveCBhbmQgcmV0YWluIGZpbHRlcmluZyBhYmlsaXRpZXMsIHBsZWFzZSB1c2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuZG9tfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoaW5nXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiRmlsdGVyXCI6IHRydWUsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGRpc3BsYXkuIFRoaXMgc2hvd3MgaW5mb3JtYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFib3V0IHRoZSBkYXRhIHRoYXQgaXMgY3VycmVudGx5IHZpc2libGUgb24gdGhlIHBhZ2UsIGluY2x1ZGluZyBpbmZvcm1hdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWJvdXQgZmlsdGVyZWQgZGF0YSBpZiB0aGF0IGFjdGlvbiBpcyBiZWluZyBwZXJmb3JtZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluZm9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJpbmZvXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiSW5mb1wiOiB0cnVlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSBqUXVlcnkgVUkgVGhlbWVSb2xsZXIgc3VwcG9ydCAocmVxdWlyZWQgYXMgVGhlbWVSb2xsZXIgcmVxdWlyZXMgc29tZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2xpZ2h0bHkgZGlmZmVyZW50IGFuZCBhZGRpdGlvbmFsIG1hcmstdXAgZnJvbSB3aGF0IERhdGFUYWJsZXMgaGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0cmFkaXRpb25hbGx5IHVzZWQpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMualF1ZXJ5VUlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImpRdWVyeVVJXCI6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJKUXVlcnlVSVwiOiBmYWxzZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBbGxvd3MgdGhlIGVuZCB1c2VyIHRvIHNlbGVjdCB0aGUgc2l6ZSBvZiBhIGZvcm1hdHRlZCBwYWdlIGZyb20gYSBzZWxlY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG1lbnUgKHNpemVzIGFyZSAxMCwgMjUsIDUwIGFuZCAxMDApLiBSZXF1aXJlcyBwYWdpbmF0aW9uIChgcGFnaW5hdGVgKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGVuZ3RoQ2hhbmdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGVuZ3RoQ2hhbmdlXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiTGVuZ3RoQ2hhbmdlXCI6IHRydWUsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgcGFnaW5hdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwicGFnaW5nXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiUGFnaW5hdGVcIjogdHJ1ZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiBhICdwcm9jZXNzaW5nJyBpbmRpY2F0b3Igd2hlbiB0aGUgdGFibGUgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJlaW5nIHByb2Nlc3NlZCAoZS5nLiBhIHNvcnQpLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHRhYmxlcyB3aXRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBsYXJnZSBhbW91bnRzIG9mIGRhdGEgd2hlcmUgaXQgY2FuIHRha2UgYSBub3RpY2VhYmxlIGFtb3VudCBvZiB0aW1lIHRvIHNvcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBlbnRyaWVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJvY2Vzc2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInByb2Nlc3NpbmdcIjogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlByb2Nlc3NpbmdcIjogZmFsc2UsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUmV0cmlldmUgdGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIE5vdGUgdGhhdCBpZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRhYmxlIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGlzZWQsIHRoaXMgcGFyYW1ldGVyIHdpbGwgY2F1c2UgRGF0YVRhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdG8gc2ltcGx5IHJldHVybiB0aGUgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzZXQgdXAgLSBpdCB3aWxsIG5vdCB0YWtlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhY2NvdW50IG9mIGFueSBjaGFuZ2VzIHlvdSBtaWdodCBoYXZlIG1hZGUgdG8gdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcGFzc2VkIHRvIERhdGFUYWJsZXMgKHNldHRpbmcgdGhpcyBwYXJhbWV0ZXIgdG8gdHJ1ZSBpcyBhbiBhY2tub3dsZWRnZW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgeW91IHVuZGVyc3RhbmQgdGhpcykuIGBkZXN0cm95YCBjYW4gYmUgdXNlZCB0byByZWluaXRpYWxpc2UgYSB0YWJsZSBpZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogeW91IG5lZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJldHJpZXZlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGluaXRUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB0YWJsZUFjdGlvbnMoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBmdW5jdGlvbiBpbml0VGFibGUgKClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgcmV0dXJuICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwcHhcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwicmV0cmlldmVcIjogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZnVuY3Rpb24gdGFibGVBY3Rpb25zICgpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciB0YWJsZSA9IGluaXRUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBwZXJmb3JtIEFQSSBvcGVyYXRpb25zIHdpdGggb1RhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlJldHJpZXZlXCI6IGZhbHNlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFdoZW4gdmVydGljYWwgKHkpIHNjcm9sbGluZyBpcyBlbmFibGVkLCBEYXRhVGFibGVzIHdpbGwgZm9yY2UgdGhlIGhlaWdodCBvZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIHRhYmxlJ3Mgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGhlaWdodCBhdCBhbGwgdGltZXMgKHVzZWZ1bCBmb3IgbGF5b3V0KS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEhvd2V2ZXIsIHRoaXMgY2FuIGxvb2sgb2RkIHdoZW4gZmlsdGVyaW5nIGRhdGEgZG93biB0byBhIHNtYWxsIGRhdGEgc2V0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW5kIHRoZSBmb290ZXIgaXMgbGVmdCBcImZsb2F0aW5nXCIgZnVydGhlciBkb3duLiBUaGlzIHBhcmFtZXRlciAod2hlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZW5hYmxlZCkgd2lsbCBjYXVzZSBEYXRhVGFibGVzIHRvIGNvbGxhcHNlIHRoZSB0YWJsZSdzIHZpZXdwb3J0IGRvd24gd2hlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIHJlc3VsdCBzZXQgd2lsbCBmaXQgd2l0aGluIHRoZSBnaXZlbiBZIGhlaWdodC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsQ29sbGFwc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbENvbGxhcHNlXCI6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTY3JvbGxDb2xsYXBzZVwiOiBmYWxzZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDb25maWd1cmUgRGF0YVRhYmxlcyB0byB1c2Ugc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gTm90ZSB0aGF0IHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYGFqYXhgIHBhcmFtZXRlciBtdXN0IGFsc28gYmUgZ2l2ZW4gaW4gb3JkZXIgdG8gZ2l2ZSBEYXRhVGFibGVzIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNvdXJjZSB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEgZm9yIGVhY2ggZHJhdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclNpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJhamF4XCI6IFwieGhyLnBocFwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU2VydmVyU2lkZVwiOiBmYWxzZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBzb3J0aW5nIG9mIGNvbHVtbnMuIFNvcnRpbmcgb2YgaW5kaXZpZHVhbCBjb2x1bW5zIGNhbiBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGlzYWJsZWQgYnkgdGhlIGBzb3J0YWJsZWAgb3B0aW9uIGZvciBlYWNoIGNvbHVtbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlcmluZ1wiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRcIjogdHJ1ZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzcGxheSBEYXRhVGFibGVzJyBhYmlsaXR5IHRvIHNvcnQgbXVsdGlwbGUgY29sdW1ucyBhdCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNhbWUgdGltZSAoYWN0aXZhdGVkIGJ5IHNoaWZ0LWNsaWNrIGJ5IHRoZSB1c2VyKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlck11bHRpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBEaXNhYmxlIG11bHRpcGxlIGNvbHVtbiBzb3J0aW5nIGFiaWxpdHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlck11bHRpXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU29ydE11bHRpXCI6IHRydWUsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQWxsb3dzIGNvbnRyb2wgb3ZlciB3aGV0aGVyIERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0aGUgdG9wICh0cnVlKSB1bmlxdWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNlbGwgdGhhdCBpcyBmb3VuZCBmb3IgYSBzaW5nbGUgY29sdW1uLCBvciB0aGUgYm90dG9tIChmYWxzZSAtIGRlZmF1bHQpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBjb21wbGV4IGhlYWRlcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2VsbHNUb3BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyQ2VsbHNUb3BcIjogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRDZWxsc1RvcFwiOiBmYWxzZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgYWRkaXRpb24gb2YgdGhlIGNsYXNzZXMgYHNvcnRpbmdcXF8xYCwgYHNvcnRpbmdcXF8yYCBhbmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGBzb3J0aW5nXFxfM2AgdG8gdGhlIGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBiZWluZyBzb3J0ZWQgb24uIFRoaXMgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByZXNlbnRlZCBhcyBhIGZlYXR1cmUgc3dpdGNoIGFzIGl0IGNhbiBpbmNyZWFzZSBwcm9jZXNzaW5nIHRpbWUgKHdoaWxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjbGFzc2VzIGFyZSByZW1vdmVkIGFuZCBhZGRlZCkgc28gZm9yIGxhcmdlIGRhdGEgc2V0cyB5b3UgbWlnaHQgd2FudCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdHVybiB0aGlzIG9mZi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJDbGFzc2VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJDbGFzc2VzXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU29ydENsYXNzZXNcIjogdHJ1ZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBzdGF0ZSBzYXZpbmcuIFdoZW4gZW5hYmxlZCBIVE1MNSBgbG9jYWxTdG9yYWdlYCB3aWxsIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB1c2VkIHRvIHNhdmUgdGFibGUgZGlzcGxheSBpbmZvcm1hdGlvbiBzdWNoIGFzIHBhZ2luYXRpb24gaW5mb3JtYXRpb24sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkaXNwbGF5IGxlbmd0aCwgZmlsdGVyaW5nIGFuZCBzb3J0aW5nLiBBcyBzdWNoIHdoZW4gdGhlIGVuZCB1c2VyIHJlbG9hZHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBwYWdlIHRoZSBkaXNwbGF5IGRpc3BsYXkgd2lsbCBtYXRjaCB3aGF0IHRoeSBoYWQgcHJldmlvdXNseSBzZXQgdXAuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRHVlIHRvIHRoZSB1c2Ugb2YgYGxvY2FsU3RvcmFnZWAgdGhlIGRlZmF1bHQgc3RhdGUgc2F2aW5nIGlzIG5vdCBzdXBwb3J0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluIElFNiBvciA3LiBJZiBzdGF0ZSBzYXZpbmcgaXMgcmVxdWlyZWQgaW4gdGhvc2UgYnJvd3NlcnMsIHVzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYHN0YXRlU2F2ZUNhbGxiYWNrYCB0byBwcm92aWRlIGEgc3RvcmFnZSBzb2x1dGlvbiBzdWNoIGFzIGNvb2tpZXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlN0YXRlU2F2ZVwiOiBmYWxzZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgVFIgZWxlbWVudCBpcyBjcmVhdGVkIChhbmQgYWxsIFREIGNoaWxkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50cyBoYXZlIGJlZW4gaW5zZXJ0ZWQpLCBvciByZWdpc3RlcmVkIGlmIHVzaW5nIGEgRE9NIHNvdXJjZSwgYWxsb3dpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG1hbmlwdWxhdGlvbiBvZiB0aGUgVFIgZWxlbWVudCAoYWRkaW5nIGNsYXNzZXMgZXRjKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gcm93IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgY3VycmVudCByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBkYXRhSW5kZXggVGhlIGluZGV4IG9mIHRoaXMgcm93IGluIHRoZSBpbnRlcm5hbCBhb0RhdGEgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jcmVhdGVkUm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjcmVhdGVkUm93XCI6IGZ1bmN0aW9uKCByb3csIGRhdGEsIGRhdGFJbmRleCApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIC8vIEJvbGQgdGhlIGdyYWRlIGZvciBhbGwgJ0EnIGdyYWRlIGJyb3dzZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAkKCd0ZDplcSg0KScsIHJvdykuaHRtbCggJzxiPkE8L2I+JyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuQ3JlYXRlZFJvd1wiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGR5bmFtaWNhbGx5IG1vZGlmeSBhbnkgYXNwZWN0IHlvdSB3YW50IGFib3V0IHRoZSBjcmVhdGVkIERPTS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRyYXdDYWxsYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIGFsZXJ0KCAnRGF0YVRhYmxlcyBoYXMgcmVkcmF3biB0aGUgdGFibGUnICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5EcmF3Q2FsbGJhY2tcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJZGVudGljYWwgdG8gZm5IZWFkZXJDYWxsYmFjaygpIGJ1dCBmb3IgdGhlIHRhYmxlIGZvb3RlciB0aGlzIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbGxvd3MgeW91IHRvIG1vZGlmeSB0aGUgdGFibGUgZm9vdGVyIG9uIGV2ZXJ5ICdkcmF3JyBldmVudC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gZm9vdCBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGZvb3RlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IHN0YXJ0aW5nIHBvaW50IGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGlzcGxheSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGlzcGxheSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXkgaW50fSBkaXNwbGF5IEluZGV4IGFycmF5IHRvIHRyYW5zbGF0ZSB0aGUgdmlzdWFsIHBvc2l0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZm9vdGVyQ2FsbGJhY2tcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImZvb3RlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCB0Zm9vdCwgZGF0YSwgc3RhcnQsIGVuZCwgZGlzcGxheSApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHRmb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aCcpWzBdLmlubmVySFRNTCA9IFwiU3RhcnRpbmcgaW5kZXggaXMgXCIrc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9IClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkZvb3RlckNhbGxiYWNrXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogV2hlbiByZW5kZXJpbmcgbGFyZ2UgbnVtYmVycyBpbiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBmb3IgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAoaS5lLiBcIlNob3dpbmcgMSB0byAxMCBvZiA1NyBlbnRyaWVzXCIpIERhdGFUYWJsZXMgd2lsbCByZW5kZXIgbGFyZ2UgbnVtYmVyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdG8gaGF2ZSBhIGNvbW1hIHNlcGFyYXRvciBmb3IgdGhlICd0aG91c2FuZHMnIHVuaXRzIChlLmcuIDEgbWlsbGlvbiBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcmVuZGVyZWQgYXMgXCIxLDAwMCwwMDBcIikgdG8gaGVscCByZWFkYWJpbGl0eSBmb3IgdGhlIGVuZCB1c2VyLiBUaGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbiB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZCBEYXRhVGFibGVzIHVzZXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbWVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHRvRm9ybWF0IG51bWJlciB0byBiZSBmb3JtYXR0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgc3RyaW5nIGZvciBEYXRhVGFibGVzIHRvIHNob3cgdGhlIG51bWJlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvcm1hdE51bWJlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gRm9ybWF0IGEgbnVtYmVyIHVzaW5nIGEgc2luZ2xlIHF1b3RlIGZvciB0aGUgc2VwYXJhdG9yIChub3RlIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIHRoaXMgY2FuIGFsc28gYmUgZG9uZSB3aXRoIHRoZSBsYW5ndWFnZS50aG91c2FuZHMgb3B0aW9uKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICggdG9Gb3JtYXQgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gdG9Gb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCInXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuRm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICh0b0Zvcm1hdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b0Zvcm1hdC50b1N0cmluZygpLnJlcGxhY2UoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9MYW5ndWFnZS5zVGhvdXNhbmRzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZHluYW1pY2FsbHkgbW9kaWZ5IHRoZSBoZWFkZXIgcm93LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBhbmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRpc3BsYXkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gaGVhZCBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGhlYWRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRnVsbCB0YWJsZSBkYXRhIChhcyBkZXJpdmVkIGZyb20gdGhlIG9yaWdpbmFsIEhUTUwpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHN0YXJ0IEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IHN0YXJ0aW5nIHBvaW50IGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGlzcGxheSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBlbmQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgZW5kaW5nIHBvaW50IGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGlzcGxheSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXkgaW50fSBkaXNwbGF5IEluZGV4IGFycmF5IHRvIHRyYW5zbGF0ZSB0aGUgdmlzdWFsIHBvc2l0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB0byB0aGUgZnVsbCBkYXRhIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaGVhZGVyQ2FsbGJhY2tcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImZoZWFkZXJDYWxsYmFja1wiOiBmdW5jdGlvbiggaGVhZCwgZGF0YSwgc3RhcnQsIGVuZCwgZGlzcGxheSApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIGhlYWQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3RoJylbMF0uaW5uZXJIVE1MID0gXCJEaXNwbGF5aW5nIFwiKyhlbmQtc3RhcnQpK1wiIHJlY29yZHNcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuSGVhZGVyQ2FsbGJhY2tcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgaW5mb3JtYXRpb24gZWxlbWVudCBjYW4gYmUgdXNlZCB0byBjb252ZXkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHN0YXRlIG9mIHRoZSB0YWJsZS4gQWx0aG91Z2ggdGhlIGludGVybmF0aW9uYWxpc2F0aW9uIG9wdGlvbnMgcHJlc2VudGVkIGJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIGFyZSBxdWl0ZSBjYXBhYmxlIG9mIGRlYWxpbmcgd2l0aCBtb3N0IGN1c3RvbWlzYXRpb25zLCB0aGVyZSBtYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJlIHRpbWVzIHdoZXJlIHlvdSB3aXNoIHRvIGN1c3RvbWlzZSB0aGUgc3RyaW5nIGZ1cnRoZXIuIFRoaXMgY2FsbGJhY2tcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFsbG93cyB5b3UgdG8gZG8gZXhhY3RseSB0aGF0LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBzdGFydCBTdGFydGluZyBwb3NpdGlvbiBpbiBkYXRhIGZvciB0aGUgZHJhd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBlbmQgRW5kIHBvc2l0aW9uIGluIGRhdGEgZm9yIHRoZSBkcmF3XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IG1heCBUb3RhbCBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdGFibGUgKHJlZ2FyZGxlc3Mgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGZpbHRlcmluZylcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gdG90YWwgVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGRhdGEgc2V0LCBhZnRlciBmaWx0ZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gcHJlIFRoZSBzdHJpbmcgdGhhdCBEYXRhVGFibGVzIGhhcyBmb3JtYXR0ZWQgdXNpbmcgaXQnc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgb3duIHJ1bGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gVGhlIHN0cmluZyB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuaW5mb0NhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBcImluZm9DYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIHByZSApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gc3RhcnQgK1wiIHRvIFwiKyBlbmQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkluZm9DYWxsYmFja1wiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC4gTm9ybWFsbHkgRGF0YVRhYmxlcyB3aWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbml0aWFsaXNlIHNlcXVlbnRpYWxseSBhbmQgdGhlcmUgd2lsbCBiZSBubyBuZWVkIGZvciB0aGlzIGZ1bmN0aW9uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaG93ZXZlciwgdGhpcyBkb2VzIG5vdCBob2xkIHRydWUgd2hlbiB1c2luZyBleHRlcm5hbCBsYW5ndWFnZSBpbmZvcm1hdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2luY2UgdGhhdCBpcyBvYnRhaW5lZCB1c2luZyBhbiBhc3luYyBYSFIgY2FsbC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHByZXNlbnQgaWYgY2xpZW50LXNpZGUgQWpheCBzb3VyY2VkIGRhdGEgaXMgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluaXRDb21wbGV0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiaW5pdENvbXBsZXRlXCI6IGZ1bmN0aW9uKHNldHRpbmdzLCBqc29uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIGZpbmlzaGVkIGl0cyBpbml0aWFsaXNhdGlvbi4nICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9IClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkluaXRDb21wbGV0ZVwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxlZCBhdCB0aGUgdmVyeSBzdGFydCBvZiBlYWNoIHRhYmxlIGRyYXcgYW5kIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRyYXcgYnkgcmV0dXJuaW5nIGZhbHNlLCBhbnkgb3RoZXIgcmV0dXJuIChpbmNsdWRpbmcgdW5kZWZpbmVkKSByZXN1bHRzIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZnVsbCBkcmF3IG9jY3VycmluZykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gRmFsc2Ugd2lsbCBjYW5jZWwgdGhlIGRyYXcsIGFueXRoaW5nIGVsc2UgKGluY2x1ZGluZyBub1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgcmV0dXJuKSB3aWxsIGFsbG93IGl0IHRvIGNvbXBsZXRlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnByZURyYXdDYWxsYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwicHJlRHJhd0NhbGxiYWNrXCI6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIGlmICggJCgnI3Rlc3QnKS52YWwoKSA9PSAxICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5QcmVEcmF3Q2FsbGJhY2tcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gJ3Bvc3QgcHJvY2VzcycgZWFjaCByb3cgYWZ0ZXIgaXQgaGF2ZSBiZWVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBnZW5lcmF0ZWQgZm9yIGVhY2ggdGFibGUgZHJhdywgYnV0IGJlZm9yZSBpdCBpcyByZW5kZXJlZCBvbiBzY3JlZW4uIFRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9uIG1pZ2h0IGJlIHVzZWQgZm9yIHNldHRpbmcgdGhlIHJvdyBjbGFzcyBuYW1lIGV0Yy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gcm93IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgY3VycmVudCByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBkaXNwbGF5SW5kZXggVGhlIGRpc3BsYXkgaW5kZXggZm9yIHRoZSBjdXJyZW50IHRhYmxlIGRyYXdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZGlzcGxheUluZGV4RnVsbCBUaGUgaW5kZXggb2YgdGhlIGRhdGEgaW4gdGhlIGZ1bGwgbGlzdCBvZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgcm93cyAoYWZ0ZXIgZmlsdGVyaW5nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0NhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJyb3dDYWxsYmFja1wiOiBmdW5jdGlvbiggcm93LCBkYXRhLCBkaXNwbGF5SW5kZXgsIGRpc3BsYXlJbmRleEZ1bGwgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgaWYgKCBkYXRhWzRdID09IFwiQVwiICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAkKCd0ZDplcSg0KScsIHJvdykuaHRtbCggJzxiPkE8L2I+JyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuUm93Q2FsbGJhY2tcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGZ1bmN0aW9uIHdoaWNoIG9idGFpbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBkYXRhIGZyb20gdGhlIHNlcnZlciBzbyBzb21ldGhpbmcgbW9yZSBzdWl0YWJsZSBmb3IgeW91ciBhcHBsaWNhdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZvciBleGFtcGxlIHlvdSBjb3VsZCB1c2UgUE9TVCBkYXRhLCBvciBwdWxsIGluZm9ybWF0aW9uIGZyb20gYSBHZWFycyBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQUlSIGRhdGFiYXNlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG1lbWJlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgSFRUUCBzb3VyY2UgdG8gb2J0YWluIHRoZSBkYXRhIGZyb20gKGBhamF4YClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEEga2V5L3ZhbHVlIHBhaXIgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gc2VuZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgdG8gdGhlIHNlcnZlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uIG9mIHRoZSBkYXRhIGdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgcHJvY2VzcyB0aGF0IHdpbGwgZHJhdyB0aGUgZGF0YSBvbiB0aGUgcGFnZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJEYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuU2VydmVyRGF0YVwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBJdCBpcyBvZnRlbiB1c2VmdWwgdG8gc2VuZCBleHRyYSBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2hlbiBtYWtpbmcgYW4gQWpheFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcmVxdWVzdCAtIGZvciBleGFtcGxlIGN1c3RvbSBmaWx0ZXJpbmcgaW5mb3JtYXRpb24sIGFuZCB0aGlzIGNhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbiBtYWtlcyBpdCB0cml2aWFsIHRvIHNlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIHNlcnZlci4gVGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwYXNzZWQgaW4gcGFyYW1ldGVyIGlzIHRoZSBkYXRhIHNldCB0aGF0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzLCBhbmQgeW91IGNhbiBhZGQgdG8gdGhpcyBvciBtb2RpZnkgaXQgYXMgeW91IHJlcXVpcmUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgYXJyYXkgKGFycmF5IG9mIG9iamVjdHMgd2hpY2ggYXJlIG5hbWUvdmFsdWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHBhaXJzKSB0aGF0IGhhcyBiZWVuIGNvbnN0cnVjdGVkIGJ5IERhdGFUYWJsZXMgYW5kIHdpbGwgYmUgc2VudCB0byB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHNlcnZlci4gSW4gdGhlIGNhc2Ugb2YgQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB0aGlzIHdpbGwgYmUgYW4gZW1wdHkgYXJyYXksIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZXJlIHdpbGwgYmUgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgc2lnbmlmaWNhbnQgbnVtYmVyIG9mIHBhcmFtZXRlcnMhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge3VuZGVmaW5lZH0gRW5zdXJlIHRoYXQgeW91IG1vZGlmeSB0aGUgZGF0YSBhcnJheSBwYXNzZWQgaW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBhcyB0aGlzIGlzIHBhc3NlZCBieSByZWZlcmVuY2UuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgU2VydmVyLXNpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyUGFyYW1zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuU2VydmVyUGFyYW1zXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTG9hZCB0aGUgdGFibGUgc3RhdGUuIFdpdGggdGhpcyBmdW5jdGlvbiB5b3UgY2FuIGRlZmluZSBmcm9tIHdoZXJlLCBhbmQgaG93LCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHN0YXRlIG9mIGEgdGFibGUgaXMgbG9hZGVkLiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb2FkIGZyb20gYGxvY2FsU3RvcmFnZWBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJ1dCB5b3UgbWlnaHQgd2lzaCB0byB1c2UgYSBzZXJ2ZXItc2lkZSBkYXRhYmFzZSBvciBjb29raWVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG1lbWJlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm4ge29iamVjdH0gVGhlIERhdGFUYWJsZXMgc3RhdGUgb2JqZWN0IHRvIGJlIGxvYWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlTG9hZENhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgdmFyIG87XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgLy8gU2VuZCBhbiBBamF4IHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIGRhdGEuIE5vdGUgdGhhdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgLy8gdGhpcyBpcyBhIHN5bmNocm9ub3VzIHJlcXVlc3QuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAkLmFqYXgoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJ1cmxcIjogXCIvc3RhdGVfbG9hZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImFzeW5jXCI6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICBvID0ganNvbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiBvO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuU3RhdGVMb2FkQ2FsbGJhY2tcIjogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLmdldEl0ZW0oXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0RhdGFUYWJsZXNfJyArIHNldHRpbmdzLnNJbnN0YW5jZSArICdfJyArIGxvY2F0aW9uLnBhdGhuYW1lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIHByaW9yIHRvIGxvYWRpbmcgdGhhdCBzdGF0ZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRhYmxlIGlzIGxvYWRpbmcgc3RhdGUgZnJvbSB0aGUgc3RvcmVkIGRhdGEsIGJ1dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGUuIE5vdGUgdGhhdCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZCB1c2UgdGhlIGBzdGF0ZUxvYWRQYXJhbXNgIGV2ZW50IHRvIGxvYWQgcGFyYW1ldGVycyBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGEgcGx1Zy1pbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCBpcyB0byBiZSBsb2FkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRQYXJhbXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFJlbW92ZSBhIHNhdmVkIGZpbHRlciwgc28gZmlsdGVyaW5nIGlzIG5ldmVyIGxvYWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZUxvYWRQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBEaXNhbGxvdyBzdGF0ZSBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZUxvYWRQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5TdGF0ZUxvYWRQYXJhbXNcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSB0aGUgc3RhdGUgc2F2aW5nIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW5kIHRoZSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBhcyBhIHJlc3VsdCBvZiB0aGUgbG9hZGVkIHN0YXRlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0aGF0IHdhcyBsb2FkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gU2hvdyBhbiBhbGVydCB3aXRoIHRoZSBmaWx0ZXJpbmcgdmFsdWUgdGhhdCB3YXMgc2F2ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVMb2FkZWRcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBhbGVydCggJ1NhdmVkIGZpbHRlciB3YXM6ICcrZGF0YS5vU2VhcmNoLnNTZWFyY2ggKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblN0YXRlTG9hZGVkXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU2F2ZSB0aGUgdGFibGUgc3RhdGUuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBkZWZpbmUgd2hlcmUgYW5kIGhvdyB0aGUgc3RhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUgaXMgc3RvcmVkIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIHVzZSBgbG9jYWxTdG9yYWdlYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbWVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZUNhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgLy8gU2VuZCBhbiBBamF4IHJlcXVlc3QgdG8gdGhlIHNlcnZlciB3aXRoIHRoZSBzdGF0ZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICQuYWpheCgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9zYXZlXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGF0YVwiOiBkYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKCkge31cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbiA9PT0gLTEgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZSkuc2V0SXRlbShcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEYXRhVGFibGVzXycgKyBzZXR0aW5ncy5zSW5zdGFuY2UgKyAnXycgKyBsb2NhdGlvbi5wYXRobmFtZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrIHdoaWNoIGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHN0YXRlIHRvIGJlIHNhdmVkLiBDYWxsZWQgd2hlbiB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmUgaXMgcmVxdWlyZWQuIFRoaXMgbWV0aG9kIGFsbG93cyBtb2RpZmljYXRpb24gb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0IHByaW9yIHRvIGFjdHVhbGx5IGRvaW5nIHRoZSBzYXZlLCBpbmNsdWRpbmcgYWRkaXRpb24gb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG90aGVyIHN0YXRlIHByb3BlcnRpZXMgb3IgbW9kaWZpY2F0aW9uLiBOb3RlIHRoYXQgZm9yIHBsdWctaW4gYXV0aG9ycywgeW91IHNob3VsZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdXNlIHRoZSBgc3RhdGVTYXZlUGFyYW1zYCBldmVudCB0byBzYXZlIHBhcmFtZXRlcnMgZm9yIGEgcGx1Zy1pbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdG8gYmUgc2F2ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVQYXJhbXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFJlbW92ZSBhIHNhdmVkIGZpbHRlciwgc28gZmlsdGVyaW5nIGlzIG5ldmVyIHNhdmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZVBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIGRhdGEub1NlYXJjaC5zU2VhcmNoID0gXCJcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblN0YXRlU2F2ZVBhcmFtc1wiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIER1cmF0aW9uIGZvciB3aGljaCB0aGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb24gaXMgY29uc2lkZXJlZCB2YWxpZC4gQWZ0ZXIgdGhpcyBwZXJpb2RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGhhcyBlbGFwc2VkIHRoZSBzdGF0ZSB3aWxsIGJlIHJldHVybmVkIHRvIHRoZSBkZWZhdWx0LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVmFsdWUgaXMgZ2l2ZW4gaW4gc2Vjb25kcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA3MjAwIDxpPigyIGhvdXJzKTwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVEdXJhdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVEdXJhdGlvblwiOiA2MCo2MCoyNDsgLy8gMSBkYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaVN0YXRlRHVyYXRpb25cIjogNzIwMCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsIG5vdCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIGZvciB0aGUgZmlyc3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBhZ2UgZHJhdyAtIHJhdGhlciBpdCB3aWxsIHVzZSB0aGUgZGF0YSBhbHJlYWR5IG9uIHRoZSBwYWdlIChubyBzb3J0aW5nIGV0Y1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2lsbCBiZSBhcHBsaWVkIHRvIGl0KSwgdGh1cyBzYXZpbmcgb24gYW4gWEhSIGF0IGxvYWQgdGltZS4gYGRlZmVyTG9hZGluZ2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBkZWZlcnJlZCBsb2FkaW5nIGlzIHJlcXVpcmVkLCBidXQgaXQgaXMgYWxzbyB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0byB0ZWxsIERhdGFUYWJsZXMgaG93IG1hbnkgcmVjb3JkcyB0aGVyZSBhcmUgaW4gdGhlIGZ1bGwgdGFibGUgKGFsbG93aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBhbmQgcGFnaW5hdGlvbiB0byBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5KS4gSW4gdGhlIGNhc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHdoZXJlIGEgZmlsdGVyaW5nIGlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIG9uIGluaXRpYWwgbG9hZCwgdGhpcyBjYW4gYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluZGljYXRlZCBieSBnaXZpbmcgdGhlIHBhcmFtZXRlciBhcyBhbiBhcnJheSwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBudW1iZXIgb2YgcmVjb3JkcyBhdmFpbGFibGUgYWZ0ZXIgZmlsdGVyaW5nIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBudW1iZXIgb2YgcmVjb3JkcyB3aXRob3V0IGZpbHRlcmluZyAoYWxsb3dpbmcgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGVsZW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvIGJlIHNob3duIGNvcnJlY3RseSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50IHwgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyTG9hZGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gNTcgcmVjb3JkcyBhdmFpbGFibGUgaW4gdGhlIHRhYmxlLCBubyBmaWx0ZXJpbmcgYXBwbGllZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJkZWZlckxvYWRpbmdcIjogNTdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gNTcgcmVjb3JkcyBhZnRlciBmaWx0ZXJpbmcsIDEwMCB3aXRob3V0IGZpbHRlcmluZyAoYW4gaW5pdGlhbCBmaWx0ZXIgYXBwbGllZClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImFqYXhcIjogXCJzY3JpcHRzL3NlcnZlcl9wcm9jZXNzaW5nLnBocFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZGVmZXJMb2FkaW5nXCI6IFsgNTcsIDEwMCBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwic2VhcmNoXCI6IFwibXlfZmlsdGVyXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJpRGVmZXJMb2FkaW5nXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTnVtYmVyIG9mIHJvd3MgdG8gZGlzcGxheSBvbiBhIHNpbmdsZSBwYWdlIHdoZW4gdXNpbmcgcGFnaW5hdGlvbi4gSWZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZlYXR1cmUgZW5hYmxlZCAoYGxlbmd0aENoYW5nZWApIHRoZW4gdGhlIGVuZCB1c2VyIHdpbGwgYmUgYWJsZSB0byBvdmVycmlkZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhpcyB0byBhIGN1c3RvbSBzZXR0aW5nIHVzaW5nIGEgcG9wLXVwIG1lbnUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnZUxlbmd0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwicGFnZUxlbmd0aFwiOiA1MFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9IClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJpRGlzcGxheUxlbmd0aFwiOiAxMCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEZWZpbmUgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciBkYXRhIGRpc3BsYXkgd2hlbiB1c2luZyBEYXRhVGFibGVzIHdpdGhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBhZ2luYXRpb24uIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJhdGhlciB0aGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgcGFnZSBudW1iZXIsIHNvIGlmIHlvdSBoYXZlIDEwIHJlY29yZHMgcGVyIHBhZ2UgYW5kIHdhbnQgdG8gc3RhcnQgb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSB0aGlyZCBwYWdlLCBpdCBzaG91bGQgYmUgXCIyMFwiLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGlzcGxheVN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJkaXNwbGF5U3RhcnRcIjogMjBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaURpc3BsYXlTdGFydFwiOiAwLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgKHNvcnRpbmcsIHBhZ2luZyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFuZCBmaWx0ZXJpbmcpIGJ5IGFkZGluZyBhIGB0YWJpbmRleGAgYXR0cmlidXRlIHRvIHRoZSByZXF1aXJlZCBlbGVtZW50cy4gVGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWxsb3dzIHlvdSB0byB0YWIgdGhyb3VnaCB0aGUgY29udHJvbHMgYW5kIHByZXNzIHRoZSBlbnRlciBrZXkgdG8gYWN0aXZhdGUgdGhlbS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSB0YWJpbmRleCBpcyBkZWZhdWx0IDAsIG1lYW5pbmcgdGhhdCB0aGUgdGFiIGZvbGxvd3MgdGhlIGZsb3cgb2YgdGhlIGRvY3VtZW50LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogWW91IGNhbiBvdmVycnVsZSB0aGlzIHVzaW5nIHRoaXMgcGFyYW1ldGVyIGlmIHlvdSB3aXNoLiBVc2UgYSB2YWx1ZSBvZiAtMSB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGlzYWJsZSBidWlsdC1pbiBrZXlib2FyZCBuYXZpZ2F0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMudGFiSW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInRhYkluZGV4XCI6IDFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImlUYWJJbmRleFwiOiAwLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENsYXNzZXMgdGhhdCBEYXRhVGFibGVzIGFzc2lnbnMgdG8gdGhlIHZhcmlvdXMgY29tcG9uZW50cyBhbmQgZmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgaXQgYWRkcyB0byB0aGUgSFRNTCB0YWJsZS4gVGhpcyBhbGxvd3MgY2xhc3NlcyB0byBiZSBjb25maWd1cmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkdXJpbmcgaW5pdGlhbGlzYXRpb24gaW4gYWRkaXRpb24gdG8gdGhyb3VnaCB0aGUgc3RhdGljXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vU3RkQ2xhc3Nlc30gb2JqZWN0KS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNsYXNzZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvQ2xhc3Nlc1wiOiB7fSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBbGwgc3RyaW5ncyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbiB0aGUgdXNlciBpbnRlcmZhY2UgdGhhdCBpdCBjcmVhdGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhcmUgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCwgYWxsb3dpbmcgeW91IHRvIG1vZGlmaWVkIHRoZW0gaW5kaXZpZHVhbGx5IG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjb21wbGV0ZWx5IHJlcGxhY2UgdGhlbSBhbGwgYXMgcmVxdWlyZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9MYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogU3RyaW5ncyB0aGF0IGFyZSB1c2VkIGZvciBXQUktQVJJQSBsYWJlbHMgYW5kIGNvbnRyb2xzIG9ubHkgKHRoZXNlIGFyZSBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBhY3R1YWxseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBidXQgd2lsbCBiZSByZWFkIGJ5IHNjcmVlbnJlYWRlcnMsIGFuZCB0aHVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogbXVzdCBiZSBpbnRlcm5hdGlvbmFsaXNlZCBhcyB3ZWxsKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwib0FyaWFcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc29ydGVkIGFzY2VuZGluZyBieSBhY3RpdmluZyB0aGUgY29sdW1uIChjbGljayBvciByZXR1cm4gd2hlbiBmb2N1c2VkKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGlzIHByZWZpeGVkIHRvIHRoaXMgc3RyaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYS5zb3J0QXNjZW5kaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImFyaWFcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwic29ydEFzY2VuZGluZ1wiOiBcIiAtIGNsaWNrL3JldHVybiB0byBzb3J0IGFzY2VuZGluZ1wiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnRBc2NlbmRpbmdcIjogXCI6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1wiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHNvcnRlZCBkZXNjZW5kaW5nIGJ5IGFjdGl2aW5nIHRoZSBjb2x1bW4gKGNsaWNrIG9yIHJldHVybiB3aGVuIGZvY3VzZWQpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGNvbHVtbiBoZWFkZXIgaXMgcHJlZml4ZWQgdG8gdGhpcyBzdHJpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gYXNjZW5kaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5hcmlhLnNvcnREZXNjZW5kaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImFyaWFcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwic29ydERlc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBkZXNjZW5kaW5nXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydERlc2NlbmRpbmdcIjogXCI6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGRlc2NlbmRpbmdcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFBhZ2luYXRpb24gc3RyaW5nIHVzZWQgYnkgRGF0YVRhYmxlcyBmb3IgdGhlIGJ1aWx0LWluIHBhZ2luYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBjb250cm9sIHR5cGVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwib1BhZ2luYXRlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGJ1dHRvbiB0byB0YWtlIHRoZSB1c2VyIHRvIHRoZSBmaXJzdCBwYWdlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBGaXJzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUuZmlyc3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZmlyc3RcIjogXCJGaXJzdCBwYWdlXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzRmlyc3RcIjogXCJGaXJzdFwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUZXh0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnZnVsbF9udW1iZXJzJyB0eXBlIG9mIHBhZ2luYXRpb24gZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBidXR0b24gdG8gdGFrZSB0aGUgdXNlciB0byB0aGUgbGFzdCBwYWdlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBMYXN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5sYXN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImxhc3RcIjogXCJMYXN0IHBhZ2VcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNMYXN0XCI6IFwiTGFzdFwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUZXh0IHRvIHVzZSBmb3IgdGhlICduZXh0JyBwYWdpbmF0aW9uIGJ1dHRvbiAodG8gdGFrZSB0aGUgdXNlciB0byB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbmV4dCBwYWdlKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgTmV4dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUubmV4dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJuZXh0XCI6IFwiTmV4dCBwYWdlXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzTmV4dFwiOiBcIk5leHRcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGV4dCB0byB1c2UgZm9yIHRoZSAncHJldmlvdXMnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBwcmV2aW91cyBwYWdlKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgUHJldmlvdXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLnByZXZpb3VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInByZXZpb3VzXCI6IFwiUHJldmlvdXMgcGFnZVwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic1ByZXZpb3VzXCI6IFwiUHJldmlvdXNcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgc3RyaW5nIGlzIHNob3duIGluIHByZWZlcmVuY2UgdG8gYHplcm9SZWNvcmRzYCB3aGVuIHRoZSB0YWJsZSBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGVtcHR5IG9mIGRhdGEgKHJlZ2FyZGxlc3Mgb2YgZmlsdGVyaW5nKS4gTm90ZSB0aGF0IHRoaXMgaXMgYW4gb3B0aW9uYWxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBwYXJhbWV0ZXIgLSBpZiBpdCBpcyBub3QgZ2l2ZW4sIHRoZSB2YWx1ZSBvZiBgemVyb1JlY29yZHNgIHdpbGwgYmUgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGluc3RlYWQgKGVpdGhlciB0aGUgZGVmYXVsdCBvciBnaXZlbiB2YWx1ZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuZW1wdHlUYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJlbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0VtcHR5VGFibGVcIjogXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBzdHJpbmcgZ2l2ZXMgaW5mb3JtYXRpb24gdG8gdGhlIGVuZCB1c2VyIGFib3V0IHRoZSBpbmZvcm1hdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgaXMgY3VycmVudCBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLiBUaGUgZm9sbG93aW5nIHRva2VucyBjYW4gYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB1c2VkIGluIHRoZSBzdHJpbmcgYW5kIHdpbGwgYmUgZHluYW1pY2FsbHkgcmVwbGFjZWQgYXMgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZGlzcGxheSB1cGRhdGVzLiBUaGlzIHRva2VucyBjYW4gYmUgcGxhY2VkIGFueXdoZXJlIGluIHRoZSBzdHJpbmcsIG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogcmVtb3ZlZCBhcyBuZWVkZWQgYnkgdGhlIGxhbmd1YWdlIHJlcXVpcmVzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBgXFxfU1RBUlRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgZmlyc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGBcXF9FTkRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgbGFzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICogYFxcX1RPVEFMXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSBhZnRlciBmaWx0ZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGBcXF9NQVhcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIHdpdGhvdXQgZmlsdGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBgXFxfUEFHRVxcX2AgLSBDdXJyZW50IHBhZ2UgbnVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBgXFxfUEFHRVNcXF9gIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIG9mIGRhdGEgaW4gdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiaW5mb1wiOiBcIlNob3dpbmcgcGFnZSBfUEFHRV8gb2YgX1BBR0VTX1wiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzSW5mb1wiOiBcIlNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIERpc3BsYXkgaW5mb3JtYXRpb24gc3RyaW5nIGZvciB3aGVuIHRoZSB0YWJsZSBpcyBlbXB0eS4gVHlwaWNhbGx5IHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZvcm1hdCBvZiB0aGlzIHN0cmluZyBzaG91bGQgbWF0Y2ggYGluZm9gLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgU2hvd2luZyAwIHRvIDAgb2YgMCBlbnRyaWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvRW1wdHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiaW5mb0VtcHR5XCI6IFwiTm8gZW50cmllcyB0byBzaG93XCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNJbmZvRW1wdHlcIjogXCJTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFdoZW4gYSB1c2VyIGZpbHRlcnMgdGhlIGluZm9ybWF0aW9uIGluIGEgdGFibGUsIHRoaXMgc3RyaW5nIGlzIGFwcGVuZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdG8gdGhlIGluZm9ybWF0aW9uIChgaW5mb2ApIHRvIGdpdmUgYW4gaWRlYSBvZiBob3cgc3Ryb25nIHRoZSBmaWx0ZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBpcy4gVGhlIHZhcmlhYmxlIF9NQVhfIGlzIGR5bmFtaWNhbGx5IHVwZGF0ZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0ZpbHRlcmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImluZm9GaWx0ZXJlZFwiOiBcIiAtIGZpbHRlcmluZyBmcm9tIF9NQVhfIHJlY29yZHNcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0luZm9GaWx0ZXJlZFwiOiBcIihmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIGVudHJpZXMpXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiBjYW4gYmUgdXNlZnVsIHRvIGFwcGVuZCBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGUgaW5mbyBzdHJpbmcgYXQgdGltZXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYW5kIHRoaXMgdmFyaWFibGUgZG9lcyBleGFjdGx5IHRoYXQuIFRoaXMgaW5mb3JtYXRpb24gd2lsbCBiZSBhcHBlbmRlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBgaW5mb2AgKGBpbmZvRW1wdHlgIGFuZCBgaW5mb0ZpbHRlcmVkYCBpbiB3aGF0ZXZlciBjb21iaW5hdGlvbiB0aGV5IGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGJlaW5nIHVzZWQpIGF0IGFsbCB0aW1lcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9Qb3N0Rml4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImluZm9Qb3N0Rml4XCI6IFwiQWxsIHJlY29yZHMgc2hvd24gYXJlIGRlcml2ZWQgZnJvbSByZWFsIGluZm9ybWF0aW9uLlwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzSW5mb1Bvc3RGaXhcIjogXCJcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgZGVjaW1hbCBwbGFjZSBvcGVyYXRvciBpcyBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3RoZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBsYW5ndWFnZSBvcHRpb25zIHNpbmNlIERhdGFUYWJsZXMgZG9lc24ndCBvdXRwdXQgZmxvYXRpbmcgcG9pbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBudW1iZXJzLCBzbyBpdCB3b24ndCBldmVyIHVzZSB0aGlzIGZvciBkaXNwbGF5IG9mIGEgbnVtYmVyLiBSYXRoZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogd2hhdCB0aGlzIHBhcmFtZXRlciBkb2VzIGlzIG1vZGlmeSB0aGUgc29ydCBtZXRob2RzIG9mIHRoZSB0YWJsZSBzb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgbnVtYmVycyB3aGljaCBhcmUgaW4gYSBmb3JtYXQgd2hpY2ggaGFzIGEgY2hhcmFjdGVyIG90aGVyIHRoYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBhIHBlcmlvZCAoYC5gKSBhcyBhIGRlY2ltYWwgcGxhY2Ugd2lsbCBiZSBzb3J0ZWQgbnVtZXJpY2FsbHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgbnVtYmVycyB3aXRoIGRpZmZlcmVudCBkZWNpbWFsIHBsYWNlcyBjYW5ub3QgYmUgc2hvd24gaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc2FtZSB0YWJsZSBhbmQgc3RpbGwgYmUgc29ydGFibGUsIHRoZSB0YWJsZSBtdXN0IGJlIGNvbnNpc3RlbnQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogSG93ZXZlciwgbXVsdGlwbGUgZGlmZmVyZW50IHRhYmxlcyBvbiB0aGUgcGFnZSBjYW4gdXNlIGRpZmZlcmVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGRlY2ltYWwgcGxhY2UgY2hhcmFjdGVycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuZGVjaW1hbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJkZWNpbWFsXCI6IFwiLFwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0aG91c2FuZHNcIjogXCIuXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNEZWNpbWFsXCI6IFwiXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIGhhcyBhIGJ1aWxkIGluIG51bWJlciBmb3JtYXR0ZXIgKGBmb3JtYXROdW1iZXJgKSB3aGljaCBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHVzZWQgdG8gZm9ybWF0IGxhcmdlIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUgaW5mb3JtYXRpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQnkgZGVmYXVsdCBhIGNvbW1hIGlzIHVzZWQsIGJ1dCB0aGlzIGNhbiBiZSB0cml2aWFsbHkgY2hhbmdlZCB0byBhbnlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBjaGFyYWN0ZXIgeW91IHdpc2ggd2l0aCB0aGlzIHBhcmFtZXRlci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0ICxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnRob3VzYW5kc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0aG91c2FuZHNcIjogXCInXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNUaG91c2FuZHNcIjogXCIsXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZXRhaWwgdGhlIGFjdGlvbiB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgZHJvcCBkb3duIG1lbnUgZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHBhZ2luYXRpb24gbGVuZ3RoIG9wdGlvbiBpcyBjaGFuZ2VkLiBUaGUgJ19NRU5VXycgdmFyaWFibGUgaXMgcmVwbGFjZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB3aXRoIGEgZGVmYXVsdCBzZWxlY3QgbGlzdCBvZiAxMCwgMjUsIDUwIGFuZCAxMDAsIGFuZCBjYW4gYmUgcmVwbGFjZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB3aXRoIGEgY3VzdG9tIHNlbGVjdCBib3ggaWYgcmVxdWlyZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBTaG93IF9NRU5VXyBlbnRyaWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5sZW5ndGhNZW51XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBMYW5ndWFnZSBjaGFuZ2Ugb25seVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwibGVuZ3RoTWVudVwiOiBcIkRpc3BsYXkgX01FTlVfIHJlY29yZHNcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgLy8gTGFuZ3VhZ2UgYW5kIG9wdGlvbnMgY2hhbmdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJsZW5ndGhNZW51XCI6ICdEaXNwbGF5IDxzZWxlY3Q+JytcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMTBcIj4xMDwvb3B0aW9uPicrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjIwXCI+MjA8L29wdGlvbj4nK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIzMFwiPjMwPC9vcHRpb24+JytcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiNDBcIj40MDwvb3B0aW9uPicrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjUwXCI+NTA8L29wdGlvbj4nK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCItMVwiPkFsbDwvb3B0aW9uPicrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAnPC9zZWxlY3Q+IHJlY29yZHMnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzTGVuZ3RoTWVudVwiOiBcIlNob3cgX01FTlVfIGVudHJpZXNcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFdoZW4gdXNpbmcgQWpheCBzb3VyY2VkIGRhdGEgYW5kIGR1cmluZyB0aGUgZmlyc3QgZHJhdyB3aGVuIERhdGFUYWJsZXMgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBnYXRoZXJpbmcgdGhlIGRhdGEsIHRoaXMgbWVzc2FnZSBpcyBzaG93biBpbiBhbiBlbXB0eSByb3cgaW4gdGhlIHRhYmxlIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogaW5kaWNhdGUgdG8gdGhlIGVuZCB1c2VyIHRoZSB0aGUgZGF0YSBpcyBiZWluZyBsb2FkZWQuIE5vdGUgdGhhdCB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogcGFyYW1ldGVyIGlzIG5vdCB1c2VkIHdoZW4gbG9hZGluZyBkYXRhIGJ5IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIGp1c3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBBamF4IHNvdXJjZWQgZGF0YSB3aXRoIGNsaWVudC1zaWRlIHByb2Nlc3NpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBMb2FkaW5nLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5sb2FkaW5nUmVjb3Jkc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJsb2FkaW5nUmVjb3Jkc1wiOiBcIlBsZWFzZSB3YWl0IC0gbG9hZGluZy4uLlwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzTG9hZGluZ1JlY29yZHNcIjogXCJMb2FkaW5nLi4uXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUZXh0IHdoaWNoIGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWJsZSBpcyBwcm9jZXNzaW5nIGEgdXNlciBhY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAodXN1YWxseSBhIHNvcnQgY29tbWFuZCBvciBzaW1pbGFyKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFByb2Nlc3NpbmcuLi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnByb2Nlc3NpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicHJvY2Vzc2luZ1wiOiBcIkRhdGFUYWJsZXMgaXMgY3VycmVudGx5IGJ1c3lcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1Byb2Nlc3NpbmdcIjogXCJQcm9jZXNzaW5nLi4uXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZXRhaWxzIHRoZSBhY3Rpb25zIHRoYXQgd2lsbCBiZSB0YWtlbiB3aGVuIHRoZSB1c2VyIHR5cGVzIGludG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZmlsdGVyaW5nIGlucHV0IHRleHQgYm94LiBUaGUgdmFyaWFibGUgXCJfSU5QVVRfXCIsIGlmIHVzZWQgaW4gdGhlIHN0cmluZyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBpcyByZXBsYWNlZCB3aXRoIHRoZSBIVE1MIHRleHQgYm94IGZvciB0aGUgZmlsdGVyaW5nIGlucHV0IGFsbG93aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogY29udHJvbCBvdmVyIHdoZXJlIGl0IGFwcGVhcnMgaW4gdGhlIHN0cmluZy4gSWYgXCJfSU5QVVRfXCIgaXMgbm90IGdpdmVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlbiB0aGUgaW5wdXQgYm94IGlzIGFwcGVuZGVkIHRvIHRoZSBzdHJpbmcgYXV0b21hdGljYWxseS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFNlYXJjaDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnNlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgLy8gSW5wdXQgdGV4dCBib3ggd2lsbCBiZSBhcHBlbmRlZCBhdCB0aGUgZW5kIGF1dG9tYXRpY2FsbHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIkZpbHRlciByZWNvcmRzOlwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBTcGVjaWZ5IHdoZXJlIHRoZSBmaWx0ZXIgc2hvdWxkIGFwcGVhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwic2VhcmNoXCI6IFwiQXBwbHkgZmlsdGVyIF9JTlBVVF8gdG8gdGFibGVcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NlYXJjaFwiOiBcIlNlYXJjaDpcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEFzc2lnbiBhIGBwbGFjZWhvbGRlcmAgYXR0cmlidXRlIHRvIHRoZSBzZWFyY2ggYGlucHV0YCBlbGVtZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnNlYXJjaFBsYWNlaG9sZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU2VhcmNoUGxhY2Vob2xkZXJcIjogXCJcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEFsbCBvZiB0aGUgbGFuZ3VhZ2UgaW5mb3JtYXRpb24gY2FuIGJlIHN0b3JlZCBpbiBhIGZpbGUgb24gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2VydmVyLXNpZGUsIHdoaWNoIERhdGFUYWJsZXMgd2lsbCBsb29rIHVwIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHBhc3NlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBJdCBtdXN0IHN0b3JlIHRoZSBVUkwgb2YgdGhlIGxhbmd1YWdlIGZpbGUsIHdoaWNoIGlzIGluIGEgSlNPTiBmb3JtYXQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYW5kIHRoZSBvYmplY3QgaGFzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIG9MYW5ndWFnZSBvYmplY3QgaW4gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogaW5pdGlhbGlzZXIgb2JqZWN0IChpLmUuIHRoZSBhYm92ZSBwYXJhbWV0ZXJzKS4gUGxlYXNlIHJlZmVyIHRvIG9uZSBvZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBleGFtcGxlIGxhbmd1YWdlIGZpbGVzIHRvIHNlZSBob3cgdGhpcyB3b3JrcyBpbiBhY3Rpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UudXJsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInVybFwiOiBcImh0dHA6Ly93d3cuc3ByeW1lZGlhLmNvLnVrL2RhdGFUYWJsZXMvbGFuZy50eHRcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1VybFwiOiBcIlwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVGV4dCBzaG93biBpbnNpZGUgdGhlIHRhYmxlIHJlY29yZHMgd2hlbiB0aGUgaXMgbm8gaW5mb3JtYXRpb24gdG8gYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBkaXNwbGF5ZWQgYWZ0ZXIgZmlsdGVyaW5nLiBgZW1wdHlUYWJsZWAgaXMgc2hvd24gd2hlbiB0aGVyZSBpcyBzaW1wbHkgbm9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbmZvcm1hdGlvbiBpbiB0aGUgdGFibGUgYXQgYWxsIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS56ZXJvUmVjb3Jkc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ6ZXJvUmVjb3Jkc1wiOiBcIk5vIHJlY29yZHMgdG8gZGlzcGxheVwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzWmVyb1JlY29yZHNcIjogXCJObyBtYXRjaGluZyByZWNvcmRzIGZvdW5kXCJcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBoYXZlIGRlZmluZSB0aGUgZ2xvYmFsIGZpbHRlcmluZyBzdGF0ZSBhdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGVmaW5lZCwgYnV0IGFsbCBvdGhlciBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gV2hlbiBgcmVnZXhgIGlzIHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc2VhcmNoIHN0cmluZyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIHdoZW4gZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyB3aWxsIHVzZSBpdCdzIHNtYXJ0IGZpbHRlcmluZyBtZXRob2RzICh0byB3b3JkIG1hdGNoIGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbnkgcG9pbnQgaW4gdGhlIGRhdGEpLCB3aGVuIGZhbHNlIHRoaXMgd2lsbCBub3QgYmUgZG9uZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoXCI6IHtcInNlYXJjaFwiOiBcIkluaXRpYWwgc2VhcmNoXCJ9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9TZWFyY2hcIjogJC5leHRlbmQoe30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCksXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9vayBmb3IgdGhlIHByb3BlcnR5IGBkYXRhYCAob3IgYGFhRGF0YWAgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhIGZyb20gYW4gQWpheFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc291cmNlIG9yIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gdGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByb3BlcnR5IHRvIGJlIGNoYW5nZWQuIFlvdSBjYW4gdXNlIEphdmFzY3JpcHQgZG90dGVkIG9iamVjdCBub3RhdGlvbiB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgU2VydmVyLXNpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheERhdGFQcm9wXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNBamF4RGF0YVByb3BcIjogXCJkYXRhXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogWW91IGNhbiBpbnN0cnVjdCBEYXRhVGFibGVzIHRvIGxvYWQgZGF0YSBmcm9tIGFuIGV4dGVybmFsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzb3VyY2UgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgKHVzZSBhRGF0YSBpZiB5b3Ugd2FudCB0byBwYXNzIGRhdGEgaW4geW91XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbHJlYWR5IGhhdmUpLiBTaW1wbHkgcHJvdmlkZSBhIHVybCBhIEpTT04gb2JqZWN0IGNhbiBiZSBvYnRhaW5lZCBmcm9tLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgU2VydmVyLXNpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFNvdXJjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzQWpheFNvdXJjZVwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaW5pdGlhbGlzYXRpb24gdmFyaWFibGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGV4YWN0bHkgd2hlcmUgaW4gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBET00geW91IHdhbnQgRGF0YVRhYmxlcyB0byBpbmplY3QgdGhlIHZhcmlvdXMgY29udHJvbHMgaXQgYWRkcyB0byB0aGUgcGFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKGZvciBleGFtcGxlIHlvdSBtaWdodCB3YW50IHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzIGF0IHRoZSB0b3Agb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0YWJsZSkuIERJViBlbGVtZW50cyAod2l0aCBvciB3aXRob3V0IGEgY3VzdG9tIGNsYXNzKSBjYW4gYWxzbyBiZSBhZGRlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWlkIHN0eWxpbmcuIFRoZSBmb2xsb3cgc3ludGF4IGlzIHVzZWQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhbGxvd2VkOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgPHVsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICA8bGk+J2wnIC0gTGVuZ3RoIGNoYW5naW5nPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPidpJyAtIEluZm9ybWF0aW9uPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICA8L3VsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSBhbGxvd2VkOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgPHVsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICA8bGk+J0gnIC0galF1ZXJ5VUkgdGhlbWUgXCJoZWFkZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci10bCB1aS1jb3JuZXItdHIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICA8bGk+J0YnIC0galF1ZXJ5VUkgdGhlbWUgXCJmb290ZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1ibCB1aS1jb3JuZXItYnIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgPC91bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT5UaGUgZm9sbG93aW5nIHN5bnRheCBpcyBleHBlY3RlZDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7JyBhbmQgJyZndDsnIC0gZGl2IGVsZW1lbnRzPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7XCJjbGFzc1wiIGFuZCAnJmd0OycgLSBkaXYgd2l0aCBhIGNsYXNzPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7XCIjaWRcIiBhbmQgJyZndDsnIC0gZGl2IHdpdGggYW4gSUQ8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgPC91bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT5FeGFtcGxlczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7XCJ3cmFwcGVyXCJmbGlwdCZndDsnPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7bGYmbHQ7dCZndDtpcCZndDsnPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIDwvdWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPC91bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBsZnJ0aXAgPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyBmYWxzZSk8L2k+IDxiPm9yPC9iPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgPFwiSFwibGZyPnQ8XCJGXCJpcD4gPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyB0cnVlKTwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZG9tXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJkb21cIjogJyZsdDtcInRvcFwiaSZndDtydCZsdDtcImJvdHRvbVwiZmxwJmd0OyZsdDtcImNsZWFyXCImZ3Q7J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0RvbVwiOiBcImxmcnRpcFwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNlYXJjaCBkZWxheSBvcHRpb24uIFRoaXMgd2lsbCB0aHJvdHRsZSBmdWxsIHRhYmxlIHNlYXJjaGVzIHRoYXQgdXNlIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBwcm92aWRlZCBzZWFyY2ggaW5wdXQgZWxlbWVudCAoaXQgZG9lcyBub3QgZWZmZWN0IGNhbGxzIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBgZHQtYXBpIHNlYXJjaCgpYCwgcHJvdmlkaW5nIGEgZGVsYXkgYmVmb3JlIHRoZSBzZWFyY2ggaXMgbWFkZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRlZ2VyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hEZWxheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoRGVsYXlcIjogMjAwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNlYXJjaERlbGF5XCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBmZWF0dXJlcyBmb3VyIGRpZmZlcmVudCBidWlsdC1pbiBvcHRpb25zIGZvciB0aGUgYnV0dG9ucyB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGlzcGxheSBmb3IgcGFnaW5hdGlvbiBjb250cm9sOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYHNpbXBsZWAgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucyBvbmx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqICdzaW1wbGVfbnVtYmVyc2AgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGZ1bGxgIC0gJ0ZpcnN0JywgJ1ByZXZpb3VzJywgJ05leHQnIGFuZCAnTGFzdCcgYnV0dG9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgZnVsbF9udW1iZXJzYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnMsIHBsdXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgcGFnZSBudW1iZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGdXJ0aGVyIG1ldGhvZHMgY2FuIGJlIGFkZGVkIHVzaW5nIHtAbGluayBEYXRhVGFibGUuZXh0Lm9QYWdpbmF0aW9ufS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBzaW1wbGVfbnVtYmVyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdpbmdUeXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJwYWdpbmdUeXBlXCI6IFwiZnVsbF9udW1iZXJzXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1BhZ2luYXRpb25UeXBlXCI6IFwic2ltcGxlX251bWJlcnNcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIFdoZW4gYSB0YWJsZSBpcyB0b28gd2lkZSB0byBmaXQgaW50byBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjZXJ0YWluIGxheW91dCwgb3IgeW91IGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGUsIHlvdVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2FuIGVuYWJsZSB4LXNjcm9sbGluZyB0byBzaG93IHRoZSB0YWJsZSBpbiBhIHZpZXdwb3J0LCB3aGljaCBjYW4gYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNjcm9sbGVkLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBgdHJ1ZWAgd2hpY2ggd2lsbCBhbGxvdyB0aGUgdGFibGUgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNjcm9sbCBob3Jpem9udGFsbHkgd2hlbiBuZWVkZWQsIG9yIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsIG1lYXN1cmVtZW50KS4gU2V0dGluZyBhcyBzaW1wbHkgYHRydWVgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyByZWNvbW1lbmRlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFufHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxYXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxYXCI6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU2Nyb2xsWFwiOiBcIlwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gZm9yY2UgYSBEYXRhVGFibGUgdG8gdXNlIG1vcmUgd2lkdGggdGhhbiBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbWlnaHQgb3RoZXJ3aXNlIGRvIHdoZW4geC1zY3JvbGxpbmcgaXMgZW5hYmxlZC4gRm9yIGV4YW1wbGUgaWYgeW91IGhhdmUgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGFibGUgd2hpY2ggcmVxdWlyZXMgdG8gYmUgd2VsbCBzcGFjZWQsIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWZ1bCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFwib3Zlci1zaXppbmdcIiB0aGUgdGFibGUsIGFuZCB0aHVzIGZvcmNpbmcgc2Nyb2xsaW5nLiBUaGlzIHByb3BlcnR5IGNhbiBieVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbWVhc3VyZW1lbnQpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhJbm5lclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsWFwiOiBcIjEwMCVcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFhJbm5lclwiOiBcIjExMCVcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbFhJbm5lclwiOiBcIlwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyB3aWxsIGNvbnN0cmFpbiB0aGUgRGF0YVRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0byB0aGUgZ2l2ZW4gaGVpZ2h0LCBhbmQgZW5hYmxlIHNjcm9sbGluZyBmb3IgYW55IGRhdGEgd2hpY2ggb3ZlcmZsb3dzIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY3VycmVudCB2aWV3cG9ydC4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBwYWdpbmcgdG8gZGlzcGxheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYSBsb3Qgb2YgZGF0YSBpbiBhIHNtYWxsIGFyZWEgKGFsdGhvdWdoIHBhZ2luZyBhbmQgc2Nyb2xsaW5nIGNhbiBib3RoIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUpLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+Ymxhbmsgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTY3JvbGxZXCI6IFwiXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU2V0IHRoZSBIVFRQIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gbWFrZSB0aGUgQWpheCBjYWxsIGZvciBzZXJ2ZXItc2lkZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcHJvY2Vzc2luZyBvciBBamF4IHNvdXJjZWQgZGF0YS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBHRVRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgU2VydmVyLXNpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyTWV0aG9kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTZXJ2ZXJNZXRob2RcIjogXCJHRVRcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIG1ha2VzIHVzZSBvZiByZW5kZXJlcnMgd2hlbiBkaXNwbGF5aW5nIEhUTUwgZWxlbWVudHMgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhIHRhYmxlLiBUaGVzZSByZW5kZXJlcnMgY2FuIGJlIGFkZGVkIG9yIG1vZGlmaWVkIGJ5IHBsdWctaW5zIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBnZW5lcmF0ZSBzdWl0YWJsZSBtYXJrLXVwIGZvciBhIHNpdGUuIEZvciBleGFtcGxlIHRoZSBCb290c3RyYXBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGludGVncmF0aW9uIHBsdWctaW4gZm9yIERhdGFUYWJsZXMgdXNlcyBhIHBhZ2luZyBidXR0b24gcmVuZGVyZXIgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRpc3BsYXkgcGFnaW5hdGlvbiBidXR0b25zIGluIHRoZSBtYXJrLXVwIHJlcXVpcmVkIGJ5IEJvb3RzdHJhcC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGb3IgZnVydGhlciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVuZGVyZXJzIGF2YWlsYWJsZSBzZWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZS5leHQucmVuZGVyZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmd8b2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmVuZGVyZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwicmVuZGVyZXJcIjogbnVsbFxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwKERhdGFUYWJsZS5kZWZhdWx0cyk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAqIERldmVsb3BlciBub3RlIC0gU2VlIG5vdGUgaW4gbW9kZWwuZGVmYXVsdHMuanMgYWJvdXQgdGhlIHVzZSBvZiBIdW5nYXJpYW5cclxuXHQgICAgICAgICAgICAgICAgICogbm90YXRpb24gYW5kIGNhbWVsIGNhc2UuXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENvbHVtbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb24gdGltZS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERlZmluZSB3aGljaCBjb2x1bW4ocykgYW4gb3JkZXIgd2lsbCBvY2N1ciBvbiBmb3IgdGhpcyBjb2x1bW4uIFRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFsbG93cyBhIGNvbHVtbidzIG9yZGVyaW5nIHRvIHRha2UgbXVsdGlwbGUgY29sdW1ucyBpbnRvIGFjY291bnQgd2hlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZG9pbmcgYSBzb3J0IG9yIHVzZSB0aGUgZGF0YSBmcm9tIGEgZGlmZmVyZW50IGNvbHVtbi4gRm9yIGV4YW1wbGUgZmlyc3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG5hbWUgLyBsYXN0IG5hbWUgY29sdW1ucyBtYWtlIHNlbnNlIHRvIGRvIGEgbXVsdGktY29sdW1uIHNvcnQgb3ZlciB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHR3byBjb2x1bW5zLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5fGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGwgPGk+VGFrZXMgdGhlIHZhbHVlIG9mIHRoZSBjb2x1bW4gaW5kZXggYXV0b21hdGljYWxseTwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlckRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAwLCAxIF0sIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDEsIDAgXSwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IDIsIFwidGFyZ2V0c1wiOiBbIDIgXSB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDAsIDEgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiBbIDEsIDAgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiAyIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFEYXRhU29ydFwiOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJpRGF0YVNvcnRcIjogLTEsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogWW91IGNhbiBjb250cm9sIHRoZSBkZWZhdWx0IG9yZGVyaW5nIGRpcmVjdGlvbiwgYW5kIGV2ZW4gYWx0ZXIgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBiZWhhdmlvdXIgb2YgdGhlIHNvcnQgaGFuZGxlciAoaS5lLiBvbmx5IGFsbG93IGFzY2VuZGluZyBvcmRlcmluZyBldGMpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB1c2luZyB0aGlzIHBhcmFtZXRlci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFsgJ2FzYycsICdkZXNjJyBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJTZXF1ZW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImFzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiwgXCJhc2NcIiwgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAyIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMyBdIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImFzY1wiIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIsIFwiYXNjXCIsIFwiYXNjXCIgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYXNTb3J0aW5nXCI6IFsnYXNjJywgJ2Rlc2MnXSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb24gdGhlIGRhdGEgaW4gdGhpcyBjb2x1bW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5zZWFyY2hhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwic2VhcmNoYWJsZVwiOiBmYWxzZSwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwic2VhcmNoYWJsZVwiOiBmYWxzZSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF0gfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTZWFyY2hhYmxlXCI6IHRydWUsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgb3JkZXJpbmcgb24gdGhpcyBjb2x1bW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlcmFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyYWJsZVwiOiBmYWxzZSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF0gfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTb3J0YWJsZVwiOiB0cnVlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIHRoaXMgY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udmlzaWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInZpc2libGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInZpc2libGVcIjogZmFsc2UgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiVmlzaWJsZVwiOiB0cnVlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERldmVsb3BlciBkZWZpbmFibGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBjZWxsIGlzIGNyZWF0ZWQgKEFqYXggc291cmNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWxsb3dpbmcgeW91IHRvIG1vZGlmeSB0aGUgRE9NIGVsZW1lbnQgKGFkZCBiYWNrZ3JvdW5kIGNvbG91ciBmb3IgZXhhbXBsZSkgd2hlbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGVsZW1lbnQgaXMgYXZhaWxhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtlbGVtZW50fSB0ZCBUaGUgVEQgbm9kZSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0geyp9IGNlbGxEYXRhIFRoZSBEYXRhIGZvciB0aGUgY2VsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSByb3dEYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHJvdyBUaGUgcm93IGluZGV4IGZvciB0aGUgYW9EYXRhIGRhdGEgc3RvcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sIFRoZSBjb2x1bW4gaW5kZXggZm9yIGFvQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNyZWF0ZWRDZWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWzNdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJjcmVhdGVkQ2VsbFwiOiBmdW5jdGlvbiAodGQsIGNlbGxEYXRhLCByb3dEYXRhLCByb3csIGNvbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBpZiAoIGNlbGxEYXRhID09IFwiMS43XCIgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgJCh0ZCkuY3NzKCdjb2xvcicsICdibHVlJylcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH0gXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVwbGFjZWQgYnkgYGRhdGFgIGluIERhdGFUYWJsZXMgdG8gZW5zdXJlIG5hbWluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29uc2lzdGVuY3kuIGBkYXRhUHJvcGAgY2FuIHN0aWxsIGJlIHVzZWQsIGFzIHRoZXJlIGlzIGJhY2t3YXJkc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29tcGF0aWJpbGl0eSBpbiBEYXRhVGFibGVzIGZvciB0aGlzIG9wdGlvbiwgYnV0IGl0IGlzIHN0cm9uZ2x5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgYGRhdGFgIGluIHByZWZlcmVuY2UgdG8gYGRhdGFQcm9wYC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRhdGFQcm9wXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIHJlYWQgZGF0YSBmcm9tIGFueSBkYXRhIHNvdXJjZSBwcm9wZXJ0eSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluY2x1ZGluZyBkZWVwbHkgbmVzdGVkIG9iamVjdHMgLyBwcm9wZXJ0aWVzLiBgZGF0YWAgY2FuIGJlIGdpdmVuIGluIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB3aGljaCBlZmZlY3QgaXRzIGJlaGF2aW91cjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICByZXR1cm5lZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LiBOb3RlIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gbm90YXRpb24gaXMgcmVjb21tZW5kZWQgZm9yIHVzZSBpbiBgcmVuZGVyYCByYXRoZXIgdGhhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBgZGF0YWAgYXMgaXQgaXMgbXVjaCBzaW1wbGVyIHRvIHVzZSBhcyBhIHJlbmRlcmVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgbnVsbGAgLSB1c2UgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IHJhdGhlciB0aGFuIHBsdWNraW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGRhdGEgZGlyZWN0bHkgZnJvbSBpdC4gVGhpcyBhY3Rpb24gaGFzIGVmZmVjdHMgb24gdHdvIG90aGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAqIGBkZWZhdWx0Q29udGVudGAgLSBXaGVuIG51bGwgaXMgZ2l2ZW4gYXMgdGhlIGBkYXRhYCBvcHRpb24gYW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgdmFsdWUgZGVmaW5lZCBieVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBgZGVmYXVsdENvbnRlbnRgIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGNlbGwuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAqIGByZW5kZXJgIC0gV2hlbiBudWxsIGlzIHVzZWQgZm9yIHRoZSBgZGF0YWAgb3B0aW9uIGFuZCB0aGUgYHJlbmRlcmBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb3B0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHdob2xlIGRhdGEgc291cmNlIGZvciB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgcm93IGlzIHVzZWQgZm9yIHRoZSByZW5kZXJlci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgbmVlZHMgdG8gc2V0IG9yIGdldCB0aGUgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFRoZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBQYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAqIGB7YXJyYXl8b2JqZWN0fWAgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICogYHtzdHJpbmd9YCBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdzZXQnIHdoZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBzZXR0aW5nIGRhdGEgb3IgJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnLCAnc29ydCcgb3IgdW5kZWZpbmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgd2hlbiBnYXRoZXJpbmcgZGF0YS4gTm90ZSB0aGF0IHdoZW4gYHVuZGVmaW5lZGAgaXMgZ2l2ZW4gZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHR5cGUgRGF0YVRhYmxlcyBleHBlY3RzIHRvIGdldCB0aGUgcmF3IGRhdGEgZm9yIHRoZSBvYmplY3QgYmFjazxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgKiBgeyp9YCBEYXRhIHRvIHNldCB3aGVuIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzICdzZXQnLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBSZXR1cm46XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyBub3QgcmVxdWlyZWQgd2hlbiAnc2V0JyBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHRoZSB0eXBlIG9mIGNhbGwsIGJ1dCBvdGhlcndpc2UgdGhlIHJldHVybiBpcyB3aGF0IHdpbGwgYmUgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGZvciB0aGUgZGF0YSByZXF1ZXN0ZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IGBkYXRhYCBpcyBhIGdldHRlciBhbmQgc2V0dGVyIG9wdGlvbi4gSWYgeW91IGp1c3QgcmVxdWlyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZm9ybWF0dGluZyBvZiBkYXRhIGZvciBvdXRwdXQsIHlvdSB3aWxsIGxpa2VseSB3YW50IHRvIHVzZSBgcmVuZGVyYCB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgc2ltcGx5IGEgZ2V0dGVyIGFuZCB0aHVzIHNpbXBsZXIgdG8gdXNlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCBwcmlvciB0byBEYXRhVGFibGVzIDEuOS4yIGBkYXRhYCB3YXMgY2FsbGVkIGBtRGF0YVByb3BgLiBUaGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG5hbWUgY2hhbmdlIHJlZmxlY3RzIHRoZSBmbGV4aWJpbGl0eSBvZiB0aGlzIHByb3BlcnR5IGFuZCBpcyBjb25zaXN0ZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aXRoIHRoZSBuYW1pbmcgb2YgbVJlbmRlci4gSWYgJ21EYXRhUHJvcCcgaXMgZ2l2ZW4sIHRoZW4gaXQgd2lsbCBzdGlsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYmUgdXNlZCBieSBEYXRhVGFibGVzLCBhcyBpdCBhdXRvbWF0aWNhbGx5IG1hcHMgdGhlIG9sZCBuYW1lIHRvIHRoZSBuZXdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlmIHJlcXVpcmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIDxpPlVzZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgY29sdW1uIGluZGV4PC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gUmVhZCB0YWJsZSBkYXRhIGZyb20gb2JqZWN0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gSlNPTiBzdHJ1Y3R1cmUgZm9yIGVhY2ggcm93OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgIFwiYnJvd3NlclwiOiB7dmFsdWV9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHt2YWx1ZX0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgIFwidmVyc2lvblwiOiB7dmFsdWV9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICAgICBcImdyYWRlXCI6IHt2YWx1ZX1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiYWpheFNvdXJjZVwiOiBcInNvdXJjZXMvb2JqZWN0cy50eHRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZ3JhZGVcIiB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBSZWFkIGluZm9ybWF0aW9uIGZyb20gZGVlcGx5IG5lc3RlZCBvYmplY3RzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBKU09OIHN0cnVjdHVyZSBmb3IgZWFjaCByb3c6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJicm93c2VyXCI6IHt2YWx1ZX0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgIFwicGxhdGZvcm1cIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICAgICAgICBcImlubmVyXCI6IHt2YWx1ZX1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJkZXRhaWxzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgICAge3ZhbHVlfSwge3ZhbHVlfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtLmlubmVyXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm0uZGV0YWlscy4wXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm0uZGV0YWlscy4xXCIgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGRhdGFgIGFzIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBkaWZmZXJlbnQgaW5mb3JtYXRpb24gZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBzb3J0aW5nLCBmaWx0ZXJpbmcgYW5kIGRpc3BsYXkuIEluIHRoaXMgY2FzZSwgY3VycmVuY3kgKHByaWNlKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIHNvdXJjZSwgdHlwZSwgdmFsICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NldCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2UgPSB2YWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvbXB1dGVkIGRpc2xheSBhbmQgZmlsdGVyIHZhbHVlcyBmb3IgZWZmaWNpZW5jeVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9kaXNwbGF5ID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9maWx0ZXIgID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpK1wiIFwiK3ZhbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Rpc3BsYXknKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9kaXNwbGF5O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmaWx0ZXInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9maWx0ZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgLy8gJ3NvcnQnLCAndHlwZScgYW5kIHVuZGVmaW5lZCBhbGwganVzdCB1c2UgdGhlIGludGVnZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgZGVmYXVsdCBjb250ZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiQ2xpY2sgdG8gZWRpdFwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfSBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGFycmF5IG5vdGF0aW9uIC0gb3V0cHV0dGluZyBhIGxpc3QgZnJvbSBhbiBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBcIm5hbWVbLCBdXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJtRGF0YVwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgcHJvcGVydHkgaXMgdGhlIHJlbmRlcmluZyBwYXJ0bmVyIHRvIGBkYXRhYCBhbmQgaXQgaXMgc3VnZ2VzdGVkIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHdoZW4geW91IHdhbnQgdG8gbWFuaXB1bGF0ZSBkYXRhIGZvciBkaXNwbGF5IChpbmNsdWRpbmcgZmlsdGVyaW5nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc29ydGluZyBldGMpIHdpdGhvdXQgYWx0ZXJpbmcgdGhlIHVuZGVybHlpbmcgZGF0YSBmb3IgdGhlIHRhYmxlLCB1c2UgdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcHJvcGVydHkuIGByZW5kZXJgIGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIHRoZSB0aGUgcmVhZCBvbmx5IGNvbXBhbmlvbiB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYGRhdGFgIHdoaWNoIGlzIHJlYWQgLyB3cml0ZSAodGhlbiBhcyBzdWNoIG1vcmUgY29tcGxleCkuIExpa2UgYGRhdGFgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIG9wdGlvbiBjYW4gYmUgZ2l2ZW4gaW4gYSBudW1iZXIgb2YgZGlmZmVyZW50IHdheXMgdG8gZWZmZWN0IGl0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYmVoYXZpb3VyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGludGVnZXJgIC0gdHJlYXRlZCBhcyBhbiBhcnJheSBpbmRleCBmb3IgdGhlIGRhdGEgc291cmNlLiBUaGlzIGlzIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgc3RyaW5nYCAtIHJlYWQgYW4gb2JqZWN0IHByb3BlcnR5IGZyb20gdGhlIGRhdGEgc291cmNlLiBUaGVyZSBhcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgdGhyZWUgJ3NwZWNpYWwnIG9wdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgc3RyaW5nIHRvIGFsdGVyIGhvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAqIGAuYCAtIERvdHRlZCBKYXZhc2NyaXB0IG5vdGF0aW9uLiBKdXN0IGFzIHlvdSB1c2UgYSBgLmAgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgSmF2YXNjcmlwdCB0byByZWFkIGZyb20gbmVzdGVkIG9iamVjdHMsIHNvIHRvIGNhbiB0aGUgb3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYGJyb3dzZXIubmFtZWAuIElmIHlvdXIgb2JqZWN0IHBhcmFtZXRlciBuYW1lIGNvbnRhaW5zIGEgcGVyaW9kLCB1c2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYFxcXFxgIHRvIGVzY2FwZSBpdCAtIGkuZS4gYGZpcnN0XFxcXC5uYW1lYC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBmcm9tIGFuZCBhcnJheSBzb3VyY2UsIGpvaW5pbmcgdGhlIGRhdGEgd2l0aCB0aGUgY2hhcmFjdGVycyBwcm92aWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBiZXR3ZWVuIHRoZSB0d28gYnJhY2tldHMuIEZvciBleGFtcGxlOiBgbmFtZVssIF1gIHdvdWxkIHByb3ZpZGUgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYXJlIHByb3ZpZGVkIGJldHdlZW4gdGhlIGJyYWNrZXRzLCB0aGUgb3JpZ2luYWwgYXJyYXkgc291cmNlIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHJldHVybmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBleGVjdXRlIGEgZnVuY3Rpb24gb2YgdGhlIG5hbWUgZ2l2ZW4uIEZvciBleGFtcGxlOiBgYnJvd3NlcigpYCBmb3IgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBzaW1wbGUgZnVuY3Rpb24gb24gdGhlIGRhdGEgc291cmNlLCBgYnJvd3Nlci52ZXJzaW9uKClgIGZvciBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb2JqZWN0IHByb3BlcnR5IGlmIHRoZSBmdW5jdGlvbiBjYWxsZWQgcmV0dXJucyBhbiBvYmplY3QuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBvYmplY3RgIC0gdXNlIGRpZmZlcmVudCBkYXRhIGZvciB0aGUgZGlmZmVyZW50IGRhdGEgdHlwZXMgcmVxdWVzdGVkIGJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIERhdGFUYWJsZXMgKCdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJyBvciAnc29ydCcpLiBUaGUgcHJvcGVydHkgbmFtZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgb2YgdGhlIG9iamVjdCBpcyB0aGUgZGF0YSB0eXBlIHRoZSBwcm9wZXJ0eSByZWZlcnMgdG8gYW5kIHRoZSB2YWx1ZSBjYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgZGVmaW5lZCB1c2luZyBhbiBpbnRlZ2VyLCBzdHJpbmcgb3IgZnVuY3Rpb24gdXNpbmcgdGhlIHNhbWUgcnVsZXMgYXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgYHJlbmRlcmAgbm9ybWFsbHkgZG9lcy4gTm90ZSB0aGF0IGFuIGBfYCBvcHRpb24gX211c3RfIGJlIHNwZWNpZmllZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgVGhpcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgeW91IGhhdmVuJ3Qgc3BlY2lmaWVkIGEgdmFsdWUgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIHRoZSBkYXRhIHR5cGUgcmVxdWVzdGVkIGJ5IERhdGFUYWJsZXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgdGFrZXMgdGhyZWUgcGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICogUGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKGJhc2VkIG9uIGBkYXRhYClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgKiB7c3RyaW5nfSBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdmaWx0ZXInLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0Jy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgKiB7YXJyYXl8b2JqZWN0fSBUaGUgZnVsbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyAobm90IGJhc2VkIG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgYGRhdGFgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBSZXR1cm46XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyB3aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgZGF0YSByZXF1ZXN0ZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ3xpbnR8ZnVuY3Rpb258b2JqZWN0fG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIFVzZSB0aGUgZGF0YSBzb3VyY2UgdmFsdWUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ucmVuZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIENyZWF0ZSBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IGZyb20gYW4gYXJyYXkgb2Ygb2JqZWN0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiYWpheFNvdXJjZVwiOiBcInNvdXJjZXMvZGVlcC50eHRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkYXRhXCI6IFwicGxhdGZvcm1cIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJyZW5kZXJcIjogXCJbLCBdLm5hbWVcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gRXhlY3V0ZSBhIGZ1bmN0aW9uIHRvIG9idGFpbiBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJyZW5kZXJcIjogXCJicm93c2VyTmFtZSgpXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gQXMgYW4gb2JqZWN0LCBleHRyYWN0aW5nIGRpZmZlcmVudCBkYXRhIGZvciB0aGUgZGlmZmVyZW50IHR5cGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBUaGlzIHdvdWxkIGJlIHVzZWQgd2l0aCBhIGRhdGEgc291cmNlIHN1Y2ggYXM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgIHsgXCJwaG9uZVwiOiA1NTUyMzY4LCBcInBob25lX2ZpbHRlclwiOiBcIjU1NTIzNjggNTU1LTIzNjhcIiwgXCJwaG9uZV9kaXNwbGF5XCI6IFwiNTU1LTIzNjhcIiB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBIZXJlIHRoZSBgcGhvbmVgIGludGVnZXIgaXMgdXNlZCBmb3Igc29ydGluZyBhbmQgdHlwZSBkZXRlY3Rpb24sIHdoaWxlIGBwaG9uZV9maWx0ZXJgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAod2hpY2ggaGFzIGJvdGggZm9ybXMpIGlzIHVzZWQgZm9yIGZpbHRlcmluZyBmb3IgaWYgYSB1c2VyIGlucHV0cyBlaXRoZXIgZm9ybWF0LCB3aGlsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gdGhlIGZvcm1hdHRlZCBwaG9uZSBudW1iZXIgaXMgdGhlIG9uZSB0aGF0IGlzIHNob3duIGluIHRoZSB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCwgLy8gVXNlIHRoZSBmdWxsIGRhdGEgc291cmNlIG9iamVjdCBmb3IgdGhlIHJlbmRlcmVyJ3Mgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInJlbmRlclwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiX1wiOiBcInBob25lXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZmlsdGVyXCI6IFwicGhvbmVfZmlsdGVyXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcInBob25lX2Rpc3BsYXlcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH0gXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2UgYXMgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBsaW5rIGZyb20gdGhlIGRhdGEgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJkYXRhXCI6IFwiZG93bmxvYWRfbGlua1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJyZW5kZXJcIjogZnVuY3Rpb24gKCBkYXRhLCB0eXBlLCBmdWxsICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICByZXR1cm4gJzxhIGhyZWY9XCInK2RhdGErJ1wiPkRvd25sb2FkPC9hPic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfSBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJtUmVuZGVyXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2hhbmdlIHRoZSBjZWxsIHR5cGUgY3JlYXRlZCBmb3IgdGhlIGNvbHVtbiAtIGVpdGhlciBURCBjZWxscyBvciBUSCBjZWxscy4gVGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2FuIGJlIHVzZWZ1bCBhcyBUSCBjZWxscyBoYXZlIHNlbWFudGljIG1lYW5pbmcgaW4gdGhlIHRhYmxlIGJvZHksIGFsbG93aW5nIHRoZW1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvIGFjdCBhcyBhIGhlYWRlciBmb3IgYSByb3cgKHlvdSBtYXkgd2lzaCB0byBhZGQgc2NvcGU9J3JvdycgdG8gdGhlIFRIIGVsZW1lbnRzKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB0ZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNlbGxUeXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIE1ha2UgdGhlIGZpcnN0IGNvbHVtbiB1c2UgVEggY2VsbHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImNlbGxUeXBlXCI6IFwidGhcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH0gXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0NlbGxUeXBlXCI6IFwidGRcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDbGFzcyB0byBnaXZlIHRvIGVhY2ggY2VsbCBpbiB0aGlzIGNvbHVtbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY2xhc3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcImNsYXNzXCI6IFwibXlfY2xhc3NcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNDbGFzc1wiOiBcIlwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEdlbmVyYWxseSB5b3Ugc2hvdWxkbid0IG5lZWQgdGhpcyFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8aT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jb250ZW50UGFkZGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImNvbnRlbnRQYWRkaW5nXCI6IFwibW1tXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzQ29udGVudFBhZGRpbmdcIjogXCJcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBgZGF0YWBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIHNldCB0byBudWxsLCBvciBiZWNhdXNlIHRoZSBkYXRhIHNvdXJjZSBpdHNlbGYgaXMgbnVsbCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRlZmF1bHRDb250ZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInRhcmdldHNcIjogWyAtMSBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFcIjogbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBpbiBEYXRhVGFibGVzJyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLiBJdCBjYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJlIGV4Y2VwdGlvbmFsbHkgdXNlZnVsIHRvIGtub3cgd2hhdCBjb2x1bW5zIGFyZSBiZWluZyBkaXNwbGF5ZWQgb24gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjbGllbnQgc2lkZSwgYW5kIHRvIG1hcCB0aGVzZSB0byBkYXRhYmFzZSBmaWVsZHMuIFdoZW4gZGVmaW5lZCwgdGhlIG5hbWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbHNvIGFsbG93IERhdGFUYWJsZXMgdG8gcmVvcmRlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgaWYgaXQgY29tZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJhY2sgaW4gYW4gdW5leHBlY3RlZCBvcmRlciAoaS5lLiBpZiB5b3Ugc3dpdGNoIHlvdXIgY29sdW1ucyBhcm91bmQgb24gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjbGllbnQtc2lkZSwgeW91ciBzZXJ2ZXItc2lkZSBjb2RlIGRvZXMgbm90IGFsc28gbmVlZCB1cGRhdGluZykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm5hbWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIsIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJwbGF0Zm9ybVwiLCBcInRhcmdldHNcIjogWyAyIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiLCBcInRhcmdldHNcIjogWyAzIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImVuZ2luZVwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImJyb3dzZXJcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJwbGF0Zm9ybVwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlcnNpb25cIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJncmFkZVwiIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzTmFtZVwiOiBcIlwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERlZmluZXMgYSBkYXRhIHNvdXJjZSB0eXBlIGZvciB0aGUgb3JkZXJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVhZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcmVhbC10aW1lIGluZm9ybWF0aW9uIGZyb20gdGhlIHRhYmxlICh1cGRhdGluZyB0aGUgaW50ZXJuYWxseSBjYWNoZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHZlcnNpb24pIHByaW9yIHRvIG9yZGVyaW5nLiBUaGlzIGFsbG93cyBvcmRlcmluZyB0byBvY2N1ciBvbiB1c2VyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlZGl0YWJsZSBlbGVtZW50cyBzdWNoIGFzIGZvcm0gaW5wdXRzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHN0ZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyRGF0YVR5cGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiwgXCJ0YXJnZXRzXCI6IFsgMiwgMyBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidHlwZVwiOiBcIm51bWVyaWNcIiwgXCJ0YXJnZXRzXCI6IFsgMyBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1zZWxlY3RcIiwgXCJ0YXJnZXRzXCI6IFsgNCBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1jaGVja2JveFwiLCBcInRhcmdldHNcIjogWyA1IF0gfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIsIFwidHlwZVwiOiBcIm51bWVyaWNcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLWNoZWNrYm94XCIgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0RGF0YVR5cGVcIjogXCJzdGRcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBjb2x1bW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5EZXJpdmVkIGZyb20gdGhlICdUSCcgdmFsdWUgZm9yIHRoaXMgY29sdW1uIGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgb3JpZ2luYWwgSFRNTCB0YWJsZS48L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udGl0bGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1RpdGxlXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIHR5cGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGhvdyB0aGUgZGF0YSBmb3IgdGhpcyBjb2x1bW4gd2lsbCBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3JkZXJlZC4gRm91ciB0eXBlcyAoc3RyaW5nLCBudW1lcmljLCBkYXRlIGFuZCBodG1sICh3aGljaCB3aWxsIHN0cmlwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBIVE1MIHRhZ3MgYmVmb3JlIG9yZGVyaW5nKSkgYXJlIGN1cnJlbnRseSBhdmFpbGFibGUuIE5vdGUgdGhhdCBvbmx5IGRhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZvcm1hdHMgdW5kZXJzdG9vZCBieSBKYXZhc2NyaXB0J3MgRGF0ZSgpIG9iamVjdCB3aWxsIGJlIGFjY2VwdGVkIGFzIHR5cGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRhdGUuIEZvciBleGFtcGxlOiBcIk1hciAyNiwgMjAwOCA1OjAzIFBNXCIuIE1heSB0YWtlIHRoZSB2YWx1ZXM6ICdzdHJpbmcnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogJ251bWVyaWMnLCAnZGF0ZScgb3IgJ2h0bWwnIChieSBkZWZhdWx0KS4gRnVydGhlciB0eXBlcyBjYW4gYmUgYWRkaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aHJvdWdoIHBsdWctaW5zLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGwgPGk+QXV0by1kZXRlY3RlZCBmcm9tIHJhdyBkYXRhPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnR5cGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiaHRtbFwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0eXBlXCI6IFwiaHRtbFwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1R5cGVcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEZWZpbmluZyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiwgdGhpcyBwYXJhbWV0ZXIgbWF5IHRha2UgYW55IENTUyB2YWx1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKDNlbSwgMjBweCBldGMpLiBEYXRhVGFibGVzIGFwcGxpZXMgJ3NtYXJ0JyB3aWR0aHMgdG8gY29sdW1ucyB3aGljaCBoYXZlIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYmVlbiBnaXZlbiBhIHNwZWNpZmljIHdpZHRoIHRocm91Z2ggdGhpcyBpbnRlcmZhY2UgZW5zdXJpbmcgdGhhdCB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlbWFpbnMgcmVhZGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvbWF0aWM8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ud2lkdGhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ3aWR0aFwiOiBcIjIwJVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ3aWR0aFwiOiBcIjIwJVwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1dpZHRoXCI6IG51bGxcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9mbkh1bmdhcmlhbk1hcChEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uKTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IC0gdGhpcyBob2xkcyBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZCBmb3IgYVxyXG5cdCAgICAgICAgICAgICAgICAgKiBnaXZlbiB0YWJsZSwgaW5jbHVkaW5nIGNvbmZpZ3VyYXRpb24sIGRhdGEgYW5kIGN1cnJlbnQgYXBwbGljYXRpb24gb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIHRhYmxlIG9wdGlvbnMuIERhdGFUYWJsZXMgZG9lcyBub3QgaGF2ZSBhIHNpbmdsZSBpbnN0YW5jZSBmb3IgZWFjaCBEYXRhVGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogd2l0aCB0aGUgc2V0dGluZ3MgYXR0YWNoZWQgdG8gdGhhdCBpbnN0YW5jZSwgYnV0IHJhdGhlciBpbnN0YW5jZXMgb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZSBcImNsYXNzXCIgYXJlIGNyZWF0ZWQgb24tdGhlLWZseSBhcyBuZWVkZWQgKHR5cGljYWxseSBieSBhXHJcblx0ICAgICAgICAgICAgICAgICAqICQoKS5kYXRhVGFibGUoKSBjYWxsKSBhbmQgdGhlIHNldHRpbmdzIG9iamVjdCBpcyB0aGVuIGFwcGxpZWQgdG8gdGhhdFxyXG5cdCAgICAgICAgICAgICAgICAgKiBpbnN0YW5jZS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIHJlbGF0ZWQgdG8ge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30gYnV0IHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICogb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy4gSXQgc2hvdWxkXHJcblx0ICAgICAgICAgICAgICAgICAqIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZCBiZSBkb25lXHJcblx0ICAgICAgICAgICAgICAgICAqIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAdG9kbyBSZWFsbHkgc2hvdWxkIGF0dGFjaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IHRvIGluZGl2aWR1YWwgaW5zdGFuY2VzIHNvIHdlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGRvbid0IG5lZWQgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb24gZWFjaCAkKCkuZGF0YVRhYmxlKCkgY2FsbCAoaWYgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIHRhYmxlIGFscmVhZHkgZXhpc3RzKS4gSXQgd291bGQgYWxzbyBzYXZlIHBhc3Npbmcgb1NldHRpbmdzIGFyb3VuZCBhbmRcclxuXHQgICAgICAgICAgICAgICAgICogICAgaW50byBldmVyeSBzaW5nbGUgZnVuY3Rpb24uIEhvd2V2ZXIsIHRoaXMgaXMgYSB2ZXJ5IHNpZ25pZmljYW50XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGFyY2hpdGVjdHVyZSBjaGFuZ2UgZm9yIERhdGFUYWJsZXMgYW5kIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBicmVha1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGluc3RhbGxhdGlvbnMuIFRoaXMgaXMgc29tZXRoaW5nIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICogICAgd2lsbCBiZSBkb25lIGluIDIuMC5cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQcmltYXJ5IGZlYXR1cmVzIG9mIERhdGFUYWJsZXMgYW5kIHRoZWlyIGVuYWJsZW1lbnQgc3RhdGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9GZWF0dXJlc1wiOiB7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEZsYWcgdG8gc2F5IGlmIERhdGFUYWJsZXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIGNhbGN1bGF0ZSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBvcHRpbXVtIHRhYmxlIGFuZCBjb2x1bW5zIHdpZHRocyAodHJ1ZSkgb3Igbm90IChmYWxzZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJiQXV0b1dpZHRoXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIERlbGF5IHRoZSBjcmVhdGlvbiBvZiBUUiBhbmQgVEQgZWxlbWVudHMgdW50aWwgdGhleSBhcmUgYWN0dWFsbHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBuZWVkZWQgYnkgYSBkcml2ZW4gcGFnZSBkcmF3LiBUaGlzIGNhbiBnaXZlIGEgc2lnbmlmaWNhbnQgc3BlZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbmNyZWFzZSBmb3IgQWpheCBzb3VyY2UgYW5kIEphdmFzY3JpcHQgc291cmNlIGRhdGEsIGJ1dCBtYWtlcyBub1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGRpZmZlcmVuY2UgYXQgYWxsIGZybyBET00gYW5kIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYkRlZmVyUmVuZGVyXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSBmaWx0ZXJpbmcgb24gdGhlIHRhYmxlIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGlzIG5vIGZpbHRlcmluZyBhdCBhbGwgb24gdGhlIHRhYmxlLCBpbmNsdWRpbmcgZm5GaWx0ZXIuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVG8ganVzdCByZW1vdmUgdGhlIGZpbHRlcmluZyBpbnB1dCB1c2Ugc0RvbSBhbmQgcmVtb3ZlIHRoZSAnZicgb3B0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYkZpbHRlclwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUYWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50ICh0aGUgJ1Nob3dpbmcgeCBvZiB5IHJlY29yZHMnIGRpdikgZW5hYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZmxhZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJJbmZvXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFByZXNlbnQgYSB1c2VyIGNvbnRyb2wgYWxsb3dpbmcgdGhlIGVuZCB1c2VyIHRvIGNoYW5nZSB0aGUgcGFnZSBzaXplXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogd2hlbiBwYWdpbmF0aW9uIGlzIGVuYWJsZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJiTGVuZ3RoQ2hhbmdlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFBhZ2luYXRpb24gZW5hYmxlZCBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkIHRoZW4gbGVuZ3RoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogY2hhbmdpbmcgbXVzdCBhbHNvIGJlIGRpc2FibGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlBhZ2luYXRlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb2Nlc3NpbmcgaW5kaWNhdG9yIGVuYWJsZSBmbGFnIHdoZW5ldmVyIERhdGFUYWJsZXMgaXMgZW5hY3RpbmcgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHVzZXIgcmVxdWVzdCAtIHR5cGljYWxseSBhbiBBamF4IHJlcXVlc3QgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJiUHJvY2Vzc2luZ1wiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGVuYWJsZWQgZmxhZyAtIHdoZW4gZW5hYmxlZCBEYXRhVGFibGVzIHdpbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXQgYWxsIGRhdGEgZnJvbSB0aGUgc2VydmVyIGZvciBldmVyeSBkcmF3IC0gdGhlcmUgaXMgbm8gZmlsdGVyaW5nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNvcnRpbmcgb3IgcGFnaW5nIGRvbmUgb24gdGhlIGNsaWVudC1zaWRlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNlcnZlclNpZGVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogU29ydGluZyBlbmFibGVtZW50IGZsYWcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJiU29ydFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBNdWx0aS1jb2x1bW4gc29ydGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRNdWx0aVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBBcHBseSBhIGNsYXNzIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBiZWluZyBzb3J0ZWQgdG8gcHJvdmlkZSBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdmlzdWFsIGhpZ2hsaWdodCBvciBub3QuIFRoaXMgY2FuIHNsb3cgdGhpbmdzIGRvd24gd2hlbiBlbmFibGVkIHNpbmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlcmUgaXMgYSBsb3Qgb2YgRE9NIGludGVyYWN0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRDbGFzc2VzXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFN0YXRlIHNhdmluZyBlbmFibGVtZW50IGZsYWcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJiU3RhdGVTYXZlXCI6IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU2Nyb2xsaW5nIHNldHRpbmdzIGZvciBhIHRhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvU2Nyb2xsXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIHRoZSB0YWJsZSBpcyBzaG9ydGVyIGluIGhlaWdodCB0aGFuIHNTY3JvbGxZLCBjb2xsYXBzZSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0YWJsZSBjb250YWluZXIgZG93biB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWJsZSAod2hlbiB0cnVlKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJDb2xsYXBzZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBXaWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGZvciB0aGUgd2ViLWJyb3dzZXIncyBwbGF0Zm9ybS4gQ2FsY3VsYXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGR1cmluZyB0YWJsZSBpbml0aWFsaXNhdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImlCYXJXaWR0aFwiOiAwLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBWaWV3cG9ydCB3aWR0aCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIEhvcml6b250YWwgc2Nyb2xsaW5nIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZGlzYWJsZWQgaWYgYW4gZW1wdHkgc3RyaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzWFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBXaWR0aCB0byBleHBhbmQgdGhlIHRhYmxlIHRvIHdoZW4gdXNpbmcgeC1zY3JvbGxpbmcuIFR5cGljYWxseSB5b3VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoaXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNYSW5uZXJcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVmlld3BvcnQgaGVpZ2h0IGZvciB2ZXJ0aWNhbCBzY3JvbGxpbmcuIFZlcnRpY2FsIHNjcm9sbGluZyBpcyBkaXNhYmxlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGlmIGFuIGVtcHR5IHN0cmluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1lcIjogbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIExhbmd1YWdlIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleHRlbmRzIERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvTGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEluZm9ybWF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uLiBTZWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmZuSW5mb0NhbGxiYWNrfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJmbkluZm9DYWxsYmFja1wiOiBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQnJvd3NlciBzdXBwb3J0IHBhcmFtZXRlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwib0Jyb3dzZXJcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEluZGljYXRlIGlmIHRoZSBicm93c2VyIGluY29ycmVjdGx5IGNhbGN1bGF0ZXMgd2lkdGg6MTAwJSBpbnNpZGUgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNjcm9sbGluZyBlbGVtZW50IChJRTYvNylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNjcm9sbE92ZXJzaXplXCI6IGZhbHNlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpcyBvbiB0aGUgcmlnaHQgb3IgbGVmdCBvZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzY3JvbGxpbmcgY29udGFpbmVyIC0gbmVlZGVkIGZvciBydGwgbGFuZ3VhZ2UgbGF5b3V0LCBhbHRob3VnaCBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBhbGwgYnJvd3NlcnMgbW92ZSB0aGUgc2Nyb2xsYmFyIChTYWZhcmkpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJiU2Nyb2xsYmFyTGVmdFwiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhamF4XCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXJyYXkgcmVmZXJlbmNpbmcgdGhlIG5vZGVzIHdoaWNoIGFyZSB1c2VkIGZvciB0aGUgZmVhdHVyZXMuIFRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcGFyYW1ldGVycyBvZiB0aGlzIG9iamVjdCBtYXRjaCB3aGF0IGlzIGFsbG93ZWQgYnkgc0RvbSAtIGkuZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPHVsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT4nbCcgLSBMZW5ndGggY2hhbmdpbmc8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT4nZicgLSBGaWx0ZXJpbmcgaW5wdXQ8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+J2knIC0gSW5mb3JtYXRpb248L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT4ncCcgLSBQYWdpbmF0aW9uPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDwvdWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFhbkZlYXR1cmVzXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU3RvcmUgZGF0YSBpbmZvcm1hdGlvbiAtIHNlZSB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vUm93fSBmb3IgZGV0YWlsZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluZm9ybWF0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb0RhdGFcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBcnJheSBvZiBpbmRleGVzIHdoaWNoIGFyZSBpbiB0aGUgY3VycmVudCBkaXNwbGF5IChhZnRlciBmaWx0ZXJpbmcgZXRjKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhaURpc3BsYXlcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBcnJheSBvZiBpbmRleGVzIGZvciBkaXNwbGF5IC0gbm8gZmlsdGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFpRGlzcGxheU1hc3RlclwiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggY29sdW1uIHRoYXQgaXMgaW4gdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvQ29sdW1uc1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSdzIGhlYWRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb0hlYWRlclwiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSdzIGZvb3RlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb0Zvb3RlclwiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0b3JlIHRoZSBhcHBsaWVkIGdsb2JhbCBzZWFyY2ggaW5mb3JtYXRpb24gaW4gY2FzZSB3ZSB3YW50IHRvIGZvcmNlIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlc2VhcmNoIG9yIGNvbXBhcmUgdGhlIG9sZCBzZWFyY2ggdG8gYSBuZXcgb25lLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9QcmV2aW91c1NlYXJjaFwiOiB7fSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0b3JlIHRoZSBhcHBsaWVkIHNlYXJjaCBmb3IgZWFjaCBjb2x1bW4gLSBzZWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2h9IGZvciB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmaWx0ZXJpbmcgaW5mb3JtYXRpb24gZm9yIGVhY2ggY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1ByZVNlYXJjaENvbHNcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTb3J0aW5nIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgdGFibGUuIE5vdGUgdGhhdCB0aGUgaW5uZXIgYXJyYXlzIGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdXNlZCBpbiB0aGUgZm9sbG93aW5nIG1hbm5lcjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPGxpPkluZGV4IDAgLSBjb2x1bW4gbnVtYmVyPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPGxpPkluZGV4IDEgLSBjdXJyZW50IHNvcnRpbmcgZGlyZWN0aW9uPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDwvdWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0b2RvIFRoZXNlIGlubmVyIGFycmF5cyBzaG91bGQgcmVhbGx5IGJlIG9iamVjdHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhYVNvcnRpbmdcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNvcnRpbmcgdGhhdCBpcyBhbHdheXMgYXBwbGllZCB0byB0aGUgdGFibGUgKGkuZS4gcHJlZml4ZWQgaW4gZnJvbnQgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFhU29ydGluZykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDbGFzc2VzIHRvIHVzZSBmb3IgdGhlIHN0cmlwaW5nIG9mIGEgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYXNTdHJpcGVDbGFzc2VzXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyBzdHJpcGluZyBjbGFzc2VzIGFzIHdlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYXNEZXN0cm95U3RyaXBlc1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIElmIHJlc3RvcmluZyBhIHRhYmxlIC0gd2Ugc2hvdWxkIHJlc3RvcmUgaXRzIHdpZHRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNEZXN0cm95V2lkdGhcIjogMCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9ucyBhcnJheSBmb3IgZXZlcnkgdGltZSBhIHJvdyBpcyBpbnNlcnRlZCAoaS5lLiBvbiBhIGRyYXcpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1Jvd0NhbGxiYWNrXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgaGVhZGVyIG9uIGVhY2ggZHJhdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9IZWFkZXJDYWxsYmFja1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgZm9vdGVyIG9uIGVhY2ggZHJhdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9Gb290ZXJDYWxsYmFja1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgZHJhdyBjYWxsYmFjayBmdW5jdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9EcmF3Q2FsbGJhY2tcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJvdyBjcmVhdGVkIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvUm93Q3JlYXRlZENhbGxiYWNrXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciBqdXN0IGJlZm9yZSB0aGUgdGFibGUgaXMgcmVkcmF3bi4gQSByZXR1cm4gb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZhbHNlIHdpbGwgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGRyYXcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvUHJlRHJhd0NhbGxiYWNrXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9Jbml0Q29tcGxldGVcIjogW10sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRvIGJlIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nLCBwcmlvciB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2F2aW5nIHN0YXRlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1N0YXRlU2F2ZVBhcmFtc1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0aGF0IGhhdmUgYmVlbiBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcHJpb3IgdG8gdXNpbmcgdGhlIHN0b3JlZCB2YWx1ZXMgdG8gcmVzdG9yZSB0aGUgc3RhdGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvU3RhdGVMb2FkUGFyYW1zXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2FsbGJhY2tzIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldHRpbmdzIG9iamVjdCBvbmNlIHRoZSBzYXZlZCBzdGF0ZSBoYXMgYmVlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbG9hZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvU3RhdGVMb2FkZWRcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWNoZSB0aGUgdGFibGUgSUQgZm9yIHF1aWNrIGFjY2Vzc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzVGFibGVJZFwiOiBcIlwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIFRBQkxFIG5vZGUgZm9yIHRoZSBtYWluIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJuVGFibGVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRoZWFkIGVsZW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm5USGVhZFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUGVybWFuZW50IHJlZiB0byB0aGUgdGZvb3QgZWxlbWVudCAtIGlmIGl0IGV4aXN0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiblRGb290XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0Ym9keSBlbGVtZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJuVEJvZHlcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhY2hlIHRoZSB3cmFwcGVyIG5vZGUgKGNvbnRhaW5zIGFsbCBEYXRhVGFibGVzIGNvbnRyb2xsZWQgZWxlbWVudHMpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJuVGFibGVXcmFwcGVyXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJbmRpY2F0ZSBpZiB3aGVuIHVzaW5nIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGhlIGxvYWRpbmcgb2YgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2hvdWxkIGJlIGRlZmVycmVkIHVudGlsIHRoZSBzZWNvbmQgZHJhdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJEZWZlckxvYWRpbmdcIjogZmFsc2UsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJbmRpY2F0ZSBpZiBhbGwgcmVxdWlyZWQgaW5mb3JtYXRpb24gaGFzIGJlZW4gcmVhZCBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJJbml0aWFsaXNlZFwiOiBmYWxzZSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEluZm9ybWF0aW9uIGFib3V0IG9wZW4gcm93cy4gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5IGhhcyB0aGUgcGFyYW1ldGVyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogJ25UcicgYW5kICduUGFyZW50J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb09wZW5Sb3dzXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGljdGF0ZSB0aGUgcG9zaXRpb25pbmcgb2YgRGF0YVRhYmxlcycgY29udHJvbCBlbGVtZW50cyAtIHNlZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbC5vSW5pdC5zRG9tfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzRG9tXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTZWFyY2ggZGVsYXkgKGluIG1TKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludGVnZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic2VhcmNoRGVsYXlcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFdoaWNoIHR5cGUgb2YgcGFnaW5hdGlvbiBzaG91bGQgYmUgdXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHR3b19idXR0b25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzUGFnaW5hdGlvblR5cGVcIjogXCJ0d29fYnV0dG9uXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgc3RhdGUgZHVyYXRpb24gKGZvciBgc3RhdGVTYXZlYCkgaW4gc2Vjb25kcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJpU3RhdGVEdXJhdGlvblwiOiAwLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBzdGF0ZSBzYXZpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICA8dWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgYW5kIHRoZSBKU09OIHN0cmluZyB0byBzYXZlIHRoYXQgaGFzIGJlZW4gdGh1cyBmYXIgY3JlYXRlZC4gUmV0dXJuc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgYSBKU09OIHN0cmluZyB0byBiZSBpbnNlcnRlZCBpbnRvIGEganNvbiBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIChpLmUuICdcInBhcmFtXCI6IFsgMCwgMSwgMl0nKTwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPGxpPnN0cmluZzpzTmFtZSAtIG5hbWUgb2YgY2FsbGJhY2s8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICA8L3VsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1N0YXRlU2F2ZVwiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgbG9hZGluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBhbmQgdGhlIG9iamVjdCBzdG9yZWQuIE1heSByZXR1cm4gZmFsc2UgdG8gY2FuY2VsIHN0YXRlIGxvYWRpbmc8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPC91bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9TdGF0ZUxvYWRcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTdGF0ZSB0aGF0IHdhcyBzYXZlZC4gVXNlZnVsIGZvciBiYWNrIHJlZmVyZW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvU2F2ZWRTdGF0ZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU3RhdGUgdGhhdCB3YXMgbG9hZGVkLiBVc2VmdWwgZm9yIGJhY2sgcmVmZXJlbmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9Mb2FkZWRTdGF0ZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU291cmNlIHVybCBmb3IgQUpBWCBkYXRhIGZvciB0aGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0FqYXhTb3VyY2VcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnR5IGZyb20gYSBnaXZlbiBvYmplY3QgZnJvbSB3aGljaCB0byByZWFkIHRoZSB0YWJsZSBkYXRhIGZyb20uIFRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcgKHdoZW4gbm90IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcpLCBpbiB3aGljaCBjYXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpdCBpcyAgYXNzdW1lZCBhbiBhbiBhcnJheSBpcyBnaXZlbiBkaXJlY3RseS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNBamF4RGF0YVByb3BcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgaWYgZHJhdyBzaG91bGQgYmUgYmxvY2tlZCB3aGlsZSBnZXR0aW5nIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJBamF4RGF0YUdldFwiOiB0cnVlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGxhc3QgalF1ZXJ5IFhIUiBvYmplY3QgdGhhdCB3YXMgdXNlZCBmb3Igc2VydmVyLXNpZGUgZGF0YSBnYXRoZXJpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIGZvciB3b3JraW5nIHdpdGggdGhlIFhIUiBpbmZvcm1hdGlvbiBpbiBvbmUgb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwianFYSFJcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGluIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImpzb25cIjogdW5kZWZpbmVkLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YSBzdWJtaXR0ZWQgYXMgcGFydCBvZiB0aGUgbGFzdCBBamF4IHJlcXVlc3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvQWpheERhdGFcIjogdW5kZWZpbmVkLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJ2ZXItc2lkZSBkYXRhLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblNlcnZlckRhdGFcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9ucyB3aGljaCBhcmUgY2FsbGVkIHByaW9yIHRvIHNlbmRpbmcgYW4gQWpheCByZXF1ZXN0IHNvIGV4dHJhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwYXJhbWV0ZXJzIGNhbiBlYXNpbHkgYmUgc2VudCB0byB0aGUgc2VydmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvU2VydmVyUGFyYW1zXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU2VuZCB0aGUgWEhSIEhUVFAgbWV0aG9kIC0gR0VUIG9yIFBPU1QgKGNvdWxkIGJlIFBVVCBvciBERUxFVEUgaWZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlcXVpcmVkKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTZXJ2ZXJNZXRob2RcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZvcm1hdCBudW1iZXJzIGZvciBkaXNwbGF5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTGlzdCBvZiBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSB1c2VyIHNlbGVjdGFibGUgbGVuZ3RoIG1lbnUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYUxlbmd0aE1lbnVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENvdW50ZXIgZm9yIHRoZSBkcmF3cyB0aGF0IHRoZSB0YWJsZSBkb2VzLiBBbHNvIHVzZWQgYXMgYSB0cmFja2VyIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJpRHJhd1wiOiAwLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSW5kaWNhdGUgaWYgYSByZWRyYXcgaXMgYmVpbmcgZG9uZSAtIHVzZWZ1bCBmb3IgQWpheFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJEcmF3aW5nXCI6IGZhbHNlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRHJhdyBpbmRleCAoaURyYXcpIG9mIHRoZSBsYXN0IGVycm9yIHdoZW4gcGFyc2luZyB0aGUgcmV0dXJuZWQgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IC0xXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaURyYXdFcnJvclwiOiAtMSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFBhZ2luZyBkaXNwbGF5IGxlbmd0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiX2lEaXNwbGF5TGVuZ3RoXCI6IDEwLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUGFnaW5nIHN0YXJ0IHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHJlc3VsdCBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIChpLmUuIGJlZm9yZSBmaWx0ZXJpbmcpLCBVc2UgZm5SZWNvcmRzVG90YWwgcmF0aGVyIHRoYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoaXMgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJlZ2FyZGxlc3Mgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwcml2YXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiX2lSZWNvcmRzVG90YWxcIjogMCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCBkaXNwbGF5IHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKGkuZS4gYWZ0ZXIgZmlsdGVyaW5nKS4gVXNlIGZuUmVjb3Jkc0Rpc3BsYXkgcmF0aGVyIHRoYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoaXMgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJlZ2FyZGxlc3Mgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHNldHRpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9pUmVjb3Jkc0Rpc3BsYXlcIjogMCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgalF1ZXJ5IFVJIG1hcmtpbmcgYW5kIGNsYXNzZXMgc2hvdWxkIGJlIHVzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYkpVSVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGNsYXNzZXMgdG8gdXNlIGZvciB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9DbGFzc2VzXCI6IHt9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNhbGxiYWNrIGlmIGZpbHRlcmluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZXZlbnRzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYkZpbHRlcmVkXCI6IGZhbHNlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNhbGxiYWNrIGlmIHNvcnRpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGV2ZW50cy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTb3J0ZWRcIjogZmFsc2UsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJbmRpY2F0ZSB0aGF0IGlmIG11bHRpcGxlIHJvd3MgYXJlIGluIHRoZSBoZWFkZXIgYW5kIHRoZXJlIGlzIG1vcmUgdGhhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb25lIHVuaXF1ZSBjZWxsIHBlciBjb2x1bW4sIGlmIHRoZSB0b3Agb25lICh0cnVlKSBvciBib3R0b20gb25lIChmYWxzZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCBiZSB1c2VkIGZvciBzb3J0aW5nIC8gdGl0bGUgYnkgRGF0YVRhYmxlcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU29ydENlbGxzVG9wXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJbml0aWFsaXNhdGlvbiBvYmplY3QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwib0luaXRcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERlc3Ryb3kgY2FsbGJhY2sgZnVuY3Rpb25zIC0gZm9yIHBsdWctaW5zIHRvIGF0dGFjaCB0aGVtc2VsdmVzIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGVzdHJveSBzbyB0aGV5IGNhbiBjbGVhbiB1cCBtYXJrdXAgYW5kIGV2ZW50cy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9EZXN0cm95Q2FsbGJhY2tcIjogW10sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBiZWZvcmUgZmlsdGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblJlY29yZHNUb3RhbFwiOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mbkRhdGFTb3VyY2UodGhpcykgPT0gJ3NzcCcgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pUmVjb3Jkc1RvdGFsICogMSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWlEaXNwbGF5TWFzdGVyLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IHJlY29yZCBzZXQsIGFmdGVyIGZpbHRlcmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5SZWNvcmRzRGlzcGxheVwiOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mbkRhdGFTb3VyY2UodGhpcykgPT0gJ3NzcCcgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5haURpc3BsYXkubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEdldCB0aGUgZGlzcGxheSBlbmQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuRGlzcGxheUVuZFwiOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMuX2lEaXNwbGF5TGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMuX2lEaXNwbGF5U3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGMgPSBzdGFydCArIGxlbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkcyA9IHRoaXMuYWlEaXNwbGF5Lmxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMgPSB0aGlzLm9GZWF0dXJlcyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGUgPSBmZWF0dXJlcy5iUGFnaW5hdGU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iU2VydmVyU2lkZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFnaW5hdGUgPT09IGZhbHNlIHx8IGxlbiA9PT0gLTEgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyByZWNvcmRzIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHN0YXJ0ICsgbGVuLCB0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFwYWdpbmF0ZSB8fCBjYWxjID4gcmVjb3JkcyB8fCBsZW4gPT09IC0xID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHMgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsYztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGlzIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9JbnN0YW5jZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIGVhY2ggaW5zdGFuY2Ugb2YgdGhlIERhdGFUYWJsZXMgb2JqZWN0LiBJZiB0aGVyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgYW4gSUQgb24gdGhlIHRhYmxlIG5vZGUsIHRoZW4gaXQgdGFrZXMgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbmNyZW1lbnRpbmcgaW50ZXJuYWwgY291bnRlciBpcyB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzSW5zdGFuY2VcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRhYmluZGV4IGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIGFkZGVkIHRvIERhdGFUYWJsZXMgY29udHJvbCBlbGVtZW50cywgYWxsb3dpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIHRhYmxlIGFuZCBpdHMgY29udHJvbHMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaVRhYkluZGV4XCI6IDAsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBESVYgY29udGFpbmVyIGZvciB0aGUgZm9vdGVyIHNjcm9sbGluZyB0YWJsZSBpZiBzY3JvbGxpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJuU2Nyb2xsSGVhZFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRElWIGNvbnRhaW5lciBmb3IgdGhlIGZvb3RlciBzY3JvbGxpbmcgdGFibGUgaWYgc2Nyb2xsaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiblNjcm9sbEZvb3RcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIExhc3QgYXBwbGllZCBzb3J0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFMYXN0U29ydFwiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0b3JlZCBwbHVnLWluIGluc3RhbmNlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwib1BsdWdpbnNcIjoge31cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBFeHRlbnNpb24gb2JqZWN0IGZvciBEYXRhVGFibGVzIHRoYXQgaXMgdXNlZCB0byBwcm92aWRlIGFsbCBleHRlbnNpb25cclxuXHQgICAgICAgICAgICAgICAgICogb3B0aW9ucy5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoZSBgRGF0YVRhYmxlLmV4dGAgb2JqZWN0IGlzIGF2YWlsYWJsZSB0aHJvdWdoXHJcblx0ICAgICAgICAgICAgICAgICAqIGBqUXVlcnkuZm4uZGF0YVRhYmxlLmV4dGAgd2hlcmUgaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZC4gSXQgaXNcclxuXHQgICAgICAgICAgICAgICAgICogYWxzbyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgaGlzdG9yaWMgcmVhc29ucy5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMuZXh0XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIGV4dGVuc2lvbnNcclxuXHQgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoaXMgbmFtZXNwYWNlIGFjdHMgYXMgYSBjb2xsZWN0aW9uIGFyZWEgZm9yIHBsdWctaW5zIHRoYXQgY2FuIGJlIHVzZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICogZXh0ZW5kIERhdGFUYWJsZXMgY2FwYWJpbGl0aWVzLiBJbmRlZWQgbWFueSBvZiB0aGUgYnVpbGQgaW4gbWV0aG9kc1xyXG5cdCAgICAgICAgICAgICAgICAgKiB1c2UgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSB0aGVpciBvd24gY2FwYWJpbGl0aWVzIChzb3J0aW5nIG1ldGhvZHMgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAqIGV4YW1wbGUpLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBuYW1lc3BhY2UgaXMgYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGxlZ2FjeVxyXG5cdCAgICAgICAgICAgICAgICAgKiByZWFzb25zXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUuZXh0ID0gX2V4dCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQnV0dG9ucy4gRm9yIHVzZSB3aXRoIHRoZSBCdXR0b25zIGV4dGVuc2lvbiBmb3IgRGF0YVRhYmxlcy4gVGhpcyBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGVmaW5lZCBoZXJlIHNvIG90aGVyIGV4dGVuc2lvbnMgY2FuIGRlZmluZSBidXR0b25zIHJlZ2FyZGxlc3Mgb2YgbG9hZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3JkZXIuIEl0IGlzIF9ub3RfIHVzZWQgYnkgRGF0YVRhYmxlcyBjb3JlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBidXR0b25zOiB7fSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbGVtZW50IGNsYXNzIG5hbWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6IHt9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVycm9yIHJlcG9ydGluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSG93IHNob3VsZCBEYXRhVGFibGVzIHJlcG9ydCBhbiBlcnJvci4gQ2FuIHRha2UgdGhlIHZhbHVlICdhbGVydCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAndGhyb3cnLCAnbm9uZScgb3IgYSBmdW5jdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgYWxlcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXJyTW9kZTogXCJhbGVydFwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZlYXR1cmUgcGx1Zy1pbnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aGljaCBkZXNjcmliZSB0aGUgZmVhdHVyZSBwbHVnLWlucyB0aGF0IGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYXZhaWxhYmxlIHRvIERhdGFUYWJsZXMuIFRoZXNlIGZlYXR1cmUgcGx1Zy1pbnMgYXJlIHRoZW4gYXZhaWxhYmxlIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdXNlIHRocm91Z2ggdGhlIGBkb21gIGluaXRpYWxpc2F0aW9uIG9wdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRWFjaCBmZWF0dXJlIHBsdWctaW4gaXMgZGVzY3JpYmVkIGJ5IGFuIG9iamVjdCB3aGljaCBtdXN0IGhhdmUgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgZm5Jbml0YCAtIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBpbml0aWFsaXNlIHRoZSBwbHVnLWluLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgY0ZlYXR1cmVgIC0gYSBjaGFyYWN0ZXIgc28gdGhlIGZlYXR1cmUgY2FuIGJlIGVuYWJsZWQgYnkgdGhlIGBkb21gXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGluc3RpbGxhdGlvbiBvcHRpb24uIFRoaXMgaXMgY2FzZSBzZW5zaXRpdmUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGBmbkluaXRgIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMS4gYHtvYmplY3R9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdDogc2VlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIHtub2RlfG51bGx9IFRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHlvdXIgZmVhdHVyZS4gTm90ZSB0aGF0IHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICByZXR1cm4gbWF5IGFsc28gYmUgdm9pZCBpZiB5b3VyIHBsdWctaW4gZG9lcyBub3QgcmVxdWlyZSB0byBpbmplY3QgYW55XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIERPTSBlbGVtZW50cyBpbnRvIERhdGFUYWJsZXMgY29udHJvbCAoYGRvbWApIC0gZm9yIGV4YW1wbGUgdGhpcyBtaWdodFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBiZSB1c2VmdWwgd2hlbiBkZXZlbG9waW5nIGEgcGx1Zy1pbiB3aGljaCBhbGxvd3MgdGFibGUgY29udHJvbCB2aWFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAga2V5Ym9hcmQgZW50cnlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC5mZWF0dXJlcy5wdXNoKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIFwiZm5Jbml0XCI6IGZ1bmN0aW9uKCBvU2V0dGluZ3MgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVRvb2xzKCB7IFwib0RUU2V0dGluZ3NcIjogb1NldHRpbmdzIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgXCJjRmVhdHVyZVwiOiBcIlRcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBmZWF0dXJlOiBbXSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBSb3cgc2VhcmNoaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZWFyY2hpbmcsIGFuZCBhIGxvdCBtb3JlIGNvbXByZWhlbnNpdmUgYXMgaXQgYWxsb3dzIHlvdSBjb21wbGV0ZSBjb250cm9sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvdmVyIHRoZSBzZWFyY2hpbmcgbG9naWMuIEVhY2ggZWxlbWVudCBpbiB0aGlzIGFycmF5IGlzIGEgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbmQgeW91ciBsb2dpYyBkZWNpZGVzIGlmIGl0IHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VhcmNoaW5nIGRhdGEgc2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvciBub3QuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU2VhcmNoaW5nIGZ1bmN0aW9ucyBoYXZlIHRoZSBmb2xsb3dpbmcgaW5wdXQgcGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDIuIGB7YXJyYXl8b2JqZWN0fWAgRGF0YSBmb3IgdGhlIHJvdyB0byBiZSBwcm9jZXNzZWQgKHNhbWUgYXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGZyb20gYSBET00gZGF0YSBzb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDMuIGB7aW50fWAgUm93IGluZGV4ICh7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MuYW9EYXRhfSksIHdoaWNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFuZCB0aGUgZm9sbG93aW5nIHJldHVybiBpcyBleHBlY3RlZDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIHtib29sZWFufSBJbmNsdWRlIHRoZSByb3cgaW4gdGhlIHNlYXJjaGVkIHJlc3VsdCBzZXQgKHRydWUpIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAoZmFsc2UpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IGFzIHdpdGggdGhlIG1haW4gc2VhcmNoIGFiaWxpdHkgaW4gRGF0YVRhYmxlcywgdGVjaG5pY2FsbHkgdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgXCJmaWx0ZXJpbmdcIiwgc2luY2UgaXQgaXMgc3VidHJhY3RpdmUuIEhvd2V2ZXIsIGZvciBjb25zaXN0ZW5jeSBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBmb3VydGggY29sdW1uIChpLmUuIHRoZSBkYXRhWzNdIGluZGV4KSBiYXNlZCBvbiB0d28gaW5wdXQgdmFsdWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBmcm9tIHRoZSBlbmQtdXNlciwgbWF0Y2hpbmcgdGhlIGRhdGEgaW4gYSBjZXJ0YWluIHJhbmdlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBmdW5jdGlvbiggc2V0dGluZ3MsIGRhdGEsIGRhdGFJbmRleCApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB2YXIgbWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pbicpLnZhbHVlICogMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB2YXIgdmVyc2lvbiA9IGRhdGFbM10gPT0gXCItXCIgPyAwIDogZGF0YVszXSoxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IFtdLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNlbGVjdG9yIGV4dGVuc2lvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgYHNlbGVjdG9yYCBvcHRpb24gY2FuIGJlIHVzZWQgdG8gZXh0ZW5kIHRoZSBvcHRpb25zIGF2YWlsYWJsZSBmb3IgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZWxlY3RvciBtb2RpZmllciBvcHRpb25zIChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCBkYXRhIHR5cGUpIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGVhY2ggb2YgdGhlIHRocmVlIGJ1aWx0IGluIHNlbGVjdG9yIHR5cGVzIG9mZmVyIChyb3csIGNvbHVtbiBhbmQgY2VsbCArXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGVpciBwbHVyYWwgY291bnRlcnBhcnRzKS4gRm9yIGV4YW1wbGUgdGhlIFNlbGVjdCBleHRlbnNpb24gdXNlcyB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBtZWNoYW5pc20gdG8gcHJvdmlkZSBhbiBvcHRpb24gdG8gc2VsZWN0IG9ubHkgcm93cywgY29sdW1ucyBhbmQgY2VsbHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgaGF2ZSBiZWVuIG1hcmtlZCBhcyBzZWxlY3RlZCBieSB0aGUgZW5kIHVzZXIgKGB7c2VsZWN0ZWQ6IHRydWV9YCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aGljaCBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBleGlzdGluZyBidWlsdCBpbiBzZWxlY3RvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3B0aW9ucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFYWNoIHByb3BlcnR5IGlzIGFuIGFycmF5IHRvIHdoaWNoIGZ1bmN0aW9ucyBjYW4gYmUgcHVzaGVkLiBUaGUgZnVuY3Rpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0YWtlIHRocmVlIGF0dHJpYnV0ZXM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBTZXR0aW5ncyBvYmplY3QgZm9yIHRoZSBob3N0IHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIE9wdGlvbnMgb2JqZWN0IChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCB0eXBlKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBBcnJheSBvZiBzZWxlY3RlZCBpdGVtIGluZGV4ZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgcmV0dXJuIGlzIGFuIGFycmF5IG9mIHRoZSByZXN1bHRpbmcgaXRlbSBpbmRleGVzIGFmdGVyIHRoZSBjdXN0b21cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNlbGVjdG9yIGhhcyBiZWVuIGFwcGxpZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvcjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNlbGw6IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbnMsIGV4cG9zZWQgZm9yIHVzZWQgaW4gcGx1Zy1pbnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFBsZWFzZSBub3RlIHRoYXQgeW91IHNob3VsZCBub3QgbmVlZCB0byB1c2UgdGhlIGludGVybmFsIG1ldGhvZHMgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbnl0aGluZyBvdGhlciB0aGFuIGEgcGx1Zy1pbiAoYW5kIGV2ZW4gdGhlbiwgdHJ5IHRvIGF2b2lkIGlmIHBvc3NpYmxlKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBpbnRlcm5hbCBmdW5jdGlvbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGludGVybmFsOiB7fSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBMZWdhY3kgY29uZmlndXJhdGlvbiBvcHRpb25zLiBFbmFibGUgYW5kIGRpc2FibGUgbGVnYWN5IG9wdGlvbnMgdGhhdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYXJlIGF2YWlsYWJsZSBpbiBEYXRhVGFibGVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVnYWN5OiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIC8gZGlzYWJsZSBEYXRhVGFibGVzIDEuOSBjb21wYXRpYmxlIHNlcnZlci1zaWRlIHByb2Nlc3NpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiByZXF1ZXN0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFqYXg6IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUGFnaW5hdGlvbiBwbHVnLWluIG1ldGhvZHMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYmUgc2hvd24gYnkgdGhlIHBhZ2luYXRpb24gcmVuZGVyaW5nIG1ldGhvZCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZTpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLnBhZ2VCdXR0b259LiBUaGUgcmVuZGVyZXIgYWRkcmVzc2VzIGhvdyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aGF0IGJ1dHRvbnMgdG8gZGlzcGxheS4gVGhpcyBpcyBkb25lIGJ5IHJldHVybmluZyBhbiBhcnJheSBvZiBidXR0b25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRlc2NyaXB0aW9ucyAod2hhdCBlYWNoIGJ1dHRvbiB3aWxsIGRvKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQYWdpbmF0aW9uIHR5cGVzICh0aGUgZm91ciBidWlsdCBpbiBvcHRpb25zIGFuZCBhbnkgYWRkaXRpb25hbCBwbHVnLWluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvcHRpb25zIGRlZmluZWQgaGVyZSkgY2FuIGJlIHVzZWQgdGhyb3VnaCB0aGUgYHBhZ2luYXRpb25UeXBlYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDEuIGB7aW50fSBwYWdlYCBUaGUgY3VycmVudCBwYWdlIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAyLiBge2ludH0gcGFnZXNgIFRoZSBudW1iZXIgb2YgcGFnZXMgaW4gdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYW4gYXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYXJyYXkgY2FuIGJlIG9uZSBvZjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBmaXJzdGAgLSBKdW1wIHRvIGZpcnN0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGxhc3RgIC0gSnVtcCB0byBsYXN0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgbmV4dGAgLSBTaG93IG5leHQgcGFnZSB3aGVuIGFjdGl2YXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBge2ludH1gIC0gU2hvdyBwYWdlIG9mIHRoZSBpbmRleCBnaXZlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBjb250YWluaW5nICdESVYnIGVsZW1lbnQgKG1pZ2h0IGJlIHVzZWZ1bCBmb3Igc3R5bGluZykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbiBvYmplY3Qgd2l0aCB0d28gZnVuY3Rpb25zIHdvdWxkIGJlIGRlZmluZWQgZm9yIGVhY2ggcGx1Zy1pbi4gVGhhdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWJpbGl0eSBpcyBzdGlsbCBzdXBwb3J0ZWQgYnkgRGF0YVRhYmxlcyAxLjEwKyB0byBwcm92aWRlIGJhY2t3YXJkc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZG9jdW1lbnRlZCBpbiBEYXRhVGFibGVzIDEuMTArLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gU2hvdyBwcmV2aW91cywgbmV4dCBhbmQgY3VycmVudCBwYWdlIGJ1dHRvbnMgb25seVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGVFeHQub1BhZ2luYXRpb24uY3VycmVudCA9IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFnZXI6IHt9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZW5kZXJlcjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VCdXR0b246IHt9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcjoge31cclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogT3JkZXJpbmcgcGx1Zy1pbnMgLSBjdXN0b20gZGF0YSBzb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGV4dGVuc2lvbiBvcHRpb25zIGZvciBvcmRlcmluZyBvZiBkYXRhIGF2YWlsYWJsZSBoZXJlIGlzIGNvbXBsaW1lbnRhcnlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvIHRoZSBkZWZhdWx0IHR5cGUgYmFzZWQgb3JkZXJpbmcgdGhhdCBEYXRhVGFibGVzIHR5cGljYWxseSB1c2VzLiBJdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWxsb3dzIG11Y2ggZ3JlYXRlciBjb250cm9sIG92ZXIgdGhlIHRoZSBkYXRhIHRoYXQgaXMgYmVpbmcgdXNlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3JkZXIgYSBjb2x1bW4sIGJ1dCBpcyBuZWNlc3NhcmlseSB0aGVyZWZvcmUgbW9yZSBjb21wbGV4LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHR5cGUgb2Ygb3JkZXJpbmcgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGRvIG9yZGVyaW5nIGJhc2VkIG9uIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGxpdmUgZnJvbSB0aGUgRE9NIChmb3IgZXhhbXBsZSB0aGUgY29udGVudHMgb2YgYW4gJ2lucHV0JyBlbGVtZW50KSByYXRoZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoYW4ganVzdCB0aGUgc3RhdGljIHN0cmluZyB0aGF0IERhdGFUYWJsZXMga25vd3Mgb2YuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSB3YXkgdGhlc2UgcGx1Zy1pbnMgd29yayBpcyB0aGF0IHlvdSBjcmVhdGUgYW4gYXJyYXkgb2YgdGhlIHZhbHVlcyB5b3VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHdpc2ggdG8gYmUgb3JkZXJpbmcgZm9yIHRoZSBjb2x1bW4gaW4gcXVlc3Rpb24gYW5kIHRoZW4gcmV0dXJuIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFycmF5LiBUaGUgZGF0YSBpbiB0aGUgYXJyYXkgbXVjaCBiZSBpbiB0aGUgaW5kZXggb3JkZXIgb2YgdGhlIHJvd3MgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSB0YWJsZSAobm90IHRoZSBjdXJyZW50bHkgb3JkZXJpbmcgb3JkZXIhKS4gV2hpY2ggb3JkZXIgZGF0YSBnYXRoZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9uIGlzIHJ1biBoZXJlIGRlcGVuZHMgb24gdGhlIGBkdC1pbml0IGNvbHVtbnMub3JkZXJEYXRhVHlwZWBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBhcmFtZXRlciB0aGF0IGlzIHVzZWQgZm9yIHRoZSBjb2x1bW4gKGlmIGFueSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMS4gYHtvYmplY3R9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdDogc2VlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAyLiBge2ludH1gIFRhcmdldCBjb2x1bW4gaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhbiBhcnJheTpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGB7YXJyYXl9YCBEYXRhIGZvciB0aGUgY29sdW1uIHRvIGJlIG9yZGVyaW5nIHVwb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIE9yZGVyaW5nIHVzaW5nIGBpbnB1dGAgbm9kZSB2YWx1ZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC5vcmRlclsnZG9tLXRleHQnXSA9IGZ1bmN0aW9uICAoIHNldHRpbmdzLCBjb2wgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICByZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOidpbmRleCd9ICkubm9kZXMoKS5tYXAoIGZ1bmN0aW9uICggdGQsIGkgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuICQoJ2lucHV0JywgdGQpLnZhbCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIG9yZGVyOiB7fSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUeXBlIGJhc2VkIHBsdWctaW5zLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVhY2ggY29sdW1uIGluIERhdGFUYWJsZXMgaGFzIGEgdHlwZSBhc3NpZ25lZCB0byBpdCwgZWl0aGVyIGJ5IGF1dG9tYXRpY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGV0ZWN0aW9uIG9yIGJ5IGRpcmVjdCBhc3NpZ25tZW50IHVzaW5nIHRoZSBgdHlwZWAgb3B0aW9uIGZvciB0aGUgY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIHR5cGUgb2YgYSBjb2x1bW4gd2lsbCBlZmZlY3QgaG93IGl0IGlzIG9yZGVyaW5nIGFuZCBzZWFyY2ggKHBsdWctaW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjYW4gYWxzbyBtYWtlIHVzZSBvZiB0aGUgY29sdW1uIHR5cGUgaWYgcmVxdWlyZWQpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZToge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGEgY29sdW1uJ3MgdHlwZSwgbWFraW5nIGluaXRpYWxpc2F0aW9uIG9mIERhdGFUYWJsZXMgc3VwZXIgZWFzeSwgZXZlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHdoZW4gY29tcGxleCBkYXRhIGlzIGluIHRoZSB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgYW5hbHlzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgMi4gYHtzZXR0aW5nc31gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgIHBlcmZvcm0gY29udGV4dCBzcGVjaWZpYyB0eXBlIGRldGVjdGlvbiAtIGZvciBleGFtcGxlIGRldGVjdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICBiYXNlZCBvbiBsYW5ndWFnZSBzZXR0aW5ncyBzdWNoIGFzIHVzaW5nIGEgY29tbWEgZm9yIGEgZGVjaW1hbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICBwbGFjZS4gR2VuZXJhbGx5IHNwZWFraW5nIHRoZSBvcHRpb25zIGZyb20gdGhlIHNldHRpbmdzIHdpbGwgbm90XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgIGJlIHJlcXVpcmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICogYHtzdHJpbmd8bnVsbH1gIERhdGEgdHlwZSBkZXRlY3RlZCwgb3IgbnVsbCBpZiB1bmtub3duIChhbmQgdGh1c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgcGFzcyBpdCBvbiB0byB0aGUgb3RoZXIgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBDdXJyZW5jeSB0eXBlIGRldGVjdGlvbiBwbHVnLWluOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdC5wdXNoKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gKCBkYXRhLCBzZXR0aW5ncyApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgLy8gQ2hlY2sgdGhlIG51bWVyaWMgcGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBpZiAoICEgJC5pc051bWVyaWMoIGRhdGEuc3Vic3RyaW5nKDEpICkgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAvLyBDaGVjayBwcmVmaXhlZCBieSBjdXJyZW5jeVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBpZiAoIGRhdGEuY2hhckF0KDApID09ICckJyB8fCBkYXRhLmNoYXJBdCgwKSA9PSAnJnBvdW5kOycgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuICdjdXJyZW5jeSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3Q6IFtdLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVHlwZSBiYXNlZCBzZWFyY2ggZm9ybWF0dGluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSB0eXBlIGJhc2VkIHNlYXJjaGluZyBmdW5jdGlvbnMgY2FuIGJlIHVzZWQgdG8gcHJlLWZvcm1hdCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBkYXRhIHRvIGJlIHNlYXJjaCBvbi4gRm9yIGV4YW1wbGUsIGl0IGNhbiBiZSB1c2VkIHRvIHN0cmlwIEhUTUxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0YWdzIG9yIHRvIGRlLWZvcm1hdCB0ZWxlcGhvbmUgbnVtYmVycyBmb3IgbnVtZXJpYyBvbmx5IHNlYXJjaGluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCBpcyBhIHNlYXJjaCBpcyBub3QgZGVmaW5lZCBmb3IgYSBjb2x1bW4gb2YgYSBnaXZlbiB0eXBlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIG5vIHNlYXJjaCBmb3JtYXR0aW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFByZS1wcm9jZXNzaW5nIG9mIHNlYXJjaGluZyBkYXRhIHBsdWctaW5zIC0gV2hlbiB5b3UgYXNzaWduIHRoZSBzVHlwZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZvciBhIGNvbHVtbiAob3IgaGF2ZSBpdCBhdXRvbWF0aWNhbGx5IGRldGVjdGVkIGZvciB5b3UgYnkgRGF0YVRhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIG9yIGEgdHlwZSBkZXRlY3Rpb24gcGx1Zy1pbiksIHlvdSB3aWxsIHR5cGljYWxseSBiZSB1c2luZyB0aGlzIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGN1c3RvbSBzb3J0aW5nLCBidXQgaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBzZWFyY2hpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBieSBhbGxvd2luZyB5b3UgdG8gcHJlLXByb2Nlc3NpbmcgdGhlIGRhdGEgYW5kIHJldHVybmluZyB0aGUgZGF0YSBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBmb3JtYXQgdGhhdCBzaG91bGQgYmUgc2VhcmNoZWQgdXBvbi4gVGhpcyBpcyBkb25lIGJ5IGFkZGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9ucyB0aGlzIG9iamVjdCB3aXRoIGEgcGFyYW1ldGVyIG5hbWUgd2hpY2ggbWF0Y2hlcyB0aGUgc1R5cGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBmb3IgdGhhdCB0YXJnZXQgY29sdW1uLiBUaGlzIGlzIHRoZSBjb3JvbGxhcnkgb2YgPGk+YWZuU29ydERhdGE8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZm9yIHNlYXJjaGluZyBkYXRhLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgcHJlcGFyZWQgZm9yIHNlYXJjaGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGB7c3RyaW5nfG51bGx9YCBGb3JtYXR0ZWQgc3RyaW5nIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGUgc2VhcmNoaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoWyd0aXRsZS1udW1lcmljJ10gPSBmdW5jdGlvbiAoIGQgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICByZXR1cm4gZC5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoOiB7fSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFR5cGUgYmFzZWQgb3JkZXJpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY29sdW1uIHR5cGUgdGVsbHMgRGF0YVRhYmxlcyB3aGF0IG9yZGVyaW5nIHRvIGFwcGx5IHRvIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHdoZW4gYSBjb2x1bW4gaXMgc29ydGVkIHVwb24uIFRoZSBvcmRlciBmb3IgZWFjaCB0eXBlIHRoYXQgaXMgZGVmaW5lZCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogRWFjaCBvcmRlcmluZyBvcHRpb24gY2FuIGJlIGRlc2NyaWJlZCBieSB0aHJlZSBwcm9wZXJ0aWVzIGFkZGVkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdGhpcyBvYmplY3Q6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGB7dHlwZX0tcHJlYCAtIFByZS1mb3JtYXR0aW5nIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGB7dHlwZX0tZGVzY2AgLSBEZXNjZW5kaW5nIG9yZGVyIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBge3R5cGV9LWFzY2AgYW5kIGB7dHlwZX0tZGVzY2AgdG9nZXRoZXIuIEl0IGlzIGdlbmVyYWxseSByZWNvbW1lbmRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYXQgb25seSBge3R5cGV9LXByZWAgaXMgdXNlZCwgYXMgdGhpcyBwcm92aWRlcyB0aGUgb3B0aW1hbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZvciBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgSmF2YXNjcmlwdCBzb3J0IGZ1bmN0aW9ucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuZCByZXR1cm46XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGB7Kn1gIERhdGEgdG8gYmUgc29ydGVkIHVwb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9ucywgdGFraW5nIHR3byBwYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIDEuIGB7Kn1gIERhdGEgdG8gY29tcGFyZSB0byB0aGUgc2Vjb25kIHBhcmFtZXRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQW5kIHJldHVybmluZzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICogYHsqfWAgT3JkZXJpbmcgbWF0Y2g6IDwwIGlmIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgc29ydGVkIGxvd2VyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICB0aGFuIHRoZSBzZWNvbmQgcGFyYW1ldGVyLCA9PT0wIGlmIHRoZSB0d28gcGFyYW1ldGVycyBhcmUgZXF1YWwgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgcGFyYW1ldGVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIE51bWVyaWMgb3JkZXJpbmcgb2YgZm9ybWF0dGVkIG51bWJlcnMgd2l0aCBhIHByZS1mb3JtYXR0ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkLmV4dGVuZCggJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUub3JkZXIsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbih4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGEgPSAoYSA9PT0gXCItXCIgfHwgYSA9PT0gXCJcIikgPyAwIDogYS5yZXBsYWNlKCAvW15cXGRcXC1cXC5dL2csIFwiXCIgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoIGEgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBDYXNlLXNlbnNpdGl2ZSBzdHJpbmcgb3JkZXJpbmcsIHdpdGggbm8gcHJlLWZvcm1hdHRpbmcgbWV0aG9kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC5vcmRlciwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgXCJzdHJpbmctY2FzZS1hc2NcIjogZnVuY3Rpb24oeCx5KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiAoKHggPCB5KSA/IC0xIDogKCh4ID4geSkgPyAxIDogMCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIFwic3RyaW5nLWNhc2UtZGVzY1wiOiBmdW5jdGlvbih4LHkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gMSA6ICgoeCA+IHkpID8gLTEgOiAwKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOiB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFVuaXF1ZSBEYXRhVGFibGVzIGluc3RhbmNlIGNvdW50ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIF91bmlxdWU6IDAsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBEZXByZWNpYXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGlibGl0eSBvbmx5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNob3VsZCBub3QgYmUgdXNlZCBpbiBuZXcgcHJvamVjdHMgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdmVyc2lvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy9cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFZlcnNpb24gY2hlY2sgZnVuY3Rpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjaWF0ZWQgU2luY2UgMS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBmblZlcnNpb25DaGVjazogRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEluZGV4IGZvciB3aGF0ICd0aGlzJyBpbmRleCBBUEkgZnVuY3Rpb25zIHNob3VsZCB1c2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpQXBpSW5kZXg6IDAsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogalF1ZXJ5IFVJIGNsYXNzIGNvbnRhaW5lclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIG9KVUlDbGFzc2VzOiB7fSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTb2Z0d2FyZSB2ZXJzaW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy9cclxuXHQgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEFsaWFzIHRvIHByZSAxLjEwIEh1bmdhcmlhbiBub3RhdGlvbiBjb3VudGVyIHBhcnRzXHJcblx0ICAgICAgICAgICAgICAgIC8vXHJcblx0ICAgICAgICAgICAgICAgICQuZXh0ZW5kKF9leHQsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGFmbkZpbHRlcmluZzogX2V4dC5zZWFyY2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICBhVHlwZXM6IF9leHQudHlwZS5kZXRlY3QsXHJcblx0ICAgICAgICAgICAgICAgICAgICBvZm5TZWFyY2g6IF9leHQudHlwZS5zZWFyY2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICBvU29ydDogX2V4dC50eXBlLm9yZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWZuU29ydERhdGE6IF9leHQub3JkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBhb0ZlYXR1cmVzOiBfZXh0LmZlYXR1cmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBvQXBpOiBfZXh0LmludGVybmFsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb1N0ZENsYXNzZXM6IF9leHQuY2xhc3NlcyxcclxuXHQgICAgICAgICAgICAgICAgICAgIG9QYWdpbmF0aW9uOiBfZXh0LnBhZ2VyXHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICQuZXh0ZW5kKERhdGFUYWJsZS5leHQuY2xhc3Nlcywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzVGFibGVcIjogXCJkYXRhVGFibGVcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic05vRm9vdGVyXCI6IFwibm8tZm9vdGVyXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogUGFnaW5nIGJ1dHRvbnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1BhZ2VCdXR0b25cIjogXCJwYWdpbmF0ZV9idXR0b25cIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1BhZ2VCdXR0b25BY3RpdmVcIjogXCJjdXJyZW50XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNQYWdlQnV0dG9uRGlzYWJsZWRcIjogXCJkaXNhYmxlZFwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFN0cmlwaW5nIGNsYXNzZXMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1N0cmlwZU9kZFwiOiBcIm9kZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU3RyaXBlRXZlblwiOiBcImV2ZW5cIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBFbXB0eSByb3cgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Jvd0VtcHR5XCI6IFwiZGF0YVRhYmxlc19lbXB0eVwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEZlYXR1cmVzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc193cmFwcGVyXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNGaWx0ZXJcIjogXCJkYXRhVGFibGVzX2ZpbHRlclwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzSW5mb1wiOiBcImRhdGFUYWJsZXNfaW5mb1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzUGFnaW5nXCI6IFwiZGF0YVRhYmxlc19wYWdpbmF0ZSBwYWdpbmdfXCIsIC8qIE5vdGUgdGhhdCB0aGUgdHlwZSBpcyBwb3N0Zml4ZWQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0xlbmd0aFwiOiBcImRhdGFUYWJsZXNfbGVuZ3RoXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNQcm9jZXNzaW5nXCI6IFwiZGF0YVRhYmxlc19wcm9jZXNzaW5nXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogU29ydGluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydEFzY1wiOiBcInNvcnRpbmdfYXNjXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0RGVzY1wiOiBcInNvcnRpbmdfZGVzY1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydGFibGVcIjogXCJzb3J0aW5nXCIsIC8qIFNvcnRhYmxlIGluIGJvdGggZGlyZWN0aW9ucyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydGFibGVBc2NcIjogXCJzb3J0aW5nX2FzY19kaXNhYmxlZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydGFibGVEZXNjXCI6IFwic29ydGluZ19kZXNjX2Rpc2FibGVkXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0YWJsZU5vbmVcIjogXCJzb3J0aW5nX2Rpc2FibGVkXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0Q29sdW1uXCI6IFwic29ydGluZ19cIiwgLyogTm90ZSB0aGF0IGFuIGludCBpcyBwb3N0Zml4ZWQgZm9yIHRoZSBzb3J0aW5nIG9yZGVyICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogRmlsdGVyaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNGaWx0ZXJJbnB1dFwiOiBcIlwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFBhZ2UgbGVuZ3RoICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNMZW5ndGhTZWxlY3RcIjogXCJcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBTY3JvbGxpbmcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbFdyYXBwZXJcIjogXCJkYXRhVGFibGVzX3Njcm9sbFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU2Nyb2xsSGVhZFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU2Nyb2xsSGVhZElubmVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkSW5uZXJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbEJvZHlcIjogXCJkYXRhVGFibGVzX3Njcm9sbEJvZHlcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbEZvb3RcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3RcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbEZvb3RJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdElubmVyXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogTWlzYyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzSGVhZGVyVEhcIjogXCJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0Zvb3RlclRIXCI6IFwiXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRGVwcmVjYXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydEpVSUFzY1wiOiBcIlwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydEpVSURlc2NcIjogXCJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRKVUlcIjogXCJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRKVUlBc2NBbGxvd2VkXCI6IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJRGVzY0FsbG93ZWRcIjogXCJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRKVUlXcmFwcGVyXCI6IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0SWNvblwiOiBcIlwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzSlVJSGVhZGVyXCI6IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNKVUlGb290ZXJcIjogXCJcIlxyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJldXNlZCBzdHJpbmdzIGZvciBiZXR0ZXIgY29tcHJlc3Npb24uIENsb3N1cmUgY29tcGlsZXIgYXBwZWFycyB0byBoYXZlIGFcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHdlaXJkIGVkZ2UgY2FzZSB3aGVyZSBpdCBpcyB0cnlpbmcgdG8gZXhwYW5kIHN0cmluZ3MgcmF0aGVyIHRoYW4gdXNlIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdmFyaWFibGUgdmVyc2lvbi4gVGhpcyByZXN1bHRzIGluIGFib3V0IDIwMCBieXRlcyBiZWluZyBhZGRlZCwgZm9yIHZlcnlcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGxpdHRsZSBwcmVmZXJlbmNlIGJlbmVmaXQgc2luY2UgaXQgdGhpcyBydW4gb24gc2NyaXB0IGxvYWQgb25seS5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfZW1wdHkgPSAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgIF9lbXB0eSA9ICcnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfc3RhdGVEZWZhdWx0ID0gX2VtcHR5ICsgJ3VpLXN0YXRlLWRlZmF1bHQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9zb3J0SWNvbiA9IF9lbXB0eSArICdjc3NfcmlnaHQgdWktaWNvbiB1aS1pY29uLSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2hlYWRlckZvb3RlciA9IF9lbXB0eSArICdmZy10b29sYmFyIHVpLXRvb2xiYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1oZWxwZXItY2xlYXJmaXgnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKERhdGFUYWJsZS5leHQub0pVSUNsYXNzZXMsIERhdGFUYWJsZS5leHQuY2xhc3Nlcywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEZ1bGwgbnVtYmVycyBwYWdpbmcgYnV0dG9ucyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1BhZ2VCdXR0b25cIjogXCJmZy1idXR0b24gdWktYnV0dG9uIFwiICsgX3N0YXRlRGVmYXVsdCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNQYWdlQnV0dG9uQWN0aXZlXCI6IFwidWktc3RhdGUtZGlzYWJsZWRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNQYWdlQnV0dG9uRGlzYWJsZWRcIjogXCJ1aS1zdGF0ZS1kaXNhYmxlZFwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBGZWF0dXJlcyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1BhZ2luZ1wiOiBcImRhdGFUYWJsZXNfcGFnaW5hdGUgZmctYnV0dG9uc2V0IHVpLWJ1dHRvbnNldCBmZy1idXR0b25zZXQtbXVsdGkgXCIgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInVpLWJ1dHRvbnNldC1tdWx0aSBwYWdpbmdfXCIsIC8qIE5vdGUgdGhhdCB0aGUgdHlwZSBpcyBwb3N0Zml4ZWQgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogU29ydGluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnRBc2NcIjogX3N0YXRlRGVmYXVsdCArIFwiIHNvcnRpbmdfYXNjXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydERlc2NcIjogX3N0YXRlRGVmYXVsdCArIFwiIHNvcnRpbmdfZGVzY1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnRhYmxlXCI6IF9zdGF0ZURlZmF1bHQgKyBcIiBzb3J0aW5nXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydGFibGVBc2NcIjogX3N0YXRlRGVmYXVsdCArIFwiIHNvcnRpbmdfYXNjX2Rpc2FibGVkXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydGFibGVEZXNjXCI6IF9zdGF0ZURlZmF1bHQgKyBcIiBzb3J0aW5nX2Rlc2NfZGlzYWJsZWRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0YWJsZU5vbmVcIjogX3N0YXRlRGVmYXVsdCArIFwiIHNvcnRpbmdfZGlzYWJsZWRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJQXNjXCI6IF9zb3J0SWNvbiArIFwidHJpYW5nbGUtMS1uXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydEpVSURlc2NcIjogX3NvcnRJY29uICsgXCJ0cmlhbmdsZS0xLXNcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJXCI6IF9zb3J0SWNvbiArIFwiY2FyYXQtMi1uLXNcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJQXNjQWxsb3dlZFwiOiBfc29ydEljb24gKyBcImNhcmF0LTEtblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnRKVUlEZXNjQWxsb3dlZFwiOiBfc29ydEljb24gKyBcImNhcmF0LTEtc1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnRKVUlXcmFwcGVyXCI6IFwiRGF0YVRhYmxlc19zb3J0X3dyYXBwZXJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0SWNvblwiOiBcIkRhdGFUYWJsZXNfc29ydF9pY29uXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNjcm9sbGluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbEhlYWRcIjogXCJkYXRhVGFibGVzX3Njcm9sbEhlYWQgXCIgKyBfc3RhdGVEZWZhdWx0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbEZvb3RcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3QgXCIgKyBfc3RhdGVEZWZhdWx0LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBNaXNjICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzSGVhZGVyVEhcIjogX3N0YXRlRGVmYXVsdCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNGb290ZXJUSFwiOiBfc3RhdGVEZWZhdWx0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0pVSUhlYWRlclwiOiBfaGVhZGVyRm9vdGVyICsgXCIgdWktY29ybmVyLXRsIHVpLWNvcm5lci10clwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0pVSUZvb3RlclwiOiBfaGVhZGVyRm9vdGVyICsgXCIgdWktY29ybmVyLWJsIHVpLWNvcm5lci1iclwiXHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIH0oKSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBleHRQYWdpbmF0aW9uID0gRGF0YVRhYmxlLmV4dC5wYWdlcjtcclxuXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzID0gW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IGV4dFBhZ2luYXRpb24ubnVtYmVyc19sZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFsZiA9IE1hdGguZmxvb3IoYnV0dG9ucyAvIDIpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAxO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYWdlcyA8PSBidXR0b25zKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycyA9IF9yYW5nZSgwLCBwYWdlcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYWdlIDw9IGhhbGYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzID0gX3JhbmdlKDAsIGJ1dHRvbnMgLSAyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzLnB1c2goJ2VsbGlwc2lzJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKHBhZ2VzIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYWdlID49IHBhZ2VzIC0gMSAtIGhhbGYpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzID0gX3JhbmdlKHBhZ2VzIC0gKGJ1dHRvbnMgLSAyKSwgcGFnZXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuc3BsaWNlKDAsIDAsICdlbGxpcHNpcycpOyAvLyBubyB1bnNoaWZ0IGluIGllNlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuc3BsaWNlKDAsIDAsIDApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycyA9IF9yYW5nZShwYWdlIC0gaGFsZiArIDIsIHBhZ2UgKyBoYWxmIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKCdlbGxpcHNpcycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMucHVzaChwYWdlcyAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuc3BsaWNlKDAsIDAsICdlbGxpcHNpcycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuc3BsaWNlKDAsIDAsIDApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIG51bWJlcnMuRFRfZWwgPSAnc3Bhbic7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVycztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICQuZXh0ZW5kKGV4dFBhZ2luYXRpb24sIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNpbXBsZTogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsncHJldmlvdXMnLCAnbmV4dCddO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmdWxsOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydmaXJzdCcsICdwcmV2aW91cycsICduZXh0JywgJ2xhc3QnXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgc2ltcGxlX251bWJlcnM6IGZ1bmN0aW9uIChwYWdlLCBwYWdlcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3ByZXZpb3VzJywgX251bWJlcnMocGFnZSwgcGFnZXMpLCAnbmV4dCddO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmdWxsX251bWJlcnM6IGZ1bmN0aW9uIChwYWdlLCBwYWdlcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZpcnN0JywgJ3ByZXZpb3VzJywgX251bWJlcnMocGFnZSwgcGFnZXMpLCAnbmV4dCcsICdsYXN0J107XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEZvciB0ZXN0aW5nIGFuZCBwbHVnLWlucyB0byB1c2VcclxuXHQgICAgICAgICAgICAgICAgICAgIF9udW1iZXJzOiBfbnVtYmVycyxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBOdW1iZXIgb2YgbnVtYmVyIGJ1dHRvbnMgKGluY2x1ZGluZyBlbGxpcHNpcykgdG8gc2hvdy4gX011c3QgYmUgb2RkIV9cclxuXHQgICAgICAgICAgICAgICAgICAgIG51bWJlcnNfbGVuZ3RoOiA3XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhZ2VCdXR0b246IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGhvc3QsIGlkeCwgYnV0dG9ucywgcGFnZSwgcGFnZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3NlcztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnRuRGlzcGxheSwgYnRuQ2xhc3MsIGNvdW50ZXIgPSAwO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dGFjaCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGJ1dHRvbnMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpZW4sIG5vZGUsIGJ1dHRvbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblBhZ2VDaGFuZ2Uoc2V0dGluZ3MsIGUuZGF0YS5hY3Rpb24sIHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBidXR0b25zLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b24gPSBidXR0b25zW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGJ1dHRvbikpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyID0gJCgnPCcgKyAoYnV0dG9uLkRUX2VsIHx8ICdkaXYnKSArICcvPicpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY29udGFpbmVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoKGlubmVyLCBidXR0b24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuRGlzcGxheSA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9ICcnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChidXR0b24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VsbGlwc2lzJzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKCc8c3BhbiBjbGFzcz1cImVsbGlwc2lzXCI+JiN4MjAyNjs8L3NwYW4+Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmlyc3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBsYW5nLnNGaXJzdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlID4gMCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnIDogJyAnICsgY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuRGlzcGxheSA9IGxhbmcuc1ByZXZpb3VzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPiAwID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgOiAnICcgKyBjbGFzc2VzLnNQYWdlQnV0dG9uRGlzYWJsZWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25leHQnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBsYW5nLnNOZXh0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPCBwYWdlcyAtIDEgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyA6ICcgJyArIGNsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGFzdCc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuRGlzcGxheSA9IGxhbmcuc0xhc3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA8IHBhZ2VzIC0gMSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnIDogJyAnICsgY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBidXR0b24gKyAxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkNsYXNzID0gcGFnZSA9PT0gYnV0dG9uID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zUGFnZUJ1dHRvbkFjdGl2ZSA6ICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnRuRGlzcGxheSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9ICQoJzxhPicsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBjbGFzc2VzLnNQYWdlQnV0dG9uICsgJyAnICsgYnRuQ2xhc3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBzZXR0aW5ncy5zVGFibGVJZCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1kdC1pZHgnOiBjb3VudGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0YWJpbmRleCc6IHNldHRpbmdzLmlUYWJJbmRleCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaWQnOiBpZHggPT09IDAgJiYgdHlwZW9mIGJ1dHRvbiA9PT0gJ3N0cmluZycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5zVGFibGVJZCArICdfJyArIGJ1dHRvbiA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwoYnRuRGlzcGxheSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY29udGFpbmVyKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5CaW5kQWN0aW9uKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsIHsgYWN0aW9uOiBidXR0b24gfSwgY2xpY2tIYW5kbGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLiBUcnkgLyBjYXRjaCB0aGUgZXJyb3IuIE5vdCBnb29kIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3NpYmlsaXR5LCBidXQgbmVpdGhlciBhcmUgZnJhbWVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aXZlRWw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGlzIGFwcHJvYWNoIGlzIGRlc3Ryb3lpbmcgYW5kIHJlY3JlYXRpbmcgdGhlIHBhZ2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudHMsIGZvY3VzIGlzIGxvc3Qgb24gdGhlIHNlbGVjdCBidXR0b24gd2hpY2ggaXMgYmFkIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzaWJpbGl0eS4gU28gd2Ugd2FudCB0byByZXN0b3JlIGZvY3VzIG9uY2UgdGhlIGRyYXcgaGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsID0gJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5kYXRhKCdkdC1pZHgnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2goJChob3N0KS5lbXB0eSgpLCBidXR0b25zKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChob3N0KS5maW5kKCdbZGF0YS1kdC1pZHg9JyArIGFjdGl2ZUVsICsgJ10nKS5mb2N1cygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gQnVpbHQgaW4gdHlwZSBkZXRlY3Rpb24uIFNlZSBtb2RlbC5leHQuYVR5cGVzIGZvciBpbmZvcm1hdGlvbiBhYm91dFxyXG5cdCAgICAgICAgICAgICAgICAvLyB3aGF0IGlzIHJlcXVpcmVkIGZyb20gdGhpcyBtZXRob2RzLlxyXG5cdCAgICAgICAgICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LCBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQbGFpbiBudW1iZXJzIC0gZmlyc3Qgc2luY2UgVjggZGV0ZWN0cyBzb21lIHBsYWluIG51bWJlcnMgYXMgZGF0ZXNcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gRGF0ZS5wYXJzZSgnNTUnKSAoYnV0IG5vdCBhbGwsIGUuZy4gRGF0ZS5wYXJzZSgnMjInKS4uLikuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2lzTnVtYmVyKGQsIGRlY2ltYWwpID8gJ251bScgKyBkZWNpbWFsIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRGF0ZXMgKG9ubHkgdGhvc2UgcmVjb2duaXNlZCBieSB0aGUgYnJvd3NlcidzIERhdGUucGFyc2UpXHJcblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBWOCB3aWxsIHJlbW92ZSBhbnkgdW5rbm93biBjaGFyYWN0ZXJzIGF0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24sIGxlYWRpbmcgdG8gZmFsc2UgbWF0Y2hlcyBzdWNoIGFzIGAkMjQ1LjEyYCBvciBgMTAlYCBiZWluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgdmFsaWQgZGF0ZS4gU2VlIGZvcnVtIHRocmVhZCAxODk0MSBmb3IgZGV0YWlsLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkICYmICEoZCBpbnN0YW5jZW9mIERhdGUpICYmICghX3JlX2RhdGVfc3RhcnQudGVzdChkKSB8fCAhX3JlX2RhdGVfZW5kLnRlc3QoZCkpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gRGF0ZS5wYXJzZShkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlZCAhPT0gbnVsbCAmJiAhaXNOYU4ocGFyc2VkKSkgfHwgX2VtcHR5KGQpID8gJ2RhdGUnIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0dGVkIG51bWJlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfaXNOdW1iZXIoZCwgZGVjaW1hbCwgdHJ1ZSkgPyAnbnVtLWZtdCcgKyBkZWNpbWFsIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSFRNTCBudW1lcmljXHJcblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2h0bWxOdW1lcmljKGQsIGRlY2ltYWwpID8gJ2h0bWwtbnVtJyArIGRlY2ltYWwgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBIVE1MIG51bWVyaWMsIGZvcm1hdHRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9odG1sTnVtZXJpYyhkLCBkZWNpbWFsLCB0cnVlKSA/ICdodG1sLW51bS1mbXQnICsgZGVjaW1hbCA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEhUTUwgKHRoaXMgaXMgc3RyaWN0IGNoZWNraW5nIC0gdGhlcmUgbXVzdCBiZSBodG1sKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbXB0eShkKSB8fCAodHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQuaW5kZXhPZignPCcpICE9PSAtMSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHRtbCcgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBdKTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zLiBTZWUgbW9kZWwuZXh0Lm9mblNlYXJjaCBmb3IgaW5mb3JtYXRpb24gYWJvdXRcclxuXHQgICAgICAgICAgICAgICAgLy8gd2hhdCBpcyByZXF1aXJlZCBmcm9tIHRoZXNlIG1ldGhvZHMuXHJcblx0ICAgICAgICAgICAgICAgIC8vIFxyXG5cdCAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgYWRkaXRpb25hbCBzZWFyY2ggbWV0aG9kcyBhcmUgYWRkZWQgZm9yIHRoZSBodG1sIG51bWJlcnMgYW5kXHJcblx0ICAgICAgICAgICAgICAgIC8vIGh0bWwgZm9ybWF0dGVkIG51bWJlcnMgYnkgYF9hZGROdW1lcmljU29ydCgpYCB3aGVuIHdlIGtub3cgd2hhdCB0aGUgZGVjaW1hbFxyXG5cdCAgICAgICAgICAgICAgICAvLyBwbGFjZSBpc1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICQuZXh0ZW5kKERhdGFUYWJsZS5leHQudHlwZS5zZWFyY2gsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGh0bWw6IGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbXB0eShkYXRhKSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKF9yZV9uZXdfbGluZXMsIFwiIFwiKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKF9yZV9odG1sLCBcIlwiKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoZGF0YSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVwbGFjZShfcmVfbmV3X2xpbmVzLCBcIiBcIikgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX251bWVyaWNSZXBsYWNlID0gZnVuY3Rpb24gKGQsIGRlY2ltYWxQbGFjZSwgcmUxLCByZTIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkICE9PSAwICYmICghZCB8fCBkID09PSAnLScpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGRlY2ltYWwgcGxhY2Ugb3RoZXIgdGhhbiBgLmAgaXMgdXNlZCwgaXQgbmVlZHMgdG8gYmUgZ2l2ZW4gdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBzbyB3ZSBjYW4gZGV0ZWN0IGl0IGFuZCByZXBsYWNlIHdpdGggYSBgLmAgd2hpY2ggaXMgdGhlIG9ubHlcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcGxhY2UgSmF2YXNjcmlwdCByZWNvZ25pc2VzIC0gaXQgaXMgbm90IGxvY2FsZSBhd2FyZS5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsUGxhY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkID0gX251bVRvRGVjaW1hbChkLCBkZWNpbWFsUGxhY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkLnJlcGxhY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmUxKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UocmUxLCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmUyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UocmUyLCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkICogMTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG51bWVyaWMgJ2RlZm9ybWF0dGluZycgZnVuY3Rpb25zIGZvciBzb3J0aW5nIGFuZCBzZWFyY2guIFRoaXMgaXMgZG9uZVxyXG5cdCAgICAgICAgICAgICAgICAvLyBpbiBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgYW4gZWFzeSBhYmlsaXR5IGZvciB0aGUgbGFuZ3VhZ2Ugb3B0aW9ucyB0byBhZGRcclxuXHQgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBtZXRob2RzIGlmIGEgbm9uLXBlcmlvZCBkZWNpbWFsIHBsYWNlIGlzIHVzZWQuXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9hZGROdW1lcmljU29ydChkZWNpbWFsUGxhY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICQuZWFjaChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWluIG51bWJlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJudW1cIjogZnVuY3Rpb24gKGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX251bWVyaWNSZXBsYWNlKGQsIGRlY2ltYWxQbGFjZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXR0ZWQgbnVtYmVyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm51bS1mbXRcIjogZnVuY3Rpb24gKGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX251bWVyaWNSZXBsYWNlKGQsIGRlY2ltYWxQbGFjZSwgX3JlX2Zvcm1hdHRlZF9udW1lcmljKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUTUwgbnVtZXJpY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0bWwtbnVtXCI6IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19udW1lcmljUmVwbGFjZShkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhUTUwgbnVtZXJpYywgZm9ybWF0dGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHRtbC1udW0tZm10XCI6IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19udW1lcmljUmVwbGFjZShkLCBkZWNpbWFsUGxhY2UsIF9yZV9odG1sLCBfcmVfZm9ybWF0dGVkX251bWVyaWMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoa2V5LCBmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG9yZGVyaW5nIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXh0LnR5cGUub3JkZXJba2V5ICsgZGVjaW1hbFBsYWNlICsgJy1wcmUnXSA9IGZuO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIEhUTUwgdHlwZXMgYWRkIGEgc2VhcmNoIGZvcm1hdHRlciB0aGF0IHdpbGwgc3RyaXAgdGhlIEhUTUxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5tYXRjaCgvXmh0bWxcXC0vKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4dC50eXBlLnNlYXJjaFtrZXkgKyBkZWNpbWFsUGxhY2VdID0gX2V4dC50eXBlLnNlYXJjaC5odG1sO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgc29ydCBtZXRob2RzXHJcblx0ICAgICAgICAgICAgICAgICQuZXh0ZW5kKF9leHQudHlwZS5vcmRlciwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRGF0ZXNcclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZGF0ZS1wcmVcIjogZnVuY3Rpb24gKGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5wYXJzZShkKSB8fCAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBodG1sXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImh0bWwtcHJlXCI6IGZ1bmN0aW9uIChhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbXB0eShhKSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5yZXBsYWNlID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucmVwbGFjZSgvPC4qPz4vZywgXCJcIikudG9Mb3dlckNhc2UoKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhICsgJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmctcHJlXCI6IGZ1bmN0aW9uIChhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGxpdHRsZSBjb21wbGV4LCBidXQgZmFzdGVyIHRoYW4gYWx3YXlzIGNhbGxpbmcgdG9TdHJpbmcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vdG9zdHJpbmctdi1jaGVja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoYSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBhID09PSAnc3RyaW5nJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnRvTG93ZXJDYXNlKCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWEudG9TdHJpbmcgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnRvU3RyaW5nKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy1hc2MgYW5kIC1kZXNjIGFyZSByZXRhaW5lZCBvbmx5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG9sZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc29ydCBtZXRob2RzXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInN0cmluZy1hc2NcIjogZnVuY3Rpb24gKHgsIHkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmctZGVzY1wiOiBmdW5jdGlvbiAoeCwgeSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHggPCB5KSA/IDEgOiAoKHggPiB5KSA/IC0xIDogMCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBOdW1lcmljIHNvcnRpbmcgdHlwZXMgLSBvcmRlciBkb2Vzbid0IG1hdHRlciBoZXJlXHJcblx0ICAgICAgICAgICAgICAgIF9hZGROdW1lcmljU29ydCgnJyk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgRGF0YVRhYmxlLmV4dC5yZW5kZXJlciwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXzogZnVuY3Rpb24gKHNldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gYWRkaXRpb25hbCBtYXJrLXVwIHJlcXVpcmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gdXBkYXRlIG9uIHNvcnQgLSBub3RlIHRoYXQgdXNpbmcgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBEVGAgbmFtZXNwYWNlIHdpbGwgYWxsb3cgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWQgYXV0b21hdGljYWxseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbiBkZXN0cm95LCB3aGlsZSB0aGUgYGR0YCBuYW1lc3BhY2VkIGV2ZW50IGlzIHRoZSBvbmUgd2UgYXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChzZXR0aW5ncy5uVGFibGUpLm9uKCdvcmRlci5kdC5EVCcsIGZ1bmN0aW9uIChlLCBjdHgsIHNvcnRpbmcsIGNvbHVtbnMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncyAhPT0gY3R4KSB7IC8vIG5lZWQgdG8gY2hlY2sgdGhpcyB0aGlzIGlzIHRoZSBob3N0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgICAgICAgICAgICAgIC8vIHRhYmxlLCBub3QgYSBuZXN0ZWQgb25lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbElkeCA9IGNvbHVtbi5pZHg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNTb3J0aW5nQ2xhc3MgKyAnICcgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0QXNjICsgJyAnICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydERlc2NcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGNvbHVtbnNbY29sSWR4XSA9PSAnYXNjJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRBc2MgOiBjb2x1bW5zW2NvbElkeF0gPT0gJ2Rlc2MnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnREZXNjIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zU29ydGluZ0NsYXNzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganF1ZXJ5dWk6IGZ1bmN0aW9uIChzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJzxkaXYvPicpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoY2xhc3Nlcy5zU29ydEpVSVdyYXBwZXIpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGNlbGwuY29udGVudHMoKSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPHNwYW4vPicpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGNsYXNzZXMuc1NvcnRJY29uICsgJyAnICsgY29sdW1uLnNTb3J0aW5nQ2xhc3NKVUkpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY2VsbCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIHVwZGF0ZSBvbiBzb3J0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS5vbignb3JkZXIuZHQuRFQnLCBmdW5jdGlvbiAoZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sSWR4ID0gY29sdW1uLmlkeDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKGNsYXNzZXMuc1NvcnRBc2MgKyBcIiBcIiArIGNsYXNzZXMuc1NvcnREZXNjKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjb2x1bW5zW2NvbElkeF0gPT0gJ2FzYycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1tjb2xJZHhdID09ICdkZXNjJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0RGVzYyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1NvcnRpbmdDbGFzc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKCdzcGFuLicgKyBjbGFzc2VzLnNTb3J0SWNvbilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRKVUlBc2MgKyBcIiBcIiArXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRKVUlEZXNjICsgXCIgXCIgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJICsgXCIgXCIgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZCArIFwiIFwiICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjb2x1bW5zW2NvbElkeF0gPT0gJ2FzYycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJQXNjIDogY29sdW1uc1tjb2xJZHhdID09ICdkZXNjJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJRGVzYyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBQdWJsaWMgaGVscGVyIGZ1bmN0aW9ucy4gVGhlc2UgYXJlbid0IHVzZWQgaW50ZXJuYWxseSBieSBEYXRhVGFibGVzLCBvclxyXG5cdCAgICAgICAgICAgICAgICAgKiBjYWxsZWQgYnkgYW55IG9mIHRoZSBvcHRpb25zIHBhc3NlZCBpbnRvIERhdGFUYWJsZXMsIGJ1dCB0aGV5IGNhbiBiZSB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAqIGV4dGVybmFsbHkgYnkgZGV2ZWxvcGVycyB3b3JraW5nIHdpdGggRGF0YVRhYmxlcy4gVGhleSBhcmUgaGVscGVyIGZ1bmN0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgKiB0byBtYWtlIHdvcmtpbmcgd2l0aCBEYXRhVGFibGVzIGEgbGl0dGxlIGJpdCBlYXNpZXIuXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEhlbHBlcnMgZm9yIGBjb2x1bW5zLnJlbmRlcmAuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoZSBvcHRpb25zIGRlZmluZWQgaGVyZSBjYW4gYmUgdXNlZCB3aXRoIHRoZSBgY29sdW1ucy5yZW5kZXJgIGluaXRpYWxpc2F0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqIG9wdGlvbiB0byBwcm92aWRlIGEgZGlzcGxheSByZW5kZXJlci4gVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIGRlZmluZWQ6XHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICogYG51bWJlcmAgLSBXaWxsIGZvcm1hdCBudW1lcmljIGRhdGEgKGRlZmluZWQgYnkgYGNvbHVtbnMuZGF0YWApIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIGRpc3BsYXksIHJldGFpbmluZyB0aGUgb3JpZ2luYWwgdW5mb3JtYXR0ZWQgZGF0YSBmb3Igc29ydGluZyBhbmQgZmlsdGVyaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIEl0IHRha2VzIDQgcGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBzdHJpbmdgIC0gVGhvdXNhbmRzIGdyb3VwaW5nIHNlcGFyYXRvclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICogYHN0cmluZ2AgLSBEZWNpbWFsIHBvaW50IGluZGljYXRvclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICogYGludGVnZXJgIC0gTnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRvIHNob3dcclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQcmVmaXguXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgLy8gQ29sdW1uIGRlZmluaXRpb24gdXNpbmcgdGhlIG51bWJlciByZW5kZXJlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHtcclxuXHQgICAgICAgICAgICAgICAgICogICAgIGRhdGE6IFwic2FsYXJ5XCIsXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICByZW5kZXI6ICQuZm4uZGF0YVRhYmxlLnJlbmRlci5udW1iZXIoICdcXCcnLCAnLicsIDAsICckJyApXHJcblx0ICAgICAgICAgICAgICAgICAqICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUucmVuZGVyID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAodGhvdXNhbmRzLCBkZWNpbWFsLCBwcmVjaXNpb24sIHByZWZpeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGQgIT09ICdudW1iZXInICYmIHR5cGVvZiBkICE9PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZWdhdGl2ZSA9IGQgPCAwID8gJy0nIDogJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gTWF0aC5hYnMocGFyc2VGbG9hdChkKSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludFBhcnQgPSBwYXJzZUludChkLCAxMCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmxvYXRQYXJ0ID0gcHJlY2lzaW9uID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNpbWFsICsgKGQgLSBpbnRQYXJ0KS50b0ZpeGVkKHByZWNpc2lvbikuc3Vic3RyaW5nKDIpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgKyAocHJlZml4IHx8ICcnKSArXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50UGFydC50b1N0cmluZygpLnJlcGxhY2UoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCB0aG91c2FuZHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdFBhcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgcmVhbGx5IGEgZ29vZCBiaXQgcnViYmlzaCB0aGlzIG1ldGhvZCBvZiBleHBvc2luZyB0aGUgaW50ZXJuYWwgbWV0aG9kc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBwdWJsaWNseS4uLiAtIFRvIGJlIGZpeGVkIGluIDIuMCB1c2luZyBtZXRob2RzIG9uIHRoZSBwcm90b3R5cGVcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENyZWF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIGV4cG9ydGluZyBhbiBpbnRlcm5hbCBmdW5jdGlvbnMgdG8gYW4gZXh0ZXJuYWwgQVBJLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IGZuIEFQSSBmdW5jdGlvbiBuYW1lXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7ZnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjaW50ZXJuYWxcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkV4dGVybkFwaUZ1bmMoZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbX2ZuU2V0dGluZ3NGcm9tTm9kZSh0aGlzW0RhdGFUYWJsZS5leHQuaUFwaUluZGV4XSldLmNvbmNhdChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERhdGFUYWJsZS5leHQuaW50ZXJuYWxbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGZvciB1c2UgYnkgcGx1Zy1pbiBkZXZlbG9wZXJzLiBOb3RlIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICogdGhlc2UgbWV0aG9kcyBhcmUgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIGFyZSBjb25zaWRlcmVkIHRvIGJlXHJcblx0ICAgICAgICAgICAgICAgICAqIHByaXZhdGUuIElmIHlvdSB1c2UgdGhlc2UgbWV0aG9kcywgYmUgYXdhcmUgdGhhdCB0aGV5IGFyZSBsaWFibGUgdG8gY2hhbmdlXHJcblx0ICAgICAgICAgICAgICAgICAqIGJldHdlZW4gdmVyc2lvbnMuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0LmludGVybmFsLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5FeHRlcm5BcGlGdW5jOiBfZm5FeHRlcm5BcGlGdW5jLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQnVpbGRBamF4OiBfZm5CdWlsZEFqYXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5BamF4VXBkYXRlOiBfZm5BamF4VXBkYXRlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWpheFBhcmFtZXRlcnM6IF9mbkFqYXhQYXJhbWV0ZXJzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWpheFVwZGF0ZURyYXc6IF9mbkFqYXhVcGRhdGVEcmF3LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWpheERhdGFTcmM6IF9mbkFqYXhEYXRhU3JjLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWRkQ29sdW1uOiBfZm5BZGRDb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5PcHRpb25zOiBfZm5Db2x1bW5PcHRpb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWRqdXN0Q29sdW1uU2l6aW5nOiBfZm5BZGp1c3RDb2x1bW5TaXppbmcsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleDogX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZTogX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5WaXNibGVDb2x1bW5zOiBfZm5WaXNibGVDb2x1bW5zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuR2V0Q29sdW1uczogX2ZuR2V0Q29sdW1ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtblR5cGVzOiBfZm5Db2x1bW5UeXBlcyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFwcGx5Q29sdW1uRGVmczogX2ZuQXBwbHlDb2x1bW5EZWZzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwOiBfZm5IdW5nYXJpYW5NYXAsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuOiBfZm5DYW1lbFRvSHVuZ2FyaWFuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuTGFuZ3VhZ2VDb21wYXQ6IF9mbkxhbmd1YWdlQ29tcGF0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQnJvd3NlckRldGVjdDogX2ZuQnJvd3NlckRldGVjdCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFkZERhdGE6IF9mbkFkZERhdGEsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5BZGRUcjogX2ZuQWRkVHIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Ob2RlVG9EYXRhSW5kZXg6IF9mbk5vZGVUb0RhdGFJbmRleCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbk5vZGVUb0NvbHVtbkluZGV4OiBfZm5Ob2RlVG9Db2x1bW5JbmRleCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkdldENlbGxEYXRhOiBfZm5HZXRDZWxsRGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNldENlbGxEYXRhOiBfZm5TZXRDZWxsRGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNwbGl0T2JqTm90YXRpb246IF9mblNwbGl0T2JqTm90YXRpb24sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5HZXRPYmplY3REYXRhRm46IF9mbkdldE9iamVjdERhdGFGbixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNldE9iamVjdERhdGFGbjogX2ZuU2V0T2JqZWN0RGF0YUZuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuR2V0RGF0YU1hc3RlcjogX2ZuR2V0RGF0YU1hc3RlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNsZWFyVGFibGU6IF9mbkNsZWFyVGFibGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5EZWxldGVJbmRleDogX2ZuRGVsZXRlSW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5JbnZhbGlkYXRlOiBfZm5JbnZhbGlkYXRlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuR2V0Um93RWxlbWVudHM6IF9mbkdldFJvd0VsZW1lbnRzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ3JlYXRlVHI6IF9mbkNyZWF0ZVRyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQnVpbGRIZWFkOiBfZm5CdWlsZEhlYWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5EcmF3SGVhZDogX2ZuRHJhd0hlYWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5EcmF3OiBfZm5EcmF3LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3OiBfZm5SZURyYXcsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5BZGRPcHRpb25zSHRtbDogX2ZuQWRkT3B0aW9uc0h0bWwsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5EZXRlY3RIZWFkZXI6IF9mbkRldGVjdEhlYWRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkdldFVuaXF1ZVRoczogX2ZuR2V0VW5pcXVlVGhzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxGaWx0ZXI6IF9mbkZlYXR1cmVIdG1sRmlsdGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ29tcGxldGU6IF9mbkZpbHRlckNvbXBsZXRlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ3VzdG9tOiBfZm5GaWx0ZXJDdXN0b20sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDb2x1bW46IF9mbkZpbHRlckNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlcjogX2ZuRmlsdGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoOiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Fc2NhcGVSZWdleDogX2ZuRXNjYXBlUmVnZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXJEYXRhOiBfZm5GaWx0ZXJEYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxJbmZvOiBfZm5GZWF0dXJlSHRtbEluZm8sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5VcGRhdGVJbmZvOiBfZm5VcGRhdGVJbmZvLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuSW5mb01hY3JvczogX2ZuSW5mb01hY3JvcyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkluaXRpYWxpc2U6IF9mbkluaXRpYWxpc2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Jbml0Q29tcGxldGU6IF9mbkluaXRDb21wbGV0ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkxlbmd0aENoYW5nZTogX2ZuTGVuZ3RoQ2hhbmdlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxMZW5ndGg6IF9mbkZlYXR1cmVIdG1sTGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZTogX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblBhZ2VDaGFuZ2U6IF9mblBhZ2VDaGFuZ2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmc6IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5OiBfZm5Qcm9jZXNzaW5nRGlzcGxheSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sVGFibGU6IF9mbkZlYXR1cmVIdG1sVGFibGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5TY3JvbGxEcmF3OiBfZm5TY3JvbGxEcmF3LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuOiBfZm5BcHBseVRvQ2hpbGRyZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHM6IF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblRocm90dGxlOiBfZm5UaHJvdHRsZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbnZlcnRUb1dpZHRoOiBfZm5Db252ZXJ0VG9XaWR0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNjcm9sbGluZ1dpZHRoQWRqdXN0OiBfZm5TY3JvbGxpbmdXaWR0aEFkanVzdCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkdldFdpZGVzdE5vZGU6IF9mbkdldFdpZGVzdE5vZGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5HZXRNYXhMZW5TdHJpbmc6IF9mbkdldE1heExlblN0cmluZyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblN0cmluZ1RvQ3NzOiBfZm5TdHJpbmdUb0NzcyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNjcm9sbEJhcldpZHRoOiBfZm5TY3JvbGxCYXJXaWR0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNvcnRGbGF0dGVuOiBfZm5Tb3J0RmxhdHRlbixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNvcnQ6IF9mblNvcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0QXJpYTogX2ZuU29ydEFyaWEsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0TGlzdGVuZXI6IF9mblNvcnRMaXN0ZW5lcixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNvcnRBdHRhY2hMaXN0ZW5lcjogX2ZuU29ydEF0dGFjaExpc3RlbmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuU29ydGluZ0NsYXNzZXM6IF9mblNvcnRpbmdDbGFzc2VzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuU29ydERhdGE6IF9mblNvcnREYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuU2F2ZVN0YXRlOiBfZm5TYXZlU3RhdGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Mb2FkU3RhdGU6IF9mbkxvYWRTdGF0ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNldHRpbmdzRnJvbU5vZGU6IF9mblNldHRpbmdzRnJvbU5vZGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Mb2c6IF9mbkxvZyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbk1hcDogX2ZuTWFwLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQmluZEFjdGlvbjogX2ZuQmluZEFjdGlvbixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnOiBfZm5DYWxsYmFja1JlZyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZTogX2ZuQ2FsbGJhY2tGaXJlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3c6IF9mbkxlbmd0aE92ZXJmbG93LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuUmVuZGVyZXI6IF9mblJlbmRlcmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRGF0YVNvdXJjZTogX2ZuRGF0YVNvdXJjZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblJvd0F0dHJpYnV0ZXM6IF9mblJvd0F0dHJpYnV0ZXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxjdWxhdGVFbmQ6IGZ1bmN0aW9uICgpIHsgfSAvLyBVc2VkIGJ5IGEgbG90IG9mIHBsdWctaW5zLCBidXQgcmVkdW5kYW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBpbiAxLjEwLCBzbyB0aGlzIGRlYWQtZW5kIGZ1bmN0aW9uIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBhZGRlZCB0byBwcmV2ZW50IGVycm9yc1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBqUXVlcnkgYWNjZXNzXHJcblx0ICAgICAgICAgICAgICAgICQuZm4uZGF0YVRhYmxlID0gRGF0YVRhYmxlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gTGVnYWN5IGFsaWFzZXNcclxuXHQgICAgICAgICAgICAgICAgJC5mbi5kYXRhVGFibGVTZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcclxuXHQgICAgICAgICAgICAgICAgJC5mbi5kYXRhVGFibGVFeHQgPSBEYXRhVGFibGUuZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gV2l0aCBhIGNhcGl0YWwgYERgIHdlIHJldHVybiBhIERhdGFUYWJsZXMgQVBJIGluc3RhbmNlIHJhdGhlciB0aGFuIGFcclxuXHQgICAgICAgICAgICAgICAgLy8galF1ZXJ5IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAkLmZuLkRhdGFUYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5kYXRhVGFibGUob3B0cykuYXBpKCk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBBbGwgcHJvcGVydGllcyB0aGF0IGFyZSBhdmFpbGFibGUgdG8gJC5mbi5kYXRhVGFibGUgc2hvdWxkIGFsc28gYmVcclxuXHQgICAgICAgICAgICAgICAgLy8gYXZhaWxhYmxlIG9uICQuZm4uRGF0YVRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICQuZWFjaChEYXRhVGFibGUsIGZ1bmN0aW9uIChwcm9wLCB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICQuZm4uRGF0YVRhYmxlW3Byb3BdID0gdmFsO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBJbmZvcm1hdGlvbiBhYm91dCBldmVudHMgZmlyZWQgYnkgRGF0YVRhYmxlcyAtIGZvciBkb2N1bWVudGF0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRHJhdyBldmVudCwgZmlyZWQgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIHJlZHJhd24gb24gdGhlIHBhZ2UsIGF0IHRoZSBzYW1lXHJcblx0ICAgICAgICAgICAgICAgICAqIHBvaW50IGFzIGZuRHJhd0NhbGxiYWNrLiBUaGlzIG1heSBiZSB1c2VmdWwgZm9yIGJpbmRpbmcgZXZlbnRzIG9yXHJcblx0ICAgICAgICAgICAgICAgICAqIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zIHdoZW4gdGhlIHRhYmxlIGlzIGFsdGVyZWQgYXQgYWxsLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI2RyYXcuZHRcclxuXHQgICAgICAgICAgICAgICAgICogIEBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFNlYXJjaCBldmVudCwgZmlyZWQgd2hlbiB0aGUgc2VhcmNoaW5nIGFwcGxpZWQgdG8gdGhlIHRhYmxlICh1c2luZyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogYnVpbHQtaW4gZ2xvYmFsIHNlYXJjaCwgb3IgY29sdW1uIGZpbHRlcnMpIGlzIGFsdGVyZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjc2VhcmNoLmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBQYWdlIGNoYW5nZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgcGFnaW5nIG9mIHRoZSB0YWJsZSBpcyBhbHRlcmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI3BhZ2UuZHRcclxuXHQgICAgICAgICAgICAgICAgICogIEBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIE9yZGVyIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBvcmRlcmluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSBpcyBhbHRlcmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI29yZGVyLmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIGluaXRpYWxpc2F0aW9uIGNvbXBsZXRlIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBpcyBmdWxseVxyXG5cdCAgICAgICAgICAgICAgICAgKiBkcmF3biwgaW5jbHVkaW5nIEFqYXggZGF0YSBsb2FkZWQsIGlmIEFqYXggZGF0YSBpcyByZXF1aXJlZC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNpbml0LmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIEpTT04gb2JqZWN0IHJlcXVlc3QgZnJvbSB0aGUgc2VydmVyIC0gb25seVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBwcmVzZW50IGlmIGNsaWVudC1zaWRlIEFqYXggc291cmNlZCBkYXRhIGlzIHVzZWQ8L2xpPjwvb2w+XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFN0YXRlIHNhdmUgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHRhYmxlIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmVcclxuXHQgICAgICAgICAgICAgICAgICogaXMgcmVxdWlyZWQuIFRoaXMgZXZlbnQgYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc3RhdGUgc2F2aW5nIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiBwcmlvciB0byBhY3R1YWxseSBkb2luZyB0aGUgc2F2ZSwgaW5jbHVkaW5nIGFkZGl0aW9uIG9yIG90aGVyIHN0YXRlXHJcblx0ICAgICAgICAgICAgICAgICAqIHByb3BlcnRpZXMgKGZvciBwbHVnLWlucykgb3IgbW9kaWZpY2F0aW9uIG9mIGEgRGF0YVRhYmxlcyBjb3JlIHByb3BlcnR5LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI3N0YXRlU2F2ZVBhcmFtcy5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBzdGF0ZSBpbmZvcm1hdGlvbiB0byBiZSBzYXZlZFxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBTdGF0ZSBsb2FkIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBkYXRhLCBidXQgcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGVcclxuXHQgICAgICAgICAgICAgICAgICogLSBhbGxvd2luZyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIGlzIHJlcXVpcmVkIG9yIGxvYWRpbmcgb2ZcclxuXHQgICAgICAgICAgICAgICAgICogc3RhdGUgZm9yIGEgcGx1Zy1pbi5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRQYXJhbXMuZHRcclxuXHQgICAgICAgICAgICAgICAgICogIEBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogU3RhdGUgbG9hZGVkIGV2ZW50LCBmaXJlZCB3aGVuIHN0YXRlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHN0b3JlZCBkYXRhIGFuZFxyXG5cdCAgICAgICAgICAgICAgICAgKiB0aGUgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIG1vZGlmaWVkIGJ5IHRoZSBsb2FkZWQgZGF0YS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRlZC5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBzYXZlZCBzdGF0ZSBpbmZvcm1hdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBQcm9jZXNzaW5nIGV2ZW50LCBmaXJlZCB3aGVuIERhdGFUYWJsZXMgaXMgZG9pbmcgc29tZSBraW5kIG9mIHByb2Nlc3NpbmdcclxuXHQgICAgICAgICAgICAgICAgICogKGJlIGl0LCBvcmRlciwgc2VhcmNnIG9yIGFueXRoaW5nIGVsc2UpLiBJdCBjYW4gYmUgdXNlZCB0byBpbmRpY2F0ZSB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiB0aGUgZW5kIHVzZXIgdGhhdCB0aGVyZSBpcyBzb21ldGhpbmcgaGFwcGVuaW5nLCBvciB0aGF0IHNvbWV0aGluZyBoYXNcclxuXHQgICAgICAgICAgICAgICAgICogZmluaXNoZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjcHJvY2Vzc2luZy5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gYlNob3cgRmxhZyBmb3IgaWYgRGF0YVRhYmxlcyBpcyBkb2luZyBwcm9jZXNzaW5nIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBamF4IChYSFIpIGV2ZW50LCBmaXJlZCB3aGVuZXZlciBhbiBBamF4IHJlcXVlc3QgaXMgY29tcGxldGVkIGZyb20gYVxyXG5cdCAgICAgICAgICAgICAgICAgKiByZXF1ZXN0IHRvIG1hZGUgdG8gdGhlIHNlcnZlciBmb3IgbmV3IGRhdGEuIFRoaXMgZXZlbnQgaXMgY2FsbGVkIGJlZm9yZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIHByb2Nlc3NlZCB0aGUgcmV0dXJuZWQgZGF0YSwgc28gaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcmUtXHJcblx0ICAgICAgICAgICAgICAgICAqIHByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCBpZiBuZWVkZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHRyaWdnZXIgaXMgY2FsbGVkIGluIGBmblNlcnZlckRhdGFgLCBpZiB5b3Ugb3ZlcnJpZGVcclxuXHQgICAgICAgICAgICAgICAgICogYGZuU2VydmVyRGF0YWAgYW5kIHdoaWNoIHRvIHVzZSB0aGlzIGV2ZW50LCB5b3UgbmVlZCB0byB0cmlnZ2VyIGl0IGluIHlvdVxyXG5cdCAgICAgICAgICAgICAgICAgKiBzdWNjZXNzIGZ1bmN0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI3hoci5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgLy8gVXNlIGEgY3VzdG9tIHByb3BlcnR5IHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiBhbm90aGVyIERPTSBlbGVtZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAkKCcjdGFibGUnKS5kYXRhVGFibGUoKS5vbigneGhyLmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBqc29uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICQoJyNzdGF0dXMnKS5odG1sKCBqc29uLnN0YXR1cyApO1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAgIC8vIFByZS1wcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgJCgnI3RhYmxlJykuZGF0YVRhYmxlKCkub24oJ3hoci5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5hYURhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAganNvbi5hYURhdGFbaV0uc3VtID0ganNvbi5hYURhdGFbaV0ub25lICsganNvbi5hYURhdGFbaV0udHdvO1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgIC8vIE5vdGUgbm8gcmV0dXJuIC0gbWFuaXB1bGF0ZSB0aGUgZGF0YSBkaXJlY3RseSBpbiB0aGUgSlNPTiBvYmplY3QuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERlc3Ryb3kgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIERhdGFUYWJsZSBpcyBkZXN0cm95ZWQgYnkgY2FsbGluZyBmbkRlc3Ryb3lcclxuXHQgICAgICAgICAgICAgICAgICogb3IgcGFzc2luZyB0aGUgYkRlc3Ryb3k6dHJ1ZSBwYXJhbWV0ZXIgaW4gdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdC4gVGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBjYW4gYmUgdXNlZCB0byByZW1vdmUgYm91bmQgZXZlbnRzLCBhZGRlZCBET00gbm9kZXMsIGV0Yy5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNkZXN0cm95LmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBQYWdlIGxlbmd0aCBjaGFuZ2UgZXZlbnQsIGZpcmVkIHdoZW4gbnVtYmVyIG9mIHJlY29yZHMgdG8gc2hvdyBvbiBlYWNoXHJcblx0ICAgICAgICAgICAgICAgICAqIHBhZ2UgKHRoZSBsZW5ndGgpIGlzIGNoYW5nZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjbGVuZ3RoLmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnRlZ2VyfSBsZW4gTmV3IGxlbmd0aFxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb2x1bW4gc2l6aW5nIGhhcyBjaGFuZ2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI2NvbHVtbi1zaXppbmcuZHRcclxuXHQgICAgICAgICAgICAgICAgICogIEBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENvbHVtbiB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI2NvbHVtbi12aXNpYmlsaXR5LmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbHVtbiBDb2x1bW4gaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gdmlzIGBmYWxzZWAgaWYgY29sdW1uIG5vdyBoaWRkZW4sIG9yIGB0cnVlYCBpZiB2aXNpYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICQuZm4uZGF0YVRhYmxlO1xyXG5cdCAgICAgICAgICAgIH0pKTtcclxuXHJcblx0ICAgICAgICB9KHdpbmRvdywgZG9jdW1lbnQpKTtcclxuXHQgICAgICAgICAgICAgICBcclxuXHQgICAgfSxcclxuXHQgICAgUnVuRGF0YVRhYmxlOiBmdW5jdGlvbiAoQ1NTaWRzZWxlY3Rvcikge1xyXG5cclxuXHQgICAgICAgIHRoaXMuanF1ZXJ5VGFibGVJbml0KCk7XHJcblxyXG5cdCAgICAgICAgJChDU1NpZHNlbGVjdG9yKS5EYXRhVGFibGUoe1xyXG5cdCAgICAgICAgICAgIFwibGFuZ3VhZ2VcIjogc3ZsYW5ndWFnZVNldHRpbmdzXHJcblx0ICAgICAgICB9KTtcclxuXHJcblx0ICAgIH1cclxuXHR9XHJcblxyXG5cdGxldCBzdmxhbmd1YWdlU2V0dGluZ3MgPSB7XHJcblx0ICAgIFwic0VtcHR5VGFibGVcIjogXCJUYWJlbGxlbiBpbm5laFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyMjkpICsgXCJsbGVyIGluZ2VuIGRhdGFcIixcclxuXHQgICAgXCJzSW5mb1wiOiBcIlZpc2FyIF9TVEFSVF8gdGlsbCBfRU5EXyBhdiB0b3RhbHQgX1RPVEFMXyByYWRlclwiLFxyXG5cdCAgICBcInNJbmZvRW1wdHlcIjogXCJWaXNhciAwIHRpbGwgMCBhdiB0b3RhbHQgMCByYWRlclwiLFxyXG5cdCAgICBcInNJbmZvRmlsdGVyZWRcIjogXCIoZmlsdHJlcmFkZSBmclwiICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyMjkpICsgXCJuIHRvdGFsdCBfTUFYXyByYWRlcilcIixcclxuXHQgICAgXCJzSW5mb1Bvc3RGaXhcIjogXCJcIixcclxuXHQgICAgXCJzSW5mb1Rob3VzYW5kc1wiOiBcIiBcIixcclxuXHQgICAgXCJzTGVuZ3RoTWVudVwiOiBcIlZpc2EgX01FTlVfIHJhZGVyXCIsXHJcblx0ICAgIFwic0xvYWRpbmdSZWNvcmRzXCI6IFwiTGFkZGFyLi4uXCIsXHJcblx0ICAgIFwic1Byb2Nlc3NpbmdcIjogXCJCZWFyYmV0YXIuLi5cIixcclxuXHQgICAgXCJzU2VhcmNoXCI6IFwiU1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNDYpICsgXCJrOlwiLFxyXG5cdCAgICBcInNaZXJvUmVjb3Jkc1wiOiBcIkhpdHRhZGUgaW5nYSBtYXRjaGFuZGUgcmVzdWx0YXRcIixcclxuXHQgICAgXCJvUGFnaW5hdGVcIjoge1xyXG5cdCAgICAgICAgXCJzRmlyc3RcIjogXCJGXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI0NikgKyBcInJzdGFcIixcclxuXHQgICAgICAgIFwic0xhc3RcIjogXCJTaXN0YVwiLFxyXG5cdCAgICAgICAgXCJzTmV4dFwiOiBcIk5cIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjI4KSArIFwic3RhXCIsXHJcblx0ICAgICAgICBcInNQcmV2aW91c1wiOiBcIkZcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjQ2KSArIFwicmVnXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDIyOSkgKyBcImVuZGVcIlxyXG5cdCAgICB9LFxyXG5cdCAgICBcIm9BcmlhXCI6IHtcclxuXHQgICAgICAgIFwic1NvcnRBc2NlbmRpbmdcIjogXCI6IGFrdGl2ZXJhIGZcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjQ2KSArIFwiciBhdHQgc29ydGVyYSBrb2x1bW5lbiBpIHN0aWdhbmRlIG9yZG5pbmdcIixcclxuXHQgICAgICAgIFwic1NvcnREZXNjZW5kaW5nXCI6IFwiOiBha3RpdmVyYSBmXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI0NikgKyBcInIgYXR0IHNvcnRlcmEga29sdW1uZW4gaSBmYWxsYW5kZSBvcmRuaW5nXCJcclxuXHQgICAgfVxyXG5cdH07XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGxldCBmaWxsb2JqID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHRsZXQgc2VydmljZWNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdGxldCAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY2FjaGVEb20oKTtcclxuXHQgICAgICAgIHRoaXMuYmluZEV2ZW50KCk7XHJcblx0ICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBjYWNoZURvbTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy4kYm9keSA9ICQoJ2JvZHknKTtcclxuXHQgICAgICAgIHRoaXMuJGJiX2FqX2FwcHJvdmUgPSAkKFwiLmJiX2FqX2FwcHJvdmVcIik7XHJcblx0ICAgICAgICB0aGlzLiRiYl9hal9tb2RhbENvbnRhaW5lciA9ICQoXCIjYmJfYWpfbW9kYWxDb250YWluZXJcIik7XHJcblx0ICAgIH0sXHJcblx0ICAgIGJpbmRFdmVudDogZnVuY3Rpb24gKHVzZXJpZCkge1xyXG5cdCAgICAgICAgbGV0IHRoYXQgPSB0aGlzO1xyXG5cdCAgICAgICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnLmJiX2FqX2FwcHJvdmUnLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgIGxldCBpZCA9ICQodGhpcykuYXR0cignZGF0YS10aXBpZCcpO1xyXG5cdCAgICAgICAgICAgIGZpbGxvYmouZ2V0Q3VycmVudEl0ZW0oaWQpO1xyXG5cdCAgICAgICAgICAgIHRoYXQuJGJiX2FqX21vZGFsQ29udGFpbmVyLnNob3coKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsICcuYmJfYWpfZGVsZXRlJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgaWQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtdGlwaWQnKTtcclxuXHQgICAgICAgICAgICBmaWxsb2JqLmRlbGV0ZWl0ZW1Cb3goaWQpO1xyXG5cdCAgICAgICAgICAgIHRoYXQuJGJiX2FqX21vZGFsQ29udGFpbmVyLnNob3coKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgXHJcblx0ICAgICAgICB0aGlzLiRib2R5Lm9uKCdjaGFuZ2UnLCAnLmJiX2FqX3ZhbHRib2t0aXBzJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgaWQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtdGlwaWQnKTtcclxuXHQgICAgICAgICAgICBsZXQgdmFsID0gMDtcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jaGVja2VkKSB7XHJcblx0ICAgICAgICAgICAgICAgdmFsID0gMTsgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHNlcnZpY2VjYWxsLmFwcHJvdmV0aXAoaWQsIHZhbCkpIHtcclxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhcHByb3ZlZCBqc29uXCIpO1xyXG5cdCAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICQodGhpcykudmFsKHRoaXMuY2hlY2tlZCk7IFxyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJyNiYl9hal9TYXZlRWRpdFRvU2VydmVyJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgaWQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtdGlwaWQnKTsgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBsZXQgcnViID0gJChcIiNiYl9hal9jdXJfdGl0bGVcIikudmFsKCk7XHJcblxyXG5cdCAgICAgICAgICAgIGZpbGxvYmouc2F2ZWl0ZW1Cb3goaWQscnViKTtcclxuXHQgICAgICAgICAgICB0aGF0LiRiYl9hal9tb2RhbENvbnRhaW5lci5zaG93KCk7XHJcblx0ICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsICcuYmJfYWpfY2xvc2VNb2RhbCcsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgdGhhdC4kYmJfYWpfbW9kYWxDb250YWluZXIuaGlkZSgpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICBcclxuXHQgICAgfSxcclxuXHQgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdCAgICB9XHJcblx0fVxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRsZXQgX2hoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KVxyXG5cdGxldCBlZHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cdGxldCBhcHBzZXR0aW5nc29iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0bGV0IGFwcHNldHRpbmdzID0gYXBwc2V0dGluZ3NvYmplY3QuY29uZmlnO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgICAgXHJcblx0ICAgIGdldEN1cnJlbnRJdGVtOiBmdW5jdGlvbiAoaWQpIHtcclxuXHQgICAgICAgIGxldCBfY3VycmVudG9iaiA9IGFwcHNldHRpbmdzLmRhdGFzZXQuY3VycmVudGRhdGFsaXN0O1xyXG5cclxuXHQgICAgICAgIGxldCBjdXJyb2JqID0gX2N1cnJlbnRvYmouQm9rdGlwcy5maWx0ZXIoaXRlbSA9PiBpdGVtLlRpcElEID09IGlkKTtcclxuXHQgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICBfaGguaW5qZWN0aHRtbHRlbXBsYXRlKFwiI2JiX2FqX21vZGFsQ29udGFpbmVyXCIsIGFwcHNldHRpbmdzLmhhbmRsZWJhcnRlbXBsYXRlLmhiX2VkaXRvcl90bXAsIGN1cnJvYmosIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICBlZHQucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgZWR0LmluaXQoXCIjYmJfYWpfbW9kYWxib2R5XCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9KTsgICAgICAgICAgICAgXHJcblx0ICAgIH0sXHJcblx0ICAgIHNhdmVpdGVtQm94OiBmdW5jdGlvbiAodGlwaWQsIHJ1Yikge1xyXG5cdCAgICAgICAgbGV0IG9iaiA9IHsgXCJUaXBJRFwiOiB0aXBpZCwgXCJydWJyaWtcIjogcnVifTtcclxuXHJcblx0ICAgICAgICBfaGguaW5qZWN0aHRtbHRlbXBsYXRlKFwiI2JiX2FqX21vZGFsQ29udGFpbmVyXCIsIGFwcHNldHRpbmdzLmhhbmRsZWJhcnRlbXBsYXRlLmhiX3NhdmVib3hfdG1wLCBvYmosIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICB9LFxyXG5cdCAgICBkZWxldGVpdGVtQm94OiBmdW5jdGlvbiAodGlwaWQpIHtcclxuXHQgICAgICAgIGxldCBvYmogPSB7IFwiVGlwSURcIjogdGlwaWQgfTtcclxuXHJcblx0ICAgICAgICBfaGguaW5qZWN0aHRtbHRlbXBsYXRlKFwiI2JiX2FqX21vZGFsQ29udGFpbmVyXCIsIGFwcHNldHRpbmdzLmhhbmRsZWJhcnRlbXBsYXRlLmhiX2RlbGJveF90bXAsIG9iaiwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgfSk7ICAgIFxyXG5cdCAgICB9LFxyXG5cdCAgICBlZGl0Y29udGVudDogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgLy9lZHQuYWN0aXZlRWRpdG9yLmdldENvbnRlbnQoJycpO1xyXG5cdCAgICB9LFxyXG5cclxuXHR9IC8vZW5kIG1vZHVsZWV4cG9ydFxyXG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgICAgaW5qZWN0aHRtbHRlbXBsYXRlOiBmdW5jdGlvbiAodGFyZ2V0Q2xhc3MsIHVzZXRlbXBsYXRlTmFtZSwgY3VycmVudGRhdGEsIGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICBcclxuXHQgICAgICAgICQuZ2V0KHVzZXRlbXBsYXRlTmFtZSwgZnVuY3Rpb24gKGRhdGEpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGVtcHRwbCA9IEhhbmRsZWJhcnMuY29tcGlsZShkYXRhKTtcclxuXHQgICAgICAgICAgICAkKHRhcmdldENsYXNzKS5odG1sKHRlbXB0cGwoY3VycmVudGRhdGEpKTtcclxuXHQgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG5cdCAgICAgICAgfSwgJ2h0bWwnKTtcclxuXHQgICAgfVxyXG5cdH1cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIF9lZGl0b3JuOiB0aW55TUNFLFxyXG5cdCAgICBpbml0OiBmdW5jdGlvbiAoQ1NTaWRzZWxlY3Rvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgIHRoaXMuX2VkaXRvcm4uaW5pdCh7XHJcblx0ICAgICAgICAgICAgc2VsZWN0b3I6IENTU2lkc2VsZWN0b3IsXHJcblx0ICAgICAgICAgICAgbWVudWJhcjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgdG9vbGJhcjogJ3VuZG8gcmVkbyB8IHN0eWxlc2VsZWN0IHwgYm9sZCBpdGFsaWMgfCBsaW5rIGltYWdlJ1xyXG5cdCAgICAgICAgfSk7XHJcblxyXG5cdCAgICB9LC8vZW5kIGluaXRcclxuXHQgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLl9lZGl0b3JuLnJlbW92ZSgpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5fZWRpdG9ybi5hY3RpdmVFZGl0b3Iuc2V0Q29udGVudCgnJyk7XHJcblx0ICAgIH0sXHJcblx0ICAgIHNldGNvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0ICAgICAgICB0aGlzLl9lZGl0b3JuLmFjdGl2ZUVkaXRvci5zZXRDb250ZW50KGNvbnRlbnQpO1xyXG5cdCAgICB9XHJcblx0fSAvL2VuZCBtb2R1bGVleHBvcnRcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGNvbmZpZzogKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vbGV0IF9hcGlzZXJ2ZXIgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6NTkwMTVcIjtcclxuXHQgICAgICAgIC8vbGV0IF9kbm5VUkwgPSBcImh0dHA6Ly9sb2NhbGRldi5raXZkZXYuc2VcIjtcclxuXHQgICAgICAgIC8vbGV0IF9hcGlzZXJ2ZXIgPSBcImh0dHA6Ly9kZXYxLmJhcm5lbnNiaWJsaW90ZWsuc2U6ODA4MFwiO1xyXG5cdCAgICAgICAgLy9sZXQgX2RublVSTCA9IFwiaHR0cDovL2RldjEuYmFybmVuc2JpYmxpb3Rlay5zZVwiO1xyXG5cdCAgICAgICAgLy9sZXQgX2FwaXNlcnZlciA9IFwiaHR0cDovL2RldjEuYmFybmVuc2JpYmxpb3Rlay5zZTo4MDgwXCI7XHJcblx0ICAgICAgICAvL2xldCBfZG5uVVJMID0gXCJodHRwOi8vbnl0dC5iYXJuZW5zYmlibGlvdGVrLnNlXCI7XHJcblx0ICAgICAgICBsZXQgX2FwaXNlcnZlciA9IFwiaHR0cHM6Ly93d3cyLmJhcm5lbnNiaWJsaW90ZWsuc2VcIjtcclxuXHQgICAgICAgIGxldCBfZG5uVVJMID0gXCJodHRwczovL3d3dy5iYXJuZW5zYmlibGlvdGVrLnNlXCI7XHJcblx0ICAgICAgICBsZXQgX2RldmtleSA9IFwiYWxmXCI7XHJcblx0ICAgICAgICBsZXQgX2FwaWRldmtleWVuZCA9IFwiL2RldmtleS9cIiArIF9kZXZrZXkgKyBcIi8/dHlwZT1qc29ucCZjYWxsYmFjaz0/XCI7XHJcblx0ICAgICAgICBsZXQgX2h0bWx0ZW1wbGF0ZVVSTCA9IFwiL0Rlc2t0b3BNb2R1bGVzL2JiX2FqX0Jva3RpcHNfQWRtaW4vdGVtcGxhdGUvXCI7ICAgICAgICBcclxuXHQgICAgICAgIGxldCBfY3VycmVudGRhdGFsaXN0O1xyXG5cdCAgICAgICAgLy8vLyB0ZW1wbGF0ZVxyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICBsZXQgX2hiX2Jvb2t0aXBMaXN0X3RlbXBsYXRlID0gX2h0bWx0ZW1wbGF0ZVVSTCArIFwidGVtcGxhdGVfZGF0YXRhYmxlUm93LnR4dFwiOyAgIFxyXG5cdCAgICAgICAgbGV0IF9oYl9lZGl0b3JfdGVtcGxhdGUgPSBfaHRtbHRlbXBsYXRlVVJMICsgXCJ0ZW1wbGF0ZV9lZGl0b3IudHh0XCI7IFxyXG5cdCAgICAgICAgbGV0IF9oYl9zYXZlYm94X3RlbXBsYXRlID0gX2h0bWx0ZW1wbGF0ZVVSTCArIFwidGVtcGxhdGVfc2F2ZS50eHRcIjtcclxuXHQgICAgICAgIGxldCBfaGJfZGVsZXRlYm94X3RlbXBsYXRlID0gX2h0bWx0ZW1wbGF0ZVVSTCArIFwidGVtcGxhdGVfdGFib3J0LnR4dFwiO1xyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICAvLyBhbnbDpG5kYXJlbnMgc2VuYXN0ZSBib2t0aXBzXHJcblx0ICAgICAgICBsZXQgX2ZuX2Jvb2t0aXBMaXN0ID0gZnVuY3Rpb24gKHVzZXJpZCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBfYXBpc2VydmVyICsgXCIvQXBpX3YxL2Jva3RpcHMvYnlsYXRlc3QvMS9kZXZrZXkvXCIgKyBfZGV2a2V5ICsgXCIvP3R5cGU9anNvblwiO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgbGV0IF9mbl9ib29rdGlwU2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gX2FwaXNlcnZlciArIFwiL0FwaV92My4xL2Jva3RpcHMvdHlwL2VkaXRib2t0aXBzL2RldmtleS9cIiArIF9kZXZrZXkgKyBcIi8/dHlwZT1qc29ucFwiO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgbGV0IF9mbl9ib29rdGlwRGVsZXRlID0gZnVuY3Rpb24gKCkgeyAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIHJldHVybiBfYXBpc2VydmVyICsgXCIvQXBpX3YzLjEvYm9rdGlwcy90eXAvZGVsZXRlYm9rdGlwcy9kZXZrZXkvXCIgKyBfZGV2a2V5ICsgXCIvP3R5cGU9anNvblwiO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgbGV0IF9mbl9ib29rdGlwQXBwcm92ZSA9IGZ1bmN0aW9uICh0aXBpZCwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIF9hcGlzZXJ2ZXIgKyBcIi9BcGlfdjMuMS9ib2t0aXBzL3R5cC9hcHByb3ZlL3ZhbC9cIiArIHRpcGlkICsgXCIvdHh0dmFsL1wiICsgdmFsICsgXCIvZGV2a2V5L1wiICsgX2RldmtleSArIFwiLz90eXBlPWpzb25cIjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGxldCBfZm5fYm9va3RpcExpc3RUb0Fwcm92ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gX2FwaXNlcnZlciArIFwiL0FwaV92My4xL2Jva3RpcHMvdHlwL3RvYXBwcm92ZS92YWwvMC90eHR2YWwvMC9kZXZrZXkvXCIgKyBfZGV2a2V5ICsgXCIvP3R5cGU9anNvblwiO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgbGV0IF9mbl9ib29rdGlwTGlzdEFsbCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gX2FwaXNlcnZlciArIFwiL0FwaV92My4xL2Jva3RpcHMvdHlwL2dldGFsbC92YWwvMC90eHR2YWwvMC9kZXZrZXkvXCIgKyBfZGV2a2V5ICsgXCIvP3R5cGU9anNvblwiO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgICAgXHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIGFwaXNlcnZlcjogX2FwaXNlcnZlcixcclxuXHQgICAgICAgICAgICBkbm5VUkw6IF9kbm5VUkwsXHJcblx0ICAgICAgICAgICAgaHRtbHRlbXBsYXRldXJsOiBfZG5uVVJMICsgX2h0bWx0ZW1wbGF0ZVVSTCxcclxuXHQgICAgICAgICAgICBkZXZrZXk6IF9kZXZrZXksXHJcblx0ICAgICAgICAgICAgaGFuZGxlYmFydGVtcGxhdGU6IHtcclxuXHQgICAgICAgICAgICAgICAgaGJfYm9va3RpcExpc3RfdG1wOiBfaGJfYm9va3RpcExpc3RfdGVtcGxhdGUsXHJcblx0ICAgICAgICAgICAgICAgIGhiX2VkaXRvcl90bXA6IF9oYl9lZGl0b3JfdGVtcGxhdGUsXHJcblx0ICAgICAgICAgICAgICAgIGhiX3NhdmVib3hfdG1wOiBfaGJfc2F2ZWJveF90ZW1wbGF0ZSxcclxuXHQgICAgICAgICAgICAgICAgaGJfZGVsYm94X3RtcDogX2hiX2RlbGV0ZWJveF90ZW1wbGF0ZVxyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgYXBpOiB7ICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgICAgICBib2t0aXBzbGlzdG9yOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBnZXRib2t0aXBzbGlzdFRvQXBwcm92ZTogX2ZuX2Jvb2t0aXBMaXN0VG9BcHJvdmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBnZXRib2t0aXBzbGlzdEFsbDogX2ZuX2Jvb2t0aXBMaXN0QWxsXHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGFwcHJvdmU6IF9mbl9ib29rdGlwQXBwcm92ZSxcclxuXHQgICAgICAgICAgICAgICAgc2F2ZTogX2ZuX2Jvb2t0aXBTYXZlLFxyXG5cdCAgICAgICAgICAgICAgICBkZWxldGU6IF9mbl9ib29rdGlwRGVsZXRlLFxyXG5cdCAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGdldHVybDogXCJcIlxyXG5cdCAgICAgICAgICAgICAgICB9LCAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICAgICAgZGV2a2V5ZW5kOiBfYXBpZGV2a2V5ZW5kXHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBkYXRhc2V0OiB7XHJcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnRkYXRhbGlzdDogIF9jdXJyZW50ZGF0YWxpc3RcclxuXHQgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICBkZWJ1ZzogXCJmYWxzZVwiXHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pKCksXHJcblx0ICAgIFxyXG5cdH1cclxuXHJcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRsZXQgX3NlcnZpY2Vfb2xkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0bGV0IF9zZXJ2aWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblx0bGV0IGFwcHNldHRpbmdzb2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHRsZXQgYXBwc2V0dGluZ3MgPSBhcHBzZXR0aW5nc29iamVjdC5jb25maWc7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBhcHByb3ZldGlwOiBmdW5jdGlvbiAodGlwaWQsIHZhbCkge1xyXG5cdCAgICAgICAgbGV0IGpzb25kYXRhcHJvbWlzZSA9IF9zZXJ2aWNlLmdldGpzb25kYXRhKGFwcHNldHRpbmdzLmFwaS5hcHByb3ZlKHRpcGlkLCB2YWwpKTtcclxuXHJcblx0ICAgICAgICBqc29uZGF0YXByb21pc2VcclxuXHQgICAgICAgICAgICAudGhlbihqc29uZGF0YSA9PiB7IHJldHVybiB0cnVlOyB9KVxyXG5cdCAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gZmFsc2UpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBkZWxldGV0aXA6IGZ1bmN0aW9uICh0aXBpZCwgY2FsbGJhY2spIHtcclxuXHQgICAgICAgIGxldCBkYXRhb3B0ID0geyAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgXCJUaXBJRFwiOiB0aXBpZFxyXG5cdCAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIF9zZXJ2aWNlX29sZC5wb3N0anNvbmRhdGEoYXBwc2V0dGluZ3MuYXBpLmRlbGV0ZSgpLCBkYXRhb3B0LCBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xyXG5cdCAgICAgICAgfSk7ICAgICAgXHJcblxyXG5cdCAgICB9LFxyXG5cdCAgICBzYXZldGlwOiBmdW5jdGlvbiAodGlwaWQsIHJ1YnJpaywgY29udGVudCwgY2FsbGJhY2spIHtcclxuXHQgICAgICAgIGxldCBkYXRhb3B0ID0ge1xyXG5cdCAgICAgICAgICAgIFwiVGlwSURcIjogdGlwaWQsXHJcblx0ICAgICAgICAgICAgXCJUaXRsZVwiOiBydWJyaWssICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgXCJSZXZpZXdcIjogY29udGVudCAgXHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgX3NlcnZpY2Vfb2xkLnBvc3Rqc29uZGF0YShhcHBzZXR0aW5ncy5hcGkuc2F2ZSgpLCBkYXRhb3B0LCBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xyXG5cdCAgICAgICAgfSk7XHJcblxyXG5cdCAgICB9XHJcblx0fVxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgICAgZ2V0anNvbmRhdGE6IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICBpZiAoIXVybCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNlYXJjaHNlcnZpY2VuIGjDpG10YXIgQXJyYW5nZW1hbmdkYXRhXCIpO1xyXG5cdCAgICAgICAgICAgICQuYWpheCh7XHJcblx0ICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiLFxyXG5cdCAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb25wJyxcclxuXHQgICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcblx0ICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlYXJjaCBEZXRhbGogYXJyYW5nZW1hbmcgaMOkbXRhdDogXCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoeGhyLCBhamF4T3B0aW9ucywgdGhyb3duRXJyb3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiTsOldHQgYmxldiBmZWwgdmlkIGjDpG10bmluZyBhdiBhcnJhbmdlbWFuZyFcIik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfSxcclxuXHQgICAgcG9zdGpzb25kYXRhOiBmdW5jdGlvbiAodXJsLCBwb3N0ZGF0YSwgY2FsbGJhY2spIHtcclxuXHQgICAgICAgIGlmICghdXJsKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU2VhcmNoc2VydmljZW4gaMOkbXRhciBBcnJhbmdlbWFuZ2RhdGFcIik7XHJcblx0ICAgICAgICAgICAgJC5hamF4KHtcclxuXHQgICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXHJcblxyXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcInBvc3RcIixcclxuXHQgICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcblx0ICAgICAgICAgICAgICAgIGRhdGE6IHBvc3RkYXRhLFxyXG5cdCAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJIw6RtdGFyIERhdGE6IFwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgYWpheE9wdGlvbnMsIHRocm93bkVycm9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBhbGVydChcIk7DpXR0IGJsZXYgZmVsIHZpZCBow6RtdG5pbmcgYXYgUE9TVCBqc29uIVwiKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9XHJcblx0fVxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0XHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGdldGpzb25kYXRhOiBmdW5jdGlvbiAodXJsKSB7XHJcblx0ICAgICAgICByZXR1cm4gZmV0Y2godXJsKVxyXG5cdCAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMuanNvbigpKVxyXG5cdCAgICAgICAgICAgIC50aGVuKGpzb25kYXRhID0+IGpzb25kYXRhKVxyXG5cdCAgICAgICAgICAgIFxyXG5cdCAgICB9LFxyXG5cdCAgICBwb3N0anNvbmRhdGE6IGZ1bmN0aW9uICh1cmwsIHBvc3RkYXRhKSB7XHJcblxyXG5cdCAgICAgICAgY29uc3Qgb3B0aW9uID0ge1xyXG5cdCAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLCBcclxuXHQgICAgICAgICAgICBtb2RlOlwibm8tY29yc1wiLFxyXG5cdCAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBvc3RkYXRhKSxcclxuXHQgICAgICAgICAgICBoZWFkZXJzOiB7XHJcblx0ICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbilcclxuXHQgICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcclxuXHQgICAgICAgICAgICAudGhlbihqc29uZGF0YSA9PiBqc29uZGF0YSlcclxuXHJcblx0ICAgIH0sXHJcblx0ICAgIGZldGNoanNvbnBkYXRhOiBmdW5jdGlvbiAodXJsLCBwb3N0ZGF0YSkge1xyXG5cdCAgICAgICAgLy9wb3N0ZGF0YT0geyBkYXRhOiBtZWRza2ljaywgbWVyZGF0YTogbWVyYSB9XHJcblx0ICAgICAgICBjb25zdCBvcHRpb24gPSB7XHJcblx0ICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcblx0ICAgICAgICAgICAgaGVhZGVyOiAnYXBwbGljYXRpb24vanNvbicsXHJcblx0ICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocG9zdGRhdGEpXHJcblxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9uKVxyXG5cdCAgICAgICAgICAgIC50aGVuKHJlcyA9PiByZXMucmVzcG9uc2VUZXh0KCkpXHJcblx0ICAgICAgICAgICAgLnRoZW4oanNvblRleHQgPT4gSlNPTi5wYXJzZShqc29uVGV4dCkpXHJcblxyXG5cdCAgICB9XHJcblx0fVxyXG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxyXG5cdGxldCBhcHBzZXR0aW5nc29iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0bGV0IGFwcHNldHRpbmdzID0gYXBwc2V0dGluZ3NvYmplY3QuY29uZmlnO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgICAgaW5pdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHQgICAgICAgIEhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIoJ2NoZWNrYXBwcm92ZWQnLCBmdW5jdGlvbiAoQXBwcm92ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIGlmIChBcHByb3ZlPT0xKSB7XHJcblx0ICAgICAgICAgICAgICAgcmV0dXJuICBcImNoZWNrZWRcIjtcclxuXHQgICAgICAgICAgICB9OyAgICAgICAgICAgIFxyXG5cdCAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICBcclxuXHQgICAgfVxyXG5cdH1cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pOyJdfQ==
