/**!
ANDREAS HANDLEBARS
 @license
 handlebars v4.0.10

Copyright (C) 2011-2016 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Handlebars"] = factory();
	else
		root["Handlebars"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap ANDREAS HANDLEBARS
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _handlebarsRuntime = __webpack_require__(2);

	var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

	// Compiler imports

	var _handlebarsCompilerAst = __webpack_require__(35);

	var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

	var _handlebarsCompilerBase = __webpack_require__(36);

	var _handlebarsCompilerCompiler = __webpack_require__(41);

	var _handlebarsCompilerJavascriptCompiler = __webpack_require__(42);

	var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

	var _handlebarsCompilerVisitor = __webpack_require__(39);

	var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

	var _handlebarsNoConflict = __webpack_require__(34);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	var _create = _handlebarsRuntime2['default'].create;
	function create() {
	  var hb = _create();

	  hb.compile = function (input, options) {
	    return _handlebarsCompilerCompiler.compile(input, options, hb);
	  };
	  hb.precompile = function (input, options) {
	    return _handlebarsCompilerCompiler.precompile(input, options, hb);
	  };

	  hb.AST = _handlebarsCompilerAst2['default'];
	  hb.Compiler = _handlebarsCompilerCompiler.Compiler;
	  hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
	  hb.Parser = _handlebarsCompilerBase.parser;
	  hb.parse = _handlebarsCompilerBase.parse;

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst.Visitor = _handlebarsCompilerVisitor2['default'];

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	};

	exports.__esModule = true;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _handlebarsBase = __webpack_require__(4);

	var base = _interopRequireWildcard(_handlebarsBase);

	// Each of these augment the Handlebars object. No need to setup here.
	// (This is done to easily share code between commonjs and browse envs)

	var _handlebarsSafeString = __webpack_require__(21);

	var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

	var _handlebarsException = __webpack_require__(6);

	var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

	var _handlebarsUtils = __webpack_require__(5);

	var Utils = _interopRequireWildcard(_handlebarsUtils);

	var _handlebarsRuntime = __webpack_require__(22);

	var runtime = _interopRequireWildcard(_handlebarsRuntime);

	var _handlebarsNoConflict = __webpack_require__(34);

	var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

	// For compatibility and usage outside of module systems, make the Handlebars object a namespace
	function create() {
	  var hb = new base.HandlebarsEnvironment();

	  Utils.extend(hb, base);
	  hb.SafeString = _handlebarsSafeString2['default'];
	  hb.Exception = _handlebarsException2['default'];
	  hb.Utils = Utils;
	  hb.escapeExpression = Utils.escapeExpression;

	  hb.VM = runtime;
	  hb.template = function (spec) {
	    return runtime.template(spec, hb);
	  };

	  return hb;
	}

	var inst = create();
	inst.create = create;

	_handlebarsNoConflict2['default'](inst);

	inst['default'] = inst;

	exports['default'] = inst;
	module.exports = exports['default'];

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	"use strict";

	exports["default"] = function (obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};

	    if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }

	    newObj["default"] = obj;
	    return newObj;
	  }
	};

	exports.__esModule = true;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.HandlebarsEnvironment = HandlebarsEnvironment;

	var _utils = __webpack_require__(5);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _helpers = __webpack_require__(10);

	var _decorators = __webpack_require__(18);

	var _logger = __webpack_require__(20);

	var _logger2 = _interopRequireDefault(_logger);

	var VERSION = '4.0.10';
	exports.VERSION = VERSION;
	var COMPILER_REVISION = 7;

	exports.COMPILER_REVISION = COMPILER_REVISION;
	var REVISION_CHANGES = {
	  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
	  2: '== 1.0.0-rc.3',
	  3: '== 1.0.0-rc.4',
	  4: '== 1.x.x',
	  5: '== 2.0.0-alpha.x',
	  6: '>= 2.0.0-beta.1',
	  7: '>= 4.0.0'
	};

	exports.REVISION_CHANGES = REVISION_CHANGES;
	var objectType = '[object Object]';

	function HandlebarsEnvironment(helpers, partials, decorators) {
	  this.helpers = helpers || {};
	  this.partials = partials || {};
	  this.decorators = decorators || {};

	  _helpers.registerDefaultHelpers(this);
	  _decorators.registerDefaultDecorators(this);
	}

	HandlebarsEnvironment.prototype = {
	  constructor: HandlebarsEnvironment,

	  logger: _logger2['default'],
	  log: _logger2['default'].log,

	  registerHelper: function registerHelper(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple helpers');
	      }
	      _utils.extend(this.helpers, name);
	    } else {
	      this.helpers[name] = fn;
	    }
	  },
	  unregisterHelper: function unregisterHelper(name) {
	    delete this.helpers[name];
	  },

	  registerPartial: function registerPartial(name, partial) {
	    if (_utils.toString.call(name) === objectType) {
	      _utils.extend(this.partials, name);
	    } else {
	      if (typeof partial === 'undefined') {
	        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
	      }
	      this.partials[name] = partial;
	    }
	  },
	  unregisterPartial: function unregisterPartial(name) {
	    delete this.partials[name];
	  },

	  registerDecorator: function registerDecorator(name, fn) {
	    if (_utils.toString.call(name) === objectType) {
	      if (fn) {
	        throw new _exception2['default']('Arg not supported with multiple decorators');
	      }
	      _utils.extend(this.decorators, name);
	    } else {
	      this.decorators[name] = fn;
	    }
	  },
	  unregisterDecorator: function unregisterDecorator(name) {
	    delete this.decorators[name];
	  }
	};

	var log = _logger2['default'].log;

	exports.log = log;
	exports.createFrame = _utils.createFrame;
	exports.logger = _logger2['default'];

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.extend = extend;
	exports.indexOf = indexOf;
	exports.escapeExpression = escapeExpression;
	exports.isEmpty = isEmpty;
	exports.createFrame = createFrame;
	exports.blockParams = blockParams;
	exports.appendContextPath = appendContextPath;
	var escape = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#x27;',
	  '`': '&#x60;',
	  '=': '&#x3D;'
	};

	var badChars = /[&<>"'`=]/g,
	    possible = /[&<>"'`=]/;

	function escapeChar(chr) {
	  return escape[chr];
	}

	function extend(obj /* , ...source */) {
	  for (var i = 1; i < arguments.length; i++) {
	    for (var key in arguments[i]) {
	      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
	        obj[key] = arguments[i][key];
	      }
	    }
	  }

	  return obj;
	}

	var toString = Object.prototype.toString;

	exports.toString = toString;
	// Sourced from lodash
	// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
	/* eslint-disable func-style */
	var isFunction = function isFunction(value) {
	  return typeof value === 'function';
	};
	// fallback for older versions of Chrome and Safari
	/* istanbul ignore next */
	if (isFunction(/x/)) {
	  exports.isFunction = isFunction = function (value) {
	    return typeof value === 'function' && toString.call(value) === '[object Function]';
	  };
	}
	exports.isFunction = isFunction;

	/* eslint-enable func-style */

	/* istanbul ignore next */
	var isArray = Array.isArray || function (value) {
	  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
	};

	exports.isArray = isArray;
	// Older IE versions do not directly support indexOf so we must implement our own, sadly.

	function indexOf(array, value) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	}

	function escapeExpression(string) {
	  if (typeof string !== 'string') {
	    // don't escape SafeStrings, since they're already safe
	    if (string && string.toHTML) {
	      return string.toHTML();
	    } else if (string == null) {
	      return '';
	    } else if (!string) {
	      return string + '';
	    }

	    // Force a string conversion as this will be done by the append regardless and
	    // the regex test will do this transparently behind the scenes, causing issues if
	    // an object's to string has escaped characters in it.
	    string = '' + string;
	  }

	  if (!possible.test(string)) {
	    return string;
	  }
	  return string.replace(badChars, escapeChar);
	}

	function isEmpty(value) {
	  if (!value && value !== 0) {
	    return true;
	  } else if (isArray(value) && value.length === 0) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function createFrame(object) {
	  var frame = extend({}, object);
	  frame._parent = object;
	  return frame;
	}

	function blockParams(params, ids) {
	  params.path = ids;
	  return params;
	}

	function appendContextPath(contextPath, id) {
	  return (contextPath ? contextPath + '.' : '') + id;
	}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$defineProperty = __webpack_require__(7)['default'];

	exports.__esModule = true;

	var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

	function Exception(message, node) {
	  var loc = node && node.loc,
	      line = undefined,
	      column = undefined;
	  if (loc) {
	    line = loc.start.line;
	    column = loc.start.column;

	    message += ' - ' + line + ':' + column;
	  }

	  var tmp = Error.prototype.constructor.call(this, message);

	  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
	  for (var idx = 0; idx < errorProps.length; idx++) {
	    this[errorProps[idx]] = tmp[errorProps[idx]];
	  }

	  /* istanbul ignore else */
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, Exception);
	  }

	  try {
	    if (loc) {
	      this.lineNumber = line;

	      // Work around issue under safari where we can't directly set the column value
	      /* istanbul ignore next */
	      if (_Object$defineProperty) {
	        Object.defineProperty(this, 'column', {
	          value: column,
	          enumerable: true
	        });
	      } else {
	        this.column = column;
	      }
	    }
	  } catch (nop) {
	    /* Ignore if the browser is very particular */
	  }
	}

	Exception.prototype = new Error();

	exports['default'] = Exception;
	module.exports = exports['default'];

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(8), __esModule: true };

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(9);
	module.exports = function defineProperty(it, key, desc){
	  return $.setDesc(it, key, desc);
	};

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	var $Object = Object;
	module.exports = {
	  create:     $Object.create,
	  getProto:   $Object.getPrototypeOf,
	  isEnum:     {}.propertyIsEnumerable,
	  getDesc:    $Object.getOwnPropertyDescriptor,
	  setDesc:    $Object.defineProperty,
	  setDescs:   $Object.defineProperties,
	  getKeys:    $Object.keys,
	  getNames:   $Object.getOwnPropertyNames,
	  getSymbols: $Object.getOwnPropertySymbols,
	  each:       [].forEach
	};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.registerDefaultHelpers = registerDefaultHelpers;

	var _helpersBlockHelperMissing = __webpack_require__(11);

	var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

	var _helpersEach = __webpack_require__(12);

	var _helpersEach2 = _interopRequireDefault(_helpersEach);

	var _helpersHelperMissing = __webpack_require__(13);

	var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

	var _helpersIf = __webpack_require__(14);

	var _helpersIf2 = _interopRequireDefault(_helpersIf);

	var _helpersLog = __webpack_require__(15);

	var _helpersLog2 = _interopRequireDefault(_helpersLog);

	var _helpersLookup = __webpack_require__(16);

	var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

	var _helpersWith = __webpack_require__(17);

	var _helpersWith2 = _interopRequireDefault(_helpersWith);

	function registerDefaultHelpers(instance) {
	  _helpersBlockHelperMissing2['default'](instance);
	  _helpersEach2['default'](instance);
	  _helpersHelperMissing2['default'](instance);
	  _helpersIf2['default'](instance);
	  _helpersLog2['default'](instance);
	  _helpersLookup2['default'](instance);
	  _helpersWith2['default'](instance);
	}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('blockHelperMissing', function (context, options) {
	    var inverse = options.inverse,
	        fn = options.fn;

	    if (context === true) {
	      return fn(this);
	    } else if (context === false || context == null) {
	      return inverse(this);
	    } else if (_utils.isArray(context)) {
	      if (context.length > 0) {
	        if (options.ids) {
	          options.ids = [options.name];
	        }

	        return instance.helpers.each(context, options);
	      } else {
	        return inverse(this);
	      }
	    } else {
	      if (options.data && options.ids) {
	        var data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
	        options = { data: data };
	      }

	      return fn(context, options);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('each', function (context, options) {
	    if (!options) {
	      throw new _exception2['default']('Must pass iterator to #each');
	    }

	    var fn = options.fn,
	        inverse = options.inverse,
	        i = 0,
	        ret = '',
	        data = undefined,
	        contextPath = undefined;

	    if (options.data && options.ids) {
	      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
	    }

	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    if (options.data) {
	      data = _utils.createFrame(options.data);
	    }

	    function execIteration(field, index, last) {
	      if (data) {
	        data.key = field;
	        data.index = index;
	        data.first = index === 0;
	        data.last = !!last;

	        if (contextPath) {
	          data.contextPath = contextPath + field;
	        }
	      }

	      ret = ret + fn(context[field], {
	        data: data,
	        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
	      });
	    }

	    if (context && typeof context === 'object') {
	      if (_utils.isArray(context)) {
	        for (var j = context.length; i < j; i++) {
	          if (i in context) {
	            execIteration(i, i, i === context.length - 1);
	          }
	        }
	      } else {
	        var priorKey = undefined;

	        for (var key in context) {
	          if (context.hasOwnProperty(key)) {
	            // We're running the iterations one step out of sync so we can detect
	            // the last iteration without have to scan the object twice and create
	            // an itermediate keys array.
	            if (priorKey !== undefined) {
	              execIteration(priorKey, i - 1);
	            }
	            priorKey = key;
	            i++;
	          }
	        }
	        if (priorKey !== undefined) {
	          execIteration(priorKey, i - 1, true);
	        }
	      }
	    }

	    if (i === 0) {
	      ret = inverse(this);
	    }

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	exports['default'] = function (instance) {
	  instance.registerHelper('helperMissing', function () /* [args, ]options */{
	    if (arguments.length === 1) {
	      // A missing field in a {{foo}} construct.
	      return undefined;
	    } else {
	      // Someone is actually trying to call something, blow up.
	      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('if', function (conditional, options) {
	    if (_utils.isFunction(conditional)) {
	      conditional = conditional.call(this);
	    }

	    // Default behavior is to render the positive path if the value is truthy and not empty.
	    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
	    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
	    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
	      return options.inverse(this);
	    } else {
	      return options.fn(this);
	    }
	  });

	  instance.registerHelper('unless', function (conditional, options) {
	    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 15 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('log', function () /* message, options */{
	    var args = [undefined],
	        options = arguments[arguments.length - 1];
	    for (var i = 0; i < arguments.length - 1; i++) {
	      args.push(arguments[i]);
	    }

	    var level = 1;
	    if (options.hash.level != null) {
	      level = options.hash.level;
	    } else if (options.data && options.data.level != null) {
	      level = options.data.level;
	    }
	    args[0] = level;

	    instance.log.apply(instance, args);
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;

	exports['default'] = function (instance) {
	  instance.registerHelper('lookup', function (obj, field) {
	    return obj && obj[field];
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerHelper('with', function (context, options) {
	    if (_utils.isFunction(context)) {
	      context = context.call(this);
	    }

	    var fn = options.fn;

	    if (!_utils.isEmpty(context)) {
	      var data = options.data;
	      if (options.data && options.ids) {
	        data = _utils.createFrame(options.data);
	        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
	      }

	      return fn(context, {
	        data: data,
	        blockParams: _utils.blockParams([context], [data && data.contextPath])
	      });
	    } else {
	      return options.inverse(this);
	    }
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.registerDefaultDecorators = registerDefaultDecorators;

	var _decoratorsInline = __webpack_require__(19);

	var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

	function registerDefaultDecorators(instance) {
	  _decoratorsInline2['default'](instance);
	}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	exports['default'] = function (instance) {
	  instance.registerDecorator('inline', function (fn, props, container, options) {
	    var ret = fn;
	    if (!props.partials) {
	      props.partials = {};
	      ret = function (context, options) {
	        // Create a new partials stack frame prior to exec.
	        var original = container.partials;
	        container.partials = _utils.extend({}, original, props.partials);
	        var ret = fn(context, options);
	        container.partials = original;
	        return ret;
	      };
	    }

	    props.partials[options.args[0]] = options.fn;

	    return ret;
	  });
	};

	module.exports = exports['default'];

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var logger = {
	  methodMap: ['debug', 'info', 'warn', 'error'],
	  level: 'info',

	  // Maps a given level value to the `methodMap` indexes above.
	  lookupLevel: function lookupLevel(level) {
	    if (typeof level === 'string') {
	      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
	      if (levelMap >= 0) {
	        level = levelMap;
	      } else {
	        level = parseInt(level, 10);
	      }
	    }

	    return level;
	  },

	  // Can be overridden in the host environment
	  log: function log(level) {
	    level = logger.lookupLevel(level);

	    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
	      var method = logger.methodMap[level];
	      if (!console[method]) {
	        // eslint-disable-line no-console
	        method = 'log';
	      }

	      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        message[_key - 1] = arguments[_key];
	      }

	      console[method].apply(console, message); // eslint-disable-line no-console
	    }
	  }
	};

	exports['default'] = logger;
	module.exports = exports['default'];

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	// Build out our basic SafeString type
	'use strict';

	exports.__esModule = true;
	function SafeString(string) {
	  this.string = string;
	}

	SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
	  return '' + this.string;
	};

	exports['default'] = SafeString;
	module.exports = exports['default'];

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _Object$seal = __webpack_require__(23)['default'];

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.checkRevision = checkRevision;
	exports.template = template;
	exports.wrapProgram = wrapProgram;
	exports.resolvePartial = resolvePartial;
	exports.invokePartial = invokePartial;
	exports.noop = noop;

	var _utils = __webpack_require__(5);

	var Utils = _interopRequireWildcard(_utils);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _base = __webpack_require__(4);

	function checkRevision(compilerInfo) {
	  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
	      currentRevision = _base.COMPILER_REVISION;

	  if (compilerRevision !== currentRevision) {
	    if (compilerRevision < currentRevision) {
	      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
	          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
	      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
	    } else {
	      // Use the embedded version info since the runtime doesn't know about this revision yet
	      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
	    }
	  }
	}

	function template(templateSpec, env) {
	  /* istanbul ignore next */
	  if (!env) {
	    throw new _exception2['default']('No environment passed to template');
	  }
	  if (!templateSpec || !templateSpec.main) {
	    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
	  }

	  templateSpec.main.decorator = templateSpec.main_d;

	  // Note: Using env.VM references rather than local var references throughout this section to allow
	  // for external users to override these as psuedo-supported APIs.
	  env.VM.checkRevision(templateSpec.compiler);

	  function invokePartialWrapper(partial, context, options) {
	    if (options.hash) {
	      context = Utils.extend({}, context, options.hash);
	      if (options.ids) {
	        options.ids[0] = true;
	      }
	    }

	    partial = env.VM.resolvePartial.call(this, partial, context, options);
	    var result = env.VM.invokePartial.call(this, partial, context, options);

	    if (result == null && env.compile) {
	      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
	      result = options.partials[options.name](context, options);
	    }
	    if (result != null) {
	      if (options.indent) {
	        var lines = result.split('\n');
	        for (var i = 0, l = lines.length; i < l; i++) {
	          if (!lines[i] && i + 1 === l) {
	            break;
	          }

	          lines[i] = options.indent + lines[i];
	        }
	        result = lines.join('\n');
	      }
	      return result;
	    } else {
	      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
	    }
	  }

	  // Just add water
	  var container = {
	    strict: function strict(obj, name) {
	      if (!(name in obj)) {
	        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
	      }
	      return obj[name];
	    },
	    lookup: function lookup(depths, name) {
	      var len = depths.length;
	      for (var i = 0; i < len; i++) {
	        if (depths[i] && depths[i][name] != null) {
	          return depths[i][name];
	        }
	      }
	    },
	    lambda: function lambda(current, context) {
	      return typeof current === 'function' ? current.call(context) : current;
	    },

	    escapeExpression: Utils.escapeExpression,
	    invokePartial: invokePartialWrapper,

	    fn: function fn(i) {
	      var ret = templateSpec[i];
	      ret.decorator = templateSpec[i + '_d'];
	      return ret;
	    },

	    programs: [],
	    program: function program(i, data, declaredBlockParams, blockParams, depths) {
	      var programWrapper = this.programs[i],
	          fn = this.fn(i);
	      if (data || depths || blockParams || declaredBlockParams) {
	        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
	      } else if (!programWrapper) {
	        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
	      }
	      return programWrapper;
	    },

	    data: function data(value, depth) {
	      while (value && depth--) {
	        value = value._parent;
	      }
	      return value;
	    },
	    merge: function merge(param, common) {
	      var obj = param || common;

	      if (param && common && param !== common) {
	        obj = Utils.extend({}, common, param);
	      }

	      return obj;
	    },
	    // An empty object to use as replacement for null-contexts
	    nullContext: _Object$seal({}),

	    noop: env.VM.noop,
	    compilerInfo: templateSpec.compiler
	  };

	  function ret(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var data = options.data;

	    ret._setup(options);
	    if (!options.partial && templateSpec.useData) {
	      data = initData(context, data);
	    }
	    var depths = undefined,
	        blockParams = templateSpec.useBlockParams ? [] : undefined;
	    if (templateSpec.useDepths) {
	      if (options.depths) {
	        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
	      } else {
	        depths = [context];
	      }
	    }

	    function main(context /*, options*/) {
	      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
	    }
	    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
	    return main(context, options);
	  }
	  ret.isTop = true;

	  ret._setup = function (options) {
	    if (!options.partial) {
	      container.helpers = container.merge(options.helpers, env.helpers);

	      if (templateSpec.usePartial) {
	        container.partials = container.merge(options.partials, env.partials);
	      }
	      if (templateSpec.usePartial || templateSpec.useDecorators) {
	        container.decorators = container.merge(options.decorators, env.decorators);
	      }
	    } else {
	      container.helpers = options.helpers;
	      container.partials = options.partials;
	      container.decorators = options.decorators;
	    }
	  };

	  ret._child = function (i, data, blockParams, depths) {
	    if (templateSpec.useBlockParams && !blockParams) {
	      throw new _exception2['default']('must pass block params');
	    }
	    if (templateSpec.useDepths && !depths) {
	      throw new _exception2['default']('must pass parent depths');
	    }

	    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
	  };
	  return ret;
	}

	function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
	  function prog(context) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	    var currentDepths = depths;
	    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
	      currentDepths = [context].concat(depths);
	    }

	    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
	  }

	  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

	  prog.program = i;
	  prog.depth = depths ? depths.length : 0;
	  prog.blockParams = declaredBlockParams || 0;
	  return prog;
	}

	function resolvePartial(partial, context, options) {
	  if (!partial) {
	    if (options.name === '@partial-block') {
	      partial = options.data['partial-block'];
	    } else {
	      partial = options.partials[options.name];
	    }
	  } else if (!partial.call && !options.name) {
	    // This is a dynamic partial that returned a string
	    options.name = partial;
	    partial = options.partials[partial];
	  }
	  return partial;
	}

	function invokePartial(partial, context, options) {
	  // Use the current closure context to save the partial-block if this partial
	  var currentPartialBlock = options.data && options.data['partial-block'];
	  options.partial = true;
	  if (options.ids) {
	    options.data.contextPath = options.ids[0] || options.data.contextPath;
	  }

	  var partialBlock = undefined;
	  if (options.fn && options.fn !== noop) {
	    (function () {
	      options.data = _base.createFrame(options.data);
	      // Wrapper function to get access to currentPartialBlock from the closure
	      var fn = options.fn;
	      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
	        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	        // Restore the partial-block from the closure for the execution of the block
	        // i.e. the part inside the block of the partial call.
	        options.data = _base.createFrame(options.data);
	        options.data['partial-block'] = currentPartialBlock;
	        return fn(context, options);
	      };
	      if (fn.partials) {
	        options.partials = Utils.extend({}, options.partials, fn.partials);
	      }
	    })();
	  }

	  if (partial === undefined && partialBlock) {
	    partial = partialBlock;
	  }

	  if (partial === undefined) {
	    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
	  } else if (partial instanceof Function) {
	    return partial(context, options);
	  }
	}

	function noop() {
	  return '';
	}

	function initData(context, data) {
	  if (!data || !('root' in data)) {
	    data = data ? _base.createFrame(data) : {};
	    data.root = context;
	  }
	  return data;
	}

	function executeDecorators(fn, prog, container, depths, data, blockParams) {
	  if (fn.decorator) {
	    var props = {};
	    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
	    Utils.extend(prog, props);
	  }
	  return prog;
	}

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(24), __esModule: true };

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(25);
	module.exports = __webpack_require__(30).Object.seal;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(26);

	__webpack_require__(27)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(it) : it;
	  };
	});

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(28)
	  , core    = __webpack_require__(30)
	  , fails   = __webpack_require__(33);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(29)
	  , core      = __webpack_require__(30)
	  , ctx       = __webpack_require__(31)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && key in target;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(param){
	        return this instanceof C ? new C(param) : C(param);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
	  }
	};
	// type bitmap
	$export.F = 1;  // forced
	$export.G = 2;  // global
	$export.S = 4;  // static
	$export.P = 8;  // proto
	$export.B = 16; // bind
	$export.W = 32; // wrap
	module.exports = $export;

/***/ }),
/* 29 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	var core = module.exports = {version: '1.2.6'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(32);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ }),
/* 32 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ }),
/* 33 */
/***/ (function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/* global window */
	'use strict';

	exports.__esModule = true;

	exports['default'] = function (Handlebars) {
	  /* istanbul ignore next */
	  var root = typeof global !== 'undefined' ? global : window,
	      $Handlebars = root.Handlebars;
	  /* istanbul ignore next */
	  Handlebars.noConflict = function () {
	    if (root.Handlebars === Handlebars) {
	      root.Handlebars = $Handlebars;
	    }
	    return Handlebars;
	  };
	};

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	'use strict';

	exports.__esModule = true;
	var AST = {
	  // Public API used to evaluate derived attributes regarding AST nodes
	  helpers: {
	    // a mustache is definitely a helper if:
	    // * it is an eligible helper, and
	    // * it has at least one parameter or hash segment
	    helperExpression: function helperExpression(node) {
	      return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
	    },

	    scopedId: function scopedId(path) {
	      return (/^\.|this\b/.test(path.original)
	      );
	    },

	    // an ID is simple if it only has one part, and that part is not
	    // `..` or `this`.
	    simpleId: function simpleId(path) {
	      return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
	    }
	  }
	};

	// Must be exported as an object rather than the root of the module as the jison lexer
	// must modify the object to operate properly.
	exports['default'] = AST;
	module.exports = exports['default'];

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	var _interopRequireWildcard = __webpack_require__(3)['default'];

	exports.__esModule = true;
	exports.parse = parse;

	var _parser = __webpack_require__(37);

	var _parser2 = _interopRequireDefault(_parser);

	var _whitespaceControl = __webpack_require__(38);

	var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

	var _helpers = __webpack_require__(40);

	var Helpers = _interopRequireWildcard(_helpers);

	var _utils = __webpack_require__(5);

	exports.parser = _parser2['default'];

	var yy = {};
	_utils.extend(yy, Helpers);

	function parse(input, options) {
	  // Just return if an already-compiled AST was passed in.
	  if (input.type === 'Program') {
	    return input;
	  }

	  _parser2['default'].yy = yy;

	  // Altering the shared object here, but this is ok as parser is a sync operation
	  yy.locInfo = function (locInfo) {
	    return new yy.SourceLocation(options && options.srcName, locInfo);
	  };

	  var strip = new _whitespaceControl2['default'](options);
	  return strip.accept(_parser2['default'].parse(input));
	}

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	// File ignored in coverage tests via setting in .istanbul.yml
	/* Jison generated parser */
	"use strict";

	exports.__esModule = true;
	var handlebars = (function () {
	    var parser = { trace: function trace() {},
	        yy: {},
	        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
	        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
	        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
	        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
	        /**/) {

	            var $0 = $$.length - 1;
	            switch (yystate) {
	                case 1:
	                    return $$[$0 - 1];
	                    break;
	                case 2:
	                    this.$ = yy.prepareProgram($$[$0]);
	                    break;
	                case 3:
	                    this.$ = $$[$0];
	                    break;
	                case 4:
	                    this.$ = $$[$0];
	                    break;
	                case 5:
	                    this.$ = $$[$0];
	                    break;
	                case 6:
	                    this.$ = $$[$0];
	                    break;
	                case 7:
	                    this.$ = $$[$0];
	                    break;
	                case 8:
	                    this.$ = $$[$0];
	                    break;
	                case 9:
	                    this.$ = {
	                        type: 'CommentStatement',
	                        value: yy.stripComment($$[$0]),
	                        strip: yy.stripFlags($$[$0], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 10:
	                    this.$ = {
	                        type: 'ContentStatement',
	                        original: $$[$0],
	                        value: $$[$0],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 11:
	                    this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 12:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
	                    break;
	                case 13:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
	                    break;
	                case 14:
	                    this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
	                    break;
	                case 15:
	                    this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 16:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 17:
	                    this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
	                    break;
	                case 18:
	                    this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
	                    break;
	                case 19:
	                    var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
	                        program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
	                    program.chained = true;

	                    this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

	                    break;
	                case 20:
	                    this.$ = $$[$0];
	                    break;
	                case 21:
	                    this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
	                    break;
	                case 22:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 23:
	                    this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
	                    break;
	                case 24:
	                    this.$ = {
	                        type: 'PartialStatement',
	                        name: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        indent: '',
	                        strip: yy.stripFlags($$[$0 - 4], $$[$0]),
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 25:
	                    this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
	                    break;
	                case 26:
	                    this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
	                    break;
	                case 27:
	                    this.$ = $$[$0];
	                    break;
	                case 28:
	                    this.$ = $$[$0];
	                    break;
	                case 29:
	                    this.$ = {
	                        type: 'SubExpression',
	                        path: $$[$0 - 3],
	                        params: $$[$0 - 2],
	                        hash: $$[$0 - 1],
	                        loc: yy.locInfo(this._$)
	                    };

	                    break;
	                case 30:
	                    this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 31:
	                    this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 32:
	                    this.$ = yy.id($$[$0 - 1]);
	                    break;
	                case 33:
	                    this.$ = $$[$0];
	                    break;
	                case 34:
	                    this.$ = $$[$0];
	                    break;
	                case 35:
	                    this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
	                    break;
	                case 36:
	                    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
	                    break;
	                case 37:
	                    this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
	                    break;
	                case 38:
	                    this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
	                    break;
	                case 39:
	                    this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
	                    break;
	                case 40:
	                    this.$ = $$[$0];
	                    break;
	                case 41:
	                    this.$ = $$[$0];
	                    break;
	                case 42:
	                    this.$ = yy.preparePath(true, $$[$0], this._$);
	                    break;
	                case 43:
	                    this.$ = yy.preparePath(false, $$[$0], this._$);
	                    break;
	                case 44:
	                    $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
	                    break;
	                case 45:
	                    this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
	                    break;
	                case 46:
	                    this.$ = [];
	                    break;
	                case 47:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 48:
	                    this.$ = [$$[$0]];
	                    break;
	                case 49:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 50:
	                    this.$ = [];
	                    break;
	                case 51:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 58:
	                    this.$ = [];
	                    break;
	                case 59:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 64:
	                    this.$ = [];
	                    break;
	                case 65:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 70:
	                    this.$ = [];
	                    break;
	                case 71:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 78:
	                    this.$ = [];
	                    break;
	                case 79:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 82:
	                    this.$ = [];
	                    break;
	                case 83:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 86:
	                    this.$ = [];
	                    break;
	                case 87:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 90:
	                    this.$ = [];
	                    break;
	                case 91:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 94:
	                    this.$ = [];
	                    break;
	                case 95:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 98:
	                    this.$ = [$$[$0]];
	                    break;
	                case 99:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	                case 100:
	                    this.$ = [$$[$0]];
	                    break;
	                case 101:
	                    $$[$0 - 1].push($$[$0]);
	                    break;
	            }
	        },
	        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
	        defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
	        parseError: function parseError(str, hash) {
	            throw new Error(str);
	        },
	        parse: function parse(input) {
	            var self = this,
	                stack = [0],
	                vstack = [null],
	                lstack = [],
	                table = this.table,
	                yytext = "",
	                yylineno = 0,
	                yyleng = 0,
	                recovering = 0,
	                TERROR = 2,
	                EOF = 1;
	            this.lexer.setInput(input);
	            this.lexer.yy = this.yy;
	            this.yy.lexer = this.lexer;
	            this.yy.parser = this;
	            if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
	            var yyloc = this.lexer.yylloc;
	            lstack.push(yyloc);
	            var ranges = this.lexer.options && this.lexer.options.ranges;
	            if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
	            function popStack(n) {
	                stack.length = stack.length - 2 * n;
	                vstack.length = vstack.length - n;
	                lstack.length = lstack.length - n;
	            }
	            function lex() {
	                var token;
	                token = self.lexer.lex() || 1;
	                if (typeof token !== "number") {
	                    token = self.symbols_[token] || token;
	                }
	                return token;
	            }
	            var symbol,
	                preErrorSymbol,
	                state,
	                action,
	                a,
	                r,
	                yyval = {},
	                p,
	                len,
	                newState,
	                expected;
	            while (true) {
	                state = stack[stack.length - 1];
	                if (this.defaultActions[state]) {
	                    action = this.defaultActions[state];
	                } else {
	                    if (symbol === null || typeof symbol == "undefined") {
	                        symbol = lex();
	                    }
	                    action = table[state] && table[state][symbol];
	                }
	                if (typeof action === "undefined" || !action.length || !action[0]) {
	                    var errStr = "";
	                    if (!recovering) {
	                        expected = [];
	                        for (p in table[state]) if (this.terminals_[p] && p > 2) {
	                            expected.push("'" + this.terminals_[p] + "'");
	                        }
	                        if (this.lexer.showPosition) {
	                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
	                        } else {
	                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
	                        }
	                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
	                    }
	                }
	                if (action[0] instanceof Array && action.length > 1) {
	                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
	                }
	                switch (action[0]) {
	                    case 1:
	                        stack.push(symbol);
	                        vstack.push(this.lexer.yytext);
	                        lstack.push(this.lexer.yylloc);
	                        stack.push(action[1]);
	                        symbol = null;
	                        if (!preErrorSymbol) {
	                            yyleng = this.lexer.yyleng;
	                            yytext = this.lexer.yytext;
	                            yylineno = this.lexer.yylineno;
	                            yyloc = this.lexer.yylloc;
	                            if (recovering > 0) recovering--;
	                        } else {
	                            symbol = preErrorSymbol;
	                            preErrorSymbol = null;
	                        }
	                        break;
	                    case 2:
	                        len = this.productions_[action[1]][1];
	                        yyval.$ = vstack[vstack.length - len];
	                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
	                        if (ranges) {
	                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
	                        }
	                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
	                        if (typeof r !== "undefined") {
	                            return r;
	                        }
	                        if (len) {
	                            stack = stack.slice(0, -1 * len * 2);
	                            vstack = vstack.slice(0, -1 * len);
	                            lstack = lstack.slice(0, -1 * len);
	                        }
	                        stack.push(this.productions_[action[1]][0]);
	                        vstack.push(yyval.$);
	                        lstack.push(yyval._$);
	                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	                        stack.push(newState);
	                        break;
	                    case 3:
	                        return true;
	                }
	            }
	            return true;
	        }
	    };
	    /* Jison generated lexer */
	    var lexer = (function () {
	        var lexer = { EOF: 1,
	            parseError: function parseError(str, hash) {
	                if (this.yy.parser) {
	                    this.yy.parser.parseError(str, hash);
	                } else {
	                    throw new Error(str);
	                }
	            },
	            setInput: function setInput(input) {
	                this._input = input;
	                this._more = this._less = this.done = false;
	                this.yylineno = this.yyleng = 0;
	                this.yytext = this.matched = this.match = '';
	                this.conditionStack = ['INITIAL'];
	                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
	                if (this.options.ranges) this.yylloc.range = [0, 0];
	                this.offset = 0;
	                return this;
	            },
	            input: function input() {
	                var ch = this._input[0];
	                this.yytext += ch;
	                this.yyleng++;
	                this.offset++;
	                this.match += ch;
	                this.matched += ch;
	                var lines = ch.match(/(?:\r\n?|\n).*/g);
	                if (lines) {
	                    this.yylineno++;
	                    this.yylloc.last_line++;
	                } else {
	                    this.yylloc.last_column++;
	                }
	                if (this.options.ranges) this.yylloc.range[1]++;

	                this._input = this._input.slice(1);
	                return ch;
	            },
	            unput: function unput(ch) {
	                var len = ch.length;
	                var lines = ch.split(/(?:\r\n?|\n)/g);

	                this._input = ch + this._input;
	                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
	                //this.yyleng -= len;
	                this.offset -= len;
	                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	                this.match = this.match.substr(0, this.match.length - 1);
	                this.matched = this.matched.substr(0, this.matched.length - 1);

	                if (lines.length - 1) this.yylineno -= lines.length - 1;
	                var r = this.yylloc.range;

	                this.yylloc = { first_line: this.yylloc.first_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.first_column,
	                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
	                };

	                if (this.options.ranges) {
	                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	                }
	                return this;
	            },
	            more: function more() {
	                this._more = true;
	                return this;
	            },
	            less: function less(n) {
	                this.unput(this.match.slice(n));
	            },
	            pastInput: function pastInput() {
	                var past = this.matched.substr(0, this.matched.length - this.match.length);
	                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
	            },
	            upcomingInput: function upcomingInput() {
	                var next = this.match;
	                if (next.length < 20) {
	                    next += this._input.substr(0, 20 - next.length);
	                }
	                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	            },
	            showPosition: function showPosition() {
	                var pre = this.pastInput();
	                var c = new Array(pre.length + 1).join("-");
	                return pre + this.upcomingInput() + "\n" + c + "^";
	            },
	            next: function next() {
	                if (this.done) {
	                    return this.EOF;
	                }
	                if (!this._input) this.done = true;

	                var token, match, tempMatch, index, col, lines;
	                if (!this._more) {
	                    this.yytext = '';
	                    this.match = '';
	                }
	                var rules = this._currentRules();
	                for (var i = 0; i < rules.length; i++) {
	                    tempMatch = this._input.match(this.rules[rules[i]]);
	                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                        match = tempMatch;
	                        index = i;
	                        if (!this.options.flex) break;
	                    }
	                }
	                if (match) {
	                    lines = match[0].match(/(?:\r\n?|\n).*/g);
	                    if (lines) this.yylineno += lines.length;
	                    this.yylloc = { first_line: this.yylloc.last_line,
	                        last_line: this.yylineno + 1,
	                        first_column: this.yylloc.last_column,
	                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
	                    this.yytext += match[0];
	                    this.match += match[0];
	                    this.matches = match;
	                    this.yyleng = this.yytext.length;
	                    if (this.options.ranges) {
	                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
	                    }
	                    this._more = false;
	                    this._input = this._input.slice(match[0].length);
	                    this.matched += match[0];
	                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
	                    if (this.done && this._input) this.done = false;
	                    if (token) return token;else return;
	                }
	                if (this._input === "") {
	                    return this.EOF;
	                } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
	                }
	            },
	            lex: function lex() {
	                var r = this.next();
	                if (typeof r !== 'undefined') {
	                    return r;
	                } else {
	                    return this.lex();
	                }
	            },
	            begin: function begin(condition) {
	                this.conditionStack.push(condition);
	            },
	            popState: function popState() {
	                return this.conditionStack.pop();
	            },
	            _currentRules: function _currentRules() {
	                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	            },
	            topState: function topState() {
	                return this.conditionStack[this.conditionStack.length - 2];
	            },
	            pushState: function begin(condition) {
	                this.begin(condition);
	            } };
	        lexer.options = {};
	        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
	        /**/) {

	            function strip(start, end) {
	                return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
	            }

	            var YYSTATE = YY_START;
	            switch ($avoiding_name_collisions) {
	                case 0:
	                    if (yy_.yytext.slice(-2) === "\\\\") {
	                        strip(0, 1);
	                        this.begin("mu");
	                    } else if (yy_.yytext.slice(-1) === "\\") {
	                        strip(0, 1);
	                        this.begin("emu");
	                    } else {
	                        this.begin("mu");
	                    }
	                    if (yy_.yytext) return 15;

	                    break;
	                case 1:
	                    return 15;
	                    break;
	                case 2:
	                    this.popState();
	                    return 15;

	                    break;
	                case 3:
	                    this.begin('raw');return 15;
	                    break;
	                case 4:
	                    this.popState();
	                    // Should be using `this.topState()` below, but it currently
	                    // returns the second top instead of the first top. Opened an
	                    // issue about it at https://github.com/zaach/jison/issues/291
	                    if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
	                        return 15;
	                    } else {
	                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
	                        return 'END_RAW_BLOCK';
	                    }

	                    break;
	                case 5:
	                    return 15;
	                    break;
	                case 6:
	                    this.popState();
	                    return 14;

	                    break;
	                case 7:
	                    return 65;
	                    break;
	                case 8:
	                    return 68;
	                    break;
	                case 9:
	                    return 19;
	                    break;
	                case 10:
	                    this.popState();
	                    this.begin('raw');
	                    return 23;

	                    break;
	                case 11:
	                    return 55;
	                    break;
	                case 12:
	                    return 60;
	                    break;
	                case 13:
	                    return 29;
	                    break;
	                case 14:
	                    return 47;
	                    break;
	                case 15:
	                    this.popState();return 44;
	                    break;
	                case 16:
	                    this.popState();return 44;
	                    break;
	                case 17:
	                    return 34;
	                    break;
	                case 18:
	                    return 39;
	                    break;
	                case 19:
	                    return 51;
	                    break;
	                case 20:
	                    return 48;
	                    break;
	                case 21:
	                    this.unput(yy_.yytext);
	                    this.popState();
	                    this.begin('com');

	                    break;
	                case 22:
	                    this.popState();
	                    return 14;

	                    break;
	                case 23:
	                    return 48;
	                    break;
	                case 24:
	                    return 73;
	                    break;
	                case 25:
	                    return 72;
	                    break;
	                case 26:
	                    return 72;
	                    break;
	                case 27:
	                    return 87;
	                    break;
	                case 28:
	                    // ignore whitespace
	                    break;
	                case 29:
	                    this.popState();return 54;
	                    break;
	                case 30:
	                    this.popState();return 33;
	                    break;
	                case 31:
	                    yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
	                    break;
	                case 32:
	                    yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
	                    break;
	                case 33:
	                    return 85;
	                    break;
	                case 34:
	                    return 82;
	                    break;
	                case 35:
	                    return 82;
	                    break;
	                case 36:
	                    return 83;
	                    break;
	                case 37:
	                    return 84;
	                    break;
	                case 38:
	                    return 81;
	                    break;
	                case 39:
	                    return 75;
	                    break;
	                case 40:
	                    return 77;
	                    break;
	                case 41:
	                    return 72;
	                    break;
	                case 42:
	                    yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
	                    break;
	                case 43:
	                    return 'INVALID';
	                    break;
	                case 44:
	                    return 5;
	                    break;
	            }
	        };
	        lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
	        lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
	        return lexer;
	    })();
	    parser.lexer = lexer;
	    function Parser() {
	        this.yy = {};
	    }Parser.prototype = parser;parser.Parser = Parser;
	    return new Parser();
	})();exports["default"] = handlebars;
	module.exports = exports["default"];

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _visitor = __webpack_require__(39);

	var _visitor2 = _interopRequireDefault(_visitor);

	function WhitespaceControl() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

	  this.options = options;
	}
	WhitespaceControl.prototype = new _visitor2['default']();

	WhitespaceControl.prototype.Program = function (program) {
	  var doStandalone = !this.options.ignoreStandalone;

	  var isRoot = !this.isRootSeen;
	  this.isRootSeen = true;

	  var body = program.body;
	  for (var i = 0, l = body.length; i < l; i++) {
	    var current = body[i],
	        strip = this.accept(current);

	    if (!strip) {
	      continue;
	    }

	    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
	        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
	        openStandalone = strip.openStandalone && _isPrevWhitespace,
	        closeStandalone = strip.closeStandalone && _isNextWhitespace,
	        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

	    if (strip.close) {
	      omitRight(body, i, true);
	    }
	    if (strip.open) {
	      omitLeft(body, i, true);
	    }

	    if (doStandalone && inlineStandalone) {
	      omitRight(body, i);

	      if (omitLeft(body, i)) {
	        // If we are on a standalone node, save the indent info for partials
	        if (current.type === 'PartialStatement') {
	          // Pull out the whitespace from the final line
	          current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
	        }
	      }
	    }
	    if (doStandalone && openStandalone) {
	      omitRight((current.program || current.inverse).body);

	      // Strip out the previous content node if it's whitespace only
	      omitLeft(body, i);
	    }
	    if (doStandalone && closeStandalone) {
	      // Always strip the next node
	      omitRight(body, i);

	      omitLeft((current.inverse || current.program).body);
	    }
	  }

	  return program;
	};

	WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
	  this.accept(block.program);
	  this.accept(block.inverse);

	  // Find the inverse program that is involed with whitespace stripping.
	  var program = block.program || block.inverse,
	      inverse = block.program && block.inverse,
	      firstInverse = inverse,
	      lastInverse = inverse;

	  if (inverse && inverse.chained) {
	    firstInverse = inverse.body[0].program;

	    // Walk the inverse chain to find the last inverse that is actually in the chain.
	    while (lastInverse.chained) {
	      lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
	    }
	  }

	  var strip = {
	    open: block.openStrip.open,
	    close: block.closeStrip.close,

	    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
	    // so our parent can determine if we actually are standalone
	    openStandalone: isNextWhitespace(program.body),
	    closeStandalone: isPrevWhitespace((firstInverse || program).body)
	  };

	  if (block.openStrip.close) {
	    omitRight(program.body, null, true);
	  }

	  if (inverse) {
	    var inverseStrip = block.inverseStrip;

	    if (inverseStrip.open) {
	      omitLeft(program.body, null, true);
	    }

	    if (inverseStrip.close) {
	      omitRight(firstInverse.body, null, true);
	    }
	    if (block.closeStrip.open) {
	      omitLeft(lastInverse.body, null, true);
	    }

	    // Find standalone else statments
	    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
	      omitLeft(program.body);
	      omitRight(firstInverse.body);
	    }
	  } else if (block.closeStrip.open) {
	    omitLeft(program.body, null, true);
	  }

	  return strip;
	};

	WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
	  return mustache.strip;
	};

	WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
	  /* istanbul ignore next */
	  var strip = node.strip || {};
	  return {
	    inlineStandalone: true,
	    open: strip.open,
	    close: strip.close
	  };
	};

	function isPrevWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = body.length;
	  }

	  // Nodes that end with newlines are considered whitespace (but are special
	  // cased for strip operations)
	  var prev = body[i - 1],
	      sibling = body[i - 2];
	  if (!prev) {
	    return isRoot;
	  }

	  if (prev.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
	  }
	}
	function isNextWhitespace(body, i, isRoot) {
	  if (i === undefined) {
	    i = -1;
	  }

	  var next = body[i + 1],
	      sibling = body[i + 2];
	  if (!next) {
	    return isRoot;
	  }

	  if (next.type === 'ContentStatement') {
	    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
	  }
	}

	// Marks the node to the right of the position as omitted.
	// I.e. {{foo}}' ' will mark the ' ' node as omitted.
	//
	// If i is undefined, then the first child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitRight(body, i, multiple) {
	  var current = body[i == null ? 0 : i + 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
	    return;
	  }

	  var original = current.value;
	  current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
	  current.rightStripped = current.value !== original;
	}

	// Marks the node to the left of the position as omitted.
	// I.e. ' '{{foo}} will mark the ' ' node as omitted.
	//
	// If i is undefined then the last child will be marked as such.
	//
	// If mulitple is truthy then all whitespace will be stripped out until non-whitespace
	// content is met.
	function omitLeft(body, i, multiple) {
	  var current = body[i == null ? body.length - 1 : i - 1];
	  if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
	    return;
	  }

	  // We omit the last node if it's whitespace only and not preceeded by a non-content node.
	  var original = current.value;
	  current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
	  current.leftStripped = current.value !== original;
	  return current.leftStripped;
	}

	exports['default'] = WhitespaceControl;
	module.exports = exports['default'];

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	function Visitor() {
	  this.parents = [];
	}

	Visitor.prototype = {
	  constructor: Visitor,
	  mutating: false,

	  // Visits a given value. If mutating, will replace the value if necessary.
	  acceptKey: function acceptKey(node, name) {
	    var value = this.accept(node[name]);
	    if (this.mutating) {
	      // Hacky sanity check: This may have a few false positives for type for the helper
	      // methods but will generally do the right thing without a lot of overhead.
	      if (value && !Visitor.prototype[value.type]) {
	        throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
	      }
	      node[name] = value;
	    }
	  },

	  // Performs an accept operation with added sanity check to ensure
	  // required keys are not removed.
	  acceptRequired: function acceptRequired(node, name) {
	    this.acceptKey(node, name);

	    if (!node[name]) {
	      throw new _exception2['default'](node.type + ' requires ' + name);
	    }
	  },

	  // Traverses a given array. If mutating, empty respnses will be removed
	  // for child elements.
	  acceptArray: function acceptArray(array) {
	    for (var i = 0, l = array.length; i < l; i++) {
	      this.acceptKey(array, i);

	      if (!array[i]) {
	        array.splice(i, 1);
	        i--;
	        l--;
	      }
	    }
	  },

	  accept: function accept(object) {
	    if (!object) {
	      return;
	    }

	    /* istanbul ignore next: Sanity code */
	    if (!this[object.type]) {
	      throw new _exception2['default']('Unknown type: ' + object.type, object);
	    }

	    if (this.current) {
	      this.parents.unshift(this.current);
	    }
	    this.current = object;

	    var ret = this[object.type](object);

	    this.current = this.parents.shift();

	    if (!this.mutating || ret) {
	      return ret;
	    } else if (ret !== false) {
	      return object;
	    }
	  },

	  Program: function Program(program) {
	    this.acceptArray(program.body);
	  },

	  MustacheStatement: visitSubExpression,
	  Decorator: visitSubExpression,

	  BlockStatement: visitBlock,
	  DecoratorBlock: visitBlock,

	  PartialStatement: visitPartial,
	  PartialBlockStatement: function PartialBlockStatement(partial) {
	    visitPartial.call(this, partial);

	    this.acceptKey(partial, 'program');
	  },

	  ContentStatement: function ContentStatement() /* content */{},
	  CommentStatement: function CommentStatement() /* comment */{},

	  SubExpression: visitSubExpression,

	  PathExpression: function PathExpression() /* path */{},

	  StringLiteral: function StringLiteral() /* string */{},
	  NumberLiteral: function NumberLiteral() /* number */{},
	  BooleanLiteral: function BooleanLiteral() /* bool */{},
	  UndefinedLiteral: function UndefinedLiteral() /* literal */{},
	  NullLiteral: function NullLiteral() /* literal */{},

	  Hash: function Hash(hash) {
	    this.acceptArray(hash.pairs);
	  },
	  HashPair: function HashPair(pair) {
	    this.acceptRequired(pair, 'value');
	  }
	};

	function visitSubExpression(mustache) {
	  this.acceptRequired(mustache, 'path');
	  this.acceptArray(mustache.params);
	  this.acceptKey(mustache, 'hash');
	}
	function visitBlock(block) {
	  visitSubExpression.call(this, block);

	  this.acceptKey(block, 'program');
	  this.acceptKey(block, 'inverse');
	}
	function visitPartial(partial) {
	  this.acceptRequired(partial, 'name');
	  this.acceptArray(partial.params);
	  this.acceptKey(partial, 'hash');
	}

	exports['default'] = Visitor;
	module.exports = exports['default'];

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.SourceLocation = SourceLocation;
	exports.id = id;
	exports.stripFlags = stripFlags;
	exports.stripComment = stripComment;
	exports.preparePath = preparePath;
	exports.prepareMustache = prepareMustache;
	exports.prepareRawBlock = prepareRawBlock;
	exports.prepareBlock = prepareBlock;
	exports.prepareProgram = prepareProgram;
	exports.preparePartialBlock = preparePartialBlock;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	function validateClose(open, close) {
	  close = close.path ? close.path.original : close;

	  if (open.path.original !== close) {
	    var errorNode = { loc: open.path.loc };

	    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
	  }
	}

	function SourceLocation(source, locInfo) {
	  this.source = source;
	  this.start = {
	    line: locInfo.first_line,
	    column: locInfo.first_column
	  };
	  this.end = {
	    line: locInfo.last_line,
	    column: locInfo.last_column
	  };
	}

	function id(token) {
	  if (/^\[.*\]$/.test(token)) {
	    return token.substr(1, token.length - 2);
	  } else {
	    return token;
	  }
	}

	function stripFlags(open, close) {
	  return {
	    open: open.charAt(2) === '~',
	    close: close.charAt(close.length - 3) === '~'
	  };
	}

	function stripComment(comment) {
	  return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
	}

	function preparePath(data, parts, loc) {
	  loc = this.locInfo(loc);

	  var original = data ? '@' : '',
	      dig = [],
	      depth = 0,
	      depthString = '';

	  for (var i = 0, l = parts.length; i < l; i++) {
	    var part = parts[i].part,

	    // If we have [] syntax then we do not treat path references as operators,
	    // i.e. foo.[this] resolves to approximately context.foo['this']
	    isLiteral = parts[i].original !== part;
	    original += (parts[i].separator || '') + part;

	    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
	      if (dig.length > 0) {
	        throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
	      } else if (part === '..') {
	        depth++;
	        depthString += '../';
	      }
	    } else {
	      dig.push(part);
	    }
	  }

	  return {
	    type: 'PathExpression',
	    data: data,
	    depth: depth,
	    parts: dig,
	    original: original,
	    loc: loc
	  };
	}

	function prepareMustache(path, params, hash, open, strip, locInfo) {
	  // Must use charAt to support IE pre-10
	  var escapeFlag = open.charAt(3) || open.charAt(2),
	      escaped = escapeFlag !== '{' && escapeFlag !== '&';

	  var decorator = /\*/.test(open);
	  return {
	    type: decorator ? 'Decorator' : 'MustacheStatement',
	    path: path,
	    params: params,
	    hash: hash,
	    escaped: escaped,
	    strip: strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareRawBlock(openRawBlock, contents, close, locInfo) {
	  validateClose(openRawBlock, close);

	  locInfo = this.locInfo(locInfo);
	  var program = {
	    type: 'Program',
	    body: contents,
	    strip: {},
	    loc: locInfo
	  };

	  return {
	    type: 'BlockStatement',
	    path: openRawBlock.path,
	    params: openRawBlock.params,
	    hash: openRawBlock.hash,
	    program: program,
	    openStrip: {},
	    inverseStrip: {},
	    closeStrip: {},
	    loc: locInfo
	  };
	}

	function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
	  if (close && close.path) {
	    validateClose(openBlock, close);
	  }

	  var decorator = /\*/.test(openBlock.open);

	  program.blockParams = openBlock.blockParams;

	  var inverse = undefined,
	      inverseStrip = undefined;

	  if (inverseAndProgram) {
	    if (decorator) {
	      throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
	    }

	    if (inverseAndProgram.chain) {
	      inverseAndProgram.program.body[0].closeStrip = close.strip;
	    }

	    inverseStrip = inverseAndProgram.strip;
	    inverse = inverseAndProgram.program;
	  }

	  if (inverted) {
	    inverted = inverse;
	    inverse = program;
	    program = inverted;
	  }

	  return {
	    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
	    path: openBlock.path,
	    params: openBlock.params,
	    hash: openBlock.hash,
	    program: program,
	    inverse: inverse,
	    openStrip: openBlock.strip,
	    inverseStrip: inverseStrip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

	function prepareProgram(statements, loc) {
	  if (!loc && statements.length) {
	    var firstLoc = statements[0].loc,
	        lastLoc = statements[statements.length - 1].loc;

	    /* istanbul ignore else */
	    if (firstLoc && lastLoc) {
	      loc = {
	        source: firstLoc.source,
	        start: {
	          line: firstLoc.start.line,
	          column: firstLoc.start.column
	        },
	        end: {
	          line: lastLoc.end.line,
	          column: lastLoc.end.column
	        }
	      };
	    }
	  }

	  return {
	    type: 'Program',
	    body: statements,
	    strip: {},
	    loc: loc
	  };
	}

	function preparePartialBlock(open, program, close, locInfo) {
	  validateClose(open, close);

	  return {
	    type: 'PartialBlockStatement',
	    name: open.path,
	    params: open.params,
	    hash: open.hash,
	    program: program,
	    openStrip: open.strip,
	    closeStrip: close && close.strip,
	    loc: this.locInfo(locInfo)
	  };
	}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint-disable new-cap */

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;
	exports.Compiler = Compiler;
	exports.precompile = precompile;
	exports.compile = compile;

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = __webpack_require__(5);

	var _ast = __webpack_require__(35);

	var _ast2 = _interopRequireDefault(_ast);

	var slice = [].slice;

	function Compiler() {}

	// the foundHelper register will disambiguate helper lookup from finding a
	// function in a context. This is necessary for mustache compatibility, which
	// requires that context functions in blocks are evaluated by blockHelperMissing,
	// and then proceed as if the resulting value was provided to blockHelperMissing.

	Compiler.prototype = {
	  compiler: Compiler,

	  equals: function equals(other) {
	    var len = this.opcodes.length;
	    if (other.opcodes.length !== len) {
	      return false;
	    }

	    for (var i = 0; i < len; i++) {
	      var opcode = this.opcodes[i],
	          otherOpcode = other.opcodes[i];
	      if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
	        return false;
	      }
	    }

	    // We know that length is the same between the two arrays because they are directly tied
	    // to the opcode behavior above.
	    len = this.children.length;
	    for (var i = 0; i < len; i++) {
	      if (!this.children[i].equals(other.children[i])) {
	        return false;
	      }
	    }

	    return true;
	  },

	  guid: 0,

	  compile: function compile(program, options) {
	    this.sourceNode = [];
	    this.opcodes = [];
	    this.children = [];
	    this.options = options;
	    this.stringParams = options.stringParams;
	    this.trackIds = options.trackIds;

	    options.blockParams = options.blockParams || [];

	    // These changes will propagate to the other compiler components
	    var knownHelpers = options.knownHelpers;
	    options.knownHelpers = {
	      'helperMissing': true,
	      'blockHelperMissing': true,
	      'each': true,
	      'if': true,
	      'unless': true,
	      'with': true,
	      'log': true,
	      'lookup': true
	    };
	    if (knownHelpers) {
	      for (var _name in knownHelpers) {
	        /* istanbul ignore else */
	        if (_name in knownHelpers) {
	          this.options.knownHelpers[_name] = knownHelpers[_name];
	        }
	      }
	    }

	    return this.accept(program);
	  },

	  compileProgram: function compileProgram(program) {
	    var childCompiler = new this.compiler(),
	        // eslint-disable-line new-cap
	    result = childCompiler.compile(program, this.options),
	        guid = this.guid++;

	    this.usePartial = this.usePartial || result.usePartial;

	    this.children[guid] = result;
	    this.useDepths = this.useDepths || result.useDepths;

	    return guid;
	  },

	  accept: function accept(node) {
	    /* istanbul ignore next: Sanity code */
	    if (!this[node.type]) {
	      throw new _exception2['default']('Unknown type: ' + node.type, node);
	    }

	    this.sourceNode.unshift(node);
	    var ret = this[node.type](node);
	    this.sourceNode.shift();
	    return ret;
	  },

	  Program: function Program(program) {
	    this.options.blockParams.unshift(program.blockParams);

	    var body = program.body,
	        bodyLength = body.length;
	    for (var i = 0; i < bodyLength; i++) {
	      this.accept(body[i]);
	    }

	    this.options.blockParams.shift();

	    this.isSimple = bodyLength === 1;
	    this.blockParams = program.blockParams ? program.blockParams.length : 0;

	    return this;
	  },

	  BlockStatement: function BlockStatement(block) {
	    transformLiteralToPath(block);

	    var program = block.program,
	        inverse = block.inverse;

	    program = program && this.compileProgram(program);
	    inverse = inverse && this.compileProgram(inverse);

	    var type = this.classifySexpr(block);

	    if (type === 'helper') {
	      this.helperSexpr(block, program, inverse);
	    } else if (type === 'simple') {
	      this.simpleSexpr(block);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('blockValue', block.path.original);
	    } else {
	      this.ambiguousSexpr(block, program, inverse);

	      // now that the simple mustache is resolved, we need to
	      // evaluate it by executing `blockHelperMissing`
	      this.opcode('pushProgram', program);
	      this.opcode('pushProgram', inverse);
	      this.opcode('emptyHash');
	      this.opcode('ambiguousBlockValue');
	    }

	    this.opcode('append');
	  },

	  DecoratorBlock: function DecoratorBlock(decorator) {
	    var program = decorator.program && this.compileProgram(decorator.program);
	    var params = this.setupFullMustacheParams(decorator, program, undefined),
	        path = decorator.path;

	    this.useDecorators = true;
	    this.opcode('registerDecorator', params.length, path.original);
	  },

	  PartialStatement: function PartialStatement(partial) {
	    this.usePartial = true;

	    var program = partial.program;
	    if (program) {
	      program = this.compileProgram(partial.program);
	    }

	    var params = partial.params;
	    if (params.length > 1) {
	      throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
	    } else if (!params.length) {
	      if (this.options.explicitPartialContext) {
	        this.opcode('pushLiteral', 'undefined');
	      } else {
	        params.push({ type: 'PathExpression', parts: [], depth: 0 });
	      }
	    }

	    var partialName = partial.name.original,
	        isDynamic = partial.name.type === 'SubExpression';
	    if (isDynamic) {
	      this.accept(partial.name);
	    }

	    this.setupFullMustacheParams(partial, program, undefined, true);

	    var indent = partial.indent || '';
	    if (this.options.preventIndent && indent) {
	      this.opcode('appendContent', indent);
	      indent = '';
	    }

	    this.opcode('invokePartial', isDynamic, partialName, indent);
	    this.opcode('append');
	  },
	  PartialBlockStatement: function PartialBlockStatement(partialBlock) {
	    this.PartialStatement(partialBlock);
	  },

	  MustacheStatement: function MustacheStatement(mustache) {
	    this.SubExpression(mustache);

	    if (mustache.escaped && !this.options.noEscape) {
	      this.opcode('appendEscaped');
	    } else {
	      this.opcode('append');
	    }
	  },
	  Decorator: function Decorator(decorator) {
	    this.DecoratorBlock(decorator);
	  },

	  ContentStatement: function ContentStatement(content) {
	    if (content.value) {
	      this.opcode('appendContent', content.value);
	    }
	  },

	  CommentStatement: function CommentStatement() {},

	  SubExpression: function SubExpression(sexpr) {
	    transformLiteralToPath(sexpr);
	    var type = this.classifySexpr(sexpr);

	    if (type === 'simple') {
	      this.simpleSexpr(sexpr);
	    } else if (type === 'helper') {
	      this.helperSexpr(sexpr);
	    } else {
	      this.ambiguousSexpr(sexpr);
	    }
	  },
	  ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
	    var path = sexpr.path,
	        name = path.parts[0],
	        isBlock = program != null || inverse != null;

	    this.opcode('getContext', path.depth);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    path.strict = true;
	    this.accept(path);

	    this.opcode('invokeAmbiguous', name, isBlock);
	  },

	  simpleSexpr: function simpleSexpr(sexpr) {
	    var path = sexpr.path;
	    path.strict = true;
	    this.accept(path);
	    this.opcode('resolvePossibleLambda');
	  },

	  helperSexpr: function helperSexpr(sexpr, program, inverse) {
	    var params = this.setupFullMustacheParams(sexpr, program, inverse),
	        path = sexpr.path,
	        name = path.parts[0];

	    if (this.options.knownHelpers[name]) {
	      this.opcode('invokeKnownHelper', params.length, name);
	    } else if (this.options.knownHelpersOnly) {
	      throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
	    } else {
	      path.strict = true;
	      path.falsy = true;

	      this.accept(path);
	      this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
	    }
	  },

	  PathExpression: function PathExpression(path) {
	    this.addDepth(path.depth);
	    this.opcode('getContext', path.depth);

	    var name = path.parts[0],
	        scoped = _ast2['default'].helpers.scopedId(path),
	        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

	    if (blockParamId) {
	      this.opcode('lookupBlockParam', blockParamId, path.parts);
	    } else if (!name) {
	      // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
	      this.opcode('pushContext');
	    } else if (path.data) {
	      this.options.data = true;
	      this.opcode('lookupData', path.depth, path.parts, path.strict);
	    } else {
	      this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
	    }
	  },

	  StringLiteral: function StringLiteral(string) {
	    this.opcode('pushString', string.value);
	  },

	  NumberLiteral: function NumberLiteral(number) {
	    this.opcode('pushLiteral', number.value);
	  },

	  BooleanLiteral: function BooleanLiteral(bool) {
	    this.opcode('pushLiteral', bool.value);
	  },

	  UndefinedLiteral: function UndefinedLiteral() {
	    this.opcode('pushLiteral', 'undefined');
	  },

	  NullLiteral: function NullLiteral() {
	    this.opcode('pushLiteral', 'null');
	  },

	  Hash: function Hash(hash) {
	    var pairs = hash.pairs,
	        i = 0,
	        l = pairs.length;

	    this.opcode('pushHash');

	    for (; i < l; i++) {
	      this.pushParam(pairs[i].value);
	    }
	    while (i--) {
	      this.opcode('assignToHash', pairs[i].key);
	    }
	    this.opcode('popHash');
	  },

	  // HELPERS
	  opcode: function opcode(name) {
	    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
	  },

	  addDepth: function addDepth(depth) {
	    if (!depth) {
	      return;
	    }

	    this.useDepths = true;
	  },

	  classifySexpr: function classifySexpr(sexpr) {
	    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

	    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

	    // a mustache is an eligible helper if:
	    // * its id is simple (a single part, not `this` or `..`)
	    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

	    // if a mustache is an eligible helper but not a definite
	    // helper, it is ambiguous, and will be resolved in a later
	    // pass or at runtime.
	    var isEligible = !isBlockParam && (isHelper || isSimple);

	    // if ambiguous, we can possibly resolve the ambiguity now
	    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
	    if (isEligible && !isHelper) {
	      var _name2 = sexpr.path.parts[0],
	          options = this.options;

	      if (options.knownHelpers[_name2]) {
	        isHelper = true;
	      } else if (options.knownHelpersOnly) {
	        isEligible = false;
	      }
	    }

	    if (isHelper) {
	      return 'helper';
	    } else if (isEligible) {
	      return 'ambiguous';
	    } else {
	      return 'simple';
	    }
	  },

	  pushParams: function pushParams(params) {
	    for (var i = 0, l = params.length; i < l; i++) {
	      this.pushParam(params[i]);
	    }
	  },

	  pushParam: function pushParam(val) {
	    var value = val.value != null ? val.value : val.original || '';

	    if (this.stringParams) {
	      if (value.replace) {
	        value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
	      }

	      if (val.depth) {
	        this.addDepth(val.depth);
	      }
	      this.opcode('getContext', val.depth || 0);
	      this.opcode('pushStringParam', value, val.type);

	      if (val.type === 'SubExpression') {
	        // SubExpressions get evaluated and passed in
	        // in string params mode.
	        this.accept(val);
	      }
	    } else {
	      if (this.trackIds) {
	        var blockParamIndex = undefined;
	        if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
	          blockParamIndex = this.blockParamIndex(val.parts[0]);
	        }
	        if (blockParamIndex) {
	          var blockParamChild = val.parts.slice(1).join('.');
	          this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
	        } else {
	          value = val.original || value;
	          if (value.replace) {
	            value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
	          }

	          this.opcode('pushId', val.type, value);
	        }
	      }
	      this.accept(val);
	    }
	  },

	  setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
	    var params = sexpr.params;
	    this.pushParams(params);

	    this.opcode('pushProgram', program);
	    this.opcode('pushProgram', inverse);

	    if (sexpr.hash) {
	      this.accept(sexpr.hash);
	    } else {
	      this.opcode('emptyHash', omitEmpty);
	    }

	    return params;
	  },

	  blockParamIndex: function blockParamIndex(name) {
	    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
	      var blockParams = this.options.blockParams[depth],
	          param = blockParams && _utils.indexOf(blockParams, name);
	      if (blockParams && param >= 0) {
	        return [depth, param];
	      }
	    }
	  }
	};

	function precompile(input, options, env) {
	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
	  }

	  options = options || {};
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var ast = env.parse(input, options),
	      environment = new env.Compiler().compile(ast, options);
	  return new env.JavaScriptCompiler().compile(environment, options);
	}

	function compile(input, options, env) {
	  if (options === undefined) options = {};

	  if (input == null || typeof input !== 'string' && input.type !== 'Program') {
	    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
	  }

	  options = _utils.extend({}, options);
	  if (!('data' in options)) {
	    options.data = true;
	  }
	  if (options.compat) {
	    options.useDepths = true;
	  }

	  var compiled = undefined;

	  function compileInput() {
	    var ast = env.parse(input, options),
	        environment = new env.Compiler().compile(ast, options),
	        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
	    return env.template(templateSpec);
	  }

	  // Template is only compiled on first use and cached after that point.
	  function ret(context, execOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled.call(this, context, execOptions);
	  }
	  ret._setup = function (setupOptions) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._setup(setupOptions);
	  };
	  ret._child = function (i, data, blockParams, depths) {
	    if (!compiled) {
	      compiled = compileInput();
	    }
	    return compiled._child(i, data, blockParams, depths);
	  };
	  return ret;
	}

	function argEquals(a, b) {
	  if (a === b) {
	    return true;
	  }

	  if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
	    for (var i = 0; i < a.length; i++) {
	      if (!argEquals(a[i], b[i])) {
	        return false;
	      }
	    }
	    return true;
	  }
	}

	function transformLiteralToPath(sexpr) {
	  if (!sexpr.path.parts) {
	    var literal = sexpr.path;
	    // Casting to string here to make false and 0 literal values play nicely with the rest
	    // of the system.
	    sexpr.path = {
	      type: 'PathExpression',
	      data: false,
	      depth: 0,
	      parts: [literal.original + ''],
	      original: literal.original + '',
	      loc: literal.loc
	    };
	  }
	}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _interopRequireDefault = __webpack_require__(1)['default'];

	exports.__esModule = true;

	var _base = __webpack_require__(4);

	var _exception = __webpack_require__(6);

	var _exception2 = _interopRequireDefault(_exception);

	var _utils = __webpack_require__(5);

	var _codeGen = __webpack_require__(43);

	var _codeGen2 = _interopRequireDefault(_codeGen);

	function Literal(value) {
	  this.value = value;
	}

	function JavaScriptCompiler() {}

	JavaScriptCompiler.prototype = {
	  // PUBLIC API: You can override these methods in a subclass to provide
	  // alternative compiled forms for name lookup and buffering semantics
	  nameLookup: function nameLookup(parent, name /* , type*/) {
	    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
	      return [parent, '.', name];
	    } else {
	      return [parent, '[', JSON.stringify(name), ']'];
	    }
	  },
	  depthedLookup: function depthedLookup(name) {
	    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
	  },

	  compilerInfo: function compilerInfo() {
	    var revision = _base.COMPILER_REVISION,
	        versions = _base.REVISION_CHANGES[revision];
	    return [revision, versions];
	  },

	  appendToBuffer: function appendToBuffer(source, location, explicit) {
	    // Force a source as this simplifies the merge logic.
	    if (!_utils.isArray(source)) {
	      source = [source];
	    }
	    source = this.source.wrap(source, location);

	    if (this.environment.isSimple) {
	      return ['return ', source, ';'];
	    } else if (explicit) {
	      // This is a case where the buffer operation occurs as a child of another
	      // construct, generally braces. We have to explicitly output these buffer
	      // operations to ensure that the emitted code goes in the correct location.
	      return ['buffer += ', source, ';'];
	    } else {
	      source.appendToBuffer = true;
	      return source;
	    }
	  },

	  initializeBuffer: function initializeBuffer() {
	    return this.quotedString('');
	  },
	  // END PUBLIC API

	  compile: function compile(environment, options, context, asObject) {
	    this.environment = environment;
	    this.options = options;
	    this.stringParams = this.options.stringParams;
	    this.trackIds = this.options.trackIds;
	    this.precompile = !asObject;

	    this.name = this.environment.name;
	    this.isChild = !!context;
	    this.context = context || {
	      decorators: [],
	      programs: [],
	      environments: []
	    };

	    this.preamble();

	    this.stackSlot = 0;
	    this.stackVars = [];
	    this.aliases = {};
	    this.registers = { list: [] };
	    this.hashes = [];
	    this.compileStack = [];
	    this.inlineStack = [];
	    this.blockParams = [];

	    this.compileChildren(environment, options);

	    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
	    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

	    var opcodes = environment.opcodes,
	        opcode = undefined,
	        firstLoc = undefined,
	        i = undefined,
	        l = undefined;

	    for (i = 0, l = opcodes.length; i < l; i++) {
	      opcode = opcodes[i];

	      this.source.currentLocation = opcode.loc;
	      firstLoc = firstLoc || opcode.loc;
	      this[opcode.opcode].apply(this, opcode.args);
	    }

	    // Flush any trailing content that might be pending.
	    this.source.currentLocation = firstLoc;
	    this.pushSource('');

	    /* istanbul ignore next */
	    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
	      throw new _exception2['default']('Compile completed with content left on stack');
	    }

	    if (!this.decorators.isEmpty()) {
	      this.useDecorators = true;

	      this.decorators.prepend('var decorators = container.decorators;\n');
	      this.decorators.push('return fn;');

	      if (asObject) {
	        this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
	      } else {
	        this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
	        this.decorators.push('}\n');
	        this.decorators = this.decorators.merge();
	      }
	    } else {
	      this.decorators = undefined;
	    }

	    var fn = this.createFunctionContext(asObject);
	    if (!this.isChild) {
	      var ret = {
	        compiler: this.compilerInfo(),
	        main: fn
	      };

	      if (this.decorators) {
	        ret.main_d = this.decorators; // eslint-disable-line camelcase
	        ret.useDecorators = true;
	      }

	      var _context = this.context;
	      var programs = _context.programs;
	      var decorators = _context.decorators;

	      for (i = 0, l = programs.length; i < l; i++) {
	        if (programs[i]) {
	          ret[i] = programs[i];
	          if (decorators[i]) {
	            ret[i + '_d'] = decorators[i];
	            ret.useDecorators = true;
	          }
	        }
	      }

	      if (this.environment.usePartial) {
	        ret.usePartial = true;
	      }
	      if (this.options.data) {
	        ret.useData = true;
	      }
	      if (this.useDepths) {
	        ret.useDepths = true;
	      }
	      if (this.useBlockParams) {
	        ret.useBlockParams = true;
	      }
	      if (this.options.compat) {
	        ret.compat = true;
	      }

	      if (!asObject) {
	        ret.compiler = JSON.stringify(ret.compiler);

	        this.source.currentLocation = { start: { line: 1, column: 0 } };
	        ret = this.objectLiteral(ret);

	        if (options.srcName) {
	          ret = ret.toStringWithSourceMap({ file: options.destName });
	          ret.map = ret.map && ret.map.toString();
	        } else {
	          ret = ret.toString();
	        }
	      } else {
	        ret.compilerOptions = this.options;
	      }

	      return ret;
	    } else {
	      return fn;
	    }
	  },

	  preamble: function preamble() {
	    // track the last context pushed into place to allow skipping the
	    // getContext opcode when it would be a noop
	    this.lastContext = 0;
	    this.source = new _codeGen2['default'](this.options.srcName);
	    this.decorators = new _codeGen2['default'](this.options.srcName);
	  },

	  createFunctionContext: function createFunctionContext(asObject) {
	    var varDeclarations = '';

	    var locals = this.stackVars.concat(this.registers.list);
	    if (locals.length > 0) {
	      varDeclarations += ', ' + locals.join(', ');
	    }

	    // Generate minimizer alias mappings
	    //
	    // When using true SourceNodes, this will update all references to the given alias
	    // as the source nodes are reused in situ. For the non-source node compilation mode,
	    // aliases will not be used, but this case is already being run on the client and
	    // we aren't concern about minimizing the template size.
	    var aliasCount = 0;
	    for (var alias in this.aliases) {
	      // eslint-disable-line guard-for-in
	      var node = this.aliases[alias];

	      if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
	        varDeclarations += ', alias' + ++aliasCount + '=' + alias;
	        node.children[0] = 'alias' + aliasCount;
	      }
	    }

	    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

	    if (this.useBlockParams || this.useDepths) {
	      params.push('blockParams');
	    }
	    if (this.useDepths) {
	      params.push('depths');
	    }

	    // Perform a second pass over the output to merge content when possible
	    var source = this.mergeSource(varDeclarations);

	    if (asObject) {
	      params.push(source);

	      return Function.apply(this, params);
	    } else {
	      return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
	    }
	  },
	  mergeSource: function mergeSource(varDeclarations) {
	    var isSimple = this.environment.isSimple,
	        appendOnly = !this.forceBuffer,
	        appendFirst = undefined,
	        sourceSeen = undefined,
	        bufferStart = undefined,
	        bufferEnd = undefined;
	    this.source.each(function (line) {
	      if (line.appendToBuffer) {
	        if (bufferStart) {
	          line.prepend('  + ');
	        } else {
	          bufferStart = line;
	        }
	        bufferEnd = line;
	      } else {
	        if (bufferStart) {
	          if (!sourceSeen) {
	            appendFirst = true;
	          } else {
	            bufferStart.prepend('buffer += ');
	          }
	          bufferEnd.add(';');
	          bufferStart = bufferEnd = undefined;
	        }

	        sourceSeen = true;
	        if (!isSimple) {
	          appendOnly = false;
	        }
	      }
	    });

	    if (appendOnly) {
	      if (bufferStart) {
	        bufferStart.prepend('return ');
	        bufferEnd.add(';');
	      } else if (!sourceSeen) {
	        this.source.push('return "";');
	      }
	    } else {
	      varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

	      if (bufferStart) {
	        bufferStart.prepend('return buffer + ');
	        bufferEnd.add(';');
	      } else {
	        this.source.push('return buffer;');
	      }
	    }

	    if (varDeclarations) {
	      this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
	    }

	    return this.source.merge();
	  },

	  // [blockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // On stack, after: return value of blockHelperMissing
	  //
	  // The purpose of this opcode is to take a block of the form
	  // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
	  // replace it on the stack with the result of properly
	  // invoking blockHelperMissing.
	  blockValue: function blockValue(name) {
	    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs(name, 0, params);

	    var blockName = this.popStack();
	    params.splice(1, 0, blockName);

	    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
	  },

	  // [ambiguousBlockValue]
	  //
	  // On stack, before: hash, inverse, program, value
	  // Compiler value, before: lastHelper=value of last found helper, if any
	  // On stack, after, if no lastHelper: same as [blockValue]
	  // On stack, after, if lastHelper: value
	  ambiguousBlockValue: function ambiguousBlockValue() {
	    // We're being a bit cheeky and reusing the options value from the prior exec
	    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
	        params = [this.contextName(0)];
	    this.setupHelperArgs('', 0, params, true);

	    this.flushInline();

	    var current = this.topStack();
	    params.splice(1, 0, current);

	    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
	  },

	  // [appendContent]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  //
	  // Appends the string value of `content` to the current buffer
	  appendContent: function appendContent(content) {
	    if (this.pendingContent) {
	      content = this.pendingContent + content;
	    } else {
	      this.pendingLocation = this.source.currentLocation;
	    }

	    this.pendingContent = content;
	  },

	  // [append]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Coerces `value` to a String and appends it to the current buffer.
	  //
	  // If `value` is truthy, or 0, it is coerced into a string and appended
	  // Otherwise, the empty string is appended
	  append: function append() {
	    if (this.isInline()) {
	      this.replaceStack(function (current) {
	        return [' != null ? ', current, ' : ""'];
	      });

	      this.pushSource(this.appendToBuffer(this.popStack()));
	    } else {
	      var local = this.popStack();
	      this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
	      if (this.environment.isSimple) {
	        this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
	      }
	    }
	  },

	  // [appendEscaped]
	  //
	  // On stack, before: value, ...
	  // On stack, after: ...
	  //
	  // Escape `value` and append it to the buffer
	  appendEscaped: function appendEscaped() {
	    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
	  },

	  // [getContext]
	  //
	  // On stack, before: ...
	  // On stack, after: ...
	  // Compiler value, after: lastContext=depth
	  //
	  // Set the value of the `lastContext` compiler value to the depth
	  getContext: function getContext(depth) {
	    this.lastContext = depth;
	  },

	  // [pushContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext, ...
	  //
	  // Pushes the value of the current context onto the stack.
	  pushContext: function pushContext() {
	    this.pushStackLiteral(this.contextName(this.lastContext));
	  },

	  // [lookupOnContext]
	  //
	  // On stack, before: ...
	  // On stack, after: currentContext[name], ...
	  //
	  // Looks up the value of `name` on the current context and pushes
	  // it onto the stack.
	  lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
	    var i = 0;

	    if (!scoped && this.options.compat && !this.lastContext) {
	      // The depthed query is expected to handle the undefined logic for the root level that
	      // is implemented below, so we evaluate that directly in compat mode
	      this.push(this.depthedLookup(parts[i++]));
	    } else {
	      this.pushContext();
	    }

	    this.resolvePath('context', parts, i, falsy, strict);
	  },

	  // [lookupBlockParam]
	  //
	  // On stack, before: ...
	  // On stack, after: blockParam[name], ...
	  //
	  // Looks up the value of `parts` on the given block param and pushes
	  // it onto the stack.
	  lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
	    this.useBlockParams = true;

	    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
	    this.resolvePath('context', parts, 1);
	  },

	  // [lookupData]
	  //
	  // On stack, before: ...
	  // On stack, after: data, ...
	  //
	  // Push the data lookup operator
	  lookupData: function lookupData(depth, parts, strict) {
	    if (!depth) {
	      this.pushStackLiteral('data');
	    } else {
	      this.pushStackLiteral('container.data(data, ' + depth + ')');
	    }

	    this.resolvePath('data', parts, 0, true, strict);
	  },

	  resolvePath: function resolvePath(type, parts, i, falsy, strict) {
	    // istanbul ignore next

	    var _this = this;

	    if (this.options.strict || this.options.assumeObjects) {
	      this.push(strictLookup(this.options.strict && strict, this, parts, type));
	      return;
	    }

	    var len = parts.length;
	    for (; i < len; i++) {
	      /* eslint-disable no-loop-func */
	      this.replaceStack(function (current) {
	        var lookup = _this.nameLookup(current, parts[i], type);
	        // We want to ensure that zero and false are handled properly if the context (falsy flag)
	        // needs to have the special handling for these values.
	        if (!falsy) {
	          return [' != null ? ', lookup, ' : ', current];
	        } else {
	          // Otherwise we can use generic falsy handling
	          return [' && ', lookup];
	        }
	      });
	      /* eslint-enable no-loop-func */
	    }
	  },

	  // [resolvePossibleLambda]
	  //
	  // On stack, before: value, ...
	  // On stack, after: resolved value, ...
	  //
	  // If the `value` is a lambda, replace it on the stack by
	  // the return value of the lambda
	  resolvePossibleLambda: function resolvePossibleLambda() {
	    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
	  },

	  // [pushStringParam]
	  //
	  // On stack, before: ...
	  // On stack, after: string, currentContext, ...
	  //
	  // This opcode is designed for use in string mode, which
	  // provides the string value of a parameter along with its
	  // depth rather than resolving it immediately.
	  pushStringParam: function pushStringParam(string, type) {
	    this.pushContext();
	    this.pushString(type);

	    // If it's a subexpression, the string result
	    // will be pushed after this opcode.
	    if (type !== 'SubExpression') {
	      if (typeof string === 'string') {
	        this.pushString(string);
	      } else {
	        this.pushStackLiteral(string);
	      }
	    }
	  },

	  emptyHash: function emptyHash(omitEmpty) {
	    if (this.trackIds) {
	      this.push('{}'); // hashIds
	    }
	    if (this.stringParams) {
	      this.push('{}'); // hashContexts
	      this.push('{}'); // hashTypes
	    }
	    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
	  },
	  pushHash: function pushHash() {
	    if (this.hash) {
	      this.hashes.push(this.hash);
	    }
	    this.hash = { values: [], types: [], contexts: [], ids: [] };
	  },
	  popHash: function popHash() {
	    var hash = this.hash;
	    this.hash = this.hashes.pop();

	    if (this.trackIds) {
	      this.push(this.objectLiteral(hash.ids));
	    }
	    if (this.stringParams) {
	      this.push(this.objectLiteral(hash.contexts));
	      this.push(this.objectLiteral(hash.types));
	    }

	    this.push(this.objectLiteral(hash.values));
	  },

	  // [pushString]
	  //
	  // On stack, before: ...
	  // On stack, after: quotedString(string), ...
	  //
	  // Push a quoted version of `string` onto the stack
	  pushString: function pushString(string) {
	    this.pushStackLiteral(this.quotedString(string));
	  },

	  // [pushLiteral]
	  //
	  // On stack, before: ...
	  // On stack, after: value, ...
	  //
	  // Pushes a value onto the stack. This operation prevents
	  // the compiler from creating a temporary variable to hold
	  // it.
	  pushLiteral: function pushLiteral(value) {
	    this.pushStackLiteral(value);
	  },

	  // [pushProgram]
	  //
	  // On stack, before: ...
	  // On stack, after: program(guid), ...
	  //
	  // Push a program expression onto the stack. This takes
	  // a compile-time guid and converts it into a runtime-accessible
	  // expression.
	  pushProgram: function pushProgram(guid) {
	    if (guid != null) {
	      this.pushStackLiteral(this.programExpression(guid));
	    } else {
	      this.pushStackLiteral(null);
	    }
	  },

	  // [registerDecorator]
	  //
	  // On stack, before: hash, program, params..., ...
	  // On stack, after: ...
	  //
	  // Pops off the decorator's parameters, invokes the decorator,
	  // and inserts the decorator into the decorators list.
	  registerDecorator: function registerDecorator(paramSize, name) {
	    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
	        options = this.setupHelperArgs(name, paramSize);

	    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
	  },

	  // [invokeHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // Pops off the helper's parameters, invokes the helper,
	  // and pushes the helper's return value onto the stack.
	  //
	  // If the helper is not found, `helperMissing` is called.
	  invokeHelper: function invokeHelper(paramSize, name, isSimple) {
	    var nonHelper = this.popStack(),
	        helper = this.setupHelper(paramSize, name),
	        simple = isSimple ? [helper.name, ' || '] : '';

	    var lookup = ['('].concat(simple, nonHelper);
	    if (!this.options.strict) {
	      lookup.push(' || ', this.aliasable('helpers.helperMissing'));
	    }
	    lookup.push(')');

	    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
	  },

	  // [invokeKnownHelper]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of helper invocation
	  //
	  // This operation is used when the helper is known to exist,
	  // so a `helperMissing` fallback is not required.
	  invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
	    var helper = this.setupHelper(paramSize, name);
	    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
	  },

	  // [invokeAmbiguous]
	  //
	  // On stack, before: hash, inverse, program, params..., ...
	  // On stack, after: result of disambiguation
	  //
	  // This operation is used when an expression like `{{foo}}`
	  // is provided, but we don't know at compile-time whether it
	  // is a helper or a path.
	  //
	  // This operation emits more code than the other options,
	  // and can be avoided by passing the `knownHelpers` and
	  // `knownHelpersOnly` flags at compile-time.
	  invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
	    this.useRegister('helper');

	    var nonHelper = this.popStack();

	    this.emptyHash();
	    var helper = this.setupHelper(0, name, helperCall);

	    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

	    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
	    if (!this.options.strict) {
	      lookup[0] = '(helper = ';
	      lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
	    }

	    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
	  },

	  // [invokePartial]
	  //
	  // On stack, before: context, ...
	  // On stack after: result of partial invocation
	  //
	  // This operation pops off a context, invokes a partial with that context,
	  // and pushes the result of the invocation back.
	  invokePartial: function invokePartial(isDynamic, name, indent) {
	    var params = [],
	        options = this.setupParams(name, 1, params);

	    if (isDynamic) {
	      name = this.popStack();
	      delete options.name;
	    }

	    if (indent) {
	      options.indent = JSON.stringify(indent);
	    }
	    options.helpers = 'helpers';
	    options.partials = 'partials';
	    options.decorators = 'container.decorators';

	    if (!isDynamic) {
	      params.unshift(this.nameLookup('partials', name, 'partial'));
	    } else {
	      params.unshift(name);
	    }

	    if (this.options.compat) {
	      options.depths = 'depths';
	    }
	    options = this.objectLiteral(options);
	    params.push(options);

	    this.push(this.source.functionCall('container.invokePartial', '', params));
	  },

	  // [assignToHash]
	  //
	  // On stack, before: value, ..., hash, ...
	  // On stack, after: ..., hash, ...
	  //
	  // Pops a value off the stack and assigns it to the current hash
	  assignToHash: function assignToHash(key) {
	    var value = this.popStack(),
	        context = undefined,
	        type = undefined,
	        id = undefined;

	    if (this.trackIds) {
	      id = this.popStack();
	    }
	    if (this.stringParams) {
	      type = this.popStack();
	      context = this.popStack();
	    }

	    var hash = this.hash;
	    if (context) {
	      hash.contexts[key] = context;
	    }
	    if (type) {
	      hash.types[key] = type;
	    }
	    if (id) {
	      hash.ids[key] = id;
	    }
	    hash.values[key] = value;
	  },

	  pushId: function pushId(type, name, child) {
	    if (type === 'BlockParam') {
	      this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
	    } else if (type === 'PathExpression') {
	      this.pushString(name);
	    } else if (type === 'SubExpression') {
	      this.pushStackLiteral('true');
	    } else {
	      this.pushStackLiteral('null');
	    }
	  },

	  // HELPERS

	  compiler: JavaScriptCompiler,

	  compileChildren: function compileChildren(environment, options) {
	    var children = environment.children,
	        child = undefined,
	        compiler = undefined;

	    for (var i = 0, l = children.length; i < l; i++) {
	      child = children[i];
	      compiler = new this.compiler(); // eslint-disable-line new-cap

	      var existing = this.matchExistingProgram(child);

	      if (existing == null) {
	        this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
	        var index = this.context.programs.length;
	        child.index = index;
	        child.name = 'program' + index;
	        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
	        this.context.decorators[index] = compiler.decorators;
	        this.context.environments[index] = child;

	        this.useDepths = this.useDepths || compiler.useDepths;
	        this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
	        child.useDepths = this.useDepths;
	        child.useBlockParams = this.useBlockParams;
	      } else {
	        child.index = existing.index;
	        child.name = 'program' + existing.index;

	        this.useDepths = this.useDepths || existing.useDepths;
	        this.useBlockParams = this.useBlockParams || existing.useBlockParams;
	      }
	    }
	  },
	  matchExistingProgram: function matchExistingProgram(child) {
	    for (var i = 0, len = this.context.environments.length; i < len; i++) {
	      var environment = this.context.environments[i];
	      if (environment && environment.equals(child)) {
	        return environment;
	      }
	    }
	  },

	  programExpression: function programExpression(guid) {
	    var child = this.environment.children[guid],
	        programParams = [child.index, 'data', child.blockParams];

	    if (this.useBlockParams || this.useDepths) {
	      programParams.push('blockParams');
	    }
	    if (this.useDepths) {
	      programParams.push('depths');
	    }

	    return 'container.program(' + programParams.join(', ') + ')';
	  },

	  useRegister: function useRegister(name) {
	    if (!this.registers[name]) {
	      this.registers[name] = true;
	      this.registers.list.push(name);
	    }
	  },

	  push: function push(expr) {
	    if (!(expr instanceof Literal)) {
	      expr = this.source.wrap(expr);
	    }

	    this.inlineStack.push(expr);
	    return expr;
	  },

	  pushStackLiteral: function pushStackLiteral(item) {
	    this.push(new Literal(item));
	  },

	  pushSource: function pushSource(source) {
	    if (this.pendingContent) {
	      this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
	      this.pendingContent = undefined;
	    }

	    if (source) {
	      this.source.push(source);
	    }
	  },

	  replaceStack: function replaceStack(callback) {
	    var prefix = ['('],
	        stack = undefined,
	        createdStack = undefined,
	        usedLiteral = undefined;

	    /* istanbul ignore next */
	    if (!this.isInline()) {
	      throw new _exception2['default']('replaceStack on non-inline');
	    }

	    // We want to merge the inline statement into the replacement statement via ','
	    var top = this.popStack(true);

	    if (top instanceof Literal) {
	      // Literals do not need to be inlined
	      stack = [top.value];
	      prefix = ['(', stack];
	      usedLiteral = true;
	    } else {
	      // Get or create the current stack name for use by the inline
	      createdStack = true;
	      var _name = this.incrStack();

	      prefix = ['((', this.push(_name), ' = ', top, ')'];
	      stack = this.topStack();
	    }

	    var item = callback.call(this, stack);

	    if (!usedLiteral) {
	      this.popStack();
	    }
	    if (createdStack) {
	      this.stackSlot--;
	    }
	    this.push(prefix.concat(item, ')'));
	  },

	  incrStack: function incrStack() {
	    this.stackSlot++;
	    if (this.stackSlot > this.stackVars.length) {
	      this.stackVars.push('stack' + this.stackSlot);
	    }
	    return this.topStackName();
	  },
	  topStackName: function topStackName() {
	    return 'stack' + this.stackSlot;
	  },
	  flushInline: function flushInline() {
	    var inlineStack = this.inlineStack;
	    this.inlineStack = [];
	    for (var i = 0, len = inlineStack.length; i < len; i++) {
	      var entry = inlineStack[i];
	      /* istanbul ignore if */
	      if (entry instanceof Literal) {
	        this.compileStack.push(entry);
	      } else {
	        var stack = this.incrStack();
	        this.pushSource([stack, ' = ', entry, ';']);
	        this.compileStack.push(stack);
	      }
	    }
	  },
	  isInline: function isInline() {
	    return this.inlineStack.length;
	  },

	  popStack: function popStack(wrapped) {
	    var inline = this.isInline(),
	        item = (inline ? this.inlineStack : this.compileStack).pop();

	    if (!wrapped && item instanceof Literal) {
	      return item.value;
	    } else {
	      if (!inline) {
	        /* istanbul ignore next */
	        if (!this.stackSlot) {
	          throw new _exception2['default']('Invalid stack pop');
	        }
	        this.stackSlot--;
	      }
	      return item;
	    }
	  },

	  topStack: function topStack() {
	    var stack = this.isInline() ? this.inlineStack : this.compileStack,
	        item = stack[stack.length - 1];

	    /* istanbul ignore if */
	    if (item instanceof Literal) {
	      return item.value;
	    } else {
	      return item;
	    }
	  },

	  contextName: function contextName(context) {
	    if (this.useDepths && context) {
	      return 'depths[' + context + ']';
	    } else {
	      return 'depth' + context;
	    }
	  },

	  quotedString: function quotedString(str) {
	    return this.source.quotedString(str);
	  },

	  objectLiteral: function objectLiteral(obj) {
	    return this.source.objectLiteral(obj);
	  },

	  aliasable: function aliasable(name) {
	    var ret = this.aliases[name];
	    if (ret) {
	      ret.referenceCount++;
	      return ret;
	    }

	    ret = this.aliases[name] = this.source.wrap(name);
	    ret.aliasable = true;
	    ret.referenceCount = 1;

	    return ret;
	  },

	  setupHelper: function setupHelper(paramSize, name, blockHelper) {
	    var params = [],
	        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
	    var foundHelper = this.nameLookup('helpers', name, 'helper'),
	        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

	    return {
	      params: params,
	      paramsInit: paramsInit,
	      name: foundHelper,
	      callParams: [callContext].concat(params)
	    };
	  },

	  setupParams: function setupParams(helper, paramSize, params) {
	    var options = {},
	        contexts = [],
	        types = [],
	        ids = [],
	        objectArgs = !params,
	        param = undefined;

	    if (objectArgs) {
	      params = [];
	    }

	    options.name = this.quotedString(helper);
	    options.hash = this.popStack();

	    if (this.trackIds) {
	      options.hashIds = this.popStack();
	    }
	    if (this.stringParams) {
	      options.hashTypes = this.popStack();
	      options.hashContexts = this.popStack();
	    }

	    var inverse = this.popStack(),
	        program = this.popStack();

	    // Avoid setting fn and inverse if neither are set. This allows
	    // helpers to do a check for `if (options.fn)`
	    if (program || inverse) {
	      options.fn = program || 'container.noop';
	      options.inverse = inverse || 'container.noop';
	    }

	    // The parameters go on to the stack in order (making sure that they are evaluated in order)
	    // so we need to pop them off the stack in reverse order
	    var i = paramSize;
	    while (i--) {
	      param = this.popStack();
	      params[i] = param;

	      if (this.trackIds) {
	        ids[i] = this.popStack();
	      }
	      if (this.stringParams) {
	        types[i] = this.popStack();
	        contexts[i] = this.popStack();
	      }
	    }

	    if (objectArgs) {
	      options.args = this.source.generateArray(params);
	    }

	    if (this.trackIds) {
	      options.ids = this.source.generateArray(ids);
	    }
	    if (this.stringParams) {
	      options.types = this.source.generateArray(types);
	      options.contexts = this.source.generateArray(contexts);
	    }

	    if (this.options.data) {
	      options.data = 'data';
	    }
	    if (this.useBlockParams) {
	      options.blockParams = 'blockParams';
	    }
	    return options;
	  },

	  setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
	    var options = this.setupParams(helper, paramSize, params);
	    options = this.objectLiteral(options);
	    if (useRegister) {
	      this.useRegister('options');
	      params.push('options');
	      return ['options=', options];
	    } else if (params) {
	      params.push(options);
	      return '';
	    } else {
	      return options;
	    }
	  }
	};

	(function () {
	  var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

	  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

	  for (var i = 0, l = reservedWords.length; i < l; i++) {
	    compilerWords[reservedWords[i]] = true;
	  }
	})();

	JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
	  return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
	};

	function strictLookup(requireTerminal, compiler, parts, type) {
	  var stack = compiler.popStack(),
	      i = 0,
	      len = parts.length;
	  if (requireTerminal) {
	    len--;
	  }

	  for (; i < len; i++) {
	    stack = compiler.nameLookup(stack, parts[i], type);
	  }

	  if (requireTerminal) {
	    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
	  } else {
	    return stack;
	  }
	}

	exports['default'] = JavaScriptCompiler;
	module.exports = exports['default'];

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/* global define */
	'use strict';

	exports.__esModule = true;

	var _utils = __webpack_require__(5);

	var SourceNode = undefined;

	try {
	  /* istanbul ignore next */
	  if (false) {
	    // We don't support this in AMD environments. For these environments, we asusme that
	    // they are running on the browser and thus have no need for the source-map library.
	    var SourceMap = require('source-map');
	    SourceNode = SourceMap.SourceNode;
	  }
	} catch (err) {}
	/* NOP */

	/* istanbul ignore if: tested but not covered in istanbul due to dist build  */
	if (!SourceNode) {
	  SourceNode = function (line, column, srcFile, chunks) {
	    this.src = '';
	    if (chunks) {
	      this.add(chunks);
	    }
	  };
	  /* istanbul ignore next */
	  SourceNode.prototype = {
	    add: function add(chunks) {
	      if (_utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src += chunks;
	    },
	    prepend: function prepend(chunks) {
	      if (_utils.isArray(chunks)) {
	        chunks = chunks.join('');
	      }
	      this.src = chunks + this.src;
	    },
	    toStringWithSourceMap: function toStringWithSourceMap() {
	      return { code: this.toString() };
	    },
	    toString: function toString() {
	      return this.src;
	    }
	  };
	}

	function castChunk(chunk, codeGen, loc) {
	  if (_utils.isArray(chunk)) {
	    var ret = [];

	    for (var i = 0, len = chunk.length; i < len; i++) {
	      ret.push(codeGen.wrap(chunk[i], loc));
	    }
	    return ret;
	  } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
	    // Handle primitives that the SourceNode will throw up on
	    return chunk + '';
	  }
	  return chunk;
	}

	function CodeGen(srcFile) {
	  this.srcFile = srcFile;
	  this.source = [];
	}

	CodeGen.prototype = {
	  isEmpty: function isEmpty() {
	    return !this.source.length;
	  },
	  prepend: function prepend(source, loc) {
	    this.source.unshift(this.wrap(source, loc));
	  },
	  push: function push(source, loc) {
	    this.source.push(this.wrap(source, loc));
	  },

	  merge: function merge() {
	    var source = this.empty();
	    this.each(function (line) {
	      source.add(['  ', line, '\n']);
	    });
	    return source;
	  },

	  each: function each(iter) {
	    for (var i = 0, len = this.source.length; i < len; i++) {
	      iter(this.source[i]);
	    }
	  },

	  empty: function empty() {
	    var loc = this.currentLocation || { start: {} };
	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
	  },
	  wrap: function wrap(chunk) {
	    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

	    if (chunk instanceof SourceNode) {
	      return chunk;
	    }

	    chunk = castChunk(chunk, this, loc);

	    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
	  },

	  functionCall: function functionCall(fn, type, params) {
	    params = this.generateList(params);
	    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
	  },

	  quotedString: function quotedString(str) {
	    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
	    .replace(/\u2029/g, '\\u2029') + '"';
	  },

	  objectLiteral: function objectLiteral(obj) {
	    var pairs = [];

	    for (var key in obj) {
	      if (obj.hasOwnProperty(key)) {
	        var value = castChunk(obj[key], this);
	        if (value !== 'undefined') {
	          pairs.push([this.quotedString(key), ':', value]);
	        }
	      }
	    }

	    var ret = this.generateList(pairs);
	    ret.prepend('{');
	    ret.add('}');
	    return ret;
	  },

	  generateList: function generateList(entries) {
	    var ret = this.empty();

	    for (var i = 0, len = entries.length; i < len; i++) {
	      if (i) {
	        ret.add(',');
	      }

	      ret.add(castChunk(entries[i], this));
	    }

	    return ret;
	  },

	  generateArray: function generateArray(entries) {
	    var ret = this.generateList(entries);
	    ret.prepend('[');
	    ret.add(']');

	    return ret;
	  }
	};

	exports['default'] = CodeGen;
	module.exports = exports['default'];

/***/ })
/******/ ])
});
;
/*
    JavaScript autoComplete v1.0.4
    Copyright (c) 2014 Simon Steinberger / Pixabay
    GitHub: https://github.com/Pixabay/JavaScript-autoComplete
    License: http://www.opensource.org/licenses/mit-license.php
*/

var autoComplete = (function(){
    // "use strict";
    function autoComplete(options){
        if (!document.querySelector) return;

        // helpers
        function hasClass(el, className){ return el.classList ? el.classList.contains(className) : new RegExp('\\b'+ className+'\\b').test(el.className); }

        function addEvent(el, type, handler){
            if (el.attachEvent) el.attachEvent('on'+type, handler); else el.addEventListener(type, handler);
        }
        function removeEvent(el, type, handler){
            // if (el.removeEventListener) not working in IE11
            if (el.detachEvent) el.detachEvent('on'+type, handler); else el.removeEventListener(type, handler);
        }
        function live(elClass, event, cb, context){
            addEvent(context || document, event, function(e){
                var found, el = e.target || e.srcElement;
                while (el && !(found = hasClass(el, elClass))) el = el.parentElement;
                if (found) cb.call(el, e);
            });
        }

        var o = {
            selector: 0,
            source: 0,
            minChars: 3,
            delay: 150,
            offsetLeft: 0,
            offsetTop: 1,
            cache: 1,
            menuClass: '',
            renderItem: function (item, search){
                // escape special characters
                search = search.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                var re = new RegExp("(" + search.split(' ').join('|') + ")", "gi");
                return '<div class="autocomplete-suggestion" data-val="' + item + '">' + item.replace(re, "<b>$1</b>") + '</div>';
            },
            onSelect: function(e, term, item){}
        };
        for (var k in options) { if (options.hasOwnProperty(k)) o[k] = options[k]; }

        // init
        var elems = typeof o.selector == 'object' ? [o.selector] : document.querySelectorAll(o.selector);
        for (var i=0; i<elems.length; i++) {
            var that = elems[i];

            // create suggestions container "sc"
            that.sc = document.createElement('div');
            that.sc.className = 'autocomplete-suggestions '+o.menuClass;

            that.autocompleteAttr = that.getAttribute('autocomplete');
            that.setAttribute('autocomplete', 'off');
            that.cache = {};
            that.last_val = '';

            that.updateSC = function(resize, next){
                var rect = that.getBoundingClientRect();
                that.sc.style.left = Math.round(rect.left + (window.pageXOffset || document.documentElement.scrollLeft) + o.offsetLeft) + 'px';
                that.sc.style.top = Math.round(rect.bottom + (window.pageYOffset || document.documentElement.scrollTop) + o.offsetTop) + 'px';
                that.sc.style.width = Math.round(rect.right - rect.left) + 'px'; // outerWidth
                if (!resize) {
                    that.sc.style.display = 'block';
                    if (!that.sc.maxHeight) { that.sc.maxHeight = parseInt((window.getComputedStyle ? getComputedStyle(that.sc, null) : that.sc.currentStyle).maxHeight); }
                    if (!that.sc.suggestionHeight) that.sc.suggestionHeight = that.sc.querySelector('.autocomplete-suggestion').offsetHeight;
                    if (that.sc.suggestionHeight)
                        if (!next) that.sc.scrollTop = 0;
                        else {
                            var scrTop = that.sc.scrollTop, selTop = next.getBoundingClientRect().top - that.sc.getBoundingClientRect().top;
                            if (selTop + that.sc.suggestionHeight - that.sc.maxHeight > 0)
                                that.sc.scrollTop = selTop + that.sc.suggestionHeight + scrTop - that.sc.maxHeight;
                            else if (selTop < 0)
                                that.sc.scrollTop = selTop + scrTop;
                        }
                }
            }
            addEvent(window, 'resize', that.updateSC);
            document.body.appendChild(that.sc);

            live('autocomplete-suggestion', 'mouseleave', function(e){
                var sel = that.sc.querySelector('.autocomplete-suggestion.selected');
                if (sel) setTimeout(function(){ sel.className = sel.className.replace('selected', ''); }, 20);
            }, that.sc);

            live('autocomplete-suggestion', 'mouseover', function(e){
                var sel = that.sc.querySelector('.autocomplete-suggestion.selected');
                if (sel) sel.className = sel.className.replace('selected', '');
                this.className += ' selected';
            }, that.sc);

            live('autocomplete-suggestion', 'mousedown', function(e){
                if (hasClass(this, 'autocomplete-suggestion')) { // else outside click
                    var v = this.getAttribute('data-val');
                    that.value = v;
                    o.onSelect(e, v, this);
                    that.sc.style.display = 'none';
                }
            }, that.sc);

            that.blurHandler = function(){
                try { var over_sb = document.querySelector('.autocomplete-suggestions:hover'); } catch(e){ var over_sb = 0; }
                if (!over_sb) {
                    that.last_val = that.value;
                    that.sc.style.display = 'none';
                    setTimeout(function(){ that.sc.style.display = 'none'; }, 350); // hide suggestions on fast input
                } else if (that !== document.activeElement) setTimeout(function(){ that.focus(); }, 20);
            };
            addEvent(that, 'blur', that.blurHandler);

            var suggest = function(data){
                var val = that.value;
                that.cache[val] = data;
                if (data.length && val.length >= o.minChars) {
                    var s = '';
                    for (var i=0;i<data.length;i++) s += o.renderItem(data[i], val);
                    that.sc.innerHTML = s;
                    that.updateSC(0);
                }
                else
                    that.sc.style.display = 'none';
            }

            that.keydownHandler = function(e){
                var key = window.event ? e.keyCode : e.which;
                // down (40), up (38)
                if ((key == 40 || key == 38) && that.sc.innerHTML) {
                    var next, sel = that.sc.querySelector('.autocomplete-suggestion.selected');
                    if (!sel) {
                        next = (key == 40) ? that.sc.querySelector('.autocomplete-suggestion') : that.sc.childNodes[that.sc.childNodes.length - 1]; // first : last
                        next.className += ' selected';
                        that.value = next.getAttribute('data-val');
                    } else {
                        next = (key == 40) ? sel.nextSibling : sel.previousSibling;
                        if (next) {
                            sel.className = sel.className.replace('selected', '');
                            next.className += ' selected';
                            that.value = next.getAttribute('data-val');
                        }
                        else { sel.className = sel.className.replace('selected', ''); that.value = that.last_val; next = 0; }
                    }
                    that.updateSC(0, next);
                    return false;
                }
                // esc
                else if (key == 27) { that.value = that.last_val; that.sc.style.display = 'none'; }
                // enter
                else if (key == 13 || key == 9) {
                    var sel = that.sc.querySelector('.autocomplete-suggestion.selected');
                    if (sel && that.sc.style.display != 'none') { o.onSelect(e, sel.getAttribute('data-val'), sel); setTimeout(function(){ that.sc.style.display = 'none'; }, 20); }
                }
            };
            addEvent(that, 'keydown', that.keydownHandler);

            that.keyupHandler = function(e){
                var key = window.event ? e.keyCode : e.which;
                if (!key || (key < 35 || key > 40) && key != 13 && key != 27) {
                    var val = that.value;
                    if (val.length >= o.minChars) {
                        if (val != that.last_val) {
                            that.last_val = val;
                            clearTimeout(that.timer);
                            if (o.cache) {
                                if (val in that.cache) { suggest(that.cache[val]); return; }
                                // no requests if previous suggestions were empty
                                for (var i=1; i<val.length-o.minChars; i++) {
                                    var part = val.slice(0, val.length-i);
                                    if (part in that.cache && !that.cache[part].length) { suggest([]); return; }
                                }
                            }
                            that.timer = setTimeout(function(){ o.source(val, suggest) }, o.delay);
                        }
                    } else {
                        that.last_val = val;
                        that.sc.style.display = 'none';
                    }
                }
            };
            addEvent(that, 'keyup', that.keyupHandler);

            that.focusHandler = function(e){
                that.last_val = '\n';
                that.keyupHandler(e)
            };
            if (!o.minChars) addEvent(that, 'focus', that.focusHandler);
        }

        // public destroy method
        this.destroy = function(){
            for (var i=0; i<elems.length; i++) {
                var that = elems[i];
                removeEvent(window, 'resize', that.updateSC);
                removeEvent(that, 'blur', that.blurHandler);
                removeEvent(that, 'focus', that.focusHandler);
                removeEvent(that, 'keydown', that.keydownHandler);
                removeEvent(that, 'keyup', that.keyupHandler);
                if (that.autocompleteAttr)
                    that.setAttribute('autocomplete', that.autocompleteAttr);
                else
                    that.removeAttribute('autocomplete');
                document.body.removeChild(that.sc);
                that = null;
            }
        };
    }
    return autoComplete;
})();

(function(){
    if (typeof define === 'function' && define.amd)
        define('autoComplete', function () { return autoComplete; });
    else if (typeof module !== 'undefined' && module.exports)
        module.exports = autoComplete;
    else
        window.autoComplete = autoComplete;
})();

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	var dt = __webpack_require__(1);
	var $ = __webpack_require__(2);
	   
	$(function () {

	    let init = function () {
	       
	        dt.init();
	    }

	    init();      
	   
	    
	});


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	let $ = __webpack_require__(2);
	let _dt = __webpack_require__(3);
	let _dtEvent = __webpack_require__(4);
	let _hh = __webpack_require__(6)
	let _hh_helper = __webpack_require__(13);
	let _service = __webpack_require__(12);
	let servicecall = __webpack_require__(10);
	let appsettingsobject = __webpack_require__(8);
	let appsettings = appsettingsobject.config;

	module.exports = {
	    init: function () {
	        this.cacheDom();
	        this.bindEvent();
	        this.EventHandler();
	        this.render();
	    },
	    cacheDom: function () {
	        this.$body = $('body');
	        this.$bb_aj_listatoApprove = $("#bb_aj_listatoApprove");
	        this.$bb_aj_listaAlla = $("#bb_aj_listaAlla");
	        this.$bb_aj_boktipsAdminList = $("#bb_aj_boktipsAdminList");
	        this.$bb_aj_boktipsAdminALLList = $("#bb_aj_boktipsAdminALLList");
	    },
	    bindEvent: function (userid) {
	        let that = this;
	                
	        this.$body.on('click', '#bb_aj_listaAlla', function (e) {
	            $(this).addClass("not-active");
	            that.$bb_aj_listatoApprove.removeClass("not-active");

	            that.$bb_aj_boktipsAdminList.hide();
	            let datatables = that.$bb_aj_boktipsAdminList.DataTable();
	            datatables.destroy();
	                        
	            that.serviceHandler("#bb_aj_boktipsAdminALLList", appsettings.api.boktipslistor.getboktipslistAll(), function(){
	                that.$bb_aj_boktipsAdminALLList.show();
	            });
	                       
	            return false;
	        });

	        this.$body.on('click', '#bb_aj_listatoApprove', function (e) {        
	            $(this).addClass("not-active");
	            that.$bb_aj_listaAlla.removeClass("not-active");
	            that.$bb_aj_boktipsAdminALLList.hide();

	            let datatables = that.$bb_aj_boktipsAdminALLList.DataTable();
	            datatables.destroy();            
	            
	            that.serviceHandler("#bb_aj_boktipsAdminList", appsettings.api.boktipslistor.getboktipslistToApprove(), function () {
	                that.$bb_aj_boktipsAdminList.show();
	            });           
	         
	            return false;
	        });

	        this.$body.on('click', '#bb_aj_Deleteboktips', function (e) {
	            let id = $(this).attr('data-tipid');

	            servicecall.deletetip(id, function (isok) {
	                that.updatetable();
	            });

	            $("#bb_aj_modalContainer").hide();
	            return false;
	        });

	        this.$body.on('click', '#bb_aj_Saveboktips', function (e) {
	            let id = $(this).attr('data-tipid');
	            let rub = $("#bb_aj_saveBoktipRubrik").html();
	            let content = tinyMCE.activeEditor.getContent();

	            servicecall.savetip(id, rub, content, function () {              
	                that.updatetable();                          
	            });

	            $("#bb_aj_modalContainer").hide();
	            return false;
	        });
	    },
	    EventHandler: function () {
	        _dtEvent.init();
	        _hh_helper.init();
	    },
	    updatetable: function () {

	        let valdlist, urlen, cssdiv;
	        if (this.$bb_aj_boktipsAdminList.is(':visible')) {
	            valdlist = this.$bb_aj_boktipsAdminList;
	            urlen = appsettings.api.boktipslistor.getboktipslistToApprove();
	            cssdiv = "#bb_aj_boktipsAdminList"
	            
	        }
	        else {
	            if (this.$bb_aj_boktipsAdminALLList.is(':visible')) {
	                valdlist = this.$bb_aj_boktipsAdminALLList
	                urlen = appsettings.api.boktipslistor.getboktipslistAll();
	                cssdiv = "#bb_aj_boktipsAdminALLList"                
	            };
	        };      
	       
	        let datatables = valdlist.DataTable();
	        datatables.destroy();
	        valdlist.hide();
	        this.serviceHandler(cssdiv, urlen, function () {
	            valdlist.show();
	        });
	    },
	    serviceHandler: function (cssSelector,url, callback) {
	        //let jsondatapromise = _service.getjsondata('https://www2.barnensbibliotek.se/Api_v3.1/boktips/typ/ByUserId/val/7017/txtval/0/devkey/alf/?type=json');
	        let jsondatapromise = _service.getjsondata(url);

	        jsondatapromise.then(jsondata => {

	            appsettings.dataset.currentdatalist = jsondata;

	            _hh.injecthtmltemplate(cssSelector, appsettings.handlebartemplate.hb_booktipList_tmp, jsondata, function () {
	                console.log("funkar1:" + appsettings.dataset.currentdatalist);
	                _dt.RunDataTable(cssSelector);
	                console.log("funkar2:" + appsettings.dataset.currentdatalist);
	                callback();
	            });
	        });    
	    },
	    render: function () {
	        
	        this.serviceHandler("#bb_aj_boktipsAdminList", appsettings.api.boktipslistor.getboktipslistToApprove(), function () { });
	        //this.serviceHandler("#bb_aj_boktipsAdminALLList", appsettings.api.boktipslistor.getboktipslistAll());
	    }
	}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.3.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2018-01-20T17:24Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};

	var isFunction = function isFunction( obj ) {

	      // Support: Chrome <=57, Firefox <=52
	      // In some browsers, typeof returns "function" for HTML <object> elements
	      // (i.e., `typeof document.createElement( "object" ) === "function"`).
	      // We don't want to classify *any* DOM node as a function.
	      return typeof obj === "function" && typeof obj.nodeType !== "number";
	  };


	var isWindow = function isWindow( obj ) {
			return obj != null && obj === obj.window;
		};




		var preservedScriptAttributes = {
			type: true,
			src: true,
			noModule: true
		};

		function DOMEval( code, doc, node ) {
			doc = doc || document;

			var i,
				script = doc.createElement( "script" );

			script.text = code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
					if ( node[ i ] ) {
						script[ i ] = node[ i ];
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}


	function toType( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.3.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = toType( obj );

		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( toType( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};


	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase );
				} else {
					key = camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Support: Firefox <=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;

			}

			initialInUnit = initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( toType( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
				"margin-top:1px;padding:0;border:0";
			div.style.cssText =
				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
				"margin:auto;border:1px;padding:1px;" +
				"width:60%;top:1%";
			documentElement.appendChild( container ).appendChild( div );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn't
			div.style.right = "60%";
			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			div.style.position = "absolute";
			scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}

		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;

		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? "border" : "content" ) ) {
			return 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin
			if ( box === "margin" ) {
				delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if ( !isBorderBox ) {

				// Add padding
				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// For "border" or "margin", add border
				if ( box !== "padding" ) {
					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

				// But still keep track of it otherwise
				} else {
					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}

			// If we get here with a border-box (content + padding + border), we're seeking "content" or
			// "padding" or "margin"
			} else {

				// For "content", subtract padding
				if ( box === "content" ) {
					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// For "content" or "padding", subtract border
				if ( box !== "margin" ) {
					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox && computedVal >= 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
			) );
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles = getStyles( elem ),
			val = curCSS( elem, dimension, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
			valueIsBorderBox = isBorderBox;

		// Support: Firefox <=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = "auto";
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = valueIsBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ dimension ] );

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		if ( val === "auto" ||
			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

			val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

			// offsetWidth/offsetHeight provide border-box values
			valueIsBorderBox = true;
		}

		// Normalize "" and auto
		val = parseFloat( val ) || 0;

		// Adjust for the element's box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, dimension ) {
		jQuery.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),
					isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					subtract = extra && boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					);

				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox && support.scrollboxSize() === styles.position ) {
					subtract -= Math.ceil(
						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, "border", false, styles ) -
						0.5
					);
				}

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ dimension ] = value;
					value = jQuery.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !== "margin" ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = Date.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === "string" ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray( value );

			if ( typeof stateVal === "boolean" && isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = classesToArray( value );

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			valueIsFunction = isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	support.focusin = "onfocusin" in window;


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = lastElement = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = Date.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && toType( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction = isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
										xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {

		// offset() relates an element's border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();

			} else {
				offset = this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &&
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
					jQuery.css( offsetParent, "position" ) === "static" ) {

					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery( offsetParent ).offset();
					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	};

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;

	jQuery.now = Date.now;

	jQuery.isNumeric = function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.7
	 * ©2008-2014 SpryMedia Ltd - datatables.net/license
	 */
	var $ = __webpack_require__(2);
	/**
	 * @summary     DataTables
	 * @description Paginate, search and order HTML tables
	 * @version     1.10.7
	 * @file        jquery.dataTables.js
	 * @author      SpryMedia Ltd (www.sprymedia.co.uk)
	 * @contact     www.sprymedia.co.uk/contact
	 * @copyright   Copyright 2008-2014 SpryMedia Ltd.
	 *
	 * This source file is free software, available under the following license:
	 *   MIT license - http://datatables.net/license
	 *
	 * This source file is distributed in the hope that it will be useful, but
	 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
	 *
	 * For details please refer to: http://www.datatables.net
	 */

	/*jslint evil: true, undef: true, browser: true */
	/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/
	module.exports = {
	    jqueryTableInit: function () {
	        (/** @lends <global> */function (window, document, undefined) {

	            (function (factory) {
	                "use strict";

	                if (true) {
	                    // Define as an AMD module if possible
	                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	                }
	                else if (typeof exports === 'object') {
	                    // Node/CommonJS
	                    module.exports = factory(require('jquery'));
	                }
	                else if (jQuery && !jQuery.fn.dataTable) {
	                    // Define using browser globals otherwise
	                    // Prevent multiple instantiations if the script is loaded twice
	                    factory(jQuery);
	                }
	            }
	            (/** @lends <global> */function ($) {
	                "use strict";

	                /**
	                 * DataTables is a plug-in for the jQuery Javascript library. It is a highly
	                 * flexible tool, based upon the foundations of progressive enhancement,
	                 * which will add advanced interaction controls to any HTML table. For a
	                 * full list of features please refer to
	                 * [DataTables.net](href="http://datatables.net).
	                 *
	                 * Note that the `DataTable` object is not a global variable but is aliased
	                 * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may
	                 * be  accessed.
	                 *
	                 *  @class
	                 *  @param {object} [init={}] Configuration object for DataTables. Options
	                 *    are defined by {@link DataTable.defaults}
	                 *  @requires jQuery 1.7+
	                 *
	                 *  @example
	                 *    // Basic initialisation
	                 *    $(document).ready( function {
	                 *      $('#example').dataTable();
	                 *    } );
	                 *
	                 *  @example
	                 *    // Initialisation with configuration options - in this case, disable
	                 *    // pagination and sorting.
	                 *    $(document).ready( function {
	                 *      $('#example').dataTable( {
	                 *        "paginate": false,
	                 *        "sort": false
	                 *      } );
	                 *    } );
	                 */
	                var DataTable;


	                /*
	                 * It is useful to have variables which are scoped locally so only the
	                 * DataTables functions can access them and they don't leak into global space.
	                 * At the same time these functions are often useful over multiple files in the
	                 * core and API, so we list, or at least document, all variables which are used
	                 * by DataTables as private variables here. This also ensures that there is no
	                 * clashing of variable names and that they can easily referenced for reuse.
	                 */


	                // Defined else where
	                //  _selector_run
	                //  _selector_opts
	                //  _selector_first
	                //  _selector_row_indexes

	                var _ext; // DataTable.ext
	                var _Api; // DataTable.Api
	                var _api_register; // DataTable.Api.register
	                var _api_registerPlural; // DataTable.Api.registerPlural

	                var _re_dic = {};
	                var _re_new_lines = /[\r\n]/g;
	                var _re_html = /<.*?>/g;
	                var _re_date_start = /^[\w\+\-]/;
	                var _re_date_end = /[\w\+\-]$/;

	                // Escape regular expression special characters
	                var _re_escape_regex = new RegExp('(\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-'].join('|\\') + ')', 'g');

	                // http://en.wikipedia.org/wiki/Foreign_exchange_market
	                // - \u20BD - Russian ruble.
	                // - \u20a9 - South Korean Won
	                // - \u20BA - Turkish Lira
	                // - \u20B9 - Indian Rupee
	                // - R - Brazil (R$) and South Africa
	                // - fr - Swiss Franc
	                // - kr - Swedish krona, Norwegian krone and Danish krone
	                // - \u2009 is thin space and \u202F is narrow no-break space, both used in many
	                //   standards as thousands separators.
	                var _re_formatted_numeric = /[',$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;


	                var _empty = function (d) {
	                    return !d || d === true || d === '-' ? true : false;
	                };


	                var _intVal = function (s) {
	                    var integer = parseInt(s, 10);
	                    return !isNaN(integer) && isFinite(s) ? integer : null;
	                };

	                // Convert from a formatted number with characters other than `.` as the
	                // decimal place, to a Javascript number
	                var _numToDecimal = function (num, decimalPoint) {
	                    // Cache created regular expressions for speed as this function is called often
	                    if (!_re_dic[decimalPoint]) {
	                        _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');
	                    }
	                    return typeof num === 'string' && decimalPoint !== '.' ?
	                        num.replace(/\./g, '').replace(_re_dic[decimalPoint], '.') :
	                        num;
	                };


	                var _isNumber = function (d, decimalPoint, formatted) {
	                    var strType = typeof d === 'string';

	                    // If empty return immediately so there must be a number if it is a
	                    // formatted string (this stops the string "k", or "kr", etc being detected
	                    // as a formatted number for currency
	                    if (_empty(d)) {
	                        return true;
	                    }

	                    if (decimalPoint && strType) {
	                        d = _numToDecimal(d, decimalPoint);
	                    }

	                    if (formatted && strType) {
	                        d = d.replace(_re_formatted_numeric, '');
	                    }

	                    return !isNaN(parseFloat(d)) && isFinite(d);
	                };


	                // A string without HTML in it can be considered to be HTML still
	                var _isHtml = function (d) {
	                    return _empty(d) || typeof d === 'string';
	                };


	                var _htmlNumeric = function (d, decimalPoint, formatted) {
	                    if (_empty(d)) {
	                        return true;
	                    }

	                    var html = _isHtml(d);
	                    return !html ?
	                        null :
	                        _isNumber(_stripHtml(d), decimalPoint, formatted) ?
	                            true :
	                            null;
	                };


	                var _pluck = function (a, prop, prop2) {
	                    var out = [];
	                    var i = 0, ien = a.length;

	                    // Could have the test in the loop for slightly smaller code, but speed
	                    // is essential here
	                    if (prop2 !== undefined) {
	                        for (; i < ien ; i++) {
	                            if (a[i] && a[i][prop]) {
	                                out.push(a[i][prop][prop2]);
	                            }
	                        }
	                    }
	                    else {
	                        for (; i < ien ; i++) {
	                            if (a[i]) {
	                                out.push(a[i][prop]);
	                            }
	                        }
	                    }

	                    return out;
	                };


	                // Basically the same as _pluck, but rather than looping over `a` we use `order`
	                // as the indexes to pick from `a`
	                var _pluck_order = function (a, order, prop, prop2) {
	                    var out = [];
	                    var i = 0, ien = order.length;

	                    // Could have the test in the loop for slightly smaller code, but speed
	                    // is essential here
	                    if (prop2 !== undefined) {
	                        for (; i < ien ; i++) {
	                            if (a[order[i]][prop]) {
	                                out.push(a[order[i]][prop][prop2]);
	                            }
	                        }
	                    }
	                    else {
	                        for (; i < ien ; i++) {
	                            out.push(a[order[i]][prop]);
	                        }
	                    }

	                    return out;
	                };


	                var _range = function (len, start) {
	                    var out = [];
	                    var end;

	                    if (start === undefined) {
	                        start = 0;
	                        end = len;
	                    }
	                    else {
	                        end = start;
	                        start = len;
	                    }

	                    for (var i = start ; i < end ; i++) {
	                        out.push(i);
	                    }

	                    return out;
	                };


	                var _removeEmpty = function (a) {
	                    var out = [];

	                    for (var i = 0, ien = a.length ; i < ien ; i++) {
	                        if (a[i]) { // careful - will remove all falsy values!
	                            out.push(a[i]);
	                        }
	                    }

	                    return out;
	                };


	                var _stripHtml = function (d) {
	                    return d.replace(_re_html, '');
	                };


	                /**
	                 * Find the unique elements in a source array.
	                 *
	                 * @param  {array} src Source array
	                 * @return {array} Array of unique items
	                 * @ignore
	                 */
	                var _unique = function (src) {
	                    // A faster unique method is to use object keys to identify used values,
	                    // but this doesn't work with arrays or objects, which we must also
	                    // consider. See jsperf.com/compare-array-unique-versions/4 for more
	                    // information.
	                    var
	                        out = [],
	                        val,
	                        i, ien = src.length,
	                        j, k = 0;

	                    again: for (i = 0 ; i < ien ; i++) {
	                        val = src[i];

	                        for (j = 0 ; j < k ; j++) {
	                            if (out[j] === val) {
	                                continue again;
	                            }
	                        }

	                        out.push(val);
	                        k++;
	                    }

	                    return out;
	                };



	                /**
	                 * Create a mapping object that allows camel case parameters to be looked up
	                 * for their Hungarian counterparts. The mapping is stored in a private
	                 * parameter called `_hungarianMap` which can be accessed on the source object.
	                 *  @param {object} o
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnHungarianMap(o) {
	                    var
	                        hungarian = 'a aa ai ao as b fn i m o s ',
	                        match,
	                        newKey,
	                        map = {};

	                    $.each(o, function (key, val) {
	                        match = key.match(/^([^A-Z]+?)([A-Z])/);

	                        if (match && hungarian.indexOf(match[1] + ' ') !== -1) {
	                            newKey = key.replace(match[0], match[2].toLowerCase());
	                            map[newKey] = key;

	                            if (match[1] === 'o') {
	                                _fnHungarianMap(o[key]);
	                            }
	                        }
	                    });

	                    o._hungarianMap = map;
	                }


	                /**
	                 * Convert from camel case parameters to Hungarian, based on a Hungarian map
	                 * created by _fnHungarianMap.
	                 *  @param {object} src The model object which holds all parameters that can be
	                 *    mapped.
	                 *  @param {object} user The object to convert from camel case to Hungarian.
	                 *  @param {boolean} force When set to `true`, properties which already have a
	                 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	                 *    won't be.
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCamelToHungarian(src, user, force) {
	                    if (!src._hungarianMap) {
	                        _fnHungarianMap(src);
	                    }

	                    var hungarianKey;

	                    $.each(user, function (key, val) {
	                        hungarianKey = src._hungarianMap[key];

	                        if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {
	                            // For objects, we need to buzz down into the object to copy parameters
	                            if (hungarianKey.charAt(0) === 'o') {
	                                // Copy the camelCase options over to the hungarian
	                                if (!user[hungarianKey]) {
	                                    user[hungarianKey] = {};
	                                }
	                                $.extend(true, user[hungarianKey], user[key]);

	                                _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
	                            }
	                            else {
	                                user[hungarianKey] = user[key];
	                            }
	                        }
	                    });
	                }


	                /**
	                 * Language compatibility - when certain options are given, and others aren't, we
	                 * need to duplicate the values over, in order to provide backwards compatibility
	                 * with older language files.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnLanguageCompat(lang) {
	                    var defaults = DataTable.defaults.oLanguage;
	                    var zeroRecords = lang.sZeroRecords;

	                    /* Backwards compatibility - if there is no sEmptyTable given, then use the same as
	                     * sZeroRecords - assuming that is given.
	                     */
	                    if (!lang.sEmptyTable && zeroRecords &&
	                        defaults.sEmptyTable === "No data available in table") {
	                        _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');
	                    }

	                    /* Likewise with loading records */
	                    if (!lang.sLoadingRecords && zeroRecords &&
	                        defaults.sLoadingRecords === "Loading...") {
	                        _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');
	                    }

	                    // Old parameter name of the thousands separator mapped onto the new
	                    if (lang.sInfoThousands) {
	                        lang.sThousands = lang.sInfoThousands;
	                    }

	                    var decimal = lang.sDecimal;
	                    if (decimal) {
	                        _addNumericSort(decimal);
	                    }
	                }


	                /**
	                 * Map one parameter onto another
	                 *  @param {object} o Object to map
	                 *  @param {*} knew The new parameter name
	                 *  @param {*} old The old parameter name
	                 */
	                var _fnCompatMap = function (o, knew, old) {
	                    if (o[knew] !== undefined) {
	                        o[old] = o[knew];
	                    }
	                };


	                /**
	                 * Provide backwards compatibility for the main DT options. Note that the new
	                 * options are mapped onto the old parameters, so this is an external interface
	                 * change only.
	                 *  @param {object} init Object to map
	                 */
	                function _fnCompatOpts(init) {
	                    _fnCompatMap(init, 'ordering', 'bSort');
	                    _fnCompatMap(init, 'orderMulti', 'bSortMulti');
	                    _fnCompatMap(init, 'orderClasses', 'bSortClasses');
	                    _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');
	                    _fnCompatMap(init, 'order', 'aaSorting');
	                    _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');
	                    _fnCompatMap(init, 'paging', 'bPaginate');
	                    _fnCompatMap(init, 'pagingType', 'sPaginationType');
	                    _fnCompatMap(init, 'pageLength', 'iDisplayLength');
	                    _fnCompatMap(init, 'searching', 'bFilter');

	                    // Column search objects are in an array, so it needs to be converted
	                    // element by element
	                    var searchCols = init.aoSearchCols;

	                    if (searchCols) {
	                        for (var i = 0, ien = searchCols.length ; i < ien ; i++) {
	                            if (searchCols[i]) {
	                                _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Provide backwards compatibility for column options. Note that the new options
	                 * are mapped onto the old parameters, so this is an external interface change
	                 * only.
	                 *  @param {object} init Object to map
	                 */
	                function _fnCompatCols(init) {
	                    _fnCompatMap(init, 'orderable', 'bSortable');
	                    _fnCompatMap(init, 'orderData', 'aDataSort');
	                    _fnCompatMap(init, 'orderSequence', 'asSorting');
	                    _fnCompatMap(init, 'orderDataType', 'sortDataType');

	                    // orderData can be given as an integer
	                    var dataSort = init.aDataSort;
	                    if (dataSort && !$.isArray(dataSort)) {
	                        init.aDataSort = [dataSort];
	                    }
	                }


	                /**
	                 * Browser feature detection for capabilities, quirks
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnBrowserDetect(settings) {
	                    var browser = settings.oBrowser;

	                    // Scrolling feature / quirks detection
	                    var n = $('<div/>')
	                        .css({
	                            position: 'absolute',
	                            top: 0,
	                            left: 0,
	                            height: 1,
	                            width: 1,
	                            overflow: 'hidden'
	                        })
	                        .append(
	                            $('<div/>')
	                                .css({
	                                    position: 'absolute',
	                                    top: 1,
	                                    left: 1,
	                                    width: 100,
	                                    overflow: 'scroll'
	                                })
	                                .append(
	                                    $('<div class="test"/>')
	                                        .css({
	                                            width: '100%',
	                                            height: 10
	                                        })
	                                )
	                        )
	                        .appendTo('body');

	                    var test = n.find('.test');

	                    // IE6/7 will oversize a width 100% element inside a scrolling element, to
	                    // include the width of the scrollbar, while other browsers ensure the inner
	                    // element is contained without forcing scrolling
	                    browser.bScrollOversize = test[0].offsetWidth === 100;

	                    // In rtl text layout, some browsers (most, but not all) will place the
	                    // scrollbar on the left, rather than the right.
	                    browser.bScrollbarLeft = Math.round(test.offset().left) !== 1;

	                    n.remove();
	                }


	                /**
	                 * Array.prototype reduce[Right] method, used for browsers which don't support
	                 * JS 1.6. Done this way to reduce code size, since we iterate either way
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnReduce(that, fn, init, start, end, inc) {
	                    var
	                        i = start,
	                        value,
	                        isSet = false;

	                    if (init !== undefined) {
	                        value = init;
	                        isSet = true;
	                    }

	                    while (i !== end) {
	                        if (!that.hasOwnProperty(i)) {
	                            continue;
	                        }

	                        value = isSet ?
	                            fn(value, that[i], i, that) :
	                            that[i];

	                        isSet = true;
	                        i += inc;
	                    }

	                    return value;
	                }

	                /**
	                 * Add a column to the list used for the table with default values
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {node} nTh The th element for this column
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAddColumn(oSettings, nTh) {
	                    // Add column to aoColumns array
	                    var oDefaults = DataTable.defaults.column;
	                    var iCol = oSettings.aoColumns.length;
	                    var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
	                        "nTh": nTh ? nTh : document.createElement('th'),
	                        "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',
	                        "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
	                        "mData": oDefaults.mData ? oDefaults.mData : iCol,
	                        idx: iCol
	                    });
	                    oSettings.aoColumns.push(oCol);

	                    // Add search object for column specific search. Note that the `searchCols[ iCol ]`
	                    // passed into extend can be undefined. This allows the user to give a default
	                    // with only some of the parameters defined, and also not give a default
	                    var searchCols = oSettings.aoPreSearchCols;
	                    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);

	                    // Use the default column options function to initialise classes etc
	                    _fnColumnOptions(oSettings, iCol, $(nTh).data());
	                }


	                /**
	                 * Apply options for a column
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {int} iCol column index to consider
	                 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnColumnOptions(oSettings, iCol, oOptions) {
	                    var oCol = oSettings.aoColumns[iCol];
	                    var oClasses = oSettings.oClasses;
	                    var th = $(oCol.nTh);

	                    // Try to get width information from the DOM. We can't get it from CSS
	                    // as we'd need to parse the CSS stylesheet. `width` option can override
	                    if (!oCol.sWidthOrig) {
	                        // Width attribute
	                        oCol.sWidthOrig = th.attr('width') || null;

	                        // Style attribute
	                        var t = (th.attr('style') || '').match(/width:\s*(\d+[pxem%]+)/);
	                        if (t) {
	                            oCol.sWidthOrig = t[1];
	                        }
	                    }

	                    /* User specified column options */
	                    if (oOptions !== undefined && oOptions !== null) {
	                        // Backwards compatibility
	                        _fnCompatCols(oOptions);

	                        // Map camel case parameters to their Hungarian counterparts
	                        _fnCamelToHungarian(DataTable.defaults.column, oOptions);

	                        /* Backwards compatibility for mDataProp */
	                        if (oOptions.mDataProp !== undefined && !oOptions.mData) {
	                            oOptions.mData = oOptions.mDataProp;
	                        }

	                        if (oOptions.sType) {
	                            oCol._sManualType = oOptions.sType;
	                        }

	                        // `class` is a reserved word in Javascript, so we need to provide
	                        // the ability to use a valid name for the camel case input
	                        if (oOptions.className && !oOptions.sClass) {
	                            oOptions.sClass = oOptions.className;
	                        }

	                        $.extend(oCol, oOptions);
	                        _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");

	                        /* iDataSort to be applied (backwards compatibility), but aDataSort will take
	                         * priority if defined
	                         */
	                        if (oOptions.iDataSort !== undefined) {
	                            oCol.aDataSort = [oOptions.iDataSort];
	                        }
	                        _fnMap(oCol, oOptions, "aDataSort");
	                    }

	                    /* Cache the data get and set functions for speed */
	                    var mDataSrc = oCol.mData;
	                    var mData = _fnGetObjectDataFn(mDataSrc);
	                    var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;

	                    var attrTest = function (src) {
	                        return typeof src === 'string' && src.indexOf('@') !== -1;
	                    };
	                    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (
	                        attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
	                    );

	                    oCol.fnGetData = function (rowData, type, meta) {
	                        var innerData = mData(rowData, type, undefined, meta);

	                        return mRender && type ?
	                            mRender(innerData, type, rowData, meta) :
	                            innerData;
	                    };
	                    oCol.fnSetData = function (rowData, val, meta) {
	                        return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
	                    };

	                    // Indicate if DataTables should read DOM data as an object or array
	                    // Used in _fnGetRowElements
	                    if (typeof mDataSrc !== 'number') {
	                        oSettings._rowReadObject = true;
	                    }

	                    /* Feature sorting overrides column specific when off */
	                    if (!oSettings.oFeatures.bSort) {
	                        oCol.bSortable = false;
	                        th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called
	                    }

	                    /* Check that the class assignment is correct for sorting */
	                    var bAsc = $.inArray('asc', oCol.asSorting) !== -1;
	                    var bDesc = $.inArray('desc', oCol.asSorting) !== -1;
	                    if (!oCol.bSortable || (!bAsc && !bDesc)) {
	                        oCol.sSortingClass = oClasses.sSortableNone;
	                        oCol.sSortingClassJUI = "";
	                    }
	                    else if (bAsc && !bDesc) {
	                        oCol.sSortingClass = oClasses.sSortableAsc;
	                        oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
	                    }
	                    else if (!bAsc && bDesc) {
	                        oCol.sSortingClass = oClasses.sSortableDesc;
	                        oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
	                    }
	                    else {
	                        oCol.sSortingClass = oClasses.sSortable;
	                        oCol.sSortingClassJUI = oClasses.sSortJUI;
	                    }
	                }


	                /**
	                 * Adjust the table column widths for new data. Note: you would probably want to
	                 * do a redraw after calling this function!
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAdjustColumnSizing(settings) {
	                    /* Not interested in doing column width calculation if auto-width is disabled */
	                    if (settings.oFeatures.bAutoWidth !== false) {
	                        var columns = settings.aoColumns;

	                        _fnCalculateColumnWidths(settings);
	                        for (var i = 0, iLen = columns.length ; i < iLen ; i++) {
	                            columns[i].nTh.style.width = columns[i].sWidth;
	                        }
	                    }

	                    var scroll = settings.oScroll;
	                    if (scroll.sY !== '' || scroll.sX !== '') {
	                        _fnScrollDraw(settings);
	                    }

	                    _fnCallbackFire(settings, null, 'column-sizing', [settings]);
	                }


	                /**
	                 * Covert the index of a visible column to the index in the data array (take account
	                 * of hidden columns)
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {int} iMatch Visible column index to lookup
	                 *  @returns {int} i the data index
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnVisibleToColumnIndex(oSettings, iMatch) {
	                    var aiVis = _fnGetColumns(oSettings, 'bVisible');

	                    return typeof aiVis[iMatch] === 'number' ?
	                        aiVis[iMatch] :
	                        null;
	                }


	                /**
	                 * Covert the index of an index in the data array and convert it to the visible
	                 *   column index (take account of hidden columns)
	                 *  @param {int} iMatch Column index to lookup
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {int} i the data index
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnColumnIndexToVisible(oSettings, iMatch) {
	                    var aiVis = _fnGetColumns(oSettings, 'bVisible');
	                    var iPos = $.inArray(iMatch, aiVis);

	                    return iPos !== -1 ? iPos : null;
	                }


	                /**
	                 * Get the number of visible columns
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {int} i the number of visible columns
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnVisbleColumns(oSettings) {
	                    return _fnGetColumns(oSettings, 'bVisible').length;
	                }


	                /**
	                 * Get an array of column indexes that match a given property
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {string} sParam Parameter in aoColumns to look for - typically
	                 *    bVisible or bSearchable
	                 *  @returns {array} Array of indexes with matched properties
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetColumns(oSettings, sParam) {
	                    var a = [];

	                    $.map(oSettings.aoColumns, function (val, i) {
	                        if (val[sParam]) {
	                            a.push(i);
	                        }
	                    });

	                    return a;
	                }


	                /**
	                 * Calculate the 'type' of a column
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnColumnTypes(settings) {
	                    var columns = settings.aoColumns;
	                    var data = settings.aoData;
	                    var types = DataTable.ext.type.detect;
	                    var i, ien, j, jen, k, ken;
	                    var col, cell, detectedType, cache;

	                    // For each column, spin over the 
	                    for (i = 0, ien = columns.length ; i < ien ; i++) {
	                        col = columns[i];
	                        cache = [];

	                        if (!col.sType && col._sManualType) {
	                            col.sType = col._sManualType;
	                        }
	                        else if (!col.sType) {
	                            for (j = 0, jen = types.length ; j < jen ; j++) {
	                                for (k = 0, ken = data.length ; k < ken ; k++) {
	                                    // Use a cache array so we only need to get the type data
	                                    // from the formatter once (when using multiple detectors)
	                                    if (cache[k] === undefined) {
	                                        cache[k] = _fnGetCellData(settings, k, i, 'type');
	                                    }

	                                    detectedType = types[j](cache[k], settings);

	                                    // If null, then this type can't apply to this column, so
	                                    // rather than testing all cells, break out. There is an
	                                    // exception for the last type which is `html`. We need to
	                                    // scan all rows since it is possible to mix string and HTML
	                                    // types
	                                    if (!detectedType && j !== types.length - 1) {
	                                        break;
	                                    }

	                                    // Only a single match is needed for html type since it is
	                                    // bottom of the pile and very similar to string
	                                    if (detectedType === 'html') {
	                                        break;
	                                    }
	                                }

	                                // Type is valid for all data points in the column - use this
	                                // type
	                                if (detectedType) {
	                                    col.sType = detectedType;
	                                    break;
	                                }
	                            }

	                            // Fall back - if no type was detected, always use string
	                            if (!col.sType) {
	                                col.sType = 'string';
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Take the column definitions and static columns arrays and calculate how
	                 * they relate to column indexes. The callback function will then apply the
	                 * definition found for a column to a suitable configuration object.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
	                 *  @param {array} aoCols The aoColumns array that defines columns individually
	                 *  @param {function} fn Callback function - takes two parameters, the calculated
	                 *    column index and the definition for that column.
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
	                    var i, iLen, j, jLen, k, kLen, def;
	                    var columns = oSettings.aoColumns;

	                    // Column definitions with aTargets
	                    if (aoColDefs) {
	                        /* Loop over the definitions array - loop in reverse so first instance has priority */
	                        for (i = aoColDefs.length - 1 ; i >= 0 ; i--) {
	                            def = aoColDefs[i];

	                            /* Each definition can target multiple columns, as it is an array */
	                            var aTargets = def.targets !== undefined ?
	                                def.targets :
	                                def.aTargets;

	                            if (!$.isArray(aTargets)) {
	                                aTargets = [aTargets];
	                            }

	                            for (j = 0, jLen = aTargets.length ; j < jLen ; j++) {
	                                if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {
	                                    /* Add columns that we don't yet know about */
	                                    while (columns.length <= aTargets[j]) {
	                                        _fnAddColumn(oSettings);
	                                    }

	                                    /* Integer, basic index */
	                                    fn(aTargets[j], def);
	                                }
	                                else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {
	                                    /* Negative integer, right to left column counting */
	                                    fn(columns.length + aTargets[j], def);
	                                }
	                                else if (typeof aTargets[j] === 'string') {
	                                    /* Class name matching on TH element */
	                                    for (k = 0, kLen = columns.length ; k < kLen ; k++) {
	                                        if (aTargets[j] == "_all" ||
	                                             $(columns[k].nTh).hasClass(aTargets[j])) {
	                                            fn(k, def);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }

	                    // Statically defined columns array
	                    if (aoCols) {
	                        for (i = 0, iLen = aoCols.length ; i < iLen ; i++) {
	                            fn(i, aoCols[i]);
	                        }
	                    }
	                }

	                /**
	                 * Add a data array to the table, creating DOM node etc. This is the parallel to
	                 * _fnGatherData, but for adding rows from a Javascript source, rather than a
	                 * DOM source.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {array} aData data array to be added
	                 *  @param {node} [nTr] TR element to add to the table - optional. If not given,
	                 *    DataTables will create a row automatically
	                 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	                 *    if nTr is.
	                 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAddData(oSettings, aDataIn, nTr, anTds) {
	                    /* Create the object for storing information about this new row */
	                    var iRow = oSettings.aoData.length;
	                    var oData = $.extend(true, {}, DataTable.models.oRow, {
	                        src: nTr ? 'dom' : 'data'
	                    });

	                    oData._aData = aDataIn;
	                    oSettings.aoData.push(oData);

	                    /* Create the cells */
	                    var nTd, sThisType;
	                    var columns = oSettings.aoColumns;
	                    for (var i = 0, iLen = columns.length ; i < iLen ; i++) {
	                        // When working with a row, the data source object must be populated. In
	                        // all other cases, the data source object is already populated, so we
	                        // don't overwrite it, which might break bindings etc
	                        if (nTr) {
	                            _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i));
	                        }
	                        columns[i].sType = null;
	                    }

	                    /* Add to the display array */
	                    oSettings.aiDisplayMaster.push(iRow);

	                    /* Create the DOM information, or register it if already present */
	                    if (nTr || !oSettings.oFeatures.bDeferRender) {
	                        _fnCreateTr(oSettings, iRow, nTr, anTds);
	                    }

	                    return iRow;
	                }


	                /**
	                 * Add one or more TR elements to the table. Generally we'd expect to
	                 * use this for reading data from a DOM sourced table, but it could be
	                 * used for an TR element. Note that if a TR is given, it is used (i.e.
	                 * it is not cloned).
	                 *  @param {object} settings dataTables settings object
	                 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
	                 *  @returns {array} Array of indexes for the added rows
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAddTr(settings, trs) {
	                    var row;

	                    // Allow an individual node to be passed in
	                    if (!(trs instanceof $)) {
	                        trs = $(trs);
	                    }

	                    return trs.map(function (i, el) {
	                        row = _fnGetRowElements(settings, el);
	                        return _fnAddData(settings, row.data, el, row.cells);
	                    });
	                }


	                /**
	                 * Take a TR element and convert it to an index in aoData
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {node} n the TR element to find
	                 *  @returns {int} index if the node is found, null if not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnNodeToDataIndex(oSettings, n) {
	                    return (n._DT_RowIndex !== undefined) ? n._DT_RowIndex : null;
	                }


	                /**
	                 * Take a TD element and convert it into a column data index (not the visible index)
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {int} iRow The row number the TD/TH can be found in
	                 *  @param {node} n The TD/TH element to find
	                 *  @returns {int} index if the node is found, -1 if not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnNodeToColumnIndex(oSettings, iRow, n) {
	                    return $.inArray(n, oSettings.aoData[iRow].anCells);
	                }


	                /**
	                 * Get the data for a given cell from the internal cache, taking into account data mapping
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} rowIdx aoData row id
	                 *  @param {int} colIdx Column index
	                 *  @param {string} type data get type ('display', 'type' 'filter' 'sort')
	                 *  @returns {*} Cell data
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetCellData(settings, rowIdx, colIdx, type) {
	                    var draw = settings.iDraw;
	                    var col = settings.aoColumns[colIdx];
	                    var rowData = settings.aoData[rowIdx]._aData;
	                    var defaultContent = col.sDefaultContent;
	                    var cellData = col.fnGetData(rowData, type, {
	                        settings: settings,
	                        row: rowIdx,
	                        col: colIdx
	                    });

	                    if (cellData === undefined) {
	                        if (settings.iDrawError != draw && defaultContent === null) {
	                            _fnLog(settings, 0, "Requested unknown parameter " +
	                                (typeof col.mData == 'function' ? '{function}' : "'" + col.mData + "'") +
	                                " for row " + rowIdx, 4);
	                            settings.iDrawError = draw;
	                        }
	                        return defaultContent;
	                    }

	                    /* When the data source is null, we can use default column data */
	                    if ((cellData === rowData || cellData === null) && defaultContent !== null) {
	                        cellData = defaultContent;
	                    }
	                    else if (typeof cellData === 'function') {
	                        // If the data source is a function, then we run it and use the return,
	                        // executing in the scope of the data object (for instances)
	                        return cellData.call(rowData);
	                    }

	                    if (cellData === null && type == 'display') {
	                        return '';
	                    }
	                    return cellData;
	                }


	                /**
	                 * Set the value for a specific cell, into the internal data cache
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} rowIdx aoData row id
	                 *  @param {int} colIdx Column index
	                 *  @param {*} val Value to set
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSetCellData(settings, rowIdx, colIdx, val) {
	                    var col = settings.aoColumns[colIdx];
	                    var rowData = settings.aoData[rowIdx]._aData;

	                    col.fnSetData(rowData, val, {
	                        settings: settings,
	                        row: rowIdx,
	                        col: colIdx
	                    });
	                }


	                // Private variable that is used to match action syntax in the data property object
	                var __reArray = /\[.*?\]$/;
	                var __reFn = /\(\)$/;

	                /**
	                 * Split string on periods, taking into account escaped periods
	                 * @param  {string} str String to split
	                 * @return {array} Split string
	                 */
	                function _fnSplitObjNotation(str) {
	                    return $.map(str.match(/(\\.|[^\.])+/g), function (s) {
	                        return s.replace(/\\./g, '.');
	                    });
	                }


	                /**
	                 * Return a function that can be used to get data from a source object, taking
	                 * into account the ability to use nested objects as a source
	                 *  @param {string|int|function} mSource The data source for the object
	                 *  @returns {function} Data get function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetObjectDataFn(mSource) {
	                    if ($.isPlainObject(mSource)) {
	                        /* Build an object of get functions, and wrap them in a single call */
	                        var o = {};
	                        $.each(mSource, function (key, val) {
	                            if (val) {
	                                o[key] = _fnGetObjectDataFn(val);
	                            }
	                        });

	                        return function (data, type, row, meta) {
	                            var t = o[type] || o._;
	                            return t !== undefined ?
	                                t(data, type, row, meta) :
	                                data;
	                        };
	                    }
	                    else if (mSource === null) {
	                        /* Give an empty string for rendering / sorting etc */
	                        return function (data) { // type, row and meta also passed, but not used
	                            return data;
	                        };
	                    }
	                    else if (typeof mSource === 'function') {
	                        return function (data, type, row, meta) {
	                            return mSource(data, type, row, meta);
	                        };
	                    }
	                    else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
	                              mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
	                        /* If there is a . in the source string then the data source is in a
	                         * nested object so we loop over the data for each level to get the next
	                         * level down. On each loop we test for undefined, and if found immediately
	                         * return. This allows entire objects to be missing and sDefaultContent to
	                         * be used if defined, rather than throwing an error
	                         */
	                        var fetchData = function (data, type, src) {
	                            var arrayNotation, funcNotation, out, innerSrc;

	                            if (src !== "") {
	                                var a = _fnSplitObjNotation(src);

	                                for (var i = 0, iLen = a.length ; i < iLen ; i++) {
	                                    // Check if we are dealing with special notation
	                                    arrayNotation = a[i].match(__reArray);
	                                    funcNotation = a[i].match(__reFn);

	                                    if (arrayNotation) {
	                                        // Array notation
	                                        a[i] = a[i].replace(__reArray, '');

	                                        // Condition allows simply [] to be passed in
	                                        if (a[i] !== "") {
	                                            data = data[a[i]];
	                                        }
	                                        out = [];

	                                        // Get the remainder of the nested object to get
	                                        a.splice(0, i + 1);
	                                        innerSrc = a.join('.');

	                                        // Traverse each entry in the array getting the properties requested
	                                        for (var j = 0, jLen = data.length ; j < jLen ; j++) {
	                                            out.push(fetchData(data[j], type, innerSrc));
	                                        }

	                                        // If a string is given in between the array notation indicators, that
	                                        // is used to join the strings together, otherwise an array is returned
	                                        var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
	                                        data = (join === "") ? out : out.join(join);

	                                        // The inner call to fetchData has already traversed through the remainder
	                                        // of the source requested, so we exit from the loop
	                                        break;
	                                    }
	                                    else if (funcNotation) {
	                                        // Function call
	                                        a[i] = a[i].replace(__reFn, '');
	                                        data = data[a[i]]();
	                                        continue;
	                                    }

	                                    if (data === null || data[a[i]] === undefined) {
	                                        return undefined;
	                                    }
	                                    data = data[a[i]];
	                                }
	                            }

	                            return data;
	                        };

	                        return function (data, type) { // row and meta also passed, but not used
	                            return fetchData(data, type, mSource);
	                        };
	                    }
	                    else {
	                        /* Array or flat object mapping */
	                        return function (data, type) { // row and meta also passed, but not used
	                            return data[mSource];
	                        };
	                    }
	                }


	                /**
	                 * Return a function that can be used to set data from a source object, taking
	                 * into account the ability to use nested objects as a source
	                 *  @param {string|int|function} mSource The data source for the object
	                 *  @returns {function} Data set function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSetObjectDataFn(mSource) {
	                    if ($.isPlainObject(mSource)) {
	                        /* Unlike get, only the underscore (global) option is used for for
	                         * setting data since we don't know the type here. This is why an object
	                         * option is not documented for `mData` (which is read/write), but it is
	                         * for `mRender` which is read only.
	                         */
	                        return _fnSetObjectDataFn(mSource._);
	                    }
	                    else if (mSource === null) {
	                        /* Nothing to do when the data source is null */
	                        return function () { };
	                    }
	                    else if (typeof mSource === 'function') {
	                        return function (data, val, meta) {
	                            mSource(data, 'set', val, meta);
	                        };
	                    }
	                    else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||
	                              mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {
	                        /* Like the get, we need to get data from a nested object */
	                        var setData = function (data, val, src) {
	                            var a = _fnSplitObjNotation(src), b;
	                            var aLast = a[a.length - 1];
	                            var arrayNotation, funcNotation, o, innerSrc;

	                            for (var i = 0, iLen = a.length - 1 ; i < iLen ; i++) {
	                                // Check if we are dealing with an array notation request
	                                arrayNotation = a[i].match(__reArray);
	                                funcNotation = a[i].match(__reFn);

	                                if (arrayNotation) {
	                                    a[i] = a[i].replace(__reArray, '');
	                                    data[a[i]] = [];

	                                    // Get the remainder of the nested object to set so we can recurse
	                                    b = a.slice();
	                                    b.splice(0, i + 1);
	                                    innerSrc = b.join('.');

	                                    // Traverse each entry in the array setting the properties requested
	                                    for (var j = 0, jLen = val.length ; j < jLen ; j++) {
	                                        o = {};
	                                        setData(o, val[j], innerSrc);
	                                        data[a[i]].push(o);
	                                    }

	                                    // The inner call to setData has already traversed through the remainder
	                                    // of the source and has set the data, thus we can exit here
	                                    return;
	                                }
	                                else if (funcNotation) {
	                                    // Function call
	                                    a[i] = a[i].replace(__reFn, '');
	                                    data = data[a[i]](val);
	                                }

	                                // If the nested object doesn't currently exist - since we are
	                                // trying to set the value - create it
	                                if (data[a[i]] === null || data[a[i]] === undefined) {
	                                    data[a[i]] = {};
	                                }
	                                data = data[a[i]];
	                            }

	                            // Last item in the input - i.e, the actual set
	                            if (aLast.match(__reFn)) {
	                                // Function call
	                                data = data[aLast.replace(__reFn, '')](val);
	                            }
	                            else {
	                                // If array notation is used, we just want to strip it and use the property name
	                                // and assign the value. If it isn't used, then we get the result we want anyway
	                                data[aLast.replace(__reArray, '')] = val;
	                            }
	                        };

	                        return function (data, val) { // meta is also passed in, but not used
	                            return setData(data, val, mSource);
	                        };
	                    }
	                    else {
	                        /* Array or flat object mapping */
	                        return function (data, val) { // meta is also passed in, but not used
	                            data[mSource] = val;
	                        };
	                    }
	                }


	                /**
	                 * Return an array with the full table data
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns array {array} aData Master data array
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetDataMaster(settings) {
	                    return _pluck(settings.aoData, '_aData');
	                }


	                /**
	                 * Nuke the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnClearTable(settings) {
	                    settings.aoData.length = 0;
	                    settings.aiDisplayMaster.length = 0;
	                    settings.aiDisplay.length = 0;
	                }


	                /**
	                * Take an array of integers (index array) and remove a target integer (value - not
	                * the key!)
	                *  @param {array} a Index array to target
	                *  @param {int} iTarget value to find
	                *  @memberof DataTable#oApi
	                */
	                function _fnDeleteIndex(a, iTarget, splice) {
	                    var iTargetIndex = -1;

	                    for (var i = 0, iLen = a.length ; i < iLen ; i++) {
	                        if (a[i] == iTarget) {
	                            iTargetIndex = i;
	                        }
	                        else if (a[i] > iTarget) {
	                            a[i]--;
	                        }
	                    }

	                    if (iTargetIndex != -1 && splice === undefined) {
	                        a.splice(iTargetIndex, 1);
	                    }
	                }


	                /**
	                 * Mark cached data as invalid such that a re-read of the data will occur when
	                 * the cached data is next requested. Also update from the data source object.
	                 *
	                 * @param {object} settings DataTables settings object
	                 * @param {int}    rowIdx   Row index to invalidate
	                 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
	                 *     or 'data'
	                 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
	                 *     row will be invalidated
	                 * @memberof DataTable#oApi
	                 *
	                 * @todo For the modularisation of v1.11 this will need to become a callback, so
	                 *   the sort and filter methods can subscribe to it. That will required
	                 *   initialisation options for sorting, which is why it is not already baked in
	                 */
	                function _fnInvalidate(settings, rowIdx, src, colIdx) {
	                    var row = settings.aoData[rowIdx];
	                    var i, ien;
	                    var cellWrite = function (cell, col) {
	                        // This is very frustrating, but in IE if you just write directly
	                        // to innerHTML, and elements that are overwritten are GC'ed,
	                        // even if there is a reference to them elsewhere
	                        while (cell.childNodes.length) {
	                            cell.removeChild(cell.firstChild);
	                        }

	                        cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');
	                    };

	                    // Are we reading last data from DOM or the data object?
	                    if (src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {
	                        // Read the data from the DOM
	                        row._aData = _fnGetRowElements(
	                                settings, row, colIdx, colIdx === undefined ? undefined : row._aData
	                            )
	                            .data;
	                    }
	                    else {
	                        // Reading from data object, update the DOM
	                        var cells = row.anCells;

	                        if (cells) {
	                            if (colIdx !== undefined) {
	                                cellWrite(cells[colIdx], colIdx);
	                            }
	                            else {
	                                for (i = 0, ien = cells.length ; i < ien ; i++) {
	                                    cellWrite(cells[i], i);
	                                }
	                            }
	                        }
	                    }

	                    // For both row and cell invalidation, the cached data for sorting and
	                    // filtering is nulled out
	                    row._aSortData = null;
	                    row._aFilterData = null;

	                    // Invalidate the type for a specific column (if given) or all columns since
	                    // the data might have changed
	                    var cols = settings.aoColumns;
	                    if (colIdx !== undefined) {
	                        cols[colIdx].sType = null;
	                    }
	                    else {
	                        for (i = 0, ien = cols.length ; i < ien ; i++) {
	                            cols[i].sType = null;
	                        }

	                        // Update DataTables special `DT_*` attributes for the row
	                        _fnRowAttributes(row);
	                    }
	                }


	                /**
	                 * Build a data source object from an HTML row, reading the contents of the
	                 * cells that are in the row.
	                 *
	                 * @param {object} settings DataTables settings object
	                 * @param {node|object} TR element from which to read data or existing row
	                 *   object from which to re-read the data from the cells
	                 * @param {int} [colIdx] Optional column index
	                 * @param {array|object} [d] Data source object. If `colIdx` is given then this
	                 *   parameter should also be given and will be used to write the data into.
	                 *   Only the column in question will be written
	                 * @returns {object} Object with two parameters: `data` the data read, in
	                 *   document order, and `cells` and array of nodes (they can be useful to the
	                 *   caller, so rather than needing a second traversal to get them, just return
	                 *   them from here).
	                 * @memberof DataTable#oApi
	                 */
	                function _fnGetRowElements(settings, row, colIdx, d) {
	                    var
	                        tds = [],
	                        td = row.firstChild,
	                        name, col, o, i = 0, contents,
	                        columns = settings.aoColumns,
	                        objectRead = settings._rowReadObject;

	                    // Allow the data object to be passed in, or construct
	                    d = d || objectRead ? {} : [];

	                    var attr = function (str, td) {
	                        if (typeof str === 'string') {
	                            var idx = str.indexOf('@');

	                            if (idx !== -1) {
	                                var attr = str.substring(idx + 1);
	                                var setter = _fnSetObjectDataFn(str);
	                                setter(d, td.getAttribute(attr));
	                            }
	                        }
	                    };

	                    // Read data from a cell and store into the data object
	                    var cellProcess = function (cell) {
	                        if (colIdx === undefined || colIdx === i) {
	                            col = columns[i];
	                            contents = $.trim(cell.innerHTML);

	                            if (col && col._bAttrSrc) {
	                                var setter = _fnSetObjectDataFn(col.mData._);
	                                setter(d, contents);

	                                attr(col.mData.sort, cell);
	                                attr(col.mData.type, cell);
	                                attr(col.mData.filter, cell);
	                            }
	                            else {
	                                // Depending on the `data` option for the columns the data can
	                                // be read to either an object or an array.
	                                if (objectRead) {
	                                    if (!col._setter) {
	                                        // Cache the setter function
	                                        col._setter = _fnSetObjectDataFn(col.mData);
	                                    }
	                                    col._setter(d, contents);
	                                }
	                                else {
	                                    d[i] = contents;
	                                }
	                            }
	                        }

	                        i++;
	                    };

	                    if (td) {
	                        // `tr` element was passed in
	                        while (td) {
	                            name = td.nodeName.toUpperCase();

	                            if (name == "TD" || name == "TH") {
	                                cellProcess(td);
	                                tds.push(td);
	                            }

	                            td = td.nextSibling;
	                        }
	                    }
	                    else {
	                        // Existing row object passed in
	                        tds = row.anCells;

	                        for (var j = 0, jen = tds.length ; j < jen ; j++) {
	                            cellProcess(tds[j]);
	                        }
	                    }

	                    return {
	                        data: d,
	                        cells: tds
	                    };
	                }
	                /**
	                 * Create a new TR element (and it's TD children) for a row
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {int} iRow Row to consider
	                 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
	                 *    DataTables will create a row automatically
	                 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
	                 *    if nTr is.
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
	                    var
	                        row = oSettings.aoData[iRow],
	                        rowData = row._aData,
	                        cells = [],
	                        nTr, nTd, oCol,
	                        i, iLen;

	                    if (row.nTr === null) {
	                        nTr = nTrIn || document.createElement('tr');

	                        row.nTr = nTr;
	                        row.anCells = cells;

	                        /* Use a private property on the node to allow reserve mapping from the node
	                         * to the aoData array for fast look up
	                         */
	                        nTr._DT_RowIndex = iRow;

	                        /* Special parameters can be given by the data source to be used on the row */
	                        _fnRowAttributes(row);

	                        /* Process each column */
	                        for (i = 0, iLen = oSettings.aoColumns.length ; i < iLen ; i++) {
	                            oCol = oSettings.aoColumns[i];

	                            nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType);
	                            cells.push(nTd);

	                            // Need to create the HTML if new, or if a rendering function is defined
	                            if (!nTrIn || oCol.mRender || oCol.mData !== i) {
	                                nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');
	                            }

	                            /* Add user defined class */
	                            if (oCol.sClass) {
	                                nTd.className += ' ' + oCol.sClass;
	                            }

	                            // Visibility - add or remove as required
	                            if (oCol.bVisible && !nTrIn) {
	                                nTr.appendChild(nTd);
	                            }
	                            else if (!oCol.bVisible && nTrIn) {
	                                nTd.parentNode.removeChild(nTd);
	                            }

	                            if (oCol.fnCreatedCell) {
	                                oCol.fnCreatedCell.call(oSettings.oInstance,
	                                    nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i
	                                );
	                            }
	                        }

	                        _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow]);
	                    }

	                    // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved
	                    // and deployed
	                    row.nTr.setAttribute('role', 'row');
	                }


	                /**
	                 * Add attributes to a row based on the special `DT_*` parameters in a data
	                 * source object.
	                 *  @param {object} DataTables row object for the row to be modified
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnRowAttributes(row) {
	                    var tr = row.nTr;
	                    var data = row._aData;

	                    if (tr) {
	                        if (data.DT_RowId) {
	                            tr.id = data.DT_RowId;
	                        }

	                        if (data.DT_RowClass) {
	                            // Remove any classes added by DT_RowClass before
	                            var a = data.DT_RowClass.split(' ');
	                            row.__rowc = row.__rowc ?
	                                _unique(row.__rowc.concat(a)) :
	                                a;

	                            $(tr)
	                                .removeClass(row.__rowc.join(' '))
	                                .addClass(data.DT_RowClass);
	                        }

	                        if (data.DT_RowAttr) {
	                            $(tr).attr(data.DT_RowAttr);
	                        }

	                        if (data.DT_RowData) {
	                            $(tr).data(data.DT_RowData);
	                        }
	                    }
	                }


	                /**
	                 * Create the HTML header for the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnBuildHead(oSettings) {
	                    var i, ien, cell, row, column;
	                    var thead = oSettings.nTHead;
	                    var tfoot = oSettings.nTFoot;
	                    var createHeader = $('th, td', thead).length === 0;
	                    var classes = oSettings.oClasses;
	                    var columns = oSettings.aoColumns;

	                    if (createHeader) {
	                        row = $('<tr/>').appendTo(thead);
	                    }

	                    for (i = 0, ien = columns.length ; i < ien ; i++) {
	                        column = columns[i];
	                        cell = $(column.nTh).addClass(column.sClass);

	                        if (createHeader) {
	                            cell.appendTo(row);
	                        }

	                        // 1.11 move into sorting
	                        if (oSettings.oFeatures.bSort) {
	                            cell.addClass(column.sSortingClass);

	                            if (column.bSortable !== false) {
	                                cell
	                                    .attr('tabindex', oSettings.iTabIndex)
	                                    .attr('aria-controls', oSettings.sTableId);

	                                _fnSortAttachListener(oSettings, column.nTh, i);
	                            }
	                        }

	                        if (column.sTitle != cell.html()) {
	                            cell.html(column.sTitle);
	                        }

	                        _fnRenderer(oSettings, 'header')(
	                            oSettings, cell, column, classes
	                        );
	                    }

	                    if (createHeader) {
	                        _fnDetectHeader(oSettings.aoHeader, thead);
	                    }

	                    /* ARIA role for the rows */
	                    $(thead).find('>tr').attr('role', 'row');

	                    /* Deal with the footer - add classes if required */
	                    $(thead).find('>tr>th, >tr>td').addClass(classes.sHeaderTH);
	                    $(tfoot).find('>tr>th, >tr>td').addClass(classes.sFooterTH);

	                    // Cache the footer cells. Note that we only take the cells from the first
	                    // row in the footer. If there is more than one row the user wants to
	                    // interact with, they need to use the table().foot() method. Note also this
	                    // allows cells to be used for multiple columns using colspan
	                    if (tfoot !== null) {
	                        var cells = oSettings.aoFooter[0];

	                        for (i = 0, ien = cells.length ; i < ien ; i++) {
	                            column = columns[i];
	                            column.nTf = cells[i].cell;

	                            if (column.sClass) {
	                                $(column.nTf).addClass(column.sClass);
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Draw the header (or footer) element based on the column visibility states. The
	                 * methodology here is to use the layout array from _fnDetectHeader, modified for
	                 * the instantaneous column visibility, to construct the new layout. The grid is
	                 * traversed over cell at a time in a rows x columns grid fashion, although each
	                 * cell insert can cover multiple elements in the grid - which is tracks using the
	                 * aApplied array. Cell inserts in the grid will only occur where there isn't
	                 * already a cell in that position.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param array {objects} aoSource Layout array from _fnDetectHeader
	                 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
	                    var i, iLen, j, jLen, k, kLen, n, nLocalTr;
	                    var aoLocal = [];
	                    var aApplied = [];
	                    var iColumns = oSettings.aoColumns.length;
	                    var iRowspan, iColspan;

	                    if (!aoSource) {
	                        return;
	                    }

	                    if (bIncludeHidden === undefined) {
	                        bIncludeHidden = false;
	                    }

	                    /* Make a copy of the master layout array, but without the visible columns in it */
	                    for (i = 0, iLen = aoSource.length ; i < iLen ; i++) {
	                        aoLocal[i] = aoSource[i].slice();
	                        aoLocal[i].nTr = aoSource[i].nTr;

	                        /* Remove any columns which are currently hidden */
	                        for (j = iColumns - 1 ; j >= 0 ; j--) {
	                            if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
	                                aoLocal[i].splice(j, 1);
	                            }
	                        }

	                        /* Prep the applied array - it needs an element for each row */
	                        aApplied.push([]);
	                    }

	                    for (i = 0, iLen = aoLocal.length ; i < iLen ; i++) {
	                        nLocalTr = aoLocal[i].nTr;

	                        /* All cells are going to be replaced, so empty out the row */
	                        if (nLocalTr) {
	                            while ((n = nLocalTr.firstChild)) {
	                                nLocalTr.removeChild(n);
	                            }
	                        }

	                        for (j = 0, jLen = aoLocal[i].length ; j < jLen ; j++) {
	                            iRowspan = 1;
	                            iColspan = 1;

	                            /* Check to see if there is already a cell (row/colspan) covering our target
	                             * insert point. If there is, then there is nothing to do.
	                             */
	                            if (aApplied[i][j] === undefined) {
	                                nLocalTr.appendChild(aoLocal[i][j].cell);
	                                aApplied[i][j] = 1;

	                                /* Expand the cell to cover as many rows as needed */
	                                while (aoLocal[i + iRowspan] !== undefined &&
	                                        aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
	                                    aApplied[i + iRowspan][j] = 1;
	                                    iRowspan++;
	                                }

	                                /* Expand the cell to cover as many columns as needed */
	                                while (aoLocal[i][j + iColspan] !== undefined &&
	                                        aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
	                                    /* Must update the applied array over the rows for the columns */
	                                    for (k = 0 ; k < iRowspan ; k++) {
	                                        aApplied[i + k][j + iColspan] = 1;
	                                    }
	                                    iColspan++;
	                                }

	                                /* Do the actual expansion in the DOM */
	                                $(aoLocal[i][j].cell)
	                                    .attr('rowspan', iRowspan)
	                                    .attr('colspan', iColspan);
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Insert the required TR nodes into the table for display
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnDraw(oSettings) {
	                    /* Provide a pre-callback function which can be used to cancel the draw is false is returned */
	                    var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);
	                    if ($.inArray(false, aPreDraw) !== -1) {
	                        _fnProcessingDisplay(oSettings, false);
	                        return;
	                    }

	                    var i, iLen, n;
	                    var anRows = [];
	                    var iRowCount = 0;
	                    var asStripeClasses = oSettings.asStripeClasses;
	                    var iStripes = asStripeClasses.length;
	                    var iOpenRows = oSettings.aoOpenRows.length;
	                    var oLang = oSettings.oLanguage;
	                    var iInitDisplayStart = oSettings.iInitDisplayStart;
	                    var bServerSide = _fnDataSource(oSettings) == 'ssp';
	                    var aiDisplay = oSettings.aiDisplay;

	                    oSettings.bDrawing = true;

	                    /* Check and see if we have an initial draw position from state saving */
	                    if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {
	                        oSettings._iDisplayStart = bServerSide ?
	                            iInitDisplayStart :
	                            iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
	                                0 :
	                                iInitDisplayStart;

	                        oSettings.iInitDisplayStart = -1;
	                    }

	                    var iDisplayStart = oSettings._iDisplayStart;
	                    var iDisplayEnd = oSettings.fnDisplayEnd();

	                    /* Server-side processing draw intercept */
	                    if (oSettings.bDeferLoading) {
	                        oSettings.bDeferLoading = false;
	                        oSettings.iDraw++;
	                        _fnProcessingDisplay(oSettings, false);
	                    }
	                    else if (!bServerSide) {
	                        oSettings.iDraw++;
	                    }
	                    else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
	                        return;
	                    }

	                    if (aiDisplay.length !== 0) {
	                        var iStart = bServerSide ? 0 : iDisplayStart;
	                        var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

	                        for (var j = iStart ; j < iEnd ; j++) {
	                            var iDataIndex = aiDisplay[j];
	                            var aoData = oSettings.aoData[iDataIndex];
	                            if (aoData.nTr === null) {
	                                _fnCreateTr(oSettings, iDataIndex);
	                            }

	                            var nRow = aoData.nTr;

	                            /* Remove the old striping classes and then add the new one */
	                            if (iStripes !== 0) {
	                                var sStripe = asStripeClasses[iRowCount % iStripes];
	                                if (aoData._sRowStripe != sStripe) {
	                                    $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
	                                    aoData._sRowStripe = sStripe;
	                                }
	                            }

	                            // Row callback functions - might want to manipulate the row
	                            // iRowCount and j are not currently documented. Are they at all
	                            // useful?
	                            _fnCallbackFire(oSettings, 'aoRowCallback', null,
	                                [nRow, aoData._aData, iRowCount, j]);

	                            anRows.push(nRow);
	                            iRowCount++;
	                        }
	                    }
	                    else {
	                        /* Table is empty - create a row with an empty message in it */
	                        var sZero = oLang.sZeroRecords;
	                        if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {
	                            sZero = oLang.sLoadingRecords;
	                        }
	                        else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
	                            sZero = oLang.sEmptyTable;
	                        }

	                        anRows[0] = $('<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' })
	                            .append($('<td />', {
	                                'valign': 'top',
	                                'colSpan': _fnVisbleColumns(oSettings),
	                                'class': oSettings.oClasses.sRowEmpty
	                            }).html(sZero))[0];
	                    }

	                    /* Header and footer callbacks */
	                    _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0],
	                        _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

	                    _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0],
	                        _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);

	                    var body = $(oSettings.nTBody);

	                    body.children().detach();
	                    body.append($(anRows));

	                    /* Call all required callback functions for the end of a draw */
	                    _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);

	                    /* Draw is complete, sorting and filtering must be as well */
	                    oSettings.bSorted = false;
	                    oSettings.bFiltered = false;
	                    oSettings.bDrawing = false;
	                }


	                /**
	                 * Redraw the table - taking account of the various features which are enabled
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {boolean} [holdPosition] Keep the current paging position. By default
	                 *    the paging is reset to the first page
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnReDraw(settings, holdPosition) {
	                    var
	                        features = settings.oFeatures,
	                        sort = features.bSort,
	                        filter = features.bFilter;

	                    if (sort) {
	                        _fnSort(settings);
	                    }

	                    if (filter) {
	                        _fnFilterComplete(settings, settings.oPreviousSearch);
	                    }
	                    else {
	                        // No filtering, so we want to just use the display master
	                        settings.aiDisplay = settings.aiDisplayMaster.slice();
	                    }

	                    if (holdPosition !== true) {
	                        settings._iDisplayStart = 0;
	                    }

	                    // Let any modules know about the draw hold position state (used by
	                    // scrolling internally)
	                    settings._drawHold = holdPosition;

	                    _fnDraw(settings);

	                    settings._drawHold = false;
	                }


	                /**
	                 * Add the options to the page HTML for the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAddOptionsHtml(oSettings) {
	                    var classes = oSettings.oClasses;
	                    var table = $(oSettings.nTable);
	                    var holding = $('<div/>').insertBefore(table); // Holding element for speed
	                    var features = oSettings.oFeatures;

	                    // All DataTables are wrapped in a div
	                    var insert = $('<div/>', {
	                        id: oSettings.sTableId + '_wrapper',
	                        'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)
	                    });

	                    oSettings.nHolding = holding[0];
	                    oSettings.nTableWrapper = insert[0];
	                    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;

	                    /* Loop over the user set positioning and place the elements as needed */
	                    var aDom = oSettings.sDom.split('');
	                    var featureNode, cOption, nNewNode, cNext, sAttr, j;
	                    for (var i = 0 ; i < aDom.length ; i++) {
	                        featureNode = null;
	                        cOption = aDom[i];

	                        if (cOption == '<') {
	                            /* New container div */
	                            nNewNode = $('<div/>')[0];

	                            /* Check to see if we should append an id and/or a class name to the container */
	                            cNext = aDom[i + 1];
	                            if (cNext == "'" || cNext == '"') {
	                                sAttr = "";
	                                j = 2;
	                                while (aDom[i + j] != cNext) {
	                                    sAttr += aDom[i + j];
	                                    j++;
	                                }

	                                /* Replace jQuery UI constants @todo depreciated */
	                                if (sAttr == "H") {
	                                    sAttr = classes.sJUIHeader;
	                                }
	                                else if (sAttr == "F") {
	                                    sAttr = classes.sJUIFooter;
	                                }

	                                /* The attribute can be in the format of "#id.class", "#id" or "class" This logic
	                                 * breaks the string into parts and applies them as needed
	                                 */
	                                if (sAttr.indexOf('.') != -1) {
	                                    var aSplit = sAttr.split('.');
	                                    nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
	                                    nNewNode.className = aSplit[1];
	                                }
	                                else if (sAttr.charAt(0) == "#") {
	                                    nNewNode.id = sAttr.substr(1, sAttr.length - 1);
	                                }
	                                else {
	                                    nNewNode.className = sAttr;
	                                }

	                                i += j; /* Move along the position array */
	                            }

	                            insert.append(nNewNode);
	                            insert = $(nNewNode);
	                        }
	                        else if (cOption == '>') {
	                            /* End container div */
	                            insert = insert.parent();
	                        }
	                            // @todo Move options into their own plugins?
	                        else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {
	                            /* Length */
	                            featureNode = _fnFeatureHtmlLength(oSettings);
	                        }
	                        else if (cOption == 'f' && features.bFilter) {
	                            /* Filter */
	                            featureNode = _fnFeatureHtmlFilter(oSettings);
	                        }
	                        else if (cOption == 'r' && features.bProcessing) {
	                            /* pRocessing */
	                            featureNode = _fnFeatureHtmlProcessing(oSettings);
	                        }
	                        else if (cOption == 't') {
	                            /* Table */
	                            featureNode = _fnFeatureHtmlTable(oSettings);
	                        }
	                        else if (cOption == 'i' && features.bInfo) {
	                            /* Info */
	                            featureNode = _fnFeatureHtmlInfo(oSettings);
	                        }
	                        else if (cOption == 'p' && features.bPaginate) {
	                            /* Pagination */
	                            featureNode = _fnFeatureHtmlPaginate(oSettings);
	                        }
	                        else if (DataTable.ext.feature.length !== 0) {
	                            /* Plug-in features */
	                            var aoFeatures = DataTable.ext.feature;
	                            for (var k = 0, kLen = aoFeatures.length ; k < kLen ; k++) {
	                                if (cOption == aoFeatures[k].cFeature) {
	                                    featureNode = aoFeatures[k].fnInit(oSettings);
	                                    break;
	                                }
	                            }
	                        }

	                        /* Add to the 2D features array */
	                        if (featureNode) {
	                            var aanFeatures = oSettings.aanFeatures;

	                            if (!aanFeatures[cOption]) {
	                                aanFeatures[cOption] = [];
	                            }

	                            aanFeatures[cOption].push(featureNode);
	                            insert.append(featureNode);
	                        }
	                    }

	                    /* Built our DOM structure - replace the holding div with what we want */
	                    holding.replaceWith(insert);
	                }


	                /**
	                 * Use the DOM source to create up an array of header cells. The idea here is to
	                 * create a layout grid (array) of rows x columns, which contains a reference
	                 * to the cell that that point in the grid (regardless of col/rowspan), such that
	                 * any column / row could be removed and the new grid constructed
	                 *  @param array {object} aLayout Array to store the calculated layout in
	                 *  @param {node} nThead The header/footer element for the table
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnDetectHeader(aLayout, nThead) {
	                    var nTrs = $(nThead).children('tr');
	                    var nTr, nCell;
	                    var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
	                    var bUnique;
	                    var fnShiftCol = function (a, i, j) {
	                        var k = a[i];
	                        while (k[j]) {
	                            j++;
	                        }
	                        return j;
	                    };

	                    aLayout.splice(0, aLayout.length);

	                    /* We know how many rows there are in the layout - so prep it */
	                    for (i = 0, iLen = nTrs.length ; i < iLen ; i++) {
	                        aLayout.push([]);
	                    }

	                    /* Calculate a layout array */
	                    for (i = 0, iLen = nTrs.length ; i < iLen ; i++) {
	                        nTr = nTrs[i];
	                        iColumn = 0;

	                        /* For every cell in the row... */
	                        nCell = nTr.firstChild;
	                        while (nCell) {
	                            if (nCell.nodeName.toUpperCase() == "TD" ||
	                                 nCell.nodeName.toUpperCase() == "TH") {
	                                /* Get the col and rowspan attributes from the DOM and sanitise them */
	                                iColspan = nCell.getAttribute('colspan') * 1;
	                                iRowspan = nCell.getAttribute('rowspan') * 1;
	                                iColspan = (!iColspan || iColspan === 0 || iColspan === 1) ? 1 : iColspan;
	                                iRowspan = (!iRowspan || iRowspan === 0 || iRowspan === 1) ? 1 : iRowspan;

	                                /* There might be colspan cells already in this row, so shift our target
	                                 * accordingly
	                                 */
	                                iColShifted = fnShiftCol(aLayout, i, iColumn);

	                                /* Cache calculation for unique columns */
	                                bUnique = iColspan === 1 ? true : false;

	                                /* If there is col / rowspan, copy the information into the layout grid */
	                                for (l = 0 ; l < iColspan ; l++) {
	                                    for (k = 0 ; k < iRowspan ; k++) {
	                                        aLayout[i + k][iColShifted + l] = {
	                                            "cell": nCell,
	                                            "unique": bUnique
	                                        };
	                                        aLayout[i + k].nTr = nTr;
	                                    }
	                                }
	                            }
	                            nCell = nCell.nextSibling;
	                        }
	                    }
	                }


	                /**
	                 * Get an array of unique th elements, one for each column
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {node} nHeader automatically detect the layout from this node - optional
	                 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
	                 *  @returns array {node} aReturn list of unique th's
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
	                    var aReturn = [];
	                    if (!aLayout) {
	                        aLayout = oSettings.aoHeader;
	                        if (nHeader) {
	                            aLayout = [];
	                            _fnDetectHeader(aLayout, nHeader);
	                        }
	                    }

	                    for (var i = 0, iLen = aLayout.length ; i < iLen ; i++) {
	                        for (var j = 0, jLen = aLayout[i].length ; j < jLen ; j++) {
	                            if (aLayout[i][j].unique &&
	                                 (!aReturn[j] || !oSettings.bSortCellsTop)) {
	                                aReturn[j] = aLayout[i][j].cell;
	                            }
	                        }
	                    }

	                    return aReturn;
	                }

	                /**
	                 * Create an Ajax call based on the table's settings, taking into account that
	                 * parameters can have multiple forms, and backwards compatibility.
	                 *
	                 * @param {object} oSettings dataTables settings object
	                 * @param {array} data Data to send to the server, required by
	                 *     DataTables - may be augmented by developer callbacks
	                 * @param {function} fn Callback function to run when data is obtained
	                 */
	                function _fnBuildAjax(oSettings, data, fn) {
	                    // Compatibility with 1.9-, allow fnServerData and event to manipulate
	                    _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]);

	                    // Convert to object based for 1.10+ if using the old array scheme which can
	                    // come from server-side processing or serverParams
	                    if (data && $.isArray(data)) {
	                        var tmp = {};
	                        var rbracket = /(.*?)\[\]$/;

	                        $.each(data, function (key, val) {
	                            var match = val.name.match(rbracket);

	                            if (match) {
	                                // Support for arrays
	                                var name = match[0];

	                                if (!tmp[name]) {
	                                    tmp[name] = [];
	                                }
	                                tmp[name].push(val.value);
	                            }
	                            else {
	                                tmp[val.name] = val.value;
	                            }
	                        });
	                        data = tmp;
	                    }

	                    var ajaxData;
	                    var ajax = oSettings.ajax;
	                    var instance = oSettings.oInstance;
	                    var callback = function (json) {
	                        _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);
	                        fn(json);
	                    };

	                    if ($.isPlainObject(ajax) && ajax.data) {
	                        ajaxData = ajax.data;

	                        var newData = $.isFunction(ajaxData) ?
	                            ajaxData(data, oSettings) :  // fn can manipulate data or return
	                            ajaxData;                      // an object object or array to merge

	                        // If the function returned something, use that alone
	                        data = $.isFunction(ajaxData) && newData ?
	                            newData :
	                            $.extend(true, data, newData);

	                        // Remove the data property as we've resolved it already and don't want
	                        // jQuery to do it again (it is restored at the end of the function)
	                        delete ajax.data;
	                    }

	                    var baseAjax = {
	                        "data": data,
	                        "success": function (json) {
	                            var error = json.error || json.sError;
	                            if (error) {
	                                _fnLog(oSettings, 0, error);
	                            }

	                            oSettings.json = json;
	                            callback(json);
	                        },
	                        "dataType": "json",
	                        "cache": false,
	                        "type": oSettings.sServerMethod,
	                        "error": function (xhr, error, thrown) {
	                            var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);

	                            if ($.inArray(true, ret) === -1) {
	                                if (error == "parsererror") {
	                                    _fnLog(oSettings, 0, 'Invalid JSON response', 1);
	                                }
	                                else if (xhr.readyState === 4) {
	                                    _fnLog(oSettings, 0, 'Ajax error', 7);
	                                }
	                            }

	                            _fnProcessingDisplay(oSettings, false);
	                        }
	                    };

	                    // Store the data submitted for the API
	                    oSettings.oAjaxData = data;

	                    // Allow plug-ins and external processes to modify the data
	                    _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);

	                    if (oSettings.fnServerData) {
	                        // DataTables 1.9- compatibility
	                        oSettings.fnServerData.call(instance,
	                            oSettings.sAjaxSource,
	                            $.map(data, function (val, key) { // Need to convert back to 1.9 trad format
	                                return { name: key, value: val };
	                            }),
	                            callback,
	                            oSettings
	                        );
	                    }
	                    else if (oSettings.sAjaxSource || typeof ajax === 'string') {
	                        // DataTables 1.9- compatibility
	                        oSettings.jqXHR = $.ajax($.extend(baseAjax, {
	                            url: ajax || oSettings.sAjaxSource
	                        }));
	                    }
	                    else if ($.isFunction(ajax)) {
	                        // Is a function - let the caller define what needs to be done
	                        oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
	                    }
	                    else {
	                        // Object to extend the base settings
	                        oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax));

	                        // Restore for next time around
	                        ajax.data = ajaxData;
	                    }
	                }


	                /**
	                 * Update the table using an Ajax call
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {boolean} Block the table drawing or not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAjaxUpdate(settings) {
	                    if (settings.bAjaxDataGet) {
	                        settings.iDraw++;
	                        _fnProcessingDisplay(settings, true);

	                        _fnBuildAjax(
	                            settings,
	                            _fnAjaxParameters(settings),
	                            function (json) {
	                                _fnAjaxUpdateDraw(settings, json);
	                            }
	                        );

	                        return false;
	                    }
	                    return true;
	                }


	                /**
	                 * Build up the parameters in an object needed for a server-side processing
	                 * request. Note that this is basically done twice, is different ways - a modern
	                 * method which is used by default in DataTables 1.10 which uses objects and
	                 * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if
	                 * the sAjaxSource option is used in the initialisation, or the legacyAjax
	                 * option is set.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {bool} block the table drawing or not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAjaxParameters(settings) {
	                    var
	                        columns = settings.aoColumns,
	                        columnCount = columns.length,
	                        features = settings.oFeatures,
	                        preSearch = settings.oPreviousSearch,
	                        preColSearch = settings.aoPreSearchCols,
	                        i, data = [], dataProp, column, columnSearch,
	                        sort = _fnSortFlatten(settings),
	                        displayStart = settings._iDisplayStart,
	                        displayLength = features.bPaginate !== false ?
	                            settings._iDisplayLength :
	                            -1;

	                    var param = function (name, value) {
	                        data.push({ 'name': name, 'value': value });
	                    };

	                    // DataTables 1.9- compatible method
	                    param('sEcho', settings.iDraw);
	                    param('iColumns', columnCount);
	                    param('sColumns', _pluck(columns, 'sName').join(','));
	                    param('iDisplayStart', displayStart);
	                    param('iDisplayLength', displayLength);

	                    // DataTables 1.10+ method
	                    var d = {
	                        draw: settings.iDraw,
	                        columns: [],
	                        order: [],
	                        start: displayStart,
	                        length: displayLength,
	                        search: {
	                            value: preSearch.sSearch,
	                            regex: preSearch.bRegex
	                        }
	                    };

	                    for (i = 0 ; i < columnCount ; i++) {
	                        column = columns[i];
	                        columnSearch = preColSearch[i];
	                        dataProp = typeof column.mData == "function" ? 'function' : column.mData;

	                        d.columns.push({
	                            data: dataProp,
	                            name: column.sName,
	                            searchable: column.bSearchable,
	                            orderable: column.bSortable,
	                            search: {
	                                value: columnSearch.sSearch,
	                                regex: columnSearch.bRegex
	                            }
	                        });

	                        param("mDataProp_" + i, dataProp);

	                        if (features.bFilter) {
	                            param('sSearch_' + i, columnSearch.sSearch);
	                            param('bRegex_' + i, columnSearch.bRegex);
	                            param('bSearchable_' + i, column.bSearchable);
	                        }

	                        if (features.bSort) {
	                            param('bSortable_' + i, column.bSortable);
	                        }
	                    }

	                    if (features.bFilter) {
	                        param('sSearch', preSearch.sSearch);
	                        param('bRegex', preSearch.bRegex);
	                    }

	                    if (features.bSort) {
	                        $.each(sort, function (i, val) {
	                            d.order.push({ column: val.col, dir: val.dir });

	                            param('iSortCol_' + i, val.col);
	                            param('sSortDir_' + i, val.dir);
	                        });

	                        param('iSortingCols', sort.length);
	                    }

	                    // If the legacy.ajax parameter is null, then we automatically decide which
	                    // form to use, based on sAjaxSource
	                    var legacy = DataTable.ext.legacy.ajax;
	                    if (legacy === null) {
	                        return settings.sAjaxSource ? data : d;
	                    }

	                    // Otherwise, if legacy has been specified then we use that to decide on the
	                    // form
	                    return legacy ? data : d;
	                }


	                /**
	                 * Data the data from the server (nuking the old) and redraw the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {object} json json data return from the server.
	                 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
	                 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
	                 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
	                 *  @param {array} json.aaData The data to display on this page
	                 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnAjaxUpdateDraw(settings, json) {
	                    // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.
	                    // Support both
	                    var compat = function (old, modern) {
	                        return json[old] !== undefined ? json[old] : json[modern];
	                    };

	                    var data = _fnAjaxDataSrc(settings, json);
	                    var draw = compat('sEcho', 'draw');
	                    var recordsTotal = compat('iTotalRecords', 'recordsTotal');
	                    var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');

	                    if (draw) {
	                        // Protect against out of sequence returns
	                        if (draw * 1 < settings.iDraw) {
	                            return;
	                        }
	                        settings.iDraw = draw * 1;
	                    }

	                    _fnClearTable(settings);
	                    settings._iRecordsTotal = parseInt(recordsTotal, 10);
	                    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

	                    for (var i = 0, ien = data.length ; i < ien ; i++) {
	                        _fnAddData(settings, data[i]);
	                    }
	                    settings.aiDisplay = settings.aiDisplayMaster.slice();

	                    settings.bAjaxDataGet = false;
	                    _fnDraw(settings);

	                    if (!settings._bInitComplete) {
	                        _fnInitComplete(settings, json);
	                    }

	                    settings.bAjaxDataGet = true;
	                    _fnProcessingDisplay(settings, false);
	                }


	                /**
	                 * Get the data from the JSON data source to use for drawing a table. Using
	                 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
	                 * source object, or from a processing function.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param  {object} json Data source object / array from the server
	                 *  @return {array} Array of data to use
	                 */
	                function _fnAjaxDataSrc(oSettings, json) {
	                    var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ?
	                        oSettings.ajax.dataSrc :
	                        oSettings.sAjaxDataProp; // Compatibility with 1.9-.

	                    // Compatibility with 1.9-. In order to read from aaData, check if the
	                    // default has been changed, if not, check for aaData
	                    if (dataSrc === 'data') {
	                        return json.aaData || json[dataSrc];
	                    }

	                    return dataSrc !== "" ?
	                        _fnGetObjectDataFn(dataSrc)(json) :
	                        json;
	                }

	                /**
	                 * Generate the node required for filtering text
	                 *  @returns {node} Filter control element
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlFilter(settings) {
	                    var classes = settings.oClasses;
	                    var tableId = settings.sTableId;
	                    var language = settings.oLanguage;
	                    var previousSearch = settings.oPreviousSearch;
	                    var features = settings.aanFeatures;
	                    var input = '<input type="search" class="' + classes.sFilterInput + '"/>';

	                    var str = language.sSearch;
	                    str = str.match(/_INPUT_/) ?
	                        str.replace('_INPUT_', input) :
	                        str + input;

	                    var filter = $('<div/>', {
	                        'id': !features.f ? tableId + '_filter' : null,
	                        'class': classes.sFilter
	                    })
	                        .append($('<label/>').append(str));

	                    var searchFn = function () {
	                        /* Update all other filter input elements for the new display */
	                        var n = features.f;
	                        var val = !this.value ? "" : this.value; // mental IE8 fix :-(

	                        /* Now do the filter */
	                        if (val != previousSearch.sSearch) {
	                            _fnFilterComplete(settings, {
	                                "sSearch": val,
	                                "bRegex": previousSearch.bRegex,
	                                "bSmart": previousSearch.bSmart,
	                                "bCaseInsensitive": previousSearch.bCaseInsensitive
	                            });

	                            // Need to redraw, without resorting
	                            settings._iDisplayStart = 0;
	                            _fnDraw(settings);
	                        }
	                    };

	                    var searchDelay = settings.searchDelay !== null ?
	                        settings.searchDelay :
	                        _fnDataSource(settings) === 'ssp' ?
	                            400 :
	                            0;

	                    var jqFilter = $('input', filter)
	                        .val(previousSearch.sSearch)
	                        .attr('placeholder', language.sSearchPlaceholder)
	                        .bind(
	                            'keyup.DT search.DT input.DT paste.DT cut.DT',
	                            searchDelay ?
	                                _fnThrottle(searchFn, searchDelay) :
	                                searchFn
	                        )
	                        .bind('keypress.DT', function (e) {
	                            /* Prevent form submission */
	                            if (e.keyCode == 13) {
	                                return false;
	                            }
	                        })
	                        .attr('aria-controls', tableId);

	                    // Update the input elements whenever the table is filtered
	                    $(settings.nTable).on('search.dt.DT', function (ev, s) {
	                        if (settings === s) {
	                            // IE9 throws an 'unknown error' if document.activeElement is used
	                            // inside an iframe or frame...
	                            try {
	                                if (jqFilter[0] !== document.activeElement) {
	                                    jqFilter.val(previousSearch.sSearch);
	                                }
	                            }
	                            catch (e) { }
	                        }
	                    });

	                    return filter[0];
	                }


	                /**
	                 * Filter the table using both the global filter and column based filtering
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {object} oSearch search information
	                 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilterComplete(oSettings, oInput, iForce) {
	                    var oPrevSearch = oSettings.oPreviousSearch;
	                    var aoPrevSearch = oSettings.aoPreSearchCols;
	                    var fnSaveFilter = function (oFilter) {
	                        /* Save the filtering values */
	                        oPrevSearch.sSearch = oFilter.sSearch;
	                        oPrevSearch.bRegex = oFilter.bRegex;
	                        oPrevSearch.bSmart = oFilter.bSmart;
	                        oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
	                    };
	                    var fnRegex = function (o) {
	                        // Backwards compatibility with the bEscapeRegex option
	                        return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;
	                    };

	                    // Resolve any column types that are unknown due to addition or invalidation
	                    // @todo As per sort - can this be moved into an event handler?
	                    _fnColumnTypes(oSettings);

	                    /* In server-side processing all filtering is done by the server, so no point hanging around here */
	                    if (_fnDataSource(oSettings) != 'ssp') {
	                        /* Global filter */
	                        _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
	                        fnSaveFilter(oInput);

	                        /* Now do the individual column filter */
	                        for (var i = 0 ; i < aoPrevSearch.length ; i++) {
	                            _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),
	                                aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
	                        }

	                        /* Custom filtering */
	                        _fnFilterCustom(oSettings);
	                    }
	                    else {
	                        fnSaveFilter(oInput);
	                    }

	                    /* Tell the draw function we have been filtering */
	                    oSettings.bFiltered = true;
	                    _fnCallbackFire(oSettings, null, 'search', [oSettings]);
	                }


	                /**
	                 * Apply custom filtering functions
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilterCustom(settings) {
	                    var filters = DataTable.ext.search;
	                    var displayRows = settings.aiDisplay;
	                    var row, rowIdx;

	                    for (var i = 0, ien = filters.length ; i < ien ; i++) {
	                        var rows = [];

	                        // Loop over each row and see if it should be included
	                        for (var j = 0, jen = displayRows.length ; j < jen ; j++) {
	                            rowIdx = displayRows[j];
	                            row = settings.aoData[rowIdx];

	                            if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {
	                                rows.push(rowIdx);
	                            }
	                        }

	                        // So the array reference doesn't break set the results into the
	                        // existing array
	                        displayRows.length = 0;
	                        displayRows.push.apply(displayRows, rows);
	                    }
	                }


	                /**
	                 * Filter the table on a per-column basis
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {string} sInput string to filter on
	                 *  @param {int} iColumn column to filter
	                 *  @param {bool} bRegex treat search string as a regular expression or not
	                 *  @param {bool} bSmart use smart filtering or not
	                 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
	                    if (searchStr === '') {
	                        return;
	                    }

	                    var data;
	                    var display = settings.aiDisplay;
	                    var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);

	                    for (var i = display.length - 1 ; i >= 0 ; i--) {
	                        data = settings.aoData[display[i]]._aFilterData[colIdx];

	                        if (!rpSearch.test(data)) {
	                            display.splice(i, 1);
	                        }
	                    }
	                }


	                /**
	                 * Filter the data table based on user input and draw the table
	                 *  @param {object} settings dataTables settings object
	                 *  @param {string} input string to filter on
	                 *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)
	                 *  @param {bool} regex treat as a regular expression or not
	                 *  @param {bool} smart perform smart filtering or not
	                 *  @param {bool} caseInsensitive Do case insenstive matching or not
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
	                    var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
	                    var prevSearch = settings.oPreviousSearch.sSearch;
	                    var displayMaster = settings.aiDisplayMaster;
	                    var display, invalidated, i;

	                    // Need to take account of custom filtering functions - always filter
	                    if (DataTable.ext.search.length !== 0) {
	                        force = true;
	                    }

	                    // Check if any of the rows were invalidated
	                    invalidated = _fnFilterData(settings);

	                    // If the input is blank - we just want the full data set
	                    if (input.length <= 0) {
	                        settings.aiDisplay = displayMaster.slice();
	                    }
	                    else {
	                        // New search - start from the master array
	                        if (invalidated ||
	                             force ||
	                             prevSearch.length > input.length ||
	                             input.indexOf(prevSearch) !== 0 ||
	                             settings.bSorted // On resort, the display master needs to be
	                            // re-filtered since indexes will have changed
	                        ) {
	                            settings.aiDisplay = displayMaster.slice();
	                        }

	                        // Search the display array
	                        display = settings.aiDisplay;

	                        for (i = display.length - 1 ; i >= 0 ; i--) {
	                            if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {
	                                display.splice(i, 1);
	                            }
	                        }
	                    }
	                }


	                /**
	                 * Build a regular expression object suitable for searching a table
	                 *  @param {string} sSearch string to search for
	                 *  @param {bool} bRegex treat as a regular expression or not
	                 *  @param {bool} bSmart perform smart filtering or not
	                 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
	                 *  @returns {RegExp} constructed object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
	                    search = regex ?
	                        search :
	                        _fnEscapeRegex(search);

	                    if (smart) {
	                        /* For smart filtering we want to allow the search to work regardless of
	                         * word order. We also want double quoted text to be preserved, so word
	                         * order is important - a la google. So this is what we want to
	                         * generate:
	                         * 
	                         * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
	                         */
	                        var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [''], function (word) {
	                            if (word.charAt(0) === '"') {
	                                var m = word.match(/^"(.*)"$/);
	                                word = m ? m[1] : word;
	                            }

	                            return word.replace('"', '');
	                        });

	                        search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';
	                    }

	                    return new RegExp(search, caseInsensitive ? 'i' : '');
	                }


	                /**
	                 * Escape a string such that it can be used in a regular expression
	                 *  @param {string} sVal string to escape
	                 *  @returns {string} escaped string
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnEscapeRegex(sVal) {
	                    return sVal.replace(_re_escape_regex, '\\$1');
	                }



	                var __filter_div = $('<div>')[0];
	                var __filter_div_textContent = __filter_div.textContent !== undefined;

	                // Update the filtering data for each row if needed (by invalidation or first run)
	                function _fnFilterData(settings) {
	                    var columns = settings.aoColumns;
	                    var column;
	                    var i, j, ien, jen, filterData, cellData, row;
	                    var fomatters = DataTable.ext.type.search;
	                    var wasInvalidated = false;

	                    for (i = 0, ien = settings.aoData.length ; i < ien ; i++) {
	                        row = settings.aoData[i];

	                        if (!row._aFilterData) {
	                            filterData = [];

	                            for (j = 0, jen = columns.length ; j < jen ; j++) {
	                                column = columns[j];

	                                if (column.bSearchable) {
	                                    cellData = _fnGetCellData(settings, i, j, 'filter');

	                                    if (fomatters[column.sType]) {
	                                        cellData = fomatters[column.sType](cellData);
	                                    }

	                                    // Search in DataTables 1.10 is string based. In 1.11 this
	                                    // should be altered to also allow strict type checking.
	                                    if (cellData === null) {
	                                        cellData = '';
	                                    }

	                                    if (typeof cellData !== 'string' && cellData.toString) {
	                                        cellData = cellData.toString();
	                                    }
	                                }
	                                else {
	                                    cellData = '';
	                                }

	                                // If it looks like there is an HTML entity in the string,
	                                // attempt to decode it so sorting works as expected. Note that
	                                // we could use a single line of jQuery to do this, but the DOM
	                                // method used here is much faster http://jsperf.com/html-decode
	                                if (cellData.indexOf && cellData.indexOf('&') !== -1) {
	                                    __filter_div.innerHTML = cellData;
	                                    cellData = __filter_div_textContent ?
	                                        __filter_div.textContent :
	                                        __filter_div.innerText;
	                                }

	                                if (cellData.replace) {
	                                    cellData = cellData.replace(/[\r\n]/g, '');
	                                }

	                                filterData.push(cellData);
	                            }

	                            row._aFilterData = filterData;
	                            row._sFilterRow = filterData.join('  ');
	                            wasInvalidated = true;
	                        }
	                    }

	                    return wasInvalidated;
	                }


	                /**
	                 * Convert from the internal Hungarian notation to camelCase for external
	                 * interaction
	                 *  @param {object} obj Object to convert
	                 *  @returns {object} Inverted object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSearchToCamel(obj) {
	                    return {
	                        search: obj.sSearch,
	                        smart: obj.bSmart,
	                        regex: obj.bRegex,
	                        caseInsensitive: obj.bCaseInsensitive
	                    };
	                }



	                /**
	                 * Convert from camelCase notation to the internal Hungarian. We could use the
	                 * Hungarian convert function here, but this is cleaner
	                 *  @param {object} obj Object to convert
	                 *  @returns {object} Inverted object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSearchToHung(obj) {
	                    return {
	                        sSearch: obj.search,
	                        bSmart: obj.smart,
	                        bRegex: obj.regex,
	                        bCaseInsensitive: obj.caseInsensitive
	                    };
	                }

	                /**
	                 * Generate the node required for the info display
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {node} Information element
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlInfo(settings) {
	                    var
	                        tid = settings.sTableId,
	                        nodes = settings.aanFeatures.i,
	                        n = $('<div/>', {
	                            'class': settings.oClasses.sInfo,
	                            'id': !nodes ? tid + '_info' : null
	                        });

	                    if (!nodes) {
	                        // Update display on each draw
	                        settings.aoDrawCallback.push({
	                            "fn": _fnUpdateInfo,
	                            "sName": "information"
	                        });

	                        n
	                            .attr('role', 'status')
	                            .attr('aria-live', 'polite');

	                        // Table is described by our info div
	                        $(settings.nTable).attr('aria-describedby', tid + '_info');
	                    }

	                    return n[0];
	                }


	                /**
	                 * Update the information elements in the display
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnUpdateInfo(settings) {
	                    /* Show information about the table */
	                    var nodes = settings.aanFeatures.i;
	                    if (nodes.length === 0) {
	                        return;
	                    }

	                    var
	                        lang = settings.oLanguage,
	                        start = settings._iDisplayStart + 1,
	                        end = settings.fnDisplayEnd(),
	                        max = settings.fnRecordsTotal(),
	                        total = settings.fnRecordsDisplay(),
	                        out = total ?
	                            lang.sInfo :
	                            lang.sInfoEmpty;

	                    if (total !== max) {
	                        /* Record set after filtering */
	                        out += ' ' + lang.sInfoFiltered;
	                    }

	                    // Convert the macros
	                    out += lang.sInfoPostFix;
	                    out = _fnInfoMacros(settings, out);

	                    var callback = lang.fnInfoCallback;
	                    if (callback !== null) {
	                        out = callback.call(settings.oInstance,
	                            settings, start, end, max, total, out
	                        );
	                    }

	                    $(nodes).html(out);
	                }


	                function _fnInfoMacros(settings, str) {
	                    // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
	                    // internally
	                    var
	                        formatter = settings.fnFormatNumber,
	                        start = settings._iDisplayStart + 1,
	                        len = settings._iDisplayLength,
	                        vis = settings.fnRecordsDisplay(),
	                        all = len === -1;

	                    return str.
	                        replace(/_START_/g, formatter.call(settings, start)).
	                        replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).
	                        replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).
	                        replace(/_TOTAL_/g, formatter.call(settings, vis)).
	                        replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).
	                        replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
	                }



	                /**
	                 * Draw the table for the first time, adding all required features
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnInitialise(settings) {
	                    var i, iLen, iAjaxStart = settings.iInitDisplayStart;
	                    var columns = settings.aoColumns, column;
	                    var features = settings.oFeatures;

	                    /* Ensure that the table data is fully initialised */
	                    if (!settings.bInitialised) {
	                        setTimeout(function () { _fnInitialise(settings); }, 200);
	                        return;
	                    }

	                    /* Show the display HTML options */
	                    _fnAddOptionsHtml(settings);

	                    /* Build and draw the header / footer for the table */
	                    _fnBuildHead(settings);
	                    _fnDrawHead(settings, settings.aoHeader);
	                    _fnDrawHead(settings, settings.aoFooter);

	                    /* Okay to show that something is going on now */
	                    _fnProcessingDisplay(settings, true);

	                    /* Calculate sizes for columns */
	                    if (features.bAutoWidth) {
	                        _fnCalculateColumnWidths(settings);
	                    }

	                    for (i = 0, iLen = columns.length ; i < iLen ; i++) {
	                        column = columns[i];

	                        if (column.sWidth) {
	                            column.nTh.style.width = _fnStringToCss(column.sWidth);
	                        }
	                    }

	                    // If there is default sorting required - let's do it. The sort function
	                    // will do the drawing for us. Otherwise we draw the table regardless of the
	                    // Ajax source - this allows the table to look initialised for Ajax sourcing
	                    // data (show 'loading' message possibly)
	                    _fnReDraw(settings);

	                    // Server-side processing init complete is done by _fnAjaxUpdateDraw
	                    var dataSrc = _fnDataSource(settings);
	                    if (dataSrc != 'ssp') {
	                        // if there is an ajax source load the data
	                        if (dataSrc == 'ajax') {
	                            _fnBuildAjax(settings, [], function (json) {
	                                var aData = _fnAjaxDataSrc(settings, json);

	                                // Got the data - add it to the table
	                                for (i = 0 ; i < aData.length ; i++) {
	                                    _fnAddData(settings, aData[i]);
	                                }

	                                // Reset the init display for cookie saving. We've already done
	                                // a filter, and therefore cleared it before. So we need to make
	                                // it appear 'fresh'
	                                settings.iInitDisplayStart = iAjaxStart;

	                                _fnReDraw(settings);

	                                _fnProcessingDisplay(settings, false);
	                                _fnInitComplete(settings, json);
	                            }, settings);
	                        }
	                        else {
	                            _fnProcessingDisplay(settings, false);
	                            _fnInitComplete(settings);
	                        }
	                    }
	                }


	                /**
	                 * Draw the table for the first time, adding all required features
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
	                 *    with client-side processing (optional)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnInitComplete(settings, json) {
	                    settings._bInitComplete = true;

	                    // On an Ajax load we now have data and therefore want to apply the column
	                    // sizing
	                    if (json) {
	                        _fnAdjustColumnSizing(settings);
	                    }

	                    _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);
	                }


	                function _fnLengthChange(settings, val) {
	                    var len = parseInt(val, 10);
	                    settings._iDisplayLength = len;

	                    _fnLengthOverflow(settings);

	                    // Fire length change event
	                    _fnCallbackFire(settings, null, 'length', [settings, len]);
	                }


	                /**
	                 * Generate the node required for user display length changing
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {node} Display length feature node
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlLength(settings) {
	                    var
	                        classes = settings.oClasses,
	                        tableId = settings.sTableId,
	                        menu = settings.aLengthMenu,
	                        d2 = $.isArray(menu[0]),
	                        lengths = d2 ? menu[0] : menu,
	                        language = d2 ? menu[1] : menu;

	                    var select = $('<select/>', {
	                        'name': tableId + '_length',
	                        'aria-controls': tableId,
	                        'class': classes.sLengthSelect
	                    });

	                    for (var i = 0, ien = lengths.length ; i < ien ; i++) {
	                        select[0][i] = new Option(language[i], lengths[i]);
	                    }

	                    var div = $('<div><label/></div>').addClass(classes.sLength);
	                    if (!settings.aanFeatures.l) {
	                        div[0].id = tableId + '_length';
	                    }

	                    div.children().append(
	                        settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)
	                    );

	                    // Can't use `select` variable as user might provide their own and the
	                    // reference is broken by the use of outerHTML
	                    $('select', div)
	                        .val(settings._iDisplayLength)
	                        .bind('change.DT', function (e) {
	                            _fnLengthChange(settings, $(this).val());
	                            _fnDraw(settings);
	                        });

	                    // Update node value whenever anything changes the table's length
	                    $(settings.nTable).bind('length.dt.DT', function (e, s, len) {
	                        if (settings === s) {
	                            $('select', div).val(len);
	                        }
	                    });

	                    return div[0];
	                }



	                /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	                 * Note that most of the paging logic is done in
	                 * DataTable.ext.pager
	                 */

	                /**
	                 * Generate the node required for default pagination
	                 *  @param {object} oSettings dataTables settings object
	                 *  @returns {node} Pagination feature node
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlPaginate(settings) {
	                    var
	                        type = settings.sPaginationType,
	                        plugin = DataTable.ext.pager[type],
	                        modern = typeof plugin === 'function',
	                        redraw = function (settings) {
	                            _fnDraw(settings);
	                        },
	                        node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],
	                        features = settings.aanFeatures;

	                    if (!modern) {
	                        plugin.fnInit(settings, node, redraw);
	                    }

	                    /* Add a draw callback for the pagination on first instance, to update the paging display */
	                    if (!features.p) {
	                        node.id = settings.sTableId + '_paginate';

	                        settings.aoDrawCallback.push({
	                            "fn": function (settings) {
	                                if (modern) {
	                                    var
	                                        start = settings._iDisplayStart,
	                                        len = settings._iDisplayLength,
	                                        visRecords = settings.fnRecordsDisplay(),
	                                        all = len === -1,
	                                        page = all ? 0 : Math.ceil(start / len),
	                                        pages = all ? 1 : Math.ceil(visRecords / len),
	                                        buttons = plugin(page, pages),
	                                        i, ien;

	                                    for (i = 0, ien = features.p.length ; i < ien ; i++) {
	                                        _fnRenderer(settings, 'pageButton')(
	                                            settings, features.p[i], i, buttons, page, pages
	                                        );
	                                    }
	                                }
	                                else {
	                                    plugin.fnUpdate(settings, redraw);
	                                }
	                            },
	                            "sName": "pagination"
	                        });
	                    }

	                    return node;
	                }


	                /**
	                 * Alter the display settings to change the page
	                 *  @param {object} settings DataTables settings object
	                 *  @param {string|int} action Paging action to take: "first", "previous",
	                 *    "next" or "last" or page number to jump to (integer)
	                 *  @param [bool] redraw Automatically draw the update or not
	                 *  @returns {bool} true page has changed, false - no change
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnPageChange(settings, action, redraw) {
	                    var
	                        start = settings._iDisplayStart,
	                        len = settings._iDisplayLength,
	                        records = settings.fnRecordsDisplay();

	                    if (records === 0 || len === -1) {
	                        start = 0;
	                    }
	                    else if (typeof action === "number") {
	                        start = action * len;

	                        if (start > records) {
	                            start = 0;
	                        }
	                    }
	                    else if (action == "first") {
	                        start = 0;
	                    }
	                    else if (action == "previous") {
	                        start = len >= 0 ?
	                            start - len :
	                            0;

	                        if (start < 0) {
	                            start = 0;
	                        }
	                    }
	                    else if (action == "next") {
	                        if (start + len < records) {
	                            start += len;
	                        }
	                    }
	                    else if (action == "last") {
	                        start = Math.floor((records - 1) / len) * len;
	                    }
	                    else {
	                        _fnLog(settings, 0, "Unknown paging action: " + action, 5);
	                    }

	                    var changed = settings._iDisplayStart !== start;
	                    settings._iDisplayStart = start;

	                    if (changed) {
	                        _fnCallbackFire(settings, null, 'page', [settings]);

	                        if (redraw) {
	                            _fnDraw(settings);
	                        }
	                    }

	                    return changed;
	                }



	                /**
	                 * Generate the node required for the processing node
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {node} Processing element
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlProcessing(settings) {
	                    return $('<div/>', {
	                        'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,
	                        'class': settings.oClasses.sProcessing
	                    })
	                        .html(settings.oLanguage.sProcessing)
	                        .insertBefore(settings.nTable)[0];
	                }


	                /**
	                 * Display or hide the processing indicator
	                 *  @param {object} settings dataTables settings object
	                 *  @param {bool} show Show the processing indicator (true) or not (false)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnProcessingDisplay(settings, show) {
	                    if (settings.oFeatures.bProcessing) {
	                        $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');
	                    }

	                    _fnCallbackFire(settings, null, 'processing', [settings, show]);
	                }

	                /**
	                 * Add any control elements for the table - specifically scrolling
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {node} Node to add to the DOM
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnFeatureHtmlTable(settings) {
	                    var table = $(settings.nTable);

	                    // Add the ARIA grid role to the table
	                    table.attr('role', 'grid');

	                    // Scrolling from here on in
	                    var scroll = settings.oScroll;

	                    if (scroll.sX === '' && scroll.sY === '') {
	                        return settings.nTable;
	                    }

	                    var scrollX = scroll.sX;
	                    var scrollY = scroll.sY;
	                    var classes = settings.oClasses;
	                    var caption = table.children('caption');
	                    var captionSide = caption.length ? caption[0]._captionSide : null;
	                    var headerClone = $(table[0].cloneNode(false));
	                    var footerClone = $(table[0].cloneNode(false));
	                    var footer = table.children('tfoot');
	                    var _div = '<div/>';
	                    var size = function (s) {
	                        return !s ? null : _fnStringToCss(s);
	                    };

	                    // This is fairly messy, but with x scrolling enabled, if the table has a
	                    // width attribute, regardless of any width applied using the column width
	                    // options, the browser will shrink or grow the table as needed to fit into
	                    // that 100%. That would make the width options useless. So we remove it.
	                    // This is okay, under the assumption that width:100% is applied to the
	                    // table in CSS (it is in the default stylesheet) which will set the table
	                    // width as appropriate (the attribute and css behave differently...)
	                    if (scroll.sX && table.attr('width') === '100%') {
	                        table.removeAttr('width');
	                    }

	                    if (!footer.length) {
	                        footer = null;
	                    }

	                    /*
	                     * The HTML structure that we want to generate in this function is:
	                     *  div - scroller
	                     *    div - scroll head
	                     *      div - scroll head inner
	                     *        table - scroll head table
	                     *          thead - thead
	                     *    div - scroll body
	                     *      table - table (master table)
	                     *        thead - thead clone for sizing
	                     *        tbody - tbody
	                     *    div - scroll foot
	                     *      div - scroll foot inner
	                     *        table - scroll foot table
	                     *          tfoot - tfoot
	                     */
	                    var scroller = $(_div, { 'class': classes.sScrollWrapper })
	                        .append(
	                            $(_div, { 'class': classes.sScrollHead })
	                                .css({
	                                    overflow: 'hidden',
	                                    position: 'relative',
	                                    border: 0,
	                                    width: scrollX ? size(scrollX) : '100%'
	                                })
	                                .append(
	                                    $(_div, { 'class': classes.sScrollHeadInner })
	                                        .css({
	                                            'box-sizing': 'content-box',
	                                            width: scroll.sXInner || '100%'
	                                        })
	                                        .append(
	                                            headerClone
	                                                .removeAttr('id')
	                                                .css('margin-left', 0)
	                                                .append(captionSide === 'top' ? caption : null)
	                                                .append(
	                                                    table.children('thead')
	                                                )
	                                        )
	                                )
	                        )
	                        .append(
	                            $(_div, { 'class': classes.sScrollBody })
	                                .css({
	                                    overflow: 'auto',
	                                    height: size(scrollY),
	                                    width: size(scrollX)
	                                })
	                                .append(table)
	                        );

	                    if (footer) {
	                        scroller.append(
	                            $(_div, { 'class': classes.sScrollFoot })
	                                .css({
	                                    overflow: 'hidden',
	                                    border: 0,
	                                    width: scrollX ? size(scrollX) : '100%'
	                                })
	                                .append(
	                                    $(_div, { 'class': classes.sScrollFootInner })
	                                        .append(
	                                            footerClone
	                                                .removeAttr('id')
	                                                .css('margin-left', 0)
	                                                .append(captionSide === 'bottom' ? caption : null)
	                                                .append(
	                                                    table.children('tfoot')
	                                                )
	                                        )
	                                )
	                        );
	                    }

	                    var children = scroller.children();
	                    var scrollHead = children[0];
	                    var scrollBody = children[1];
	                    var scrollFoot = footer ? children[2] : null;

	                    // When the body is scrolled, then we also want to scroll the headers
	                    if (scrollX) {
	                        $(scrollBody).on('scroll.DT', function (e) {
	                            var scrollLeft = this.scrollLeft;

	                            scrollHead.scrollLeft = scrollLeft;

	                            if (footer) {
	                                scrollFoot.scrollLeft = scrollLeft;
	                            }
	                        });
	                    }

	                    settings.nScrollHead = scrollHead;
	                    settings.nScrollBody = scrollBody;
	                    settings.nScrollFoot = scrollFoot;

	                    // On redraw - align columns
	                    settings.aoDrawCallback.push({
	                        "fn": _fnScrollDraw,
	                        "sName": "scrolling"
	                    });

	                    return scroller[0];
	                }



	                /**
	                 * Update the header, footer and body tables for resizing - i.e. column
	                 * alignment.
	                 *
	                 * Welcome to the most horrible function DataTables. The process that this
	                 * function follows is basically:
	                 *   1. Re-create the table inside the scrolling div
	                 *   2. Take live measurements from the DOM
	                 *   3. Apply the measurements to align the columns
	                 *   4. Clean up
	                 *
	                 *  @param {object} settings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnScrollDraw(settings) {
	                    // Given that this is such a monster function, a lot of variables are use
	                    // to try and keep the minimised size as small as possible
	                    var
	                        scroll = settings.oScroll,
	                        scrollX = scroll.sX,
	                        scrollXInner = scroll.sXInner,
	                        scrollY = scroll.sY,
	                        barWidth = scroll.iBarWidth,
	                        divHeader = $(settings.nScrollHead),
	                        divHeaderStyle = divHeader[0].style,
	                        divHeaderInner = divHeader.children('div'),
	                        divHeaderInnerStyle = divHeaderInner[0].style,
	                        divHeaderTable = divHeaderInner.children('table'),
	                        divBodyEl = settings.nScrollBody,
	                        divBody = $(divBodyEl),
	                        divBodyStyle = divBodyEl.style,
	                        divFooter = $(settings.nScrollFoot),
	                        divFooterInner = divFooter.children('div'),
	                        divFooterTable = divFooterInner.children('table'),
	                        header = $(settings.nTHead),
	                        table = $(settings.nTable),
	                        tableEl = table[0],
	                        tableStyle = tableEl.style,
	                        footer = settings.nTFoot ? $(settings.nTFoot) : null,
	                        browser = settings.oBrowser,
	                        ie67 = browser.bScrollOversize,
	                        headerTrgEls, footerTrgEls,
	                        headerSrcEls, footerSrcEls,
	                        headerCopy, footerCopy,
	                        headerWidths = [], footerWidths = [],
	                        headerContent = [],
	                        idx, correction, sanityWidth,
	                        zeroOut = function (nSizer) {
	                            var style = nSizer.style;
	                            style.paddingTop = "0";
	                            style.paddingBottom = "0";
	                            style.borderTopWidth = "0";
	                            style.borderBottomWidth = "0";
	                            style.height = 0;
	                        };

	                    /*
	                     * 1. Re-create the table inside the scrolling div
	                     */

	                    // Remove the old minimised thead and tfoot elements in the inner table
	                    table.children('thead, tfoot').remove();

	                    // Clone the current header and footer elements and then place it into the inner table
	                    headerCopy = header.clone().prependTo(table);
	                    headerTrgEls = header.find('tr'); // original header is in its own table
	                    headerSrcEls = headerCopy.find('tr');
	                    headerCopy.find('th, td').removeAttr('tabindex');

	                    if (footer) {
	                        footerCopy = footer.clone().prependTo(table);
	                        footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized
	                        footerSrcEls = footerCopy.find('tr');
	                    }


	                    /*
	                     * 2. Take live measurements from the DOM - do not alter the DOM itself!
	                     */

	                    // Remove old sizing and apply the calculated column widths
	                    // Get the unique column headers in the newly created (cloned) header. We want to apply the
	                    // calculated sizes to this header
	                    if (!scrollX) {
	                        divBodyStyle.width = '100%';
	                        divHeader[0].style.width = '100%';
	                    }

	                    $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {
	                        idx = _fnVisibleToColumnIndex(settings, i);
	                        el.style.width = settings.aoColumns[idx].sWidth;
	                    });

	                    if (footer) {
	                        _fnApplyToChildren(function (n) {
	                            n.style.width = "";
	                        }, footerSrcEls);
	                    }

	                    // If scroll collapse is enabled, when we put the headers back into the body for sizing, we
	                    // will end up forcing the scrollbar to appear, making our measurements wrong for when we
	                    // then hide it (end of this function), so add the header height to the body scroller.
	                    if (scroll.bCollapse && scrollY !== "") {
	                        divBodyStyle.height = (divBody[0].offsetHeight + header[0].offsetHeight) + "px";
	                    }

	                    // Size the table as a whole
	                    sanityWidth = table.outerWidth();
	                    if (scrollX === "") {
	                        // No x scrolling
	                        tableStyle.width = "100%";

	                        // IE7 will make the width of the table when 100% include the scrollbar
	                        // - which is shouldn't. When there is a scrollbar we need to take this
	                        // into account.
	                        if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||
	                            divBody.css('overflow-y') == "scroll")
	                        ) {
	                            tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
	                        }
	                    }
	                    else {
	                        // x scrolling
	                        if (scrollXInner !== "") {
	                            // x scroll inner has been given - use it
	                            tableStyle.width = _fnStringToCss(scrollXInner);
	                        }
	                        else if (sanityWidth == divBody.width() && divBody.height() < table.height()) {
	                            // There is y-scrolling - try to take account of the y scroll bar
	                            tableStyle.width = _fnStringToCss(sanityWidth - barWidth);
	                            if (table.outerWidth() > sanityWidth - barWidth) {
	                                // Not possible to take account of it
	                                tableStyle.width = _fnStringToCss(sanityWidth);
	                            }
	                        }
	                        else {
	                            // When all else fails
	                            tableStyle.width = _fnStringToCss(sanityWidth);
	                        }
	                    }

	                    // Recalculate the sanity width - now that we've applied the required width,
	                    // before it was a temporary variable. This is required because the column
	                    // width calculation is done before this table DOM is created.
	                    sanityWidth = table.outerWidth();

	                    // Hidden header should have zero height, so remove padding and borders. Then
	                    // set the width based on the real headers

	                    // Apply all styles in one pass
	                    _fnApplyToChildren(zeroOut, headerSrcEls);

	                    // Read all widths in next pass
	                    _fnApplyToChildren(function (nSizer) {
	                        headerContent.push(nSizer.innerHTML);
	                        headerWidths.push(_fnStringToCss($(nSizer).css('width')));
	                    }, headerSrcEls);

	                    // Apply all widths in final pass
	                    _fnApplyToChildren(function (nToSize, i) {
	                        nToSize.style.width = headerWidths[i];
	                    }, headerTrgEls);

	                    $(headerSrcEls).height(0);

	                    /* Same again with the footer if we have one */
	                    if (footer) {
	                        _fnApplyToChildren(zeroOut, footerSrcEls);

	                        _fnApplyToChildren(function (nSizer) {
	                            footerWidths.push(_fnStringToCss($(nSizer).css('width')));
	                        }, footerSrcEls);

	                        _fnApplyToChildren(function (nToSize, i) {
	                            nToSize.style.width = footerWidths[i];
	                        }, footerTrgEls);

	                        $(footerSrcEls).height(0);
	                    }


	                    /*
	                     * 3. Apply the measurements
	                     */

	                    // "Hide" the header and footer that we used for the sizing. We need to keep
	                    // the content of the cell so that the width applied to the header and body
	                    // both match, but we want to hide it completely. We want to also fix their
	                    // width to what they currently are
	                    _fnApplyToChildren(function (nSizer, i) {
	                        nSizer.innerHTML = '<div class="dataTables_sizing" style="height:0;overflow:hidden;">' + headerContent[i] + '</div>';
	                        nSizer.style.width = headerWidths[i];
	                    }, headerSrcEls);

	                    if (footer) {
	                        _fnApplyToChildren(function (nSizer, i) {
	                            nSizer.innerHTML = "";
	                            nSizer.style.width = footerWidths[i];
	                        }, footerSrcEls);
	                    }

	                    // Sanity check that the table is of a sensible width. If not then we are going to get
	                    // misalignment - try to prevent this by not allowing the table to shrink below its min width
	                    if (table.outerWidth() < sanityWidth) {
	                        // The min width depends upon if we have a vertical scrollbar visible or not */
	                        correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||
	                            divBody.css('overflow-y') == "scroll")) ?
	                                sanityWidth + barWidth :
	                                sanityWidth;

	                        // IE6/7 are a law unto themselves...
	                        if (ie67 && (divBodyEl.scrollHeight >
	                            divBodyEl.offsetHeight || divBody.css('overflow-y') == "scroll")
	                        ) {
	                            tableStyle.width = _fnStringToCss(correction - barWidth);
	                        }

	                        // And give the user a warning that we've stopped the table getting too small
	                        if (scrollX === "" || scrollXInner !== "") {
	                            _fnLog(settings, 1, 'Possible column misalignment', 6);
	                        }
	                    }
	                    else {
	                        correction = '100%';
	                    }

	                    // Apply to the container elements
	                    divBodyStyle.width = _fnStringToCss(correction);
	                    divHeaderStyle.width = _fnStringToCss(correction);

	                    if (footer) {
	                        settings.nScrollFoot.style.width = _fnStringToCss(correction);
	                    }


	                    /*
	                     * 4. Clean up
	                     */
	                    if (!scrollY) {
	                        /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
	                         * the scrollbar height from the visible display, rather than adding it on. We need to
	                         * set the height in order to sort this. Don't want to do it in any other browsers.
	                         */
	                        if (ie67) {
	                            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
	                        }
	                    }

	                    if (scrollY && scroll.bCollapse) {
	                        divBodyStyle.height = _fnStringToCss(scrollY);

	                        var iExtra = (scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth) ?
	                            barWidth :
	                            0;

	                        if (tableEl.offsetHeight < divBodyEl.offsetHeight) {
	                            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + iExtra);
	                        }
	                    }

	                    /* Finally set the width's of the header and footer tables */
	                    var iOuterWidth = table.outerWidth();
	                    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
	                    divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);

	                    // Figure out if there are scrollbar present - if so then we need a the header and footer to
	                    // provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
	                    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
	                    var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');
	                    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";

	                    if (footer) {
	                        divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
	                        divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
	                        divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
	                    }

	                    /* Adjust the position of the header in case we loose the y-scrollbar */
	                    divBody.scroll();

	                    // If sorting or filtering has occurred, jump the scrolling back to the top
	                    // only if we aren't holding the position
	                    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
	                        divBodyEl.scrollTop = 0;
	                    }
	                }



	                /**
	                 * Apply a given function to the display child nodes of an element array (typically
	                 * TD children of TR rows
	                 *  @param {function} fn Method to apply to the objects
	                 *  @param array {nodes} an1 List of elements to look through for display children
	                 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnApplyToChildren(fn, an1, an2) {
	                    var index = 0, i = 0, iLen = an1.length;
	                    var nNode1, nNode2;

	                    while (i < iLen) {
	                        nNode1 = an1[i].firstChild;
	                        nNode2 = an2 ? an2[i].firstChild : null;

	                        while (nNode1) {
	                            if (nNode1.nodeType === 1) {
	                                if (an2) {
	                                    fn(nNode1, nNode2, index);
	                                }
	                                else {
	                                    fn(nNode1, index);
	                                }

	                                index++;
	                            }

	                            nNode1 = nNode1.nextSibling;
	                            nNode2 = an2 ? nNode2.nextSibling : null;
	                        }

	                        i++;
	                    }
	                }



	                var __re_html_remove = /<.*?>/g;


	                /**
	                 * Calculate the width of columns for the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCalculateColumnWidths(oSettings) {
	                    var
	                        table = oSettings.nTable,
	                        columns = oSettings.aoColumns,
	                        scroll = oSettings.oScroll,
	                        scrollY = scroll.sY,
	                        scrollX = scroll.sX,
	                        scrollXInner = scroll.sXInner,
	                        columnCount = columns.length,
	                        visibleColumns = _fnGetColumns(oSettings, 'bVisible'),
	                        headerCells = $('th', oSettings.nTHead),
	                        tableWidthAttr = table.getAttribute('width'), // from DOM element
	                        tableContainer = table.parentNode,
	                        userInputs = false,
	                        i, column, columnIdx, width, outerWidth;

	                    var styleWidth = table.style.width;
	                    if (styleWidth && styleWidth.indexOf('%') !== -1) {
	                        tableWidthAttr = styleWidth;
	                    }

	                    /* Convert any user input sizes into pixel sizes */
	                    for (i = 0 ; i < visibleColumns.length ; i++) {
	                        column = columns[visibleColumns[i]];

	                        if (column.sWidth !== null) {
	                            column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);

	                            userInputs = true;
	                        }
	                    }

	                    /* If the number of columns in the DOM equals the number that we have to
	                     * process in DataTables, then we can use the offsets that are created by
	                     * the web- browser. No custom sizes can be set in order for this to happen,
	                     * nor scrolling used
	                     */
	                    if (!userInputs && !scrollX && !scrollY &&
	                        columnCount == _fnVisbleColumns(oSettings) &&
	                        columnCount == headerCells.length
	                    ) {
	                        for (i = 0 ; i < columnCount ; i++) {
	                            columns[i].sWidth = _fnStringToCss(headerCells.eq(i).width());
	                        }
	                    }
	                    else {
	                        // Otherwise construct a single row, worst case, table with the widest
	                        // node in the data, assign any user defined widths, then insert it into
	                        // the DOM and allow the browser to do all the hard work of calculating
	                        // table widths
	                        var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table
	                            .css('visibility', 'hidden')
	                            .removeAttr('id');

	                        // Clean up the table body
	                        tmpTable.find('tbody tr').remove();
	                        var tr = $('<tr/>').appendTo(tmpTable.find('tbody'));

	                        // Remove any assigned widths from the footer (from scrolling)
	                        tmpTable.find('tfoot th, tfoot td').css('width', '');

	                        // Apply custom sizing to the cloned header
	                        headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);

	                        for (i = 0 ; i < visibleColumns.length ; i++) {
	                            column = columns[visibleColumns[i]];

	                            headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?
	                                _fnStringToCss(column.sWidthOrig) :
	                                '';
	                        }

	                        // Find the widest cell for each column and put it into the table
	                        if (oSettings.aoData.length) {
	                            for (i = 0 ; i < visibleColumns.length ; i++) {
	                                columnIdx = visibleColumns[i];
	                                column = columns[columnIdx];

	                                $(_fnGetWidestNode(oSettings, columnIdx))
	                                    .clone(false)
	                                    .append(column.sContentPadding)
	                                    .appendTo(tr);
	                            }
	                        }

	                        // Table has been built, attach to the document so we can work with it
	                        tmpTable.appendTo(tableContainer);

	                        // When scrolling (X or Y) we want to set the width of the table as 
	                        // appropriate. However, when not scrolling leave the table width as it
	                        // is. This results in slightly different, but I think correct behaviour
	                        if (scrollX && scrollXInner) {
	                            tmpTable.width(scrollXInner);
	                        }
	                        else if (scrollX) {
	                            tmpTable.css('width', 'auto');

	                            if (tmpTable.width() < tableContainer.offsetWidth) {
	                                tmpTable.width(tableContainer.offsetWidth);
	                            }
	                        }
	                        else if (scrollY) {
	                            tmpTable.width(tableContainer.offsetWidth);
	                        }
	                        else if (tableWidthAttr) {
	                            tmpTable.width(tableWidthAttr);
	                        }

	                        // Take into account the y scrollbar
	                        _fnScrollingWidthAdjust(oSettings, tmpTable[0]);

	                        // Browsers need a bit of a hand when a width is assigned to any columns
	                        // when x-scrolling as they tend to collapse the table to the min-width,
	                        // even if we sent the column widths. So we need to keep track of what
	                        // the table width should be by summing the user given values, and the
	                        // automatic values
	                        if (scrollX) {
	                            var total = 0;

	                            for (i = 0 ; i < visibleColumns.length ; i++) {
	                                column = columns[visibleColumns[i]];
	                                outerWidth = $(headerCells[i]).outerWidth();

	                                total += column.sWidthOrig === null ?
	                                    outerWidth :
	                                    parseInt(column.sWidth, 10) + outerWidth - $(headerCells[i]).width();
	                            }

	                            tmpTable.width(_fnStringToCss(total));
	                            table.style.width = _fnStringToCss(total);
	                        }

	                        // Get the width of each column in the constructed table
	                        for (i = 0 ; i < visibleColumns.length ; i++) {
	                            column = columns[visibleColumns[i]];
	                            width = $(headerCells[i]).width();

	                            if (width) {
	                                column.sWidth = _fnStringToCss(width);
	                            }
	                        }

	                        table.style.width = _fnStringToCss(tmpTable.css('width'));

	                        // Finished with the table - ditch it
	                        tmpTable.remove();
	                    }

	                    // If there is a width attr, we want to attach an event listener which
	                    // allows the table sizing to automatically adjust when the window is
	                    // resized. Use the width attr rather than CSS, since we can't know if the
	                    // CSS is a relative value or absolute - DOM read is always px.
	                    if (tableWidthAttr) {
	                        table.style.width = _fnStringToCss(tableWidthAttr);
	                    }

	                    if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
	                        var bindResize = function () {
	                            $(window).bind('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {
	                                _fnAdjustColumnSizing(oSettings);
	                            }));
	                        };

	                        // IE6/7 will crash if we bind a resize event handler on page load.
	                        // To be removed in 1.11 which drops IE6/7 support
	                        if (oSettings.oBrowser.bScrollOversize) {
	                            setTimeout(bindResize, 1000);
	                        }
	                        else {
	                            bindResize();
	                        }

	                        oSettings._reszEvt = true;
	                    }
	                }


	                /**
	                 * Throttle the calls to a function. Arguments and context are maintained for
	                 * the throttled function
	                 *  @param {function} fn Function to be called
	                 *  @param {int} [freq=200] call frequency in mS
	                 *  @returns {function} wrapped function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnThrottle(fn, freq) {
	                    var
	                        frequency = freq !== undefined ? freq : 200,
	                        last,
	                        timer;

	                    return function () {
	                        var
	                            that = this,
	                            now = +new Date(),
	                            args = arguments;

	                        if (last && now < last + frequency) {
	                            clearTimeout(timer);

	                            timer = setTimeout(function () {
	                                last = undefined;
	                                fn.apply(that, args);
	                            }, frequency);
	                        }
	                        else {
	                            last = now;
	                            fn.apply(that, args);
	                        }
	                    };
	                }


	                /**
	                 * Convert a CSS unit width to pixels (e.g. 2em)
	                 *  @param {string} width width to be converted
	                 *  @param {node} parent parent to get the with for (required for relative widths) - optional
	                 *  @returns {int} width in pixels
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnConvertToWidth(width, parent) {
	                    if (!width) {
	                        return 0;
	                    }

	                    var n = $('<div/>')
	                        .css('width', _fnStringToCss(width))
	                        .appendTo(parent || document.body);

	                    var val = n[0].offsetWidth;
	                    n.remove();

	                    return val;
	                }


	                /**
	                 * Adjust a table's width to take account of vertical scroll bar
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {node} n table node
	                 *  @memberof DataTable#oApi
	                 */

	                function _fnScrollingWidthAdjust(settings, n) {
	                    var scroll = settings.oScroll;

	                    if (scroll.sX || scroll.sY) {
	                        // When y-scrolling only, we want to remove the width of the scroll bar
	                        // so the table + scroll bar will fit into the area available, otherwise
	                        // we fix the table at its current size with no adjustment
	                        var correction = !scroll.sX ? scroll.iBarWidth : 0;
	                        n.style.width = _fnStringToCss($(n).outerWidth() - correction);
	                    }
	                }


	                /**
	                 * Get the widest node
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} colIdx column of interest
	                 *  @returns {node} widest table node
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetWidestNode(settings, colIdx) {
	                    var idx = _fnGetMaxLenString(settings, colIdx);
	                    if (idx < 0) {
	                        return null;
	                    }

	                    var data = settings.aoData[idx];
	                    return !data.nTr ? // Might not have been created when deferred rendering
	                        $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] :
	                        data.anCells[colIdx];
	                }


	                /**
	                 * Get the maximum strlen for each data column
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} colIdx column of interest
	                 *  @returns {string} max string length for each column
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnGetMaxLenString(settings, colIdx) {
	                    var s, max = -1, maxIdx = -1;

	                    for (var i = 0, ien = settings.aoData.length ; i < ien ; i++) {
	                        s = _fnGetCellData(settings, i, colIdx, 'display') + '';
	                        s = s.replace(__re_html_remove, '');

	                        if (s.length > max) {
	                            max = s.length;
	                            maxIdx = i;
	                        }
	                    }

	                    return maxIdx;
	                }


	                /**
	                 * Append a CSS unit (only if required) to a string
	                 *  @param {string} value to css-ify
	                 *  @returns {string} value with css unit
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnStringToCss(s) {
	                    if (s === null) {
	                        return '0px';
	                    }

	                    if (typeof s == 'number') {
	                        return s < 0 ?
	                            '0px' :
	                            s + 'px';
	                    }

	                    // Check it has a unit character already
	                    return s.match(/\d$/) ?
	                        s + 'px' :
	                        s;
	                }


	                /**
	                 * Get the width of a scroll bar in this browser being used
	                 *  @returns {int} width in pixels
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnScrollBarWidth() {
	                    // On first run a static variable is set, since this is only needed once.
	                    // Subsequent runs will just use the previously calculated value
	                    var width = DataTable.__scrollbarWidth;

	                    if (width === undefined) {
	                        var sizer = $('<p/>').css({
	                            position: 'absolute',
	                            top: 0,
	                            left: 0,
	                            width: '100%',
	                            height: 150,
	                            padding: 0,
	                            overflow: 'scroll',
	                            visibility: 'hidden'
	                        })
	                            .appendTo('body');

	                        width = sizer[0].offsetWidth - sizer[0].clientWidth;
	                        DataTable.__scrollbarWidth = width;

	                        sizer.remove();
	                    }

	                    return width;
	                }



	                function _fnSortFlatten(settings) {
	                    var
	                        i, iLen, k, kLen,
	                        aSort = [],
	                        aiOrig = [],
	                        aoColumns = settings.aoColumns,
	                        aDataSort, iCol, sType, srcCol,
	                        fixed = settings.aaSortingFixed,
	                        fixedObj = $.isPlainObject(fixed),
	                        nestedSort = [],
	                        add = function (a) {
	                            if (a.length && !$.isArray(a[0])) {
	                                // 1D array
	                                nestedSort.push(a);
	                            }
	                            else {
	                                // 2D array
	                                nestedSort.push.apply(nestedSort, a);
	                            }
	                        };

	                    // Build the sort array, with pre-fix and post-fix options if they have been
	                    // specified
	                    if ($.isArray(fixed)) {
	                        add(fixed);
	                    }

	                    if (fixedObj && fixed.pre) {
	                        add(fixed.pre);
	                    }

	                    add(settings.aaSorting);

	                    if (fixedObj && fixed.post) {
	                        add(fixed.post);
	                    }

	                    for (i = 0 ; i < nestedSort.length ; i++) {
	                        srcCol = nestedSort[i][0];
	                        aDataSort = aoColumns[srcCol].aDataSort;

	                        for (k = 0, kLen = aDataSort.length ; k < kLen ; k++) {
	                            iCol = aDataSort[k];
	                            sType = aoColumns[iCol].sType || 'string';

	                            if (nestedSort[i]._idx === undefined) {
	                                nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);
	                            }

	                            aSort.push({
	                                src: srcCol,
	                                col: iCol,
	                                dir: nestedSort[i][1],
	                                index: nestedSort[i]._idx,
	                                type: sType,
	                                formatter: DataTable.ext.type.order[sType + "-pre"]
	                            });
	                        }
	                    }

	                    return aSort;
	                }

	                /**
	                 * Change the order of the table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 *  @todo This really needs split up!
	                 */
	                function _fnSort(oSettings) {
	                    var
	                        i, ien, iLen, j, jLen, k, kLen,
	                        sDataType, nTh,
	                        aiOrig = [],
	                        oExtSort = DataTable.ext.type.order,
	                        aoData = oSettings.aoData,
	                        aoColumns = oSettings.aoColumns,
	                        aDataSort, data, iCol, sType, oSort,
	                        formatters = 0,
	                        sortCol,
	                        displayMaster = oSettings.aiDisplayMaster,
	                        aSort;

	                    // Resolve any column types that are unknown due to addition or invalidation
	                    // @todo Can this be moved into a 'data-ready' handler which is called when
	                    //   data is going to be used in the table?
	                    _fnColumnTypes(oSettings);

	                    aSort = _fnSortFlatten(oSettings);

	                    for (i = 0, ien = aSort.length ; i < ien ; i++) {
	                        sortCol = aSort[i];

	                        // Track if we can use the fast sort algorithm
	                        if (sortCol.formatter) {
	                            formatters++;
	                        }

	                        // Load the data needed for the sort, for each cell
	                        _fnSortData(oSettings, sortCol.col);
	                    }

	                    /* No sorting required if server-side or no sorting array */
	                    if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {
	                        // Create a value - key array of the current row positions such that we can use their
	                        // current position during the sort, if values match, in order to perform stable sorting
	                        for (i = 0, iLen = displayMaster.length ; i < iLen ; i++) {
	                            aiOrig[displayMaster[i]] = i;
	                        }

	                        /* Do the sort - here we want multi-column sorting based on a given data source (column)
	                         * and sorting function (from oSort) in a certain direction. It's reasonably complex to
	                         * follow on it's own, but this is what we want (example two column sorting):
	                         *  fnLocalSorting = function(a,b){
	                         *    var iTest;
	                         *    iTest = oSort['string-asc']('data11', 'data12');
	                         *      if (iTest !== 0)
	                         *        return iTest;
	                         *    iTest = oSort['numeric-desc']('data21', 'data22');
	                         *    if (iTest !== 0)
	                         *      return iTest;
	                         *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
	                         *  }
	                         * Basically we have a test for each sorting column, if the data in that column is equal,
	                         * test the next column. If all columns match, then we use a numeric sort on the row
	                         * positions in the original data array to provide a stable sort.
	                         *
	                         * Note - I know it seems excessive to have two sorting methods, but the first is around
	                         * 15% faster, so the second is only maintained for backwards compatibility with sorting
	                         * methods which do not have a pre-sort formatting function.
	                         */
	                        if (formatters === aSort.length) {
	                            // All sort types have formatting functions
	                            displayMaster.sort(function (a, b) {
	                                var
	                                    x, y, k, test, sort,
	                                    len = aSort.length,
	                                    dataA = aoData[a]._aSortData,
	                                    dataB = aoData[b]._aSortData;

	                                for (k = 0 ; k < len ; k++) {
	                                    sort = aSort[k];

	                                    x = dataA[sort.col];
	                                    y = dataB[sort.col];

	                                    test = x < y ? -1 : x > y ? 1 : 0;
	                                    if (test !== 0) {
	                                        return sort.dir === 'asc' ? test : -test;
	                                    }
	                                }

	                                x = aiOrig[a];
	                                y = aiOrig[b];
	                                return x < y ? -1 : x > y ? 1 : 0;
	                            });
	                        }
	                        else {
	                            // Depreciated - remove in 1.11 (providing a plug-in option)
	                            // Not all sort types have formatting methods, so we have to call their sorting
	                            // methods.
	                            displayMaster.sort(function (a, b) {
	                                var
	                                    x, y, k, l, test, sort, fn,
	                                    len = aSort.length,
	                                    dataA = aoData[a]._aSortData,
	                                    dataB = aoData[b]._aSortData;

	                                for (k = 0 ; k < len ; k++) {
	                                    sort = aSort[k];

	                                    x = dataA[sort.col];
	                                    y = dataB[sort.col];

	                                    fn = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
	                                    test = fn(x, y);
	                                    if (test !== 0) {
	                                        return test;
	                                    }
	                                }

	                                x = aiOrig[a];
	                                y = aiOrig[b];
	                                return x < y ? -1 : x > y ? 1 : 0;
	                            });
	                        }
	                    }

	                    /* Tell the draw function that we have sorted the data */
	                    oSettings.bSorted = true;
	                }


	                function _fnSortAria(settings) {
	                    var label;
	                    var nextSort;
	                    var columns = settings.aoColumns;
	                    var aSort = _fnSortFlatten(settings);
	                    var oAria = settings.oLanguage.oAria;

	                    // ARIA attributes - need to loop all columns, to update all (removing old
	                    // attributes as needed)
	                    for (var i = 0, iLen = columns.length ; i < iLen ; i++) {
	                        var col = columns[i];
	                        var asSorting = col.asSorting;
	                        var sTitle = col.sTitle.replace(/<.*?>/g, "");
	                        var th = col.nTh;

	                        // IE7 is throwing an error when setting these properties with jQuery's
	                        // attr() and removeAttr() methods...
	                        th.removeAttribute('aria-sort');

	                        /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
	                        if (col.bSortable) {
	                            if (aSort.length > 0 && aSort[0].col == i) {
	                                th.setAttribute('aria-sort', aSort[0].dir == "asc" ? "ascending" : "descending");
	                                nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
	                            }
	                            else {
	                                nextSort = asSorting[0];
	                            }

	                            label = sTitle + (nextSort === "asc" ?
	                                oAria.sSortAscending :
	                                oAria.sSortDescending
	                            );
	                        }
	                        else {
	                            label = sTitle;
	                        }

	                        th.setAttribute('aria-label', label);
	                    }
	                }


	                /**
	                 * Function to run on user sort request
	                 *  @param {object} settings dataTables settings object
	                 *  @param {node} attachTo node to attach the handler to
	                 *  @param {int} colIdx column sorting index
	                 *  @param {boolean} [append=false] Append the requested sort to the existing
	                 *    sort if true (i.e. multi-column sort)
	                 *  @param {function} [callback] callback function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSortListener(settings, colIdx, append, callback) {
	                    var col = settings.aoColumns[colIdx];
	                    var sorting = settings.aaSorting;
	                    var asSorting = col.asSorting;
	                    var nextSortIdx;
	                    var next = function (a, overflow) {
	                        var idx = a._idx;
	                        if (idx === undefined) {
	                            idx = $.inArray(a[1], asSorting);
	                        }

	                        return idx + 1 < asSorting.length ?
	                            idx + 1 :
	                            overflow ?
	                                null :
	                                0;
	                    };

	                    // Convert to 2D array if needed
	                    if (typeof sorting[0] === 'number') {
	                        sorting = settings.aaSorting = [sorting];
	                    }

	                    // If appending the sort then we are multi-column sorting
	                    if (append && settings.oFeatures.bSortMulti) {
	                        // Are we already doing some kind of sort on this column?
	                        var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));

	                        if (sortIdx !== -1) {
	                            // Yes, modify the sort
	                            nextSortIdx = next(sorting[sortIdx], true);

	                            if (nextSortIdx === null && sorting.length === 1) {
	                                nextSortIdx = 0; // can't remove sorting completely
	                            }

	                            if (nextSortIdx === null) {
	                                sorting.splice(sortIdx, 1);
	                            }
	                            else {
	                                sorting[sortIdx][1] = asSorting[nextSortIdx];
	                                sorting[sortIdx]._idx = nextSortIdx;
	                            }
	                        }
	                        else {
	                            // No sort on this column yet
	                            sorting.push([colIdx, asSorting[0], 0]);
	                            sorting[sorting.length - 1]._idx = 0;
	                        }
	                    }
	                    else if (sorting.length && sorting[0][0] == colIdx) {
	                        // Single column - already sorting on this column, modify the sort
	                        nextSortIdx = next(sorting[0]);

	                        sorting.length = 1;
	                        sorting[0][1] = asSorting[nextSortIdx];
	                        sorting[0]._idx = nextSortIdx;
	                    }
	                    else {
	                        // Single column - sort only on this column
	                        sorting.length = 0;
	                        sorting.push([colIdx, asSorting[0]]);
	                        sorting[0]._idx = 0;
	                    }

	                    // Run the sort by calling a full redraw
	                    _fnReDraw(settings);

	                    // callback used for async user interaction
	                    if (typeof callback == 'function') {
	                        callback(settings);
	                    }
	                }


	                /**
	                 * Attach a sort handler (click) to a node
	                 *  @param {object} settings dataTables settings object
	                 *  @param {node} attachTo node to attach the handler to
	                 *  @param {int} colIdx column sorting index
	                 *  @param {function} [callback] callback function
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
	                    var col = settings.aoColumns[colIdx];

	                    _fnBindAction(attachTo, {}, function (e) {
	                        /* If the column is not sortable - don't to anything */
	                        if (col.bSortable === false) {
	                            return;
	                        }

	                        // If processing is enabled use a timeout to allow the processing
	                        // display to be shown - otherwise to it synchronously
	                        if (settings.oFeatures.bProcessing) {
	                            _fnProcessingDisplay(settings, true);

	                            setTimeout(function () {
	                                _fnSortListener(settings, colIdx, e.shiftKey, callback);

	                                // In server-side processing, the draw callback will remove the
	                                // processing display
	                                if (_fnDataSource(settings) !== 'ssp') {
	                                    _fnProcessingDisplay(settings, false);
	                                }
	                            }, 0);
	                        }
	                        else {
	                            _fnSortListener(settings, colIdx, e.shiftKey, callback);
	                        }
	                    });
	                }


	                /**
	                 * Set the sorting classes on table's body, Note: it is safe to call this function
	                 * when bSort and bSortClasses are false
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSortingClasses(settings) {
	                    var oldSort = settings.aLastSort;
	                    var sortClass = settings.oClasses.sSortColumn;
	                    var sort = _fnSortFlatten(settings);
	                    var features = settings.oFeatures;
	                    var i, ien, colIdx;

	                    if (features.bSort && features.bSortClasses) {
	                        // Remove old sorting classes
	                        for (i = 0, ien = oldSort.length ; i < ien ; i++) {
	                            colIdx = oldSort[i].src;

	                            // Remove column sorting
	                            $(_pluck(settings.aoData, 'anCells', colIdx))
	                                .removeClass(sortClass + (i < 2 ? i + 1 : 3));
	                        }

	                        // Add new column sorting
	                        for (i = 0, ien = sort.length ; i < ien ; i++) {
	                            colIdx = sort[i].src;

	                            $(_pluck(settings.aoData, 'anCells', colIdx))
	                                .addClass(sortClass + (i < 2 ? i + 1 : 3));
	                        }
	                    }

	                    settings.aLastSort = sort;
	                }


	                // Get the data to sort a column, be it from cache, fresh (populating the
	                // cache), or from a sort formatter
	                function _fnSortData(settings, idx) {
	                    // Custom sorting function - provided by the sort data type
	                    var column = settings.aoColumns[idx];
	                    var customSort = DataTable.ext.order[column.sSortDataType];
	                    var customData;

	                    if (customSort) {
	                        customData = customSort.call(settings.oInstance, settings, idx,
	                            _fnColumnIndexToVisible(settings, idx)
	                        );
	                    }

	                    // Use / populate cache
	                    var row, cellData;
	                    var formatter = DataTable.ext.type.order[column.sType + "-pre"];

	                    for (var i = 0, ien = settings.aoData.length ; i < ien ; i++) {
	                        row = settings.aoData[i];

	                        if (!row._aSortData) {
	                            row._aSortData = [];
	                        }

	                        if (!row._aSortData[idx] || customSort) {
	                            cellData = customSort ?
	                                customData[i] : // If there was a custom sort function, use data from there
	                                _fnGetCellData(settings, i, idx, 'sort');

	                            row._aSortData[idx] = formatter ?
	                                formatter(cellData) :
	                                cellData;
	                        }
	                    }
	                }



	                /**
	                 * Save the state of a table
	                 *  @param {object} oSettings dataTables settings object
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSaveState(settings) {
	                    if (!settings.oFeatures.bStateSave || settings.bDestroying) {
	                        return;
	                    }

	                    /* Store the interesting variables */
	                    var state = {
	                        time: +new Date(),
	                        start: settings._iDisplayStart,
	                        length: settings._iDisplayLength,
	                        order: $.extend(true, [], settings.aaSorting),
	                        search: _fnSearchToCamel(settings.oPreviousSearch),
	                        columns: $.map(settings.aoColumns, function (col, i) {
	                            return {
	                                visible: col.bVisible,
	                                search: _fnSearchToCamel(settings.aoPreSearchCols[i])
	                            };
	                        })
	                    };

	                    _fnCallbackFire(settings, "aoStateSaveParams", 'stateSaveParams', [settings, state]);

	                    settings.oSavedState = state;
	                    settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
	                }


	                /**
	                 * Attempt to load a saved table state
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {object} oInit DataTables init object so we can override settings
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnLoadState(settings, oInit) {
	                    var i, ien;
	                    var columns = settings.aoColumns;

	                    if (!settings.oFeatures.bStateSave) {
	                        return;
	                    }

	                    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings);
	                    if (!state || !state.time) {
	                        return;
	                    }

	                    /* Allow custom and plug-in manipulation functions to alter the saved data set and
	                     * cancelling of loading by returning false
	                     */
	                    var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state]);
	                    if ($.inArray(false, abStateLoad) !== -1) {
	                        return;
	                    }

	                    /* Reject old data */
	                    var duration = settings.iStateDuration;
	                    if (duration > 0 && state.time < +new Date() - (duration * 1000)) {
	                        return;
	                    }

	                    // Number of columns have changed - all bets are off, no restore of settings
	                    if (columns.length !== state.columns.length) {
	                        return;
	                    }

	                    // Store the saved state so it might be accessed at any time
	                    settings.oLoadedState = $.extend(true, {}, state);

	                    // Restore key features - todo - for 1.11 this needs to be done by
	                    // subscribed events
	                    if (state.start !== undefined) {
	                        settings._iDisplayStart = state.start;
	                        settings.iInitDisplayStart = state.start;
	                    }
	                    if (state.length !== undefined) {
	                        settings._iDisplayLength = state.length;
	                    }

	                    // Order
	                    if (state.order !== undefined) {
	                        settings.aaSorting = [];
	                        $.each(state.order, function (i, col) {
	                            settings.aaSorting.push(col[0] >= columns.length ?
	                                [0, col[1]] :
	                                col
	                            );
	                        });
	                    }

	                    // Search
	                    if (state.search !== undefined) {
	                        $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search));
	                    }

	                    // Columns
	                    for (i = 0, ien = state.columns.length ; i < ien ; i++) {
	                        var col = state.columns[i];

	                        // Visibility
	                        if (col.visible !== undefined) {
	                            columns[i].bVisible = col.visible;
	                        }

	                        // Search
	                        if (col.search !== undefined) {
	                            $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));
	                        }
	                    }

	                    _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, state]);
	                }


	                /**
	                 * Return the settings object for a particular table
	                 *  @param {node} table table we are using as a dataTable
	                 *  @returns {object} Settings object - or null if not found
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnSettingsFromNode(table) {
	                    var settings = DataTable.settings;
	                    var idx = $.inArray(table, _pluck(settings, 'nTable'));

	                    return idx !== -1 ?
	                        settings[idx] :
	                        null;
	                }


	                /**
	                 * Log an error message
	                 *  @param {object} settings dataTables settings object
	                 *  @param {int} level log error messages, or display them to the user
	                 *  @param {string} msg error message
	                 *  @param {int} tn Technical note id to get more information about the error.
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnLog(settings, level, msg, tn) {
	                    msg = 'DataTables warning: ' +
	                        (settings !== null ? 'table id=' + settings.sTableId + ' - ' : '') + msg;

	                    if (tn) {
	                        msg += '. For more information about this error, please see ' +
	                        'http://datatables.net/tn/' + tn;
	                    }

	                    if (!level) {
	                        // Backwards compatibility pre 1.10
	                        var ext = DataTable.ext;
	                        var type = ext.sErrMode || ext.errMode;

	                        _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);

	                        if (type == 'alert') {
	                            alert(msg);
	                        }
	                        else if (type == 'throw') {
	                            throw new Error(msg);
	                        }
	                        else if (typeof type == 'function') {
	                            type(settings, tn, msg);
	                        }
	                    }
	                    else if (window.console && console.log) {
	                        console.log(msg);
	                    }
	                }


	                /**
	                 * See if a property is defined on one object, if so assign it to the other object
	                 *  @param {object} ret target object
	                 *  @param {object} src source object
	                 *  @param {string} name property
	                 *  @param {string} [mappedName] name to map too - optional, name used if not given
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnMap(ret, src, name, mappedName) {
	                    if ($.isArray(name)) {
	                        $.each(name, function (i, val) {
	                            if ($.isArray(val)) {
	                                _fnMap(ret, src, val[0], val[1]);
	                            }
	                            else {
	                                _fnMap(ret, src, val);
	                            }
	                        });

	                        return;
	                    }

	                    if (mappedName === undefined) {
	                        mappedName = name;
	                    }

	                    if (src[name] !== undefined) {
	                        ret[mappedName] = src[name];
	                    }
	                }


	                /**
	                 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
	                 * shallow copy arrays. The reason we need to do this, is that we don't want to
	                 * deep copy array init values (such as aaSorting) since the dev wouldn't be
	                 * able to override them, but we do want to deep copy arrays.
	                 *  @param {object} out Object to extend
	                 *  @param {object} extender Object from which the properties will be applied to
	                 *      out
	                 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
	                 *      independent copy with the exception of the `data` or `aaData` parameters
	                 *      if they are present. This is so you can pass in a collection to
	                 *      DataTables and have that used as your data source without breaking the
	                 *      references
	                 *  @returns {object} out Reference, just for convenience - out === the return.
	                 *  @memberof DataTable#oApi
	                 *  @todo This doesn't take account of arrays inside the deep copied objects.
	                 */
	                function _fnExtend(out, extender, breakRefs) {
	                    var val;

	                    for (var prop in extender) {
	                        if (extender.hasOwnProperty(prop)) {
	                            val = extender[prop];

	                            if ($.isPlainObject(val)) {
	                                if (!$.isPlainObject(out[prop])) {
	                                    out[prop] = {};
	                                }
	                                $.extend(true, out[prop], val);
	                            }
	                            else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {
	                                out[prop] = val.slice();
	                            }
	                            else {
	                                out[prop] = val;
	                            }
	                        }
	                    }

	                    return out;
	                }


	                /**
	                 * Bind an event handers to allow a click or return key to activate the callback.
	                 * This is good for accessibility since a return on the keyboard will have the
	                 * same effect as a click, if the element has focus.
	                 *  @param {element} n Element to bind the action to
	                 *  @param {object} oData Data object to pass to the triggered function
	                 *  @param {function} fn Callback function for when the event is triggered
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnBindAction(n, oData, fn) {
	                    $(n)
	                        .bind('click.DT', oData, function (e) {
	                            n.blur(); // Remove focus outline for mouse users
	                            fn(e);
	                        })
	                        .bind('keypress.DT', oData, function (e) {
	                            if (e.which === 13) {
	                                e.preventDefault();
	                                fn(e);
	                            }
	                        })
	                        .bind('selectstart.DT', function () {
	                            /* Take the brutal approach to cancelling text selection */
	                            return false;
	                        });
	                }


	                /**
	                 * Register a callback function. Easily allows a callback function to be added to
	                 * an array store of callback functions that can then all be called together.
	                 *  @param {object} oSettings dataTables settings object
	                 *  @param {string} sStore Name of the array storage for the callbacks in oSettings
	                 *  @param {function} fn Function to be called back
	                 *  @param {string} sName Identifying name for the callback (i.e. a label)
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCallbackReg(oSettings, sStore, fn, sName) {
	                    if (fn) {
	                        oSettings[sStore].push({
	                            "fn": fn,
	                            "sName": sName
	                        });
	                    }
	                }


	                /**
	                 * Fire callback functions and trigger events. Note that the loop over the
	                 * callback array store is done backwards! Further note that you do not want to
	                 * fire off triggers in time sensitive applications (for example cell creation)
	                 * as its slow.
	                 *  @param {object} settings dataTables settings object
	                 *  @param {string} callbackArr Name of the array storage for the callbacks in
	                 *      oSettings
	                 *  @param {string} eventName Name of the jQuery custom event to trigger. If
	                 *      null no trigger is fired
	                 *  @param {array} args Array of arguments to pass to the callback function /
	                 *      trigger
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnCallbackFire(settings, callbackArr, eventName, args) {
	                    var ret = [];

	                    if (callbackArr) {
	                        ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {
	                            return val.fn.apply(settings.oInstance, args);
	                        });
	                    }

	                    if (eventName !== null) {
	                        var e = $.Event(eventName + '.dt');

	                        $(settings.nTable).trigger(e, args);

	                        ret.push(e.result);
	                    }

	                    return ret;
	                }


	                function _fnLengthOverflow(settings) {
	                    var
	                        start = settings._iDisplayStart,
	                        end = settings.fnDisplayEnd(),
	                        len = settings._iDisplayLength;

	                    /* If we have space to show extra rows (backing up from the end point - then do so */
	                    if (start >= end) {
	                        start = end - len;
	                    }

	                    // Keep the start record on the current page
	                    start -= (start % len);

	                    if (len === -1 || start < 0) {
	                        start = 0;
	                    }

	                    settings._iDisplayStart = start;
	                }


	                function _fnRenderer(settings, type) {
	                    var renderer = settings.renderer;
	                    var host = DataTable.ext.renderer[type];

	                    if ($.isPlainObject(renderer) && renderer[type]) {
	                        // Specific renderer for this type. If available use it, otherwise use
	                        // the default.
	                        return host[renderer[type]] || host._;
	                    }
	                    else if (typeof renderer === 'string') {
	                        // Common renderer - if there is one available for this type use it,
	                        // otherwise use the default
	                        return host[renderer] || host._;
	                    }

	                    // Use the default
	                    return host._;
	                }


	                /**
	                 * Detect the data source being used for the table. Used to simplify the code
	                 * a little (ajax) and to make it compress a little smaller.
	                 *
	                 *  @param {object} settings dataTables settings object
	                 *  @returns {string} Data source
	                 *  @memberof DataTable#oApi
	                 */
	                function _fnDataSource(settings) {
	                    if (settings.oFeatures.bServerSide) {
	                        return 'ssp';
	                    }
	                    else if (settings.ajax || settings.sAjaxSource) {
	                        return 'ajax';
	                    }
	                    return 'dom';
	                }


	                DataTable = function (options) {
	                    /**
	                     * Perform a jQuery selector action on the table's TR elements (from the tbody) and
	                     * return the resulting jQuery object.
	                     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
	                     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
	                     *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
	                     *    criterion ("applied") or all TR elements (i.e. no filter).
	                     *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
	                     *    Can be either 'current', whereby the current sorting of the table is used, or
	                     *    'original' whereby the original order the data was read into the table is used.
	                     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
	                     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
	                     *    'current' and filter is 'applied', regardless of what they might be given as.
	                     *  @returns {object} jQuery object, filtered by the given selector.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Highlight every second row
	                     *      oTable.$('tr:odd').css('backgroundColor', 'blue');
	                     *    } );
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Filter to rows with 'Webkit' in them, add a background colour and then
	                     *      // remove the filter, thus highlighting the 'Webkit' rows only.
	                     *      oTable.fnFilter('Webkit');
	                     *      oTable.$('tr', {"search": "applied"}).css('backgroundColor', 'blue');
	                     *      oTable.fnFilter('');
	                     *    } );
	                     */
	                    this.$ = function (sSelector, oOpts) {
	                        return this.api(true).$(sSelector, oOpts);
	                    };


	                    /**
	                     * Almost identical to $ in operation, but in this case returns the data for the matched
	                     * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
	                     * rather than any descendants, so the data can be obtained for the row/cell. If matching
	                     * rows are found, the data returned is the original data array/object that was used to
	                     * create the row (or a generated array if from a DOM source).
	                     *
	                     * This method is often useful in-combination with $ where both functions are given the
	                     * same parameters and the array indexes will match identically.
	                     *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
	                     *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
	                     *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
	                     *    criterion ("applied") or all elements (i.e. no filter).
	                     *  @param {string} [oOpts.order=current] Order of the data in the processed array.
	                     *    Can be either 'current', whereby the current sorting of the table is used, or
	                     *    'original' whereby the original order the data was read into the table is used.
	                     *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
	                     *    ("current") or not ("all"). If 'current' is given, then order is assumed to be
	                     *    'current' and filter is 'applied', regardless of what they might be given as.
	                     *  @returns {array} Data for the matched elements. If any elements, as a result of the
	                     *    selector, were not TR, TD or TH elements in the DataTable, they will have a null
	                     *    entry in the array.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Get the data from the first row in the table
	                     *      var data = oTable._('tr:first');
	                     *
	                     *      // Do something useful with the data
	                     *      alert( "First cell is: "+data[0] );
	                     *    } );
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Filter to 'Webkit' and get all data for
	                     *      oTable.fnFilter('Webkit');
	                     *      var data = oTable._('tr', {"search": "applied"});
	                     *
	                     *      // Do something with the data
	                     *      alert( data.length+" rows matched the search" );
	                     *    } );
	                     */
	                    this._ = function (sSelector, oOpts) {
	                        return this.api(true).rows(sSelector, oOpts).data();
	                    };


	                    /**
	                     * Create a DataTables Api instance, with the currently selected tables for
	                     * the Api's context.
	                     * @param {boolean} [traditional=false] Set the API instance's context to be
	                     *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was
	                     *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),
	                     *   or if all tables captured in the jQuery object should be used.
	                     * @return {DataTables.Api}
	                     */
	                    this.api = function (traditional) {
	                        return traditional ?
	                            new _Api(
	                                _fnSettingsFromNode(this[_ext.iApiIndex])
	                            ) :
	                            new _Api(this);
	                    };


	                    /**
	                     * Add a single new row or multiple rows of data to the table. Please note
	                     * that this is suitable for client-side processing only - if you are using
	                     * server-side processing (i.e. "bServerSide": true), then to add data, you
	                     * must add it to the data source, i.e. the server-side, through an Ajax call.
	                     *  @param {array|object} data The data to be added to the table. This can be:
	                     *    <ul>
	                     *      <li>1D array of data - add a single row with the data provided</li>
	                     *      <li>2D array of arrays - add multiple rows in a single call</li>
	                     *      <li>object - data object when using <i>mData</i></li>
	                     *      <li>array of objects - multiple data objects when using <i>mData</i></li>
	                     *    </ul>
	                     *  @param {bool} [redraw=true] redraw the table or not
	                     *  @returns {array} An array of integers, representing the list of indexes in
	                     *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to
	                     *    the table.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    // Global var for counter
	                     *    var giCount = 2;
	                     *
	                     *    $(document).ready(function() {
	                     *      $('#example').dataTable();
	                     *    } );
	                     *
	                     *    function fnClickAddRow() {
	                     *      $('#example').dataTable().fnAddData( [
	                     *        giCount+".1",
	                     *        giCount+".2",
	                     *        giCount+".3",
	                     *        giCount+".4" ]
	                     *      );
	                     *
	                     *      giCount++;
	                     *    }
	                     */
	                    this.fnAddData = function (data, redraw) {
	                        var api = this.api(true);

	                        /* Check if we want to add multiple rows or not */
	                        var rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ?
	                            api.rows.add(data) :
	                            api.row.add(data);

	                        if (redraw === undefined || redraw) {
	                            api.draw();
	                        }

	                        return rows.flatten().toArray();
	                    };


	                    /**
	                     * This function will make DataTables recalculate the column sizes, based on the data
	                     * contained in the table and the sizes applied to the columns (in the DOM, CSS or
	                     * through the sWidth parameter). This can be useful when the width of the table's
	                     * parent element changes (for example a window resize).
	                     *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable( {
	                     *        "sScrollY": "200px",
	                     *        "bPaginate": false
	                     *      } );
	                     *
	                     *      $(window).bind('resize', function () {
	                     *        oTable.fnAdjustColumnSizing();
	                     *      } );
	                     *    } );
	                     */
	                    this.fnAdjustColumnSizing = function (bRedraw) {
	                        var api = this.api(true).columns.adjust();
	                        var settings = api.settings()[0];
	                        var scroll = settings.oScroll;

	                        if (bRedraw === undefined || bRedraw) {
	                            api.draw(false);
	                        }
	                        else if (scroll.sX !== "" || scroll.sY !== "") {
	                            /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
	                            _fnScrollDraw(settings);
	                        }
	                    };


	                    /**
	                     * Quickly and simply clear a table
	                     *  @param {bool} [bRedraw=true] redraw the table or not
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
	                     *      oTable.fnClearTable();
	                     *    } );
	                     */
	                    this.fnClearTable = function (bRedraw) {
	                        var api = this.api(true).clear();

	                        if (bRedraw === undefined || bRedraw) {
	                            api.draw();
	                        }
	                    };


	                    /**
	                     * The exact opposite of 'opening' a row, this function will close any rows which
	                     * are currently 'open'.
	                     *  @param {node} nTr the table row to 'close'
	                     *  @returns {int} 0 on success, or 1 if failed (can't find the row)
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable;
	                     *
	                     *      // 'open' an information row when a row is clicked on
	                     *      $('#example tbody tr').click( function () {
	                     *        if ( oTable.fnIsOpen(this) ) {
	                     *          oTable.fnClose( this );
	                     *        } else {
	                     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
	                     *        }
	                     *      } );
	                     *
	                     *      oTable = $('#example').dataTable();
	                     *    } );
	                     */
	                    this.fnClose = function (nTr) {
	                        this.api(true).row(nTr).child.hide();
	                    };


	                    /**
	                     * Remove a row for the table
	                     *  @param {mixed} target The index of the row from aoData to be deleted, or
	                     *    the TR element you want to delete
	                     *  @param {function|null} [callBack] Callback function
	                     *  @param {bool} [redraw=true] Redraw the table or not
	                     *  @returns {array} The row that was deleted
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Immediately remove the first row
	                     *      oTable.fnDeleteRow( 0 );
	                     *    } );
	                     */
	                    this.fnDeleteRow = function (target, callback, redraw) {
	                        var api = this.api(true);
	                        var rows = api.rows(target);
	                        var settings = rows.settings()[0];
	                        var data = settings.aoData[rows[0][0]];

	                        rows.remove();

	                        if (callback) {
	                            callback.call(this, settings, data);
	                        }

	                        if (redraw === undefined || redraw) {
	                            api.draw();
	                        }

	                        return data;
	                    };


	                    /**
	                     * Restore the table to it's original state in the DOM by removing all of DataTables
	                     * enhancements, alterations to the DOM structure of the table and event listeners.
	                     *  @param {boolean} [remove=false] Completely remove the table from the DOM
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
	                     *      var oTable = $('#example').dataTable();
	                     *      oTable.fnDestroy();
	                     *    } );
	                     */
	                    this.fnDestroy = function (remove) {
	                        this.api(true).destroy(remove);
	                    };


	                    /**
	                     * Redraw the table
	                     *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
	                     *      oTable.fnDraw();
	                     *    } );
	                     */
	                    this.fnDraw = function (complete) {
	                        // Note that this isn't an exact match to the old call to _fnDraw - it takes
	                        // into account the new data, but can hold position.
	                        this.api(true).draw(complete);
	                    };


	                    /**
	                     * Filter the input based on data
	                     *  @param {string} sInput String to filter the table on
	                     *  @param {int|null} [iColumn] Column to limit filtering to
	                     *  @param {bool} [bRegex=false] Treat as regular expression or not
	                     *  @param {bool} [bSmart=true] Perform smart filtering or not
	                     *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
	                     *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Sometime later - filter...
	                     *      oTable.fnFilter( 'test string' );
	                     *    } );
	                     */
	                    this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
	                        var api = this.api(true);

	                        if (iColumn === null || iColumn === undefined) {
	                            api.search(sInput, bRegex, bSmart, bCaseInsensitive);
	                        }
	                        else {
	                            api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
	                        }

	                        api.draw();
	                    };


	                    /**
	                     * Get the data for the whole table, an individual row or an individual cell based on the
	                     * provided parameters.
	                     *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as
	                     *    a TR node then the data source for the whole row will be returned. If given as a
	                     *    TD/TH cell node then iCol will be automatically calculated and the data for the
	                     *    cell returned. If given as an integer, then this is treated as the aoData internal
	                     *    data index for the row (see fnGetPosition) and the data for that row used.
	                     *  @param {int} [col] Optional column index that you want the data of.
	                     *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
	                     *    returned. If mRow is defined, just data for that row, and is iCol is
	                     *    defined, only data for the designated cell is returned.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    // Row data
	                     *    $(document).ready(function() {
	                     *      oTable = $('#example').dataTable();
	                     *
	                     *      oTable.$('tr').click( function () {
	                     *        var data = oTable.fnGetData( this );
	                     *        // ... do something with the array / object of data for the row
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Individual cell data
	                     *    $(document).ready(function() {
	                     *      oTable = $('#example').dataTable();
	                     *
	                     *      oTable.$('td').click( function () {
	                     *        var sData = oTable.fnGetData( this );
	                     *        alert( 'The cell clicked on had the value of '+sData );
	                     *      } );
	                     *    } );
	                     */
	                    this.fnGetData = function (src, col) {
	                        var api = this.api(true);

	                        if (src !== undefined) {
	                            var type = src.nodeName ? src.nodeName.toLowerCase() : '';

	                            return col !== undefined || type == 'td' || type == 'th' ?
	                                api.cell(src, col).data() :
	                                api.row(src).data() || null;
	                        }

	                        return api.data().toArray();
	                    };


	                    /**
	                     * Get an array of the TR nodes that are used in the table's body. Note that you will
	                     * typically want to use the '$' API method in preference to this as it is more
	                     * flexible.
	                     *  @param {int} [iRow] Optional row index for the TR element you want
	                     *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
	                     *    in the table's body, or iRow is defined, just the TR element requested.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Get the nodes from the table
	                     *      var nNodes = oTable.fnGetNodes( );
	                     *    } );
	                     */
	                    this.fnGetNodes = function (iRow) {
	                        var api = this.api(true);

	                        return iRow !== undefined ?
	                            api.row(iRow).node() :
	                            api.rows().nodes().flatten().toArray();
	                    };


	                    /**
	                     * Get the array indexes of a particular cell from it's DOM element
	                     * and column index including hidden columns
	                     *  @param {node} node this can either be a TR, TD or TH in the table's body
	                     *  @returns {int} If nNode is given as a TR, then a single index is returned, or
	                     *    if given as a cell, an array of [row index, column index (visible),
	                     *    column index (all)] is given.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      $('#example tbody td').click( function () {
	                     *        // Get the position of the current data from the node
	                     *        var aPos = oTable.fnGetPosition( this );
	                     *
	                     *        // Get the data array for this row
	                     *        var aData = oTable.fnGetData( aPos[0] );
	                     *
	                     *        // Update the data array and return the value
	                     *        aData[ aPos[1] ] = 'clicked';
	                     *        this.innerHTML = 'clicked';
	                     *      } );
	                     *
	                     *      // Init DataTables
	                     *      oTable = $('#example').dataTable();
	                     *    } );
	                     */
	                    this.fnGetPosition = function (node) {
	                        var api = this.api(true);
	                        var nodeName = node.nodeName.toUpperCase();

	                        if (nodeName == 'TR') {
	                            return api.row(node).index();
	                        }
	                        else if (nodeName == 'TD' || nodeName == 'TH') {
	                            var cell = api.cell(node).index();

	                            return [
	                                cell.row,
	                                cell.columnVisible,
	                                cell.column
	                            ];
	                        }
	                        return null;
	                    };


	                    /**
	                     * Check to see if a row is 'open' or not.
	                     *  @param {node} nTr the table row to check
	                     *  @returns {boolean} true if the row is currently open, false otherwise
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable;
	                     *
	                     *      // 'open' an information row when a row is clicked on
	                     *      $('#example tbody tr').click( function () {
	                     *        if ( oTable.fnIsOpen(this) ) {
	                     *          oTable.fnClose( this );
	                     *        } else {
	                     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
	                     *        }
	                     *      } );
	                     *
	                     *      oTable = $('#example').dataTable();
	                     *    } );
	                     */
	                    this.fnIsOpen = function (nTr) {
	                        return this.api(true).row(nTr).child.isShown();
	                    };


	                    /**
	                     * This function will place a new row directly after a row which is currently
	                     * on display on the page, with the HTML contents that is passed into the
	                     * function. This can be used, for example, to ask for confirmation that a
	                     * particular record should be deleted.
	                     *  @param {node} nTr The table row to 'open'
	                     *  @param {string|node|jQuery} mHtml The HTML to put into the row
	                     *  @param {string} sClass Class to give the new TD cell
	                     *  @returns {node} The row opened. Note that if the table row passed in as the
	                     *    first parameter, is not found in the table, this method will silently
	                     *    return.
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable;
	                     *
	                     *      // 'open' an information row when a row is clicked on
	                     *      $('#example tbody tr').click( function () {
	                     *        if ( oTable.fnIsOpen(this) ) {
	                     *          oTable.fnClose( this );
	                     *        } else {
	                     *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
	                     *        }
	                     *      } );
	                     *
	                     *      oTable = $('#example').dataTable();
	                     *    } );
	                     */
	                    this.fnOpen = function (nTr, mHtml, sClass) {
	                        return this.api(true)
	                            .row(nTr)
	                            .child(mHtml, sClass)
	                            .show()
	                            .child()[0];
	                    };


	                    /**
	                     * Change the pagination - provides the internal logic for pagination in a simple API
	                     * function. With this function you can have a DataTables table go to the next,
	                     * previous, first or last pages.
	                     *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
	                     *    or page number to jump to (integer), note that page 0 is the first page.
	                     *  @param {bool} [bRedraw=true] Redraw the table or not
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *      oTable.fnPageChange( 'next' );
	                     *    } );
	                     */
	                    this.fnPageChange = function (mAction, bRedraw) {
	                        var api = this.api(true).page(mAction);

	                        if (bRedraw === undefined || bRedraw) {
	                            api.draw(false);
	                        }
	                    };


	                    /**
	                     * Show a particular column
	                     *  @param {int} iCol The column whose display should be changed
	                     *  @param {bool} bShow Show (true) or hide (false) the column
	                     *  @param {bool} [bRedraw=true] Redraw the table or not
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Hide the second column after initialisation
	                     *      oTable.fnSetColumnVis( 1, false );
	                     *    } );
	                     */
	                    this.fnSetColumnVis = function (iCol, bShow, bRedraw) {
	                        var api = this.api(true).column(iCol).visible(bShow);

	                        if (bRedraw === undefined || bRedraw) {
	                            api.columns.adjust().draw();
	                        }
	                    };


	                    /**
	                     * Get the settings for a particular table for external manipulation
	                     *  @returns {object} DataTables settings object. See
	                     *    {@link DataTable.models.oSettings}
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *      var oSettings = oTable.fnSettings();
	                     *
	                     *      // Show an example parameter from the settings
	                     *      alert( oSettings._iDisplayStart );
	                     *    } );
	                     */
	                    this.fnSettings = function () {
	                        return _fnSettingsFromNode(this[_ext.iApiIndex]);
	                    };


	                    /**
	                     * Sort the table by a particular column
	                     *  @param {int} iCol the data index to sort on. Note that this will not match the
	                     *    'display index' if you have hidden data entries
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Sort immediately with columns 0 and 1
	                     *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
	                     *    } );
	                     */
	                    this.fnSort = function (aaSort) {
	                        this.api(true).order(aaSort).draw();
	                    };


	                    /**
	                     * Attach a sort listener to an element for a given column
	                     *  @param {node} nNode the element to attach the sort listener to
	                     *  @param {int} iColumn the column that a click on this node will sort on
	                     *  @param {function} [fnCallback] callback function when sort is run
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *
	                     *      // Sort on column 1, when 'sorter' is clicked on
	                     *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
	                     *    } );
	                     */
	                    this.fnSortListener = function (nNode, iColumn, fnCallback) {
	                        this.api(true).order.listener(nNode, iColumn, fnCallback);
	                    };


	                    /**
	                     * Update a table cell or row - this method will accept either a single value to
	                     * update the cell with, an array of values with one element for each column or
	                     * an object in the same format as the original data source. The function is
	                     * self-referencing in order to make the multi column updates easier.
	                     *  @param {object|array|string} mData Data to update the cell/row with
	                     *  @param {node|int} mRow TR element you want to update or the aoData index
	                     *  @param {int} [iColumn] The column to update, give as null or undefined to
	                     *    update a whole row.
	                     *  @param {bool} [bRedraw=true] Redraw the table or not
	                     *  @param {bool} [bAction=true] Perform pre-draw actions or not
	                     *  @returns {int} 0 on success, 1 on error
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
	                     *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row
	                     *    } );
	                     */
	                    this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {
	                        var api = this.api(true);

	                        if (iColumn === undefined || iColumn === null) {
	                            api.row(mRow).data(mData);
	                        }
	                        else {
	                            api.cell(mRow, iColumn).data(mData);
	                        }

	                        if (bAction === undefined || bAction) {
	                            api.columns.adjust();
	                        }

	                        if (bRedraw === undefined || bRedraw) {
	                            api.draw();
	                        }
	                        return 0;
	                    };


	                    /**
	                     * Provide a common method for plug-ins to check the version of DataTables being used, in order
	                     * to ensure compatibility.
	                     *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
	                     *    formats "X" and "X.Y" are also acceptable.
	                     *  @returns {boolean} true if this version of DataTables is greater or equal to the required
	                     *    version, or false if this version of DataTales is not suitable
	                     *  @method
	                     *  @dtopt API
	                     *  @deprecated Since v1.10
	                     *
	                     *  @example
	                     *    $(document).ready(function() {
	                     *      var oTable = $('#example').dataTable();
	                     *      alert( oTable.fnVersionCheck( '1.9.0' ) );
	                     *    } );
	                     */
	                    this.fnVersionCheck = _ext.fnVersionCheck;


	                    var _that = this;
	                    var emptyInit = options === undefined;
	                    var len = this.length;

	                    if (emptyInit) {
	                        options = {};
	                    }

	                    this.oApi = this.internal = _ext.internal;

	                    // Extend with old style plug-in API methods
	                    for (var fn in DataTable.ext.internal) {
	                        if (fn) {
	                            this[fn] = _fnExternApiFunc(fn);
	                        }
	                    }

	                    this.each(function () {
	                        // For each initialisation we want to give it a clean initialisation
	                        // object that can be bashed around
	                        var o = {};
	                        var oInit = len > 1 ? // optimisation for single table case
	                            _fnExtend(o, options, true) :
	                            options;

	                        /*global oInit,_that,emptyInit*/
	                        var i = 0, iLen, j, jLen, k, kLen;
	                        var sId = this.getAttribute('id');
	                        var bInitHandedOff = false;
	                        var defaults = DataTable.defaults;
	                        var $this = $(this);


	                        /* Sanity check */
	                        if (this.nodeName.toLowerCase() != 'table') {
	                            _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);
	                            return;
	                        }

	                        /* Backwards compatibility for the defaults */
	                        _fnCompatOpts(defaults);
	                        _fnCompatCols(defaults.column);

	                        /* Convert the camel-case defaults to Hungarian */
	                        _fnCamelToHungarian(defaults, defaults, true);
	                        _fnCamelToHungarian(defaults.column, defaults.column, true);

	                        /* Setting up the initialisation object */
	                        _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));



	                        /* Check to see if we are re-initialising a table */
	                        var allSettings = DataTable.settings;
	                        for (i = 0, iLen = allSettings.length ; i < iLen ; i++) {
	                            var s = allSettings[i];

	                            /* Base check on table node */
	                            if (s.nTable == this || s.nTHead.parentNode == this || (s.nTFoot && s.nTFoot.parentNode == this)) {
	                                var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
	                                var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;

	                                if (emptyInit || bRetrieve) {
	                                    return s.oInstance;
	                                }
	                                else if (bDestroy) {
	                                    s.oInstance.fnDestroy();
	                                    break;
	                                }
	                                else {
	                                    _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);
	                                    return;
	                                }
	                            }

	                            /* If the element we are initialising has the same ID as a table which was previously
	                             * initialised, but the table nodes don't match (from before) then we destroy the old
	                             * instance by simply deleting it. This is under the assumption that the table has been
	                             * destroyed by other methods. Anyone using non-id selectors will need to do this manually
	                             */
	                            if (s.sTableId == this.id) {
	                                allSettings.splice(i, 1);
	                                break;
	                            }
	                        }

	                        /* Ensure the table has an ID - required for accessibility */
	                        if (sId === null || sId === "") {
	                            sId = "DataTables_Table_" + (DataTable.ext._unique++);
	                            this.id = sId;
	                        }

	                        /* Create the settings object for this table and set some of the default parameters */
	                        var oSettings = $.extend(true, {}, DataTable.models.oSettings, {
	                            "sDestroyWidth": $this[0].style.width,
	                            "sInstance": sId,
	                            "sTableId": sId
	                        });
	                        oSettings.nTable = this;
	                        oSettings.oApi = _that.internal;
	                        oSettings.oInit = oInit;

	                        allSettings.push(oSettings);

	                        // Need to add the instance after the instance after the settings object has been added
	                        // to the settings array, so we can self reference the table instance if more than one
	                        oSettings.oInstance = (_that.length === 1) ? _that : $this.dataTable();

	                        // Backwards compatibility, before we apply all the defaults
	                        _fnCompatOpts(oInit);

	                        if (oInit.oLanguage) {
	                            _fnLanguageCompat(oInit.oLanguage);
	                        }

	                        // If the length menu is given, but the init display length is not, use the length menu
	                        if (oInit.aLengthMenu && !oInit.iDisplayLength) {
	                            oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ?
	                                oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
	                        }

	                        // Apply the defaults and init options to make a single init object will all
	                        // options defined from defaults and instance options.
	                        oInit = _fnExtend($.extend(true, {}, defaults), oInit);


	                        // Map the initialisation options onto the settings object
	                        _fnMap(oSettings.oFeatures, oInit, [
	                            "bPaginate",
	                            "bLengthChange",
	                            "bFilter",
	                            "bSort",
	                            "bSortMulti",
	                            "bInfo",
	                            "bProcessing",
	                            "bAutoWidth",
	                            "bSortClasses",
	                            "bServerSide",
	                            "bDeferRender"
	                        ]);
	                        _fnMap(oSettings, oInit, [
	                            "asStripeClasses",
	                            "ajax",
	                            "fnServerData",
	                            "fnFormatNumber",
	                            "sServerMethod",
	                            "aaSorting",
	                            "aaSortingFixed",
	                            "aLengthMenu",
	                            "sPaginationType",
	                            "sAjaxSource",
	                            "sAjaxDataProp",
	                            "iStateDuration",
	                            "sDom",
	                            "bSortCellsTop",
	                            "iTabIndex",
	                            "fnStateLoadCallback",
	                            "fnStateSaveCallback",
	                            "renderer",
	                            "searchDelay",
	                            ["iCookieDuration", "iStateDuration"], // backwards compat
	                            ["oSearch", "oPreviousSearch"],
	                            ["aoSearchCols", "aoPreSearchCols"],
	                            ["iDisplayLength", "_iDisplayLength"],
	                            ["bJQueryUI", "bJUI"]
	                        ]);
	                        _fnMap(oSettings.oScroll, oInit, [
	                            ["sScrollX", "sX"],
	                            ["sScrollXInner", "sXInner"],
	                            ["sScrollY", "sY"],
	                            ["bScrollCollapse", "bCollapse"]
	                        ]);
	                        _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");

	                        /* Callback functions which are array driven */
	                        _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');
	                        _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');
	                        _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');
	                        _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');
	                        _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');
	                        _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');
	                        _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');
	                        _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');
	                        _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');
	                        _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');
	                        _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');

	                        var oClasses = oSettings.oClasses;

	                        // @todo Remove in 1.11
	                        if (oInit.bJQueryUI) {
	                            /* Use the JUI classes object for display. You could clone the oStdClasses object if
	                             * you want to have multiple tables with multiple independent classes
	                             */
	                            $.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses);

	                            if (oInit.sDom === defaults.sDom && defaults.sDom === "lfrtip") {
	                                /* Set the DOM to use a layout suitable for jQuery UI's theming */
	                                oSettings.sDom = '<"H"lfr>t<"F"ip>';
	                            }

	                            if (!oSettings.renderer) {
	                                oSettings.renderer = 'jqueryui';
	                            }
	                            else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {
	                                oSettings.renderer.header = 'jqueryui';
	                            }
	                        }
	                        else {
	                            $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
	                        }
	                        $this.addClass(oClasses.sTable);

	                        /* Calculate the scroll bar width and cache it for use later on */
	                        if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
	                            oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
	                        }
	                        if (oSettings.oScroll.sX === true) { // Easy initialisation of x-scrolling
	                            oSettings.oScroll.sX = '100%';
	                        }

	                        if (oSettings.iInitDisplayStart === undefined) {
	                            /* Display start point, taking into account the save saving */
	                            oSettings.iInitDisplayStart = oInit.iDisplayStart;
	                            oSettings._iDisplayStart = oInit.iDisplayStart;
	                        }

	                        if (oInit.iDeferLoading !== null) {
	                            oSettings.bDeferLoading = true;
	                            var tmp = $.isArray(oInit.iDeferLoading);
	                            oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
	                            oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
	                        }

	                        /* Language definitions */
	                        var oLanguage = oSettings.oLanguage;
	                        $.extend(true, oLanguage, oInit.oLanguage);

	                        if (oLanguage.sUrl !== "") {
	                            /* Get the language definitions from a file - because this Ajax call makes the language
	                             * get async to the remainder of this function we use bInitHandedOff to indicate that
	                             * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
	                             */
	                            $.ajax({
	                                dataType: 'json',
	                                url: oLanguage.sUrl,
	                                success: function (json) {
	                                    _fnLanguageCompat(json);
	                                    _fnCamelToHungarian(defaults.oLanguage, json);
	                                    $.extend(true, oLanguage, json);
	                                    _fnInitialise(oSettings);
	                                },
	                                error: function () {
	                                    // Error occurred loading language file, continue on as best we can
	                                    _fnInitialise(oSettings);
	                                }
	                            });
	                            bInitHandedOff = true;
	                        }

	                        /*
	                         * Stripes
	                         */
	                        if (oInit.asStripeClasses === null) {
	                            oSettings.asStripeClasses = [
	                                oClasses.sStripeOdd,
	                                oClasses.sStripeEven
	                            ];
	                        }

	                        /* Remove row stripe classes if they are already on the table row */
	                        var stripeClasses = oSettings.asStripeClasses;
	                        var rowOne = $this.children('tbody').find('tr').eq(0);
	                        if ($.inArray(true, $.map(stripeClasses, function (el, i) {
	                            return rowOne.hasClass(el);
	                        })) !== -1) {
	                            $('tbody tr', this).removeClass(stripeClasses.join(' '));
	                            oSettings.asDestroyStripes = stripeClasses.slice();
	                        }

	                        /*
	                         * Columns
	                         * See if we should load columns automatically or use defined ones
	                         */
	                        var anThs = [];
	                        var aoColumnsInit;
	                        var nThead = this.getElementsByTagName('thead');
	                        if (nThead.length !== 0) {
	                            _fnDetectHeader(oSettings.aoHeader, nThead[0]);
	                            anThs = _fnGetUniqueThs(oSettings);
	                        }

	                        /* If not given a column array, generate one with nulls */
	                        if (oInit.aoColumns === null) {
	                            aoColumnsInit = [];
	                            for (i = 0, iLen = anThs.length ; i < iLen ; i++) {
	                                aoColumnsInit.push(null);
	                            }
	                        }
	                        else {
	                            aoColumnsInit = oInit.aoColumns;
	                        }

	                        /* Add the columns */
	                        for (i = 0, iLen = aoColumnsInit.length ; i < iLen ; i++) {
	                            _fnAddColumn(oSettings, anThs ? anThs[i] : null);
	                        }

	                        /* Apply the column definitions */
	                        _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
	                            _fnColumnOptions(oSettings, iCol, oDef);
	                        });

	                        /* HTML5 attribute detection - build an mData object automatically if the
	                         * attributes are found
	                         */
	                        if (rowOne.length) {
	                            var a = function (cell, name) {
	                                return cell.getAttribute('data-' + name) !== null ? name : null;
	                            };

	                            $.each(_fnGetRowElements(oSettings, rowOne[0]).cells, function (i, cell) {
	                                var col = oSettings.aoColumns[i];

	                                if (col.mData === i) {
	                                    var sort = a(cell, 'sort') || a(cell, 'order');
	                                    var filter = a(cell, 'filter') || a(cell, 'search');

	                                    if (sort !== null || filter !== null) {
	                                        col.mData = {
	                                            _: i + '.display',
	                                            sort: sort !== null ? i + '.@data-' + sort : undefined,
	                                            type: sort !== null ? i + '.@data-' + sort : undefined,
	                                            filter: filter !== null ? i + '.@data-' + filter : undefined
	                                        };

	                                        _fnColumnOptions(oSettings, i);
	                                    }
	                                }
	                            });
	                        }

	                        var features = oSettings.oFeatures;

	                        /* Must be done after everything which can be overridden by the state saving! */
	                        if (oInit.bStateSave) {
	                            features.bStateSave = true;
	                            _fnLoadState(oSettings, oInit);
	                            _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');
	                        }


	                        /*
	                         * Sorting
	                         * @todo For modularisation (1.11) this needs to do into a sort start up handler
	                         */

	                        // If aaSorting is not defined, then we use the first indicator in asSorting
	                        // in case that has been altered, so the default sort reflects that option
	                        if (oInit.aaSorting === undefined) {
	                            var sorting = oSettings.aaSorting;
	                            for (i = 0, iLen = sorting.length ; i < iLen ; i++) {
	                                sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
	                            }
	                        }

	                        /* Do a first pass on the sorting classes (allows any size changes to be taken into
	                         * account, and also will apply sorting disabled classes if disabled
	                         */
	                        _fnSortingClasses(oSettings);

	                        if (features.bSort) {
	                            _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
	                                if (oSettings.bSorted) {
	                                    var aSort = _fnSortFlatten(oSettings);
	                                    var sortedColumns = {};

	                                    $.each(aSort, function (i, val) {
	                                        sortedColumns[val.src] = val.dir;
	                                    });

	                                    _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);
	                                    _fnSortAria(oSettings);
	                                }
	                            });
	                        }

	                        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {
	                            if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {
	                                _fnSortingClasses(oSettings);
	                            }
	                        }, 'sc');


	                        /*
	                         * Final init
	                         * Cache the header, body and footer as required, creating them if needed
	                         */

	                        /* Browser support detection */
	                        _fnBrowserDetect(oSettings);

	                        // Work around for Webkit bug 83867 - store the caption-side before removing from doc
	                        var captions = $this.children('caption').each(function () {
	                            this._captionSide = $this.css('caption-side');
	                        });

	                        var thead = $this.children('thead');
	                        if (thead.length === 0) {
	                            thead = $('<thead/>').appendTo(this);
	                        }
	                        oSettings.nTHead = thead[0];

	                        var tbody = $this.children('tbody');
	                        if (tbody.length === 0) {
	                            tbody = $('<tbody/>').appendTo(this);
	                        }
	                        oSettings.nTBody = tbody[0];

	                        var tfoot = $this.children('tfoot');
	                        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
	                            // If we are a scrolling table, and no footer has been given, then we need to create
	                            // a tfoot element for the caption element to be appended to
	                            tfoot = $('<tfoot/>').appendTo(this);
	                        }

	                        if (tfoot.length === 0 || tfoot.children().length === 0) {
	                            $this.addClass(oClasses.sNoFooter);
	                        }
	                        else if (tfoot.length > 0) {
	                            oSettings.nTFoot = tfoot[0];
	                            _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
	                        }

	                        /* Check if there is data passing into the constructor */
	                        if (oInit.aaData) {
	                            for (i = 0 ; i < oInit.aaData.length ; i++) {
	                                _fnAddData(oSettings, oInit.aaData[i]);
	                            }
	                        }
	                        else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {
	                            /* Grab the data from the page - only do this when deferred loading or no Ajax
	                             * source since there is no point in reading the DOM data if we are then going
	                             * to replace it with Ajax data
	                             */
	                            _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));
	                        }

	                        /* Copy the data index array */
	                        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();

	                        /* Initialisation complete - table can be drawn */
	                        oSettings.bInitialised = true;

	                        /* Check if we need to initialise the table (it might not have been handed off to the
	                         * language processor)
	                         */
	                        if (bInitHandedOff === false) {
	                            _fnInitialise(oSettings);
	                        }
	                    });
	                    _that = null;
	                    return this;
	                };



	                /**
	                 * Computed structure of the DataTables API, defined by the options passed to
	                 * `DataTable.Api.register()` when building the API.
	                 *
	                 * The structure is built in order to speed creation and extension of the Api
	                 * objects since the extensions are effectively pre-parsed.
	                 *
	                 * The array is an array of objects with the following structure, where this
	                 * base array represents the Api prototype base:
	                 *
	                 *     [
	                 *       {
	                 *         name:      'data'                -- string   - Property name
	                 *         val:       function () {},       -- function - Api method (or undefined if just an object
	                 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	                 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	                 *       },
	                 *       {
	                 *         name:     'row'
	                 *         val:       {},
	                 *         methodExt: [ ... ],
	                 *         propExt:   [
	                 *           {
	                 *             name:      'data'
	                 *             val:       function () {},
	                 *             methodExt: [ ... ],
	                 *             propExt:   [ ... ]
	                 *           },
	                 *           ...
	                 *         ]
	                 *       }
	                 *     ]
	                 *
	                 * @type {Array}
	                 * @ignore
	                 */
	                var __apiStruct = [];


	                /**
	                 * `Array.prototype` reference.
	                 *
	                 * @type object
	                 * @ignore
	                 */
	                var __arrayProto = Array.prototype;


	                /**
	                 * Abstraction for `context` parameter of the `Api` constructor to allow it to
	                 * take several different forms for ease of use.
	                 *
	                 * Each of the input parameter types will be converted to a DataTables settings
	                 * object where possible.
	                 *
	                 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
	                 *   of:
	                 *
	                 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	                 *     with be found and used.
	                 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	                 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	                 *   * `object` - DataTables settings object
	                 *   * `DataTables.Api` - API instance
	                 * @return {array|null} Matching DataTables settings objects. `null` or
	                 *   `undefined` is returned if no matching DataTable is found.
	                 * @ignore
	                 */
	                var _toSettings = function (mixed) {
	                    var idx, jq;
	                    var settings = DataTable.settings;
	                    var tables = $.map(settings, function (el, i) {
	                        return el.nTable;
	                    });

	                    if (!mixed) {
	                        return [];
	                    }
	                    else if (mixed.nTable && mixed.oApi) {
	                        // DataTables settings object
	                        return [mixed];
	                    }
	                    else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {
	                        // Table node
	                        idx = $.inArray(mixed, tables);
	                        return idx !== -1 ? [settings[idx]] : null;
	                    }
	                    else if (mixed && typeof mixed.settings === 'function') {
	                        return mixed.settings().toArray();
	                    }
	                    else if (typeof mixed === 'string') {
	                        // jQuery selector
	                        jq = $(mixed);
	                    }
	                    else if (mixed instanceof $) {
	                        // jQuery object (also DataTables instance)
	                        jq = mixed;
	                    }

	                    if (jq) {
	                        return jq.map(function (i) {
	                            idx = $.inArray(this, tables);
	                            return idx !== -1 ? settings[idx] : null;
	                        }).toArray();
	                    }
	                };


	                /**
	                 * DataTables API class - used to control and interface with  one or more
	                 * DataTables enhanced tables.
	                 *
	                 * The API class is heavily based on jQuery, presenting a chainable interface
	                 * that you can use to interact with tables. Each instance of the API class has
	                 * a "context" - i.e. the tables that it will operate on. This could be a single
	                 * table, all tables on a page or a sub-set thereof.
	                 *
	                 * Additionally the API is designed to allow you to easily work with the data in
	                 * the tables, retrieving and manipulating it as required. This is done by
	                 * presenting the API class as an array like interface. The contents of the
	                 * array depend upon the actions requested by each method (for example
	                 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
	                 * return an array of objects or arrays depending upon your table's
	                 * configuration). The API object has a number of array like methods (`push`,
	                 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
	                 * `unique` etc) to assist your working with the data held in a table.
	                 *
	                 * Most methods (those which return an Api instance) are chainable, which means
	                 * the return from a method call also has all of the methods available that the
	                 * top level object had. For example, these two calls are equivalent:
	                 *
	                 *     // Not chained
	                 *     api.row.add( {...} );
	                 *     api.draw();
	                 *
	                 *     // Chained
	                 *     api.row.add( {...} ).draw();
	                 *
	                 * @class DataTable.Api
	                 * @param {array|object|string|jQuery} context DataTable identifier. This is
	                 *   used to define which DataTables enhanced tables this API will operate on.
	                 *   Can be one of:
	                 *
	                 *   * `string` - jQuery selector. Any DataTables' matching the given selector
	                 *     with be found and used.
	                 *   * `node` - `TABLE` node which has already been formed into a DataTable.
	                 *   * `jQuery` - A jQuery object of `TABLE` nodes.
	                 *   * `object` - DataTables settings object
	                 * @param {array} [data] Data to initialise the Api instance with.
	                 *
	                 * @example
	                 *   // Direct initialisation during DataTables construction
	                 *   var api = $('#example').DataTable();
	                 *
	                 * @example
	                 *   // Initialisation using a DataTables jQuery object
	                 *   var api = $('#example').dataTable().api();
	                 *
	                 * @example
	                 *   // Initialisation as a constructor
	                 *   var api = new $.fn.DataTable.Api( 'table.dataTable' );
	                 */
	                _Api = function (context, data) {
	                    if (!(this instanceof _Api)) {
	                        return new _Api(context, data);
	                    }

	                    var settings = [];
	                    var ctxSettings = function (o) {
	                        var a = _toSettings(o);
	                        if (a) {
	                            settings.push.apply(settings, a);
	                        }
	                    };

	                    if ($.isArray(context)) {
	                        for (var i = 0, ien = context.length ; i < ien ; i++) {
	                            ctxSettings(context[i]);
	                        }
	                    }
	                    else {
	                        ctxSettings(context);
	                    }

	                    // Remove duplicates
	                    this.context = _unique(settings);

	                    // Initial data
	                    if (data) {
	                        this.push.apply(this, data.toArray ? data.toArray() : data);
	                    }

	                    // selector
	                    this.selector = {
	                        rows: null,
	                        cols: null,
	                        opts: null
	                    };

	                    _Api.extend(this, this, __apiStruct);
	                };

	                DataTable.Api = _Api;

	                _Api.prototype = /** @lends DataTables.Api */{
	                    any: function () {
	                        return this.flatten().length !== 0;
	                    },


	                    concat: __arrayProto.concat,


	                    context: [], // array of table settings objects


	                    each: function (fn) {
	                        for (var i = 0, ien = this.length ; i < ien; i++) {
	                            fn.call(this, this[i], i, this);
	                        }

	                        return this;
	                    },


	                    eq: function (idx) {
	                        var ctx = this.context;

	                        return ctx.length > idx ?
	                            new _Api(ctx[idx], this[idx]) :
	                            null;
	                    },


	                    filter: function (fn) {
	                        var a = [];

	                        if (__arrayProto.filter) {
	                            a = __arrayProto.filter.call(this, fn, this);
	                        }
	                        else {
	                            // Compatibility for browsers without EMCA-252-5 (JS 1.6)
	                            for (var i = 0, ien = this.length ; i < ien ; i++) {
	                                if (fn.call(this, this[i], i, this)) {
	                                    a.push(this[i]);
	                                }
	                            }
	                        }

	                        return new _Api(this.context, a);
	                    },


	                    flatten: function () {
	                        var a = [];
	                        return new _Api(this.context, a.concat.apply(a, this.toArray()));
	                    },


	                    join: __arrayProto.join,


	                    indexOf: __arrayProto.indexOf || function (obj, start) {
	                        for (var i = (start || 0), ien = this.length ; i < ien ; i++) {
	                            if (this[i] === obj) {
	                                return i;
	                            }
	                        }
	                        return -1;
	                    },

	                    iterator: function (flatten, type, fn, alwaysNew) {
	                        var
	                            a = [], ret,
	                            i, ien, j, jen,
	                            context = this.context,
	                            rows, items, item,
	                            selector = this.selector;

	                        // Argument shifting
	                        if (typeof flatten === 'string') {
	                            alwaysNew = fn;
	                            fn = type;
	                            type = flatten;
	                            flatten = false;
	                        }

	                        for (i = 0, ien = context.length ; i < ien ; i++) {
	                            var apiInst = new _Api(context[i]);

	                            if (type === 'table') {
	                                ret = fn.call(apiInst, context[i], i);

	                                if (ret !== undefined) {
	                                    a.push(ret);
	                                }
	                            }
	                            else if (type === 'columns' || type === 'rows') {
	                                // this has same length as context - one entry for each table
	                                ret = fn.call(apiInst, context[i], this[i], i);

	                                if (ret !== undefined) {
	                                    a.push(ret);
	                                }
	                            }
	                            else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {
	                                // columns and rows share the same structure.
	                                // 'this' is an array of column indexes for each context
	                                items = this[i];

	                                if (type === 'column-rows') {
	                                    rows = _selector_row_indexes(context[i], selector.opts);
	                                }

	                                for (j = 0, jen = items.length ; j < jen ; j++) {
	                                    item = items[j];

	                                    if (type === 'cell') {
	                                        ret = fn.call(apiInst, context[i], item.row, item.column, i, j);
	                                    }
	                                    else {
	                                        ret = fn.call(apiInst, context[i], item, i, j, rows);
	                                    }

	                                    if (ret !== undefined) {
	                                        a.push(ret);
	                                    }
	                                }
	                            }
	                        }

	                        if (a.length || alwaysNew) {
	                            var api = new _Api(context, flatten ? a.concat.apply([], a) : a);
	                            var apiSelector = api.selector;
	                            apiSelector.rows = selector.rows;
	                            apiSelector.cols = selector.cols;
	                            apiSelector.opts = selector.opts;
	                            return api;
	                        }
	                        return this;
	                    },


	                    lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {
	                        // Bit cheeky...
	                        return this.indexOf.apply(this.toArray.reverse(), arguments);
	                    },


	                    length: 0,


	                    map: function (fn) {
	                        var a = [];

	                        if (__arrayProto.map) {
	                            a = __arrayProto.map.call(this, fn, this);
	                        }
	                        else {
	                            // Compatibility for browsers without EMCA-252-5 (JS 1.6)
	                            for (var i = 0, ien = this.length ; i < ien ; i++) {
	                                a.push(fn.call(this, this[i], i));
	                            }
	                        }

	                        return new _Api(this.context, a);
	                    },


	                    pluck: function (prop) {
	                        return this.map(function (el) {
	                            return el[prop];
	                        });
	                    },

	                    pop: __arrayProto.pop,


	                    push: __arrayProto.push,


	                    // Does not return an API instance
	                    reduce: __arrayProto.reduce || function (fn, init) {
	                        return _fnReduce(this, fn, init, 0, this.length, 1);
	                    },


	                    reduceRight: __arrayProto.reduceRight || function (fn, init) {
	                        return _fnReduce(this, fn, init, this.length - 1, -1, -1);
	                    },


	                    reverse: __arrayProto.reverse,


	                    // Object with rows, columns and opts
	                    selector: null,


	                    shift: __arrayProto.shift,


	                    sort: __arrayProto.sort, // ? name - order?


	                    splice: __arrayProto.splice,


	                    toArray: function () {
	                        return __arrayProto.slice.call(this);
	                    },


	                    to$: function () {
	                        return $(this);
	                    },


	                    toJQuery: function () {
	                        return $(this);
	                    },


	                    unique: function () {
	                        return new _Api(this.context, _unique(this));
	                    },


	                    unshift: __arrayProto.unshift
	                };


	                _Api.extend = function (scope, obj, ext) {
	                    // Only extend API instances and static properties of the API
	                    if (!ext.length || !obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {
	                        return;
	                    }

	                    var
	                        i, ien,
	                        j, jen,
	                        struct, inner,
	                        methodScoping = function (scope, fn, struc) {
	                            return function () {
	                                var ret = fn.apply(scope, arguments);

	                                // Method extension
	                                _Api.extend(ret, ret, struc.methodExt);
	                                return ret;
	                            };
	                        };

	                    for (i = 0, ien = ext.length ; i < ien ; i++) {
	                        struct = ext[i];

	                        // Value
	                        obj[struct.name] = typeof struct.val === 'function' ?
	                            methodScoping(scope, struct.val, struct) :
	                            $.isPlainObject(struct.val) ?
						{} :
	                                struct.val;

	                        obj[struct.name].__dt_wrapper = true;

	                        // Property extension
	                        _Api.extend(scope, obj[struct.name], struct.propExt);
	                    }
	                };


	                // @todo - Is there need for an augment function?
	                // _Api.augment = function ( inst, name )
	                // {
	                // 	// Find src object in the structure from the name
	                // 	var parts = name.split('.');

	                // 	_Api.extend( inst, obj );
	                // };


	                //     [
	                //       {
	                //         name:      'data'                -- string   - Property name
	                //         val:       function () {},       -- function - Api method (or undefined if just an object
	                //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
	                //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
	                //       },
	                //       {
	                //         name:     'row'
	                //         val:       {},
	                //         methodExt: [ ... ],
	                //         propExt:   [
	                //           {
	                //             name:      'data'
	                //             val:       function () {},
	                //             methodExt: [ ... ],
	                //             propExt:   [ ... ]
	                //           },
	                //           ...
	                //         ]
	                //       }
	                //     ]

	                _Api.register = _api_register = function (name, val) {
	                    if ($.isArray(name)) {
	                        for (var j = 0, jen = name.length ; j < jen ; j++) {
	                            _Api.register(name[j], val);
	                        }
	                        return;
	                    }

	                    var
	                        i, ien,
	                        heir = name.split('.'),
	                        struct = __apiStruct,
	                        key, method;

	                    var find = function (src, name) {
	                        for (var i = 0, ien = src.length ; i < ien ; i++) {
	                            if (src[i].name === name) {
	                                return src[i];
	                            }
	                        }
	                        return null;
	                    };

	                    for (i = 0, ien = heir.length ; i < ien ; i++) {
	                        method = heir[i].indexOf('()') !== -1;
	                        key = method ?
	                            heir[i].replace('()', '') :
	                            heir[i];

	                        var src = find(struct, key);
	                        if (!src) {
	                            src = {
	                                name: key,
	                                val: {},
	                                methodExt: [],
	                                propExt: []
	                            };
	                            struct.push(src);
	                        }

	                        if (i === ien - 1) {
	                            src.val = val;
	                        }
	                        else {
	                            struct = method ?
	                                src.methodExt :
	                                src.propExt;
	                        }
	                    }
	                };


	                _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {
	                    _Api.register(pluralName, val);

	                    _Api.register(singularName, function () {
	                        var ret = val.apply(this, arguments);

	                        if (ret === this) {
	                            // Returned item is the API instance that was passed in, return it
	                            return this;
	                        }
	                        else if (ret instanceof _Api) {
	                            // New API instance returned, want the value from the first item
	                            // in the returned array for the singular result.
	                            return ret.length ?
	                                $.isArray(ret[0]) ?
	                                    new _Api(ret.context, ret[0]) : // Array results are 'enhanced'
	                                    ret[0] :
	                                undefined;
	                        }

	                        // Non-API return - just fire it back
	                        return ret;
	                    });
	                };


	                /**
	                 * Selector for HTML tables. Apply the given selector to the give array of
	                 * DataTables settings objects.
	                 *
	                 * @param {string|integer} [selector] jQuery selector string or integer
	                 * @param  {array} Array of DataTables settings objects to be filtered
	                 * @return {array}
	                 * @ignore
	                 */
	                var __table_selector = function (selector, a) {
	                    // Integer is used to pick out a table by index
	                    if (typeof selector === 'number') {
	                        return [a[selector]];
	                    }

	                    // Perform a jQuery selector on the table nodes
	                    var nodes = $.map(a, function (el, i) {
	                        return el.nTable;
	                    });

	                    return $(nodes)
	                        .filter(selector)
	                        .map(function (i) {
	                            // Need to translate back from the table node to the settings
	                            var idx = $.inArray(this, nodes);
	                            return a[idx];
	                        })
	                        .toArray();
	                };



	                /**
	                 * Context selector for the API's context (i.e. the tables the API instance
	                 * refers to.
	                 *
	                 * @name    DataTable.Api#tables
	                 * @param {string|integer} [selector] Selector to pick which tables the iterator
	                 *   should operate on. If not given, all tables in the current context are
	                 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
	                 *   select multiple tables or as an integer to select a single table.
	                 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
	                 */
	                _api_register('tables()', function (selector) {
	                    // A new instance is created if there was a selector specified
	                    return selector ?
	                        new _Api(__table_selector(selector, this.context)) :
	                        this;
	                });


	                _api_register('table()', function (selector) {
	                    var tables = this.tables(selector);
	                    var ctx = tables.context;

	                    // Truncate to the first matched table
	                    return ctx.length ?
	                        new _Api(ctx[0]) :
	                        tables;
	                });


	                _api_registerPlural('tables().nodes()', 'table().node()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTable;
	                    }, 1);
	                });


	                _api_registerPlural('tables().body()', 'table().body()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTBody;
	                    }, 1);
	                });


	                _api_registerPlural('tables().header()', 'table().header()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTHead;
	                    }, 1);
	                });


	                _api_registerPlural('tables().footer()', 'table().footer()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTFoot;
	                    }, 1);
	                });


	                _api_registerPlural('tables().containers()', 'table().container()', function () {
	                    return this.iterator('table', function (ctx) {
	                        return ctx.nTableWrapper;
	                    }, 1);
	                });



	                /**
	                 * Redraw the tables in the current context.
	                 *
	                 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	                 *   position. A full re-sort and re-filter is performed when this method is
	                 *   called, which is why the pagination reset is the default action.
	                 * @returns {DataTables.Api} this
	                 */
	                _api_register('draw()', function (resetPaging) {
	                    return this.iterator('table', function (settings) {
	                        _fnReDraw(settings, resetPaging === false);
	                    });
	                });



	                /**
	                 * Get the current page index.
	                 *
	                 * @return {integer} Current page index (zero based)
	                 *//**
		 * Set the current page.
		 *
		 * Note that if you attempt to show a page which does not exist, DataTables will
		 * not throw an error, but rather reset the paging.
		 *
		 * @param {integer|string} action The paging action to take. This can be one of:
		 *  * `integer` - The page index to jump to
		 *  * `string` - An action to take:
		 *    * `first` - Jump to first page.
		 *    * `next` - Jump to the next page
		 *    * `previous` - Jump to previous page
		 *    * `last` - Jump to the last page.
		 * @returns {DataTables.Api} this
		 */
	                _api_register('page()', function (action) {
	                    if (action === undefined) {
	                        return this.page.info().page; // not an expensive call
	                    }

	                    // else, have an action to take on all tables
	                    return this.iterator('table', function (settings) {
	                        _fnPageChange(settings, action);
	                    });
	                });


	                /**
	                 * Paging information for the first table in the current context.
	                 *
	                 * If you require paging information for another table, use the `table()` method
	                 * with a suitable selector.
	                 *
	                 * @return {object} Object with the following properties set:
	                 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
	                 *  * `pages` - Total number of pages
	                 *  * `start` - Display index for the first record shown on the current page
	                 *  * `end` - Display index for the last record shown on the current page
	                 *  * `length` - Display length (number of records). Note that generally `start
	                 *    + length = end`, but this is not always true, for example if there are
	                 *    only 2 records to show on the final page, with a length of 10.
	                 *  * `recordsTotal` - Full data set length
	                 *  * `recordsDisplay` - Data set length once the current filtering criterion
	                 *    are applied.
	                 */
	                _api_register('page.info()', function (action) {
	                    if (this.context.length === 0) {
	                        return undefined;
	                    }

	                    var
	                        settings = this.context[0],
	                        start = settings._iDisplayStart,
	                        len = settings._iDisplayLength,
	                        visRecords = settings.fnRecordsDisplay(),
	                        all = len === -1;

	                    return {
	                        "page": all ? 0 : Math.floor(start / len),
	                        "pages": all ? 1 : Math.ceil(visRecords / len),
	                        "start": start,
	                        "end": settings.fnDisplayEnd(),
	                        "length": len,
	                        "recordsTotal": settings.fnRecordsTotal(),
	                        "recordsDisplay": visRecords
	                    };
	                });


	                /**
	                 * Get the current page length.
	                 *
	                 * @return {integer} Current page length. Note `-1` indicates that all records
	                 *   are to be shown.
	                 *//**
		 * Set the current page length.
		 *
		 * @param {integer} Page length to set. Use `-1` to show all records.
		 * @returns {DataTables.Api} this
		 */
	                _api_register('page.len()', function (len) {
	                    // Note that we can't call this function 'length()' because `length`
	                    // is a Javascript property of functions which defines how many arguments
	                    // the function expects.
	                    if (len === undefined) {
	                        return this.context.length !== 0 ?
	                            this.context[0]._iDisplayLength :
	                            undefined;
	                    }

	                    // else, set the page length
	                    return this.iterator('table', function (settings) {
	                        _fnLengthChange(settings, len);
	                    });
	                });



	                var __reload = function (settings, holdPosition, callback) {
	                    // Use the draw event to trigger a callback
	                    if (callback) {
	                        var api = new _Api(settings);

	                        api.one('draw', function () {
	                            callback(api.ajax.json());
	                        });
	                    }

	                    if (_fnDataSource(settings) == 'ssp') {
	                        _fnReDraw(settings, holdPosition);
	                    }
	                    else {
	                        // Trigger xhr
	                        _fnProcessingDisplay(settings, true);

	                        _fnBuildAjax(settings, [], function (json) {
	                            _fnClearTable(settings);

	                            var data = _fnAjaxDataSrc(settings, json);
	                            for (var i = 0, ien = data.length ; i < ien ; i++) {
	                                _fnAddData(settings, data[i]);
	                            }

	                            _fnReDraw(settings, holdPosition);
	                            _fnProcessingDisplay(settings, false);
	                        });
	                    }
	                };


	                /**
	                 * Get the JSON response from the last Ajax request that DataTables made to the
	                 * server. Note that this returns the JSON from the first table in the current
	                 * context.
	                 *
	                 * @return {object} JSON received from the server.
	                 */
	                _api_register('ajax.json()', function () {
	                    var ctx = this.context;

	                    if (ctx.length > 0) {
	                        return ctx[0].json;
	                    }

	                    // else return undefined;
	                });


	                /**
	                 * Get the data submitted in the last Ajax request
	                 */
	                _api_register('ajax.params()', function () {
	                    var ctx = this.context;

	                    if (ctx.length > 0) {
	                        return ctx[0].oAjaxData;
	                    }

	                    // else return undefined;
	                });


	                /**
	                 * Reload tables from the Ajax data source. Note that this function will
	                 * automatically re-draw the table when the remote data has been loaded.
	                 *
	                 * @param {boolean} [reset=true] Reset (default) or hold the current paging
	                 *   position. A full re-sort and re-filter is performed when this method is
	                 *   called, which is why the pagination reset is the default action.
	                 * @returns {DataTables.Api} this
	                 */
	                _api_register('ajax.reload()', function (callback, resetPaging) {
	                    return this.iterator('table', function (settings) {
	                        __reload(settings, resetPaging === false, callback);
	                    });
	                });


	                /**
	                 * Get the current Ajax URL. Note that this returns the URL from the first
	                 * table in the current context.
	                 *
	                 * @return {string} Current Ajax source URL
	                 *//**
		 * Set the Ajax URL. Note that this will set the URL for all tables in the
		 * current context.
		 *
		 * @param {string} url URL to set.
		 * @returns {DataTables.Api} this
		 */
	                _api_register('ajax.url()', function (url) {
	                    var ctx = this.context;

	                    if (url === undefined) {
	                        // get
	                        if (ctx.length === 0) {
	                            return undefined;
	                        }
	                        ctx = ctx[0];

	                        return ctx.ajax ?
	                            $.isPlainObject(ctx.ajax) ?
	                                ctx.ajax.url :
	                                ctx.ajax :
	                            ctx.sAjaxSource;
	                    }

	                    // set
	                    return this.iterator('table', function (settings) {
	                        if ($.isPlainObject(settings.ajax)) {
	                            settings.ajax.url = url;
	                        }
	                        else {
	                            settings.ajax = url;
	                        }
	                        // No need to consider sAjaxSource here since DataTables gives priority
	                        // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any
	                        // value of `sAjaxSource` redundant.
	                    });
	                });


	                /**
	                 * Load data from the newly set Ajax URL. Note that this method is only
	                 * available when `ajax.url()` is used to set a URL. Additionally, this method
	                 * has the same effect as calling `ajax.reload()` but is provided for
	                 * convenience when setting a new URL. Like `ajax.reload()` it will
	                 * automatically redraw the table once the remote data has been loaded.
	                 *
	                 * @returns {DataTables.Api} this
	                 */
	                _api_register('ajax.url().load()', function (callback, resetPaging) {
	                    // Same as a reload, but makes sense to present it for easy access after a
	                    // url change
	                    return this.iterator('table', function (ctx) {
	                        __reload(ctx, resetPaging === false, callback);
	                    });
	                });




	                var _selector_run = function (type, selector, selectFn, settings, opts) {
	                    var
	                        out = [], res,
	                        a, i, ien, j, jen,
	                        selectorType = typeof selector;

	                    // Can't just check for isArray here, as an API or jQuery instance might be
	                    // given with their array like look
	                    if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {
	                        selector = [selector];
	                    }

	                    for (i = 0, ien = selector.length ; i < ien ; i++) {
	                        a = selector[i] && selector[i].split ?
	                            selector[i].split(',') :
	                            [selector[i]];

	                        for (j = 0, jen = a.length ; j < jen ; j++) {
	                            res = selectFn(typeof a[j] === 'string' ? $.trim(a[j]) : a[j]);

	                            if (res && res.length) {
	                                out.push.apply(out, res);
	                            }
	                        }
	                    }

	                    // selector extensions
	                    var ext = _ext.selector[type];
	                    if (ext.length) {
	                        for (i = 0, ien = ext.length ; i < ien ; i++) {
	                            out = ext[i](settings, opts, out);
	                        }
	                    }

	                    return out;
	                };


	                var _selector_opts = function (opts) {
	                    if (!opts) {
	                        opts = {};
	                    }

	                    // Backwards compatibility for 1.9- which used the terminology filter rather
	                    // than search
	                    if (opts.filter && opts.search === undefined) {
	                        opts.search = opts.filter;
	                    }

	                    return $.extend({
	                        search: 'none',
	                        order: 'current',
	                        page: 'all'
	                    }, opts);
	                };


	                var _selector_first = function (inst) {
	                    // Reduce the API instance to the first item found
	                    for (var i = 0, ien = inst.length ; i < ien ; i++) {
	                        if (inst[i].length > 0) {
	                            // Assign the first element to the first item in the instance
	                            // and truncate the instance and context
	                            inst[0] = inst[i];
	                            inst[0].length = 1;
	                            inst.length = 1;
	                            inst.context = [inst.context[i]];

	                            return inst;
	                        }
	                    }

	                    // Not found - return an empty instance
	                    inst.length = 0;
	                    return inst;
	                };


	                var _selector_row_indexes = function (settings, opts) {
	                    var
	                        i, ien, tmp, a = [],
	                        displayFiltered = settings.aiDisplay,
	                        displayMaster = settings.aiDisplayMaster;

	                    var
	                        search = opts.search,  // none, applied, removed
	                        order = opts.order,   // applied, current, index (original - compatibility with 1.9)
	                        page = opts.page;    // all, current

	                    if (_fnDataSource(settings) == 'ssp') {
	                        // In server-side processing mode, most options are irrelevant since
	                        // rows not shown don't exist and the index order is the applied order
	                        // Removed is a special case - for consistency just return an empty
	                        // array
	                        return search === 'removed' ?
	                            [] :
	                            _range(0, displayMaster.length);
	                    }
	                    else if (page == 'current') {
	                        // Current page implies that order=current and fitler=applied, since it is
	                        // fairly senseless otherwise, regardless of what order and search actually
	                        // are
	                        for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd() ; i < ien ; i++) {
	                            a.push(displayFiltered[i]);
	                        }
	                    }
	                    else if (order == 'current' || order == 'applied') {
	                        a = search == 'none' ?
	                            displayMaster.slice() :                      // no search
	                            search == 'applied' ?
	                                displayFiltered.slice() :                // applied search
	                                $.map(displayMaster, function (el, i) { // removed search
	                                    return $.inArray(el, displayFiltered) === -1 ? el : null;
	                                });
	                    }
	                    else if (order == 'index' || order == 'original') {
	                        for (i = 0, ien = settings.aoData.length ; i < ien ; i++) {
	                            if (search == 'none') {
	                                a.push(i);
	                            }
	                            else { // applied | removed
	                                tmp = $.inArray(i, displayFiltered);

	                                if ((tmp === -1 && search == 'removed') ||
	                                    (tmp >= 0 && search == 'applied')) {
	                                    a.push(i);
	                                }
	                            }
	                        }
	                    }

	                    return a;
	                };


	                /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	                 * Rows
	                 *
	                 * {}          - no selector - use all available rows
	                 * {integer}   - row aoData index
	                 * {node}      - TR node
	                 * {string}    - jQuery selector to apply to the TR elements
	                 * {array}     - jQuery array of nodes, or simply an array of TR nodes
	                 *
	                 */


	                var __row_selector = function (settings, selector, opts) {
	                    var run = function (sel) {
	                        var selInt = _intVal(sel);
	                        var i, ien;

	                        // Short cut - selector is a number and no options provided (default is
	                        // all records, so no need to check if the index is in there, since it
	                        // must be - dev error if the index doesn't exist).
	                        if (selInt !== null && !opts) {
	                            return [selInt];
	                        }

	                        var rows = _selector_row_indexes(settings, opts);

	                        if (selInt !== null && $.inArray(selInt, rows) !== -1) {
	                            // Selector - integer
	                            return [selInt];
	                        }
	                        else if (!sel) {
	                            // Selector - none
	                            return rows;
	                        }

	                        // Selector - function
	                        if (typeof sel === 'function') {
	                            return $.map(rows, function (idx) {
	                                var row = settings.aoData[idx];
	                                return sel(idx, row._aData, row.nTr) ? idx : null;
	                            });
	                        }

	                        // Get nodes in the order from the `rows` array with null values removed
	                        var nodes = _removeEmpty(
	                            _pluck_order(settings.aoData, rows, 'nTr')
	                        );

	                        // Selector - node
	                        if (sel.nodeName) {
	                            if ($.inArray(sel, nodes) !== -1) {
	                                return [sel._DT_RowIndex]; // sel is a TR node that is in the table
	                                // and DataTables adds a prop for fast lookup
	                            }
	                        }

	                        // Selector - jQuery selector string, array of nodes or jQuery object/
	                        // As jQuery's .filter() allows jQuery objects to be passed in filter,
	                        // it also allows arrays, so this will cope with all three options
	                        return $(nodes)
	                            .filter(sel)
	                            .map(function () {
	                                return this._DT_RowIndex;
	                            })
	                            .toArray();
	                    };

	                    return _selector_run('row', selector, run, settings, opts);
	                };


	                _api_register('rows()', function (selector, opts) {
	                    // argument shifting
	                    if (selector === undefined) {
	                        selector = '';
	                    }
	                    else if ($.isPlainObject(selector)) {
	                        opts = selector;
	                        selector = '';
	                    }

	                    opts = _selector_opts(opts);

	                    var inst = this.iterator('table', function (settings) {
	                        return __row_selector(settings, selector, opts);
	                    }, 1);

	                    // Want argument shifting here and in __row_selector?
	                    inst.selector.rows = selector;
	                    inst.selector.opts = opts;

	                    return inst;
	                });

	                _api_register('rows().nodes()', function () {
	                    return this.iterator('row', function (settings, row) {
	                        return settings.aoData[row].nTr || undefined;
	                    }, 1);
	                });

	                _api_register('rows().data()', function () {
	                    return this.iterator(true, 'rows', function (settings, rows) {
	                        return _pluck_order(settings.aoData, rows, '_aData');
	                    }, 1);
	                });

	                _api_registerPlural('rows().cache()', 'row().cache()', function (type) {
	                    return this.iterator('row', function (settings, row) {
	                        var r = settings.aoData[row];
	                        return type === 'search' ? r._aFilterData : r._aSortData;
	                    }, 1);
	                });

	                _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {
	                    return this.iterator('row', function (settings, row) {
	                        _fnInvalidate(settings, row, src);
	                    });
	                });

	                _api_registerPlural('rows().indexes()', 'row().index()', function () {
	                    return this.iterator('row', function (settings, row) {
	                        return row;
	                    }, 1);
	                });

	                _api_registerPlural('rows().remove()', 'row().remove()', function () {
	                    var that = this;

	                    return this.iterator('row', function (settings, row, thatIdx) {
	                        var data = settings.aoData;

	                        data.splice(row, 1);

	                        // Update the _DT_RowIndex parameter on all rows in the table
	                        for (var i = 0, ien = data.length ; i < ien ; i++) {
	                            if (data[i].nTr !== null) {
	                                data[i].nTr._DT_RowIndex = i;
	                            }
	                        }

	                        // Remove the target row from the search array
	                        var displayIndex = $.inArray(row, settings.aiDisplay);

	                        // Delete from the display arrays
	                        _fnDeleteIndex(settings.aiDisplayMaster, row);
	                        _fnDeleteIndex(settings.aiDisplay, row);
	                        _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes

	                        // Check for an 'overflow' they case for displaying the table
	                        _fnLengthOverflow(settings);
	                    });
	                });


	                _api_register('rows.add()', function (rows) {
	                    var newRows = this.iterator('table', function (settings) {
	                        var row, i, ien;
	                        var out = [];

	                        for (i = 0, ien = rows.length ; i < ien ; i++) {
	                            row = rows[i];

	                            if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
	                                out.push(_fnAddTr(settings, row)[0]);
	                            }
	                            else {
	                                out.push(_fnAddData(settings, row));
	                            }
	                        }

	                        return out;
	                    }, 1);

	                    // Return an Api.rows() extended instance, so rows().nodes() etc can be used
	                    var modRows = this.rows(-1);
	                    modRows.pop();
	                    modRows.push.apply(modRows, newRows.toArray());

	                    return modRows;
	                });





	                /**
	                 *
	                 */
	                _api_register('row()', function (selector, opts) {
	                    return _selector_first(this.rows(selector, opts));
	                });


	                _api_register('row().data()', function (data) {
	                    var ctx = this.context;

	                    if (data === undefined) {
	                        // Get
	                        return ctx.length && this.length ?
	                            ctx[0].aoData[this[0]]._aData :
	                            undefined;
	                    }

	                    // Set
	                    ctx[0].aoData[this[0]]._aData = data;

	                    // Automatically invalidate
	                    _fnInvalidate(ctx[0], this[0], 'data');

	                    return this;
	                });


	                _api_register('row().node()', function () {
	                    var ctx = this.context;

	                    return ctx.length && this.length ?
	                        ctx[0].aoData[this[0]].nTr || null :
	                        null;
	                });


	                _api_register('row.add()', function (row) {
	                    // Allow a jQuery object to be passed in - only a single row is added from
	                    // it though - the first element in the set
	                    if (row instanceof $ && row.length) {
	                        row = row[0];
	                    }

	                    var rows = this.iterator('table', function (settings) {
	                        if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {
	                            return _fnAddTr(settings, row)[0];
	                        }
	                        return _fnAddData(settings, row);
	                    });

	                    // Return an Api.rows() extended instance, with the newly added row selected
	                    return this.row(rows[0]);
	                });



	                var __details_add = function (ctx, row, data, klass) {
	                    // Convert to array of TR elements
	                    var rows = [];
	                    var addRow = function (r, k) {
	                        // Recursion to allow for arrays of jQuery objects
	                        if ($.isArray(r) || r instanceof $) {
	                            for (var i = 0, ien = r.length ; i < ien ; i++) {
	                                addRow(r[i], k);
	                            }
	                            return;
	                        }

	                        // If we get a TR element, then just add it directly - up to the dev
	                        // to add the correct number of columns etc
	                        if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {
	                            rows.push(r);
	                        }
	                        else {
	                            // Otherwise create a row with a wrapper
	                            var created = $('<tr><td/></tr>').addClass(k);
	                            $('td', created)
	                                .addClass(k)
	                                .html(r)
	                                [0].colSpan = _fnVisbleColumns(ctx);

	                            rows.push(created[0]);
	                        }
	                    };

	                    addRow(data, klass);

	                    if (row._details) {
	                        row._details.remove();
	                    }

	                    row._details = $(rows);

	                    // If the children were already shown, that state should be retained
	                    if (row._detailsShow) {
	                        row._details.insertAfter(row.nTr);
	                    }
	                };


	                var __details_remove = function (api, idx) {
	                    var ctx = api.context;

	                    if (ctx.length) {
	                        var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];

	                        if (row._details) {
	                            row._details.remove();

	                            row._detailsShow = undefined;
	                            row._details = undefined;
	                        }
	                    }
	                };


	                var __details_display = function (api, show) {
	                    var ctx = api.context;

	                    if (ctx.length && api.length) {
	                        var row = ctx[0].aoData[api[0]];

	                        if (row._details) {
	                            row._detailsShow = show;

	                            if (show) {
	                                row._details.insertAfter(row.nTr);
	                            }
	                            else {
	                                row._details.detach();
	                            }

	                            __details_events(ctx[0]);
	                        }
	                    }
	                };


	                var __details_events = function (settings) {
	                    var api = new _Api(settings);
	                    var namespace = '.dt.DT_details';
	                    var drawEvent = 'draw' + namespace;
	                    var colvisEvent = 'column-visibility' + namespace;
	                    var destroyEvent = 'destroy' + namespace;
	                    var data = settings.aoData;

	                    api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);

	                    if (_pluck(data, '_details').length > 0) {
	                        // On each draw, insert the required elements into the document
	                        api.on(drawEvent, function (e, ctx) {
	                            if (settings !== ctx) {
	                                return;
	                            }

	                            api.rows({ page: 'current' }).eq(0).each(function (idx) {
	                                // Internal data grab
	                                var row = data[idx];

	                                if (row._detailsShow) {
	                                    row._details.insertAfter(row.nTr);
	                                }
	                            });
	                        });

	                        // Column visibility change - update the colspan
	                        api.on(colvisEvent, function (e, ctx, idx, vis) {
	                            if (settings !== ctx) {
	                                return;
	                            }

	                            // Update the colspan for the details rows (note, only if it already has
	                            // a colspan)
	                            var row, visible = _fnVisbleColumns(ctx);

	                            for (var i = 0, ien = data.length ; i < ien ; i++) {
	                                row = data[i];

	                                if (row._details) {
	                                    row._details.children('td[colspan]').attr('colspan', visible);
	                                }
	                            }
	                        });

	                        // Table destroyed - nuke any child rows
	                        api.on(destroyEvent, function (e, ctx) {
	                            if (settings !== ctx) {
	                                return;
	                            }

	                            for (var i = 0, ien = data.length ; i < ien ; i++) {
	                                if (data[i]._details) {
	                                    __details_remove(api, i);
	                                }
	                            }
	                        });
	                    }
	                };

	                // Strings for the method names to help minification
	                var _emp = '';
	                var _child_obj = _emp + 'row().child';
	                var _child_mth = _child_obj + '()';

	                // data can be:
	                //  tr
	                //  string
	                //  jQuery or array of any of the above
	                _api_register(_child_mth, function (data, klass) {
	                    var ctx = this.context;

	                    if (data === undefined) {
	                        // get
	                        return ctx.length && this.length ?
	                            ctx[0].aoData[this[0]]._details :
	                            undefined;
	                    }
	                    else if (data === true) {
	                        // show
	                        this.child.show();
	                    }
	                    else if (data === false) {
	                        // remove
	                        __details_remove(this);
	                    }
	                    else if (ctx.length && this.length) {
	                        // set
	                        __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
	                    }

	                    return this;
	                });


	                _api_register([
	                    _child_obj + '.show()',
	                    _child_mth + '.show()' // only when `child()` was called with parameters (without
	                ], function (show) {   // it returns an object and this method is not executed)
	                    __details_display(this, true);
	                    return this;
	                });


	                _api_register([
	                    _child_obj + '.hide()',
	                    _child_mth + '.hide()' // only when `child()` was called with parameters (without
	                ], function () {         // it returns an object and this method is not executed)
	                    __details_display(this, false);
	                    return this;
	                });


	                _api_register([
	                    _child_obj + '.remove()',
	                    _child_mth + '.remove()' // only when `child()` was called with parameters (without
	                ], function () {           // it returns an object and this method is not executed)
	                    __details_remove(this);
	                    return this;
	                });


	                _api_register(_child_obj + '.isShown()', function () {
	                    var ctx = this.context;

	                    if (ctx.length && this.length) {
	                        // _detailsShown as false or undefined will fall through to return false
	                        return ctx[0].aoData[this[0]]._detailsShow || false;
	                    }
	                    return false;
	                });



	                /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	                 * Columns
	                 *
	                 * {integer}           - column index (>=0 count from left, <0 count from right)
	                 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
	                 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
	                 * "{string}:name"     - column name
	                 * "{string}"          - jQuery selector on column header nodes
	                 *
	                 */

	                // can be an array of these items, comma separated list, or an array of comma
	                // separated lists

	                var __re_column_selector = /^(.+):(name|visIdx|visible)$/;


	                // r1 and r2 are redundant - but it means that the parameters match for the
	                // iterator callback in columns().data()
	                var __columnData = function (settings, column, r1, r2, rows) {
	                    var a = [];
	                    for (var row = 0, ien = rows.length ; row < ien ; row++) {
	                        a.push(_fnGetCellData(settings, rows[row], column));
	                    }
	                    return a;
	                };


	                var __column_selector = function (settings, selector, opts) {
	                    var
	                        columns = settings.aoColumns,
	                        names = _pluck(columns, 'sName'),
	                        nodes = _pluck(columns, 'nTh');

	                    var run = function (s) {
	                        var selInt = _intVal(s);

	                        // Selector - all
	                        if (s === '') {
	                            return _range(columns.length);
	                        }

	                        // Selector - index
	                        if (selInt !== null) {
	                            return [selInt >= 0 ?
	                                selInt : // Count from left
	                                columns.length + selInt // Count from right (+ because its a negative value)
	                            ];
	                        }

	                        // Selector = function
	                        if (typeof s === 'function') {
	                            var rows = _selector_row_indexes(settings, opts);

	                            return $.map(columns, function (col, idx) {
	                                return s(
	                                        idx,
	                                        __columnData(settings, idx, 0, 0, rows),
	                                        nodes[idx]
	                                    ) ? idx : null;
	                            });
	                        }

	                        // jQuery or string selector
	                        var match = typeof s === 'string' ?
	                            s.match(__re_column_selector) :
	                            '';

	                        if (match) {
	                            switch (match[2]) {
	                                case 'visIdx':
	                                case 'visible':
	                                    var idx = parseInt(match[1], 10);
	                                    // Visible index given, convert to column index
	                                    if (idx < 0) {
	                                        // Counting from the right
	                                        var visColumns = $.map(columns, function (col, i) {
	                                            return col.bVisible ? i : null;
	                                        });
	                                        return [visColumns[visColumns.length + idx]];
	                                    }
	                                    // Counting from the left
	                                    return [_fnVisibleToColumnIndex(settings, idx)];

	                                case 'name':
	                                    // match by name. `names` is column index complete and in order
	                                    return $.map(names, function (name, i) {
	                                        return name === match[1] ? i : null;
	                                    });
	                            }
	                        }
	                        else {
	                            // jQuery selector on the TH elements for the columns
	                            return $(nodes)
	                                .filter(s)
	                                .map(function () {
	                                    return $.inArray(this, nodes); // `nodes` is column index complete and in order
	                                })
	                                .toArray();
	                        }
	                    };

	                    return _selector_run('column', selector, run, settings, opts);
	                };


	                var __setColumnVis = function (settings, column, vis, recalc) {
	                    var
	                        cols = settings.aoColumns,
	                        col = cols[column],
	                        data = settings.aoData,
	                        row, cells, i, ien, tr;

	                    // Get
	                    if (vis === undefined) {
	                        return col.bVisible;
	                    }

	                    // Set
	                    // No change
	                    if (col.bVisible === vis) {
	                        return;
	                    }

	                    if (vis) {
	                        // Insert column
	                        // Need to decide if we should use appendChild or insertBefore
	                        var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);

	                        for (i = 0, ien = data.length ; i < ien ; i++) {
	                            tr = data[i].nTr;
	                            cells = data[i].anCells;

	                            if (tr) {
	                                // insertBefore can act like appendChild if 2nd arg is null
	                                tr.insertBefore(cells[column], cells[insertBefore] || null);
	                            }
	                        }
	                    }
	                    else {
	                        // Remove column
	                        $(_pluck(settings.aoData, 'anCells', column)).detach();
	                    }

	                    // Common actions
	                    col.bVisible = vis;
	                    _fnDrawHead(settings, settings.aoHeader);
	                    _fnDrawHead(settings, settings.aoFooter);

	                    if (recalc === undefined || recalc) {
	                        // Automatically adjust column sizing
	                        _fnAdjustColumnSizing(settings);

	                        // Realign columns for scrolling
	                        if (settings.oScroll.sX || settings.oScroll.sY) {
	                            _fnScrollDraw(settings);
	                        }
	                    }

	                    _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis]);

	                    _fnSaveState(settings);
	                };


	                _api_register('columns()', function (selector, opts) {
	                    // argument shifting
	                    if (selector === undefined) {
	                        selector = '';
	                    }
	                    else if ($.isPlainObject(selector)) {
	                        opts = selector;
	                        selector = '';
	                    }

	                    opts = _selector_opts(opts);

	                    var inst = this.iterator('table', function (settings) {
	                        return __column_selector(settings, selector, opts);
	                    }, 1);

	                    // Want argument shifting here and in _row_selector?
	                    inst.selector.cols = selector;
	                    inst.selector.opts = opts;

	                    return inst;
	                });

	                _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {
	                    return this.iterator('column', function (settings, column) {
	                        return settings.aoColumns[column].nTh;
	                    }, 1);
	                });

	                _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {
	                    return this.iterator('column', function (settings, column) {
	                        return settings.aoColumns[column].nTf;
	                    }, 1);
	                });

	                _api_registerPlural('columns().data()', 'column().data()', function () {
	                    return this.iterator('column-rows', __columnData, 1);
	                });

	                _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {
	                    return this.iterator('column', function (settings, column) {
	                        return settings.aoColumns[column].mData;
	                    }, 1);
	                });

	                _api_registerPlural('columns().cache()', 'column().cache()', function (type) {
	                    return this.iterator('column-rows', function (settings, column, i, j, rows) {
	                        return _pluck_order(settings.aoData, rows,
	                            type === 'search' ? '_aFilterData' : '_aSortData', column
	                        );
	                    }, 1);
	                });

	                _api_registerPlural('columns().nodes()', 'column().nodes()', function () {
	                    return this.iterator('column-rows', function (settings, column, i, j, rows) {
	                        return _pluck_order(settings.aoData, rows, 'anCells', column);
	                    }, 1);
	                });

	                _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {
	                    return this.iterator('column', function (settings, column) {
	                        if (vis === undefined) {
	                            return settings.aoColumns[column].bVisible;
	                        } // else
	                        __setColumnVis(settings, column, vis, calc);
	                    });
	                });

	                _api_registerPlural('columns().indexes()', 'column().index()', function (type) {
	                    return this.iterator('column', function (settings, column) {
	                        return type === 'visible' ?
	                            _fnColumnIndexToVisible(settings, column) :
	                            column;
	                    }, 1);
	                });

	                _api_register('columns.adjust()', function () {
	                    return this.iterator('table', function (settings) {
	                        _fnAdjustColumnSizing(settings);
	                    }, 1);
	                });

	                _api_register('column.index()', function (type, idx) {
	                    if (this.context.length !== 0) {
	                        var ctx = this.context[0];

	                        if (type === 'fromVisible' || type === 'toData') {
	                            return _fnVisibleToColumnIndex(ctx, idx);
	                        }
	                        else if (type === 'fromData' || type === 'toVisible') {
	                            return _fnColumnIndexToVisible(ctx, idx);
	                        }
	                    }
	                });

	                _api_register('column()', function (selector, opts) {
	                    return _selector_first(this.columns(selector, opts));
	                });




	                var __cell_selector = function (settings, selector, opts) {
	                    var data = settings.aoData;
	                    var rows = _selector_row_indexes(settings, opts);
	                    var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));
	                    var allCells = $([].concat.apply([], cells));
	                    var row;
	                    var columns = settings.aoColumns.length;
	                    var a, i, ien, j, o, host;

	                    var run = function (s) {
	                        var fnSelector = typeof s === 'function';

	                        if (s === null || s === undefined || fnSelector) {
	                            // All cells and function selectors
	                            a = [];

	                            for (i = 0, ien = rows.length ; i < ien ; i++) {
	                                row = rows[i];

	                                for (j = 0 ; j < columns ; j++) {
	                                    o = {
	                                        row: row,
	                                        column: j
	                                    };

	                                    if (fnSelector) {
	                                        // Selector - function
	                                        host = settings.aoData[row];

	                                        if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {
	                                            a.push(o);
	                                        }
	                                    }
	                                    else {
	                                        // Selector - all
	                                        a.push(o);
	                                    }
	                                }
	                            }

	                            return a;
	                        }

	                        // Selector - index
	                        if ($.isPlainObject(s)) {
	                            return [s];
	                        }

	                        // Selector - jQuery filtered cells
	                        return allCells
	                            .filter(s)
	                            .map(function (i, el) {
	                                row = el.parentNode._DT_RowIndex;

	                                return {
	                                    row: row,
	                                    column: $.inArray(el, data[row].anCells)
	                                };
	                            })
	                            .toArray();
	                    };

	                    return _selector_run('cell', selector, run, settings, opts);
	                };




	                _api_register('cells()', function (rowSelector, columnSelector, opts) {
	                    // Argument shifting
	                    if ($.isPlainObject(rowSelector)) {
	                        // Indexes
	                        if (rowSelector.row === undefined) {
	                            // Selector options in first parameter
	                            opts = rowSelector;
	                            rowSelector = null;
	                        }
	                        else {
	                            // Cell index objects in first parameter
	                            opts = columnSelector;
	                            columnSelector = null;
	                        }
	                    }
	                    if ($.isPlainObject(columnSelector)) {
	                        opts = columnSelector;
	                        columnSelector = null;
	                    }

	                    // Cell selector
	                    if (columnSelector === null || columnSelector === undefined) {
	                        return this.iterator('table', function (settings) {
	                            return __cell_selector(settings, rowSelector, _selector_opts(opts));
	                        });
	                    }

	                    // Row + column selector
	                    var columns = this.columns(columnSelector, opts);
	                    var rows = this.rows(rowSelector, opts);
	                    var a, i, ien, j, jen;

	                    var cells = this.iterator('table', function (settings, idx) {
	                        a = [];

	                        for (i = 0, ien = rows[idx].length ; i < ien ; i++) {
	                            for (j = 0, jen = columns[idx].length ; j < jen ; j++) {
	                                a.push({
	                                    row: rows[idx][i],
	                                    column: columns[idx][j]
	                                });
	                            }
	                        }

	                        return a;
	                    }, 1);

	                    $.extend(cells.selector, {
	                        cols: columnSelector,
	                        rows: rowSelector,
	                        opts: opts
	                    });

	                    return cells;
	                });


	                _api_registerPlural('cells().nodes()', 'cell().node()', function () {
	                    return this.iterator('cell', function (settings, row, column) {
	                        var cells = settings.aoData[row].anCells;
	                        return cells ?
	                            cells[column] :
	                            undefined;
	                    }, 1);
	                });


	                _api_register('cells().data()', function () {
	                    return this.iterator('cell', function (settings, row, column) {
	                        return _fnGetCellData(settings, row, column);
	                    }, 1);
	                });


	                _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {
	                    type = type === 'search' ? '_aFilterData' : '_aSortData';

	                    return this.iterator('cell', function (settings, row, column) {
	                        return settings.aoData[row][type][column];
	                    }, 1);
	                });


	                _api_registerPlural('cells().render()', 'cell().render()', function (type) {
	                    return this.iterator('cell', function (settings, row, column) {
	                        return _fnGetCellData(settings, row, column, type);
	                    }, 1);
	                });


	                _api_registerPlural('cells().indexes()', 'cell().index()', function () {
	                    return this.iterator('cell', function (settings, row, column) {
	                        return {
	                            row: row,
	                            column: column,
	                            columnVisible: _fnColumnIndexToVisible(settings, column)
	                        };
	                    }, 1);
	                });


	                _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {
	                    return this.iterator('cell', function (settings, row, column) {
	                        _fnInvalidate(settings, row, src, column);
	                    });
	                });



	                _api_register('cell()', function (rowSelector, columnSelector, opts) {
	                    return _selector_first(this.cells(rowSelector, columnSelector, opts));
	                });


	                _api_register('cell().data()', function (data) {
	                    var ctx = this.context;
	                    var cell = this[0];

	                    if (data === undefined) {
	                        // Get
	                        return ctx.length && cell.length ?
	                            _fnGetCellData(ctx[0], cell[0].row, cell[0].column) :
	                            undefined;
	                    }

	                    // Set
	                    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
	                    _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);

	                    return this;
	                });



	                /**
	                 * Get current ordering (sorting) that has been applied to the table.
	                 *
	                 * @returns {array} 2D array containing the sorting information for the first
	                 *   table in the current context. Each element in the parent array represents
	                 *   a column being sorted upon (i.e. multi-sorting with two columns would have
	                 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
	                 *   the column index that the sorting condition applies to, the second is the
	                 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
	                 *   index of the sorting order from the `column.sorting` initialisation array.
	                 *//**
		 * Set the ordering for the table.
		 *
		 * @param {integer} order Column index to sort upon.
		 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 1D array of sorting information to be applied.
		 * @param {array} [...] Optional additional sorting conditions
		 * @returns {DataTables.Api} this
		 *//**
		 * Set the ordering for the table.
		 *
		 * @param {array} order 2D array of sorting information to be applied.
		 * @returns {DataTables.Api} this
		 */
	                _api_register('order()', function (order, dir) {
	                    var ctx = this.context;

	                    if (order === undefined) {
	                        // get
	                        return ctx.length !== 0 ?
	                            ctx[0].aaSorting :
	                            undefined;
	                    }

	                    // set
	                    if (typeof order === 'number') {
	                        // Simple column / direction passed in
	                        order = [[order, dir]];
	                    }
	                    else if (!$.isArray(order[0])) {
	                        // Arguments passed in (list of 1D arrays)
	                        order = Array.prototype.slice.call(arguments);
	                    }
	                    // otherwise a 2D array was passed in

	                    return this.iterator('table', function (settings) {
	                        settings.aaSorting = order.slice();
	                    });
	                });


	                /**
	                 * Attach a sort listener to an element for a given column
	                 *
	                 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
	                 *   listener to. This can take the form of a single DOM node, a jQuery
	                 *   collection of nodes or a jQuery selector which will identify the node(s).
	                 * @param {integer} column the column that a click on this node will sort on
	                 * @param {function} [callback] callback function when sort is run
	                 * @returns {DataTables.Api} this
	                 */
	                _api_register('order.listener()', function (node, column, callback) {
	                    return this.iterator('table', function (settings) {
	                        _fnSortAttachListener(settings, node, column, callback);
	                    });
	                });


	                // Order by the selected column(s)
	                _api_register([
	                    'columns().order()',
	                    'column().order()'
	                ], function (dir) {
	                    var that = this;

	                    return this.iterator('table', function (settings, i) {
	                        var sort = [];

	                        $.each(that[i], function (j, col) {
	                            sort.push([col, dir]);
	                        });

	                        settings.aaSorting = sort;
	                    });
	                });



	                _api_register('search()', function (input, regex, smart, caseInsen) {
	                    var ctx = this.context;

	                    if (input === undefined) {
	                        // get
	                        return ctx.length !== 0 ?
	                            ctx[0].oPreviousSearch.sSearch :
	                            undefined;
	                    }

	                    // set
	                    return this.iterator('table', function (settings) {
	                        if (!settings.oFeatures.bFilter) {
	                            return;
	                        }

	                        _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
	                            "sSearch": input + "",
	                            "bRegex": regex === null ? false : regex,
	                            "bSmart": smart === null ? true : smart,
	                            "bCaseInsensitive": caseInsen === null ? true : caseInsen
	                        }), 1);
	                    });
	                });


	                _api_registerPlural(
	                    'columns().search()',
	                    'column().search()',
	                    function (input, regex, smart, caseInsen) {
	                        return this.iterator('column', function (settings, column) {
	                            var preSearch = settings.aoPreSearchCols;

	                            if (input === undefined) {
	                                // get
	                                return preSearch[column].sSearch;
	                            }

	                            // set
	                            if (!settings.oFeatures.bFilter) {
	                                return;
	                            }

	                            $.extend(preSearch[column], {
	                                "sSearch": input + "",
	                                "bRegex": regex === null ? false : regex,
	                                "bSmart": smart === null ? true : smart,
	                                "bCaseInsensitive": caseInsen === null ? true : caseInsen
	                            });

	                            _fnFilterComplete(settings, settings.oPreviousSearch, 1);
	                        });
	                    }
	                );

	                /*
	                 * State API methods
	                 */

	                _api_register('state()', function () {
	                    return this.context.length ?
	                        this.context[0].oSavedState :
	                        null;
	                });


	                _api_register('state.clear()', function () {
	                    return this.iterator('table', function (settings) {
	                        // Save an empty object
	                        settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
	                    });
	                });


	                _api_register('state.loaded()', function () {
	                    return this.context.length ?
	                        this.context[0].oLoadedState :
	                        null;
	                });


	                _api_register('state.save()', function () {
	                    return this.iterator('table', function (settings) {
	                        _fnSaveState(settings);
	                    });
	                });



	                /**
	                 * Provide a common method for plug-ins to check the version of DataTables being
	                 * used, in order to ensure compatibility.
	                 *
	                 *  @param {string} version Version string to check for, in the format "X.Y.Z".
	                 *    Note that the formats "X" and "X.Y" are also acceptable.
	                 *  @returns {boolean} true if this version of DataTables is greater or equal to
	                 *    the required version, or false if this version of DataTales is not
	                 *    suitable
	                 *  @static
	                 *  @dtopt API-Static
	                 *
	                 *  @example
	                 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
	                 */
	                DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {
	                    var aThis = DataTable.version.split('.');
	                    var aThat = version.split('.');
	                    var iThis, iThat;

	                    for (var i = 0, iLen = aThat.length ; i < iLen ; i++) {
	                        iThis = parseInt(aThis[i], 10) || 0;
	                        iThat = parseInt(aThat[i], 10) || 0;

	                        // Parts are the same, keep comparing
	                        if (iThis === iThat) {
	                            continue;
	                        }

	                        // Parts are different, return immediately
	                        return iThis > iThat;
	                    }

	                    return true;
	                };


	                /**
	                 * Check if a `<table>` node is a DataTable table already or not.
	                 *
	                 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
	                 *      selector for the table to test. Note that if more than more than one
	                 *      table is passed on, only the first will be checked
	                 *  @returns {boolean} true the table given is a DataTable, or false otherwise
	                 *  @static
	                 *  @dtopt API-Static
	                 *
	                 *  @example
	                 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
	                 *      $('#example').dataTable();
	                 *    }
	                 */
	                DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {
	                    var t = $(table).get(0);
	                    var is = false;

	                    $.each(DataTable.settings, function (i, o) {
	                        var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
	                        var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

	                        if (o.nTable === t || head === t || foot === t) {
	                            is = true;
	                        }
	                    });

	                    return is;
	                };


	                /**
	                 * Get all DataTable tables that have been initialised - optionally you can
	                 * select to get only currently visible tables.
	                 *
	                 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
	                 *    or visible tables only.
	                 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
	                 *    DataTables
	                 *  @static
	                 *  @dtopt API-Static
	                 *
	                 *  @example
	                 *    $.each( $.fn.dataTable.tables(true), function () {
	                 *      $(table).DataTable().columns.adjust();
	                 *    } );
	                 */
	                DataTable.tables = DataTable.fnTables = function (visible) {
	                    return $.map(DataTable.settings, function (o) {
	                        if (!visible || (visible && $(o.nTable).is(':visible'))) {
	                            return o.nTable;
	                        }
	                    });
	                };


	                /**
	                 * DataTables utility methods
	                 * 
	                 * This namespace provides helper methods that DataTables uses internally to
	                 * create a DataTable, but which are not exclusively used only for DataTables.
	                 * These methods can be used by extension authors to save the duplication of
	                 * code.
	                 *
	                 *  @namespace
	                 */
	                DataTable.util = {
	                    /**
	                     * Throttle the calls to a function. Arguments and context are maintained
	                     * for the throttled function.
	                     *
	                     * @param {function} fn Function to be called
	                     * @param {integer} freq Call frequency in mS
	                     * @return {function} Wrapped function
	                     */
	                    throttle: _fnThrottle,


	                    /**
	                     * Escape a string such that it can be used in a regular expression
	                     *
	                     *  @param {string} sVal string to escape
	                     *  @returns {string} escaped string
	                     */
	                    escapeRegex: _fnEscapeRegex
	                };


	                /**
	                 * Convert from camel case parameters to Hungarian notation. This is made public
	                 * for the extensions to provide the same ability as DataTables core to accept
	                 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
	                 * parameters.
	                 *
	                 *  @param {object} src The model object which holds all parameters that can be
	                 *    mapped.
	                 *  @param {object} user The object to convert from camel case to Hungarian.
	                 *  @param {boolean} force When set to `true`, properties which already have a
	                 *    Hungarian value in the `user` object will be overwritten. Otherwise they
	                 *    won't be.
	                 */
	                DataTable.camelToHungarian = _fnCamelToHungarian;



	                /**
	                 *
	                 */
	                _api_register('$()', function (selector, opts) {
	                    var
	                        rows = this.rows(opts).nodes(), // Get all rows
	                        jqRows = $(rows);

	                    return $([].concat(
	                        jqRows.filter(selector).toArray(),
	                        jqRows.find(selector).toArray()
	                    ));
	                });


	                // jQuery functions to operate on the tables
	                $.each(['on', 'one', 'off'], function (i, key) {
	                    _api_register(key + '()', function ( /* event, handler */) {
	                        var args = Array.prototype.slice.call(arguments);

	                        // Add the `dt` namespace automatically if it isn't already present
	                        if (!args[0].match(/\.dt\b/)) {
	                            args[0] += '.dt';
	                        }

	                        var inst = $(this.tables().nodes());
	                        inst[key].apply(inst, args);
	                        return this;
	                    });
	                });


	                _api_register('clear()', function () {
	                    return this.iterator('table', function (settings) {
	                        _fnClearTable(settings);
	                    });
	                });


	                _api_register('settings()', function () {
	                    return new _Api(this.context, this.context);
	                });


	                _api_register('init()', function () {
	                    var ctx = this.context;
	                    return ctx.length ? ctx[0].oInit : null;
	                });


	                _api_register('data()', function () {
	                    return this.iterator('table', function (settings) {
	                        return _pluck(settings.aoData, '_aData');
	                    }).flatten();
	                });


	                _api_register('destroy()', function (remove) {
	                    remove = remove || false;

	                    return this.iterator('table', function (settings) {
	                        var orig = settings.nTableWrapper.parentNode;
	                        var classes = settings.oClasses;
	                        var table = settings.nTable;
	                        var tbody = settings.nTBody;
	                        var thead = settings.nTHead;
	                        var tfoot = settings.nTFoot;
	                        var jqTable = $(table);
	                        var jqTbody = $(tbody);
	                        var jqWrapper = $(settings.nTableWrapper);
	                        var rows = $.map(settings.aoData, function (r) { return r.nTr; });
	                        var i, ien;

	                        // Flag to note that the table is currently being destroyed - no action
	                        // should be taken
	                        settings.bDestroying = true;

	                        // Fire off the destroy callbacks for plug-ins etc
	                        _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]);

	                        // If not being removed from the document, make all columns visible
	                        if (!remove) {
	                            new _Api(settings).columns().visible(true);
	                        }

	                        // Blitz all `DT` namespaced events (these are internal events, the
	                        // lowercase, `dt` events are user subscribed and they are responsible
	                        // for removing them
	                        jqWrapper.unbind('.DT').find(':not(tbody *)').unbind('.DT');
	                        $(window).unbind('.DT-' + settings.sInstance);

	                        // When scrolling we had to break the table up - restore it
	                        if (table != thead.parentNode) {
	                            jqTable.children('thead').detach();
	                            jqTable.append(thead);
	                        }

	                        if (tfoot && table != tfoot.parentNode) {
	                            jqTable.children('tfoot').detach();
	                            jqTable.append(tfoot);
	                        }

	                        // Remove the DataTables generated nodes, events and classes
	                        jqTable.detach();
	                        jqWrapper.detach();

	                        settings.aaSorting = [];
	                        settings.aaSortingFixed = [];
	                        _fnSortingClasses(settings);

	                        $(rows).removeClass(settings.asStripeClasses.join(' '));

	                        $('th, td', thead).removeClass(classes.sSortable + ' ' +
	                            classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone
	                        );

	                        if (settings.bJUI) {
	                            $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach();
	                            $('th, td', thead).each(function () {
	                                var wrapper = $('div.' + classes.sSortJUIWrapper, this);
	                                $(this).append(wrapper.contents());
	                                wrapper.detach();
	                            });
	                        }

	                        if (!remove && orig) {
	                            // insertBefore acts like appendChild if !arg[1]
	                            orig.insertBefore(table, settings.nTableReinsertBefore);
	                        }

	                        // Add the TR elements back into the table in their original order
	                        jqTbody.children().detach();
	                        jqTbody.append(rows);

	                        // Restore the width of the original table - was read from the style property,
	                        // so we can restore directly to that
	                        jqTable
	                            .css('width', settings.sDestroyWidth)
	                            .removeClass(classes.sTable);

	                        // If the were originally stripe classes - then we add them back here.
	                        // Note this is not fool proof (for example if not all rows had stripe
	                        // classes - but it's a good effort without getting carried away
	                        ien = settings.asDestroyStripes.length;

	                        if (ien) {
	                            jqTbody.children().each(function (i) {
	                                $(this).addClass(settings.asDestroyStripes[i % ien]);
	                            });
	                        }

	                        /* Remove the settings object from the settings array */
	                        var idx = $.inArray(settings, DataTable.settings);
	                        if (idx !== -1) {
	                            DataTable.settings.splice(idx, 1);
	                        }
	                    });
	                });


	                // Add the `every()` method for rows, columns and cells in a compact form
	                $.each(['column', 'row', 'cell'], function (i, type) {
	                    _api_register(type + 's().every()', function (fn) {
	                        return this.iterator(type, function (settings, idx, idx2) {
	                            // idx2 is undefined for rows and columns.
	                            fn.call(new _Api(settings)[type](idx, idx2));
	                        });
	                    });
	                });


	                // i18n method for extensions to be able to use the language object from the
	                // DataTable
	                _api_register('i18n()', function (token, def, plural) {
	                    var ctx = this.context[0];
	                    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);

	                    if (resolved === undefined) {
	                        resolved = def;
	                    }

	                    if (plural !== undefined && $.isPlainObject(resolved)) {
	                        resolved = resolved[plural] !== undefined ?
	                            resolved[plural] :
	                            resolved._;
	                    }

	                    return resolved.replace('%d', plural); // nb: plural might be undefined,
	                });

	                /**
	                 * Version string for plug-ins to check compatibility. Allowed format is
	                 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
	                 * only for non-release builds. See http://semver.org/ for more information.
	                 *  @member
	                 *  @type string
	                 *  @default Version number
	                 */
	                DataTable.version = "1.10.7";

	                /**
	                 * Private data store, containing all of the settings objects that are
	                 * created for the tables on a given page.
	                 *
	                 * Note that the `DataTable.settings` object is aliased to
	                 * `jQuery.fn.dataTableExt` through which it may be accessed and
	                 * manipulated, or `jQuery.fn.dataTable.settings`.
	                 *  @member
	                 *  @type array
	                 *  @default []
	                 *  @private
	                 */
	                DataTable.settings = [];

	                /**
	                 * Object models container, for the various models that DataTables has
	                 * available to it. These models define the objects that are used to hold
	                 * the active state and configuration of the table.
	                 *  @namespace
	                 */
	                DataTable.models = {};



	                /**
	                 * Template object for the way in which DataTables holds information about
	                 * search information for the global filter and individual column filters.
	                 *  @namespace
	                 */
	                DataTable.models.oSearch = {
	                    /**
	                     * Flag to indicate if the filtering should be case insensitive or not
	                     *  @type boolean
	                     *  @default true
	                     */
	                    "bCaseInsensitive": true,

	                    /**
	                     * Applied search term
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     */
	                    "sSearch": "",

	                    /**
	                     * Flag to indicate if the search term should be interpreted as a
	                     * regular expression (true) or not (false) and therefore and special
	                     * regex characters escaped.
	                     *  @type boolean
	                     *  @default false
	                     */
	                    "bRegex": false,

	                    /**
	                     * Flag to indicate if DataTables is to use its smart filtering or not.
	                     *  @type boolean
	                     *  @default true
	                     */
	                    "bSmart": true
	                };




	                /**
	                 * Template object for the way in which DataTables holds information about
	                 * each individual row. This is the object format used for the settings
	                 * aoData array.
	                 *  @namespace
	                 */
	                DataTable.models.oRow = {
	                    /**
	                     * TR element for the row
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTr": null,

	                    /**
	                     * Array of TD elements for each row. This is null until the row has been
	                     * created.
	                     *  @type array nodes
	                     *  @default []
	                     */
	                    "anCells": null,

	                    /**
	                     * Data object from the original data source for the row. This is either
	                     * an array if using the traditional form of DataTables, or an object if
	                     * using mData options. The exact type will depend on the passed in
	                     * data from the data source, or will be an array if using DOM a data
	                     * source.
	                     *  @type array|object
	                     *  @default []
	                     */
	                    "_aData": [],

	                    /**
	                     * Sorting data cache - this array is ostensibly the same length as the
	                     * number of columns (although each index is generated only as it is
	                     * needed), and holds the data that is used for sorting each column in the
	                     * row. We do this cache generation at the start of the sort in order that
	                     * the formatting of the sort data need be done only once for each cell
	                     * per sort. This array should not be read from or written to by anything
	                     * other than the master sorting methods.
	                     *  @type array
	                     *  @default null
	                     *  @private
	                     */
	                    "_aSortData": null,

	                    /**
	                     * Per cell filtering data cache. As per the sort data cache, used to
	                     * increase the performance of the filtering in DataTables
	                     *  @type array
	                     *  @default null
	                     *  @private
	                     */
	                    "_aFilterData": null,

	                    /**
	                     * Filtering data cache. This is the same as the cell filtering cache, but
	                     * in this case a string rather than an array. This is easily computed with
	                     * a join on `_aFilterData`, but is provided as a cache so the join isn't
	                     * needed on every search (memory traded for performance)
	                     *  @type array
	                     *  @default null
	                     *  @private
	                     */
	                    "_sFilterRow": null,

	                    /**
	                     * Cache of the class name that DataTables has applied to the row, so we
	                     * can quickly look at this variable rather than needing to do a DOM check
	                     * on className for the nTr property.
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     *  @private
	                     */
	                    "_sRowStripe": "",

	                    /**
	                     * Denote if the original data source was from the DOM, or the data source
	                     * object. This is used for invalidating data, so DataTables can
	                     * automatically read data from the original source, unless uninstructed
	                     * otherwise.
	                     *  @type string
	                     *  @default null
	                     *  @private
	                     */
	                    "src": null
	                };


	                /**
	                 * Template object for the column information object in DataTables. This object
	                 * is held in the settings aoColumns array and contains all the information that
	                 * DataTables needs about each individual column.
	                 *
	                 * Note that this object is related to {@link DataTable.defaults.column}
	                 * but this one is the internal data store for DataTables's cache of columns.
	                 * It should NOT be manipulated outside of DataTables. Any configuration should
	                 * be done through the initialisation options.
	                 *  @namespace
	                 */
	                DataTable.models.oColumn = {
	                    /**
	                     * Column index. This could be worked out on-the-fly with $.inArray, but it
	                     * is faster to just hold it as a variable
	                     *  @type integer
	                     *  @default null
	                     */
	                    "idx": null,

	                    /**
	                     * A list of the columns that sorting should occur on when this column
	                     * is sorted. That this property is an array allows multi-column sorting
	                     * to be defined for a column (for example first name / last name columns
	                     * would benefit from this). The values are integers pointing to the
	                     * columns to be sorted on (typically it will be a single integer pointing
	                     * at itself, but that doesn't need to be the case).
	                     *  @type array
	                     */
	                    "aDataSort": null,

	                    /**
	                     * Define the sorting directions that are applied to the column, in sequence
	                     * as the column is repeatedly sorted upon - i.e. the first value is used
	                     * as the sorting direction when the column if first sorted (clicked on).
	                     * Sort it again (click again) and it will move on to the next index.
	                     * Repeat until loop.
	                     *  @type array
	                     */
	                    "asSorting": null,

	                    /**
	                     * Flag to indicate if the column is searchable, and thus should be included
	                     * in the filtering or not.
	                     *  @type boolean
	                     */
	                    "bSearchable": null,

	                    /**
	                     * Flag to indicate if the column is sortable or not.
	                     *  @type boolean
	                     */
	                    "bSortable": null,

	                    /**
	                     * Flag to indicate if the column is currently visible in the table or not
	                     *  @type boolean
	                     */
	                    "bVisible": null,

	                    /**
	                     * Store for manual type assignment using the `column.type` option. This
	                     * is held in store so we can manipulate the column's `sType` property.
	                     *  @type string
	                     *  @default null
	                     *  @private
	                     */
	                    "_sManualType": null,

	                    /**
	                     * Flag to indicate if HTML5 data attributes should be used as the data
	                     * source for filtering or sorting. True is either are.
	                     *  @type boolean
	                     *  @default false
	                     *  @private
	                     */
	                    "_bAttrSrc": false,

	                    /**
	                     * Developer definable function that is called whenever a cell is created (Ajax source,
	                     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	                     * allowing you to modify the DOM element (add background colour for example) when the
	                     * element is available.
	                     *  @type function
	                     *  @param {element} nTd The TD node that has been created
	                     *  @param {*} sData The Data for the cell
	                     *  @param {array|object} oData The data for the whole row
	                     *  @param {int} iRow The row index for the aoData data store
	                     *  @default null
	                     */
	                    "fnCreatedCell": null,

	                    /**
	                     * Function to get data from a cell in a column. You should <b>never</b>
	                     * access data directly through _aData internally in DataTables - always use
	                     * the method attached to this property. It allows mData to function as
	                     * required. This function is automatically assigned by the column
	                     * initialisation method
	                     *  @type function
	                     *  @param {array|object} oData The data array/object for the array
	                     *    (i.e. aoData[]._aData)
	                     *  @param {string} sSpecific The specific data type you want to get -
	                     *    'display', 'type' 'filter' 'sort'
	                     *  @returns {*} The data for the cell from the given row's data
	                     *  @default null
	                     */
	                    "fnGetData": null,

	                    /**
	                     * Function to set data for a cell in the column. You should <b>never</b>
	                     * set the data directly to _aData internally in DataTables - always use
	                     * this method. It allows mData to function as required. This function
	                     * is automatically assigned by the column initialisation method
	                     *  @type function
	                     *  @param {array|object} oData The data array/object for the array
	                     *    (i.e. aoData[]._aData)
	                     *  @param {*} sValue Value to set
	                     *  @default null
	                     */
	                    "fnSetData": null,

	                    /**
	                     * Property to read the value for the cells in the column from the data
	                     * source array / object. If null, then the default content is used, if a
	                     * function is given then the return from the function is used.
	                     *  @type function|int|string|null
	                     *  @default null
	                     */
	                    "mData": null,

	                    /**
	                     * Partner property to mData which is used (only when defined) to get
	                     * the data - i.e. it is basically the same as mData, but without the
	                     * 'set' option, and also the data fed to it is the result from mData.
	                     * This is the rendering method to match the data method of mData.
	                     *  @type function|int|string|null
	                     *  @default null
	                     */
	                    "mRender": null,

	                    /**
	                     * Unique header TH/TD element for this column - this is what the sorting
	                     * listener is attached to (if sorting is enabled.)
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTh": null,

	                    /**
	                     * Unique footer TH/TD element for this column (if there is one). Not used
	                     * in DataTables as such, but can be used for plug-ins to reference the
	                     * footer for each column.
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTf": null,

	                    /**
	                     * The class to apply to all TD elements in the table's TBODY for the column
	                     *  @type string
	                     *  @default null
	                     */
	                    "sClass": null,

	                    /**
	                     * When DataTables calculates the column widths to assign to each column,
	                     * it finds the longest string in each column and then constructs a
	                     * temporary table and reads the widths from that. The problem with this
	                     * is that "mmm" is much wider then "iiii", but the latter is a longer
	                     * string - thus the calculation can go wrong (doing it properly and putting
	                     * it into an DOM object and measuring that is horribly(!) slow). Thus as
	                     * a "work around" we provide this option. It will append its value to the
	                     * text that is found to be the longest string for the column - i.e. padding.
	                     *  @type string
	                     */
	                    "sContentPadding": null,

	                    /**
	                     * Allows a default value to be given for a column's data, and will be used
	                     * whenever a null data source is encountered (this can be because mData
	                     * is set to null, or because the data source itself is null).
	                     *  @type string
	                     *  @default null
	                     */
	                    "sDefaultContent": null,

	                    /**
	                     * Name for the column, allowing reference to the column by name as well as
	                     * by index (needs a lookup to work by name).
	                     *  @type string
	                     */
	                    "sName": null,

	                    /**
	                     * Custom sorting data type - defines which of the available plug-ins in
	                     * afnSortData the custom sorting will use - if any is defined.
	                     *  @type string
	                     *  @default std
	                     */
	                    "sSortDataType": 'std',

	                    /**
	                     * Class to be applied to the header element when sorting on this column
	                     *  @type string
	                     *  @default null
	                     */
	                    "sSortingClass": null,

	                    /**
	                     * Class to be applied to the header element when sorting on this column -
	                     * when jQuery UI theming is used.
	                     *  @type string
	                     *  @default null
	                     */
	                    "sSortingClassJUI": null,

	                    /**
	                     * Title of the column - what is seen in the TH element (nTh).
	                     *  @type string
	                     */
	                    "sTitle": null,

	                    /**
	                     * Column sorting and filtering type
	                     *  @type string
	                     *  @default null
	                     */
	                    "sType": null,

	                    /**
	                     * Width of the column
	                     *  @type string
	                     *  @default null
	                     */
	                    "sWidth": null,

	                    /**
	                     * Width of the column when it was first "encountered"
	                     *  @type string
	                     *  @default null
	                     */
	                    "sWidthOrig": null
	                };


	                /*
	                 * Developer note: The properties of the object below are given in Hungarian
	                 * notation, that was used as the interface for DataTables prior to v1.10, however
	                 * from v1.10 onwards the primary interface is camel case. In order to avoid
	                 * breaking backwards compatibility utterly with this change, the Hungarian
	                 * version is still, internally the primary interface, but is is not documented
	                 * - hence the @name tags in each doc comment. This allows a Javascript function
	                 * to create a map from Hungarian notation to camel case (going the other direction
	                 * would require each property to be listed, which would at around 3K to the size
	                 * of DataTables, while this method is about a 0.5K hit.
	                 *
	                 * Ultimately this does pave the way for Hungarian notation to be dropped
	                 * completely, but that is a massive amount of work and will break current
	                 * installs (therefore is on-hold until v2).
	                 */

	                /**
	                 * Initialisation options that can be given to DataTables at initialisation
	                 * time.
	                 *  @namespace
	                 */
	                DataTable.defaults = {
	                    /**
	                     * An array of data to use for the table, passed in at initialisation which
	                     * will be used in preference to any data which is already in the DOM. This is
	                     * particularly useful for constructing tables purely in Javascript, for
	                     * example with a custom Ajax call.
	                     *  @type array
	                     *  @default null
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.data
	                     *
	                     *  @example
	                     *    // Using a 2D array data source
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "data": [
	                     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
	                     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
	                     *        ],
	                     *        "columns": [
	                     *          { "title": "Engine" },
	                     *          { "title": "Browser" },
	                     *          { "title": "Platform" },
	                     *          { "title": "Version" },
	                     *          { "title": "Grade" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using an array of objects as a data source (`data`)
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "data": [
	                     *          {
	                     *            "engine":   "Trident",
	                     *            "browser":  "Internet Explorer 4.0",
	                     *            "platform": "Win 95+",
	                     *            "version":  4,
	                     *            "grade":    "X"
	                     *          },
	                     *          {
	                     *            "engine":   "Trident",
	                     *            "browser":  "Internet Explorer 5.0",
	                     *            "platform": "Win 95+",
	                     *            "version":  5,
	                     *            "grade":    "C"
	                     *          }
	                     *        ],
	                     *        "columns": [
	                     *          { "title": "Engine",   "data": "engine" },
	                     *          { "title": "Browser",  "data": "browser" },
	                     *          { "title": "Platform", "data": "platform" },
	                     *          { "title": "Version",  "data": "version" },
	                     *          { "title": "Grade",    "data": "grade" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "aaData": null,


	                    /**
	                     * If ordering is enabled, then DataTables will perform a first pass sort on
	                     * initialisation. You can define which column(s) the sort is performed
	                     * upon, and the sorting direction, with this variable. The `sorting` array
	                     * should contain an array for each column to be sorted initially containing
	                     * the column's index and a direction string ('asc' or 'desc').
	                     *  @type array
	                     *  @default [[0,'asc']]
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.order
	                     *
	                     *  @example
	                     *    // Sort by 3rd column first, and then 4th column
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "order": [[2,'asc'], [3,'desc']]
	                     *      } );
	                     *    } );
	                     *
	                     *    // No initial sorting
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "order": []
	                     *      } );
	                     *    } );
	                     */
	                    "aaSorting": [[0, 'asc']],


	                    /**
	                     * This parameter is basically identical to the `sorting` parameter, but
	                     * cannot be overridden by user interaction with the table. What this means
	                     * is that you could have a column (visible or hidden) which the sorting
	                     * will always be forced on first - any sorting after that (from the user)
	                     * will then be performed as required. This can be useful for grouping rows
	                     * together.
	                     *  @type array
	                     *  @default null
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.orderFixed
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "orderFixed": [[0,'asc']]
	                     *      } );
	                     *    } )
	                     */
	                    "aaSortingFixed": [],


	                    /**
	                     * DataTables can be instructed to load data to display in the table from a
	                     * Ajax source. This option defines how that Ajax call is made and where to.
	                     *
	                     * The `ajax` property has three different modes of operation, depending on
	                     * how it is defined. These are:
	                     *
	                     * * `string` - Set the URL from where the data should be loaded from.
	                     * * `object` - Define properties for `jQuery.ajax`.
	                     * * `function` - Custom data get function
	                     *
	                     * `string`
	                     * --------
	                     *
	                     * As a string, the `ajax` property simply defines the URL from which
	                     * DataTables will load data.
	                     *
	                     * `object`
	                     * --------
	                     *
	                     * As an object, the parameters in the object are passed to
	                     * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control
	                     * of the Ajax request. DataTables has a number of default parameters which
	                     * you can override using this option. Please refer to the jQuery
	                     * documentation for a full description of the options available, although
	                     * the following parameters provide additional options in DataTables or
	                     * require special consideration:
	                     *
	                     * * `data` - As with jQuery, `data` can be provided as an object, but it
	                     *   can also be used as a function to manipulate the data DataTables sends
	                     *   to the server. The function takes a single parameter, an object of
	                     *   parameters with the values that DataTables has readied for sending. An
	                     *   object may be returned which will be merged into the DataTables
	                     *   defaults, or you can add the items to the object that was passed in and
	                     *   not return anything from the function. This supersedes `fnServerParams`
	                     *   from DataTables 1.9-.
	                     *
	                     * * `dataSrc` - By default DataTables will look for the property `data` (or
	                     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
	                     *   from an Ajax source or for server-side processing - this parameter
	                     *   allows that property to be changed. You can use Javascript dotted
	                     *   object notation to get a data source for multiple levels of nesting, or
	                     *   it my be used as a function. As a function it takes a single parameter,
	                     *   the JSON returned from the server, which can be manipulated as
	                     *   required, with the returned value being that used by DataTables as the
	                     *   data source for the table. This supersedes `sAjaxDataProp` from
	                     *   DataTables 1.9-.
	                     *
	                     * * `success` - Should not be overridden it is used internally in
	                     *   DataTables. To manipulate / transform the data returned by the server
	                     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
	                     *
	                     * `function`
	                     * ----------
	                     *
	                     * As a function, making the Ajax call is left up to yourself allowing
	                     * complete control of the Ajax request. Indeed, if desired, a method other
	                     * than Ajax could be used to obtain the required data, such as Web storage
	                     * or an AIR database.
	                     *
	                     * The function is given four parameters and no return is required. The
	                     * parameters are:
	                     *
	                     * 1. _object_ - Data to send to the server
	                     * 2. _function_ - Callback function that must be executed when the required
	                     *    data has been obtained. That data should be passed into the callback
	                     *    as the only parameter
	                     * 3. _object_ - DataTables settings object for the table
	                     *
	                     * Note that this supersedes `fnServerData` from DataTables 1.9-.
	                     *
	                     *  @type string|object|function
	                     *  @default null
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.ajax
	                     *  @since 1.10.0
	                     *
	                     * @example
	                     *   // Get JSON data from a file via Ajax.
	                     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
	                     *   $('#example').dataTable( {
	                     *     "ajax": "data.json"
	                     *   } );
	                     *
	                     * @example
	                     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
	                     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "dataSrc": "tableData"
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
	                     *   // from a plain array rather than an array in an object
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "dataSrc": ""
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Manipulate the data returned from the server - add a link to data
	                     *   // (note this can, should, be done using `render` for the column - this
	                     *   // is just a simple example of how the data can be manipulated).
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "dataSrc": function ( json ) {
	                     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
	                     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
	                     *         }
	                     *         return json;
	                     *       }
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Add data to the request
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "data": function ( d ) {
	                     *         return {
	                     *           "extra_search": $('#extra').val()
	                     *         };
	                     *       }
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Send request as POST
	                     *   $('#example').dataTable( {
	                     *     "ajax": {
	                     *       "url": "data.json",
	                     *       "type": "POST"
	                     *     }
	                     *   } );
	                     *
	                     * @example
	                     *   // Get the data from localStorage (could interface with a form for
	                     *   // adding, editing and removing rows).
	                     *   $('#example').dataTable( {
	                     *     "ajax": function (data, callback, settings) {
	                     *       callback(
	                     *         JSON.parse( localStorage.getItem('dataTablesData') )
	                     *       );
	                     *     }
	                     *   } );
	                     */
	                    "ajax": null,


	                    /**
	                     * This parameter allows you to readily specify the entries in the length drop
	                     * down menu that DataTables shows when pagination is enabled. It can be
	                     * either a 1D array of options which will be used for both the displayed
	                     * option and the value, or a 2D array which will use the array in the first
	                     * position as the value, and the array in the second position as the
	                     * displayed options (useful for language strings such as 'All').
	                     *
	                     * Note that the `pageLength` property will be automatically set to the
	                     * first value given in this array, unless `pageLength` is also provided.
	                     *  @type array
	                     *  @default [ 10, 25, 50, 100 ]
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.lengthMenu
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
	                     *      } );
	                     *    } );
	                     */
	                    "aLengthMenu": [10, 25, 50, 100],


	                    /**
	                     * The `columns` option in the initialisation parameter allows you to define
	                     * details about the way individual columns behave. For a full list of
	                     * column options that can be set, please see
	                     * {@link DataTable.defaults.column}. Note that if you use `columns` to
	                     * define your columns, you must have an entry in the array for every single
	                     * column that you have in your table (these can be null if you don't which
	                     * to specify any options).
	                     *  @member
	                     *
	                     *  @name DataTable.defaults.column
	                     */
	                    "aoColumns": null,

	                    /**
	                     * Very similar to `columns`, `columnDefs` allows you to target a specific
	                     * column, multiple columns, or all columns, using the `targets` property of
	                     * each object in the array. This allows great flexibility when creating
	                     * tables, as the `columnDefs` arrays can be of any length, targeting the
	                     * columns you specifically want. `columnDefs` may use any of the column
	                     * options available: {@link DataTable.defaults.column}, but it _must_
	                     * have `targets` defined in each object in the array. Values in the `targets`
	                     * array may be:
	                     *   <ul>
	                     *     <li>a string - class name will be matched on the TH for the column</li>
	                     *     <li>0 or a positive integer - column index counting from the left</li>
	                     *     <li>a negative integer - column index counting from the right</li>
	                     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
	                     *   </ul>
	                     *  @member
	                     *
	                     *  @name DataTable.defaults.columnDefs
	                     */
	                    "aoColumnDefs": null,


	                    /**
	                     * Basically the same as `search`, this parameter defines the individual column
	                     * filtering state at initialisation time. The array must be of the same size
	                     * as the number of columns, and each element be an object with the parameters
	                     * `search` and `escapeRegex` (the latter is optional). 'null' is also
	                     * accepted and the default will be used.
	                     *  @type array
	                     *  @default []
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.searchCols
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "searchCols": [
	                     *          null,
	                     *          { "search": "My filter" },
	                     *          null,
	                     *          { "search": "^[0-9]", "escapeRegex": false }
	                     *        ]
	                     *      } );
	                     *    } )
	                     */
	                    "aoSearchCols": [],


	                    /**
	                     * An array of CSS classes that should be applied to displayed rows. This
	                     * array may be of any length, and DataTables will apply each class
	                     * sequentially, looping when required.
	                     *  @type array
	                     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
	                     *    options</i>
	                     *
	                     *  @dtopt Option
	                     *  @name DataTable.defaults.stripeClasses
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
	                     *      } );
	                     *    } )
	                     */
	                    "asStripeClasses": null,


	                    /**
	                     * Enable or disable automatic column width calculation. This can be disabled
	                     * as an optimisation (it takes some time to calculate the widths) if the
	                     * tables widths are passed in using `columns`.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.autoWidth
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "autoWidth": false
	                     *      } );
	                     *    } );
	                     */
	                    "bAutoWidth": true,


	                    /**
	                     * Deferred rendering can provide DataTables with a huge speed boost when you
	                     * are using an Ajax or JS data source for the table. This option, when set to
	                     * true, will cause DataTables to defer the creation of the table elements for
	                     * each row until they are needed for a draw - saving a significant amount of
	                     * time.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.deferRender
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "ajax": "sources/arrays.txt",
	                     *        "deferRender": true
	                     *      } );
	                     *    } );
	                     */
	                    "bDeferRender": false,


	                    /**
	                     * Replace a DataTable which matches the given selector and replace it with
	                     * one which has the properties of the new initialisation object passed. If no
	                     * table matches the selector, then the new DataTable will be constructed as
	                     * per normal.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.destroy
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "srollY": "200px",
	                     *        "paginate": false
	                     *      } );
	                     *
	                     *      // Some time later....
	                     *      $('#example').dataTable( {
	                     *        "filter": false,
	                     *        "destroy": true
	                     *      } );
	                     *    } );
	                     */
	                    "bDestroy": false,


	                    /**
	                     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
	                     * that it allows the end user to input multiple words (space separated) and
	                     * will match a row containing those words, even if not in the order that was
	                     * specified (this allow matching across multiple columns). Note that if you
	                     * wish to use filtering in DataTables this must remain 'true' - to remove the
	                     * default filtering input box and retain filtering abilities, please use
	                     * {@link DataTable.defaults.dom}.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.searching
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "searching": false
	                     *      } );
	                     *    } );
	                     */
	                    "bFilter": true,


	                    /**
	                     * Enable or disable the table information display. This shows information
	                     * about the data that is currently visible on the page, including information
	                     * about filtered data if that action is being performed.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.info
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "info": false
	                     *      } );
	                     *    } );
	                     */
	                    "bInfo": true,


	                    /**
	                     * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
	                     * slightly different and additional mark-up from what DataTables has
	                     * traditionally used).
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.jQueryUI
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "jQueryUI": true
	                     *      } );
	                     *    } );
	                     */
	                    "bJQueryUI": false,


	                    /**
	                     * Allows the end user to select the size of a formatted page from a select
	                     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.lengthChange
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "lengthChange": false
	                     *      } );
	                     *    } );
	                     */
	                    "bLengthChange": true,


	                    /**
	                     * Enable or disable pagination.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.paging
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "paging": false
	                     *      } );
	                     *    } );
	                     */
	                    "bPaginate": true,


	                    /**
	                     * Enable or disable the display of a 'processing' indicator when the table is
	                     * being processed (e.g. a sort). This is particularly useful for tables with
	                     * large amounts of data where it can take a noticeable amount of time to sort
	                     * the entries.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.processing
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "processing": true
	                     *      } );
	                     *    } );
	                     */
	                    "bProcessing": false,


	                    /**
	                     * Retrieve the DataTables object for the given selector. Note that if the
	                     * table has already been initialised, this parameter will cause DataTables
	                     * to simply return the object that has already been set up - it will not take
	                     * account of any changes you might have made to the initialisation object
	                     * passed to DataTables (setting this parameter to true is an acknowledgement
	                     * that you understand this). `destroy` can be used to reinitialise a table if
	                     * you need.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.retrieve
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      initTable();
	                     *      tableActions();
	                     *    } );
	                     *
	                     *    function initTable ()
	                     *    {
	                     *      return $('#example').dataTable( {
	                     *        "scrollY": "200px",
	                     *        "paginate": false,
	                     *        "retrieve": true
	                     *      } );
	                     *    }
	                     *
	                     *    function tableActions ()
	                     *    {
	                     *      var table = initTable();
	                     *      // perform API operations with oTable
	                     *    }
	                     */
	                    "bRetrieve": false,


	                    /**
	                     * When vertical (y) scrolling is enabled, DataTables will force the height of
	                     * the table's viewport to the given height at all times (useful for layout).
	                     * However, this can look odd when filtering data down to a small data set,
	                     * and the footer is left "floating" further down. This parameter (when
	                     * enabled) will cause DataTables to collapse the table's viewport down when
	                     * the result set will fit within the given Y height.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.scrollCollapse
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "scrollY": "200",
	                     *        "scrollCollapse": true
	                     *      } );
	                     *    } );
	                     */
	                    "bScrollCollapse": false,


	                    /**
	                     * Configure DataTables to use server-side processing. Note that the
	                     * `ajax` parameter must also be given in order to give DataTables a
	                     * source to obtain the required data for each draw.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.serverSide
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "serverSide": true,
	                     *        "ajax": "xhr.php"
	                     *      } );
	                     *    } );
	                     */
	                    "bServerSide": false,


	                    /**
	                     * Enable or disable sorting of columns. Sorting of individual columns can be
	                     * disabled by the `sortable` option for each column.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.ordering
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "ordering": false
	                     *      } );
	                     *    } );
	                     */
	                    "bSort": true,


	                    /**
	                     * Enable or display DataTables' ability to sort multiple columns at the
	                     * same time (activated by shift-click by the user).
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.orderMulti
	                     *
	                     *  @example
	                     *    // Disable multiple column sorting ability
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "orderMulti": false
	                     *      } );
	                     *    } );
	                     */
	                    "bSortMulti": true,


	                    /**
	                     * Allows control over whether DataTables should use the top (true) unique
	                     * cell that is found for a single column, or the bottom (false - default).
	                     * This is useful when using complex headers.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.orderCellsTop
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "orderCellsTop": true
	                     *      } );
	                     *    } );
	                     */
	                    "bSortCellsTop": false,


	                    /**
	                     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
	                     * `sorting\_3` to the columns which are currently being sorted on. This is
	                     * presented as a feature switch as it can increase processing time (while
	                     * classes are removed and added) so for large data sets you might want to
	                     * turn this off.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.orderClasses
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "orderClasses": false
	                     *      } );
	                     *    } );
	                     */
	                    "bSortClasses": true,


	                    /**
	                     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
	                     * used to save table display information such as pagination information,
	                     * display length, filtering and sorting. As such when the end user reloads
	                     * the page the display display will match what thy had previously set up.
	                     *
	                     * Due to the use of `localStorage` the default state saving is not supported
	                     * in IE6 or 7. If state saving is required in those browsers, use
	                     * `stateSaveCallback` to provide a storage solution such as cookies.
	                     *  @type boolean
	                     *  @default false
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.stateSave
	                     *
	                     *  @example
	                     *    $(document).ready( function () {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true
	                     *      } );
	                     *    } );
	                     */
	                    "bStateSave": false,


	                    /**
	                     * This function is called when a TR element is created (and all TD child
	                     * elements have been inserted), or registered if using a DOM source, allowing
	                     * manipulation of the TR element (adding classes etc).
	                     *  @type function
	                     *  @param {node} row "TR" element for the current row
	                     *  @param {array} data Raw data array for this row
	                     *  @param {int} dataIndex The index of this row in the internal aoData array
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.createdRow
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "createdRow": function( row, data, dataIndex ) {
	                     *          // Bold the grade for all 'A' grade browsers
	                     *          if ( data[4] == "A" )
	                     *          {
	                     *            $('td:eq(4)', row).html( '<b>A</b>' );
	                     *          }
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnCreatedRow": null,


	                    /**
	                     * This function is called on every 'draw' event, and allows you to
	                     * dynamically modify any aspect you want about the created DOM.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.drawCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "drawCallback": function( settings ) {
	                     *          alert( 'DataTables has redrawn the table' );
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnDrawCallback": null,


	                    /**
	                     * Identical to fnHeaderCallback() but for the table footer this function
	                     * allows you to modify the table footer on every 'draw' event.
	                     *  @type function
	                     *  @param {node} foot "TR" element for the footer
	                     *  @param {array} data Full table data (as derived from the original HTML)
	                     *  @param {int} start Index for the current display starting point in the
	                     *    display array
	                     *  @param {int} end Index for the current display ending point in the
	                     *    display array
	                     *  @param {array int} display Index array to translate the visual position
	                     *    to the full data array
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.footerCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "footerCallback": function( tfoot, data, start, end, display ) {
	                     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
	                     *        }
	                     *      } );
	                     *    } )
	                     */
	                    "fnFooterCallback": null,


	                    /**
	                     * When rendering large numbers in the information element for the table
	                     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
	                     * to have a comma separator for the 'thousands' units (e.g. 1 million is
	                     * rendered as "1,000,000") to help readability for the end user. This
	                     * function will override the default method DataTables uses.
	                     *  @type function
	                     *  @member
	                     *  @param {int} toFormat number to be formatted
	                     *  @returns {string} formatted string for DataTables to show the number
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.formatNumber
	                     *
	                     *  @example
	                     *    // Format a number using a single quote for the separator (note that
	                     *    // this can also be done with the language.thousands option)
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "formatNumber": function ( toFormat ) {
	                     *          return toFormat.toString().replace(
	                     *            /\B(?=(\d{3})+(?!\d))/g, "'"
	                     *          );
	                     *        };
	                     *      } );
	                     *    } );
	                     */
	                    "fnFormatNumber": function (toFormat) {
	                        return toFormat.toString().replace(
	                            /\B(?=(\d{3})+(?!\d))/g,
	                            this.oLanguage.sThousands
	                        );
	                    },


	                    /**
	                     * This function is called on every 'draw' event, and allows you to
	                     * dynamically modify the header row. This can be used to calculate and
	                     * display useful information about the table.
	                     *  @type function
	                     *  @param {node} head "TR" element for the header
	                     *  @param {array} data Full table data (as derived from the original HTML)
	                     *  @param {int} start Index for the current display starting point in the
	                     *    display array
	                     *  @param {int} end Index for the current display ending point in the
	                     *    display array
	                     *  @param {array int} display Index array to translate the visual position
	                     *    to the full data array
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.headerCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "fheaderCallback": function( head, data, start, end, display ) {
	                     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
	                     *        }
	                     *      } );
	                     *    } )
	                     */
	                    "fnHeaderCallback": null,


	                    /**
	                     * The information element can be used to convey information about the current
	                     * state of the table. Although the internationalisation options presented by
	                     * DataTables are quite capable of dealing with most customisations, there may
	                     * be times where you wish to customise the string further. This callback
	                     * allows you to do exactly that.
	                     *  @type function
	                     *  @param {object} oSettings DataTables settings object
	                     *  @param {int} start Starting position in data for the draw
	                     *  @param {int} end End position in data for the draw
	                     *  @param {int} max Total number of rows in the table (regardless of
	                     *    filtering)
	                     *  @param {int} total Total number of rows in the data set, after filtering
	                     *  @param {string} pre The string that DataTables has formatted using it's
	                     *    own rules
	                     *  @returns {string} The string to be displayed in the information element.
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.infoCallback
	                     *
	                     *  @example
	                     *    $('#example').dataTable( {
	                     *      "infoCallback": function( settings, start, end, max, total, pre ) {
	                     *        return start +" to "+ end;
	                     *      }
	                     *    } );
	                     */
	                    "fnInfoCallback": null,


	                    /**
	                     * Called when the table has been initialised. Normally DataTables will
	                     * initialise sequentially and there will be no need for this function,
	                     * however, this does not hold true when using external language information
	                     * since that is obtained using an async XHR call.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} json The JSON object request from the server - only
	                     *    present if client-side Ajax sourced data is used
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.initComplete
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "initComplete": function(settings, json) {
	                     *          alert( 'DataTables has finished its initialisation.' );
	                     *        }
	                     *      } );
	                     *    } )
	                     */
	                    "fnInitComplete": null,


	                    /**
	                     * Called at the very start of each table draw and can be used to cancel the
	                     * draw by returning false, any other return (including undefined) results in
	                     * the full draw occurring).
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @returns {boolean} False will cancel the draw, anything else (including no
	                     *    return) will allow it to complete.
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.preDrawCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "preDrawCallback": function( settings ) {
	                     *          if ( $('#test').val() == 1 ) {
	                     *            return false;
	                     *          }
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnPreDrawCallback": null,


	                    /**
	                     * This function allows you to 'post process' each row after it have been
	                     * generated for each table draw, but before it is rendered on screen. This
	                     * function might be used for setting the row class name etc.
	                     *  @type function
	                     *  @param {node} row "TR" element for the current row
	                     *  @param {array} data Raw data array for this row
	                     *  @param {int} displayIndex The display index for the current table draw
	                     *  @param {int} displayIndexFull The index of the data in the full list of
	                     *    rows (after filtering)
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.rowCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
	                     *          // Bold the grade for all 'A' grade browsers
	                     *          if ( data[4] == "A" ) {
	                     *            $('td:eq(4)', row).html( '<b>A</b>' );
	                     *          }
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnRowCallback": null,


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     * This parameter allows you to override the default function which obtains
	                     * the data from the server so something more suitable for your application.
	                     * For example you could use POST data, or pull information from a Gears or
	                     * AIR database.
	                     *  @type function
	                     *  @member
	                     *  @param {string} source HTTP source to obtain the data from (`ajax`)
	                     *  @param {array} data A key/value pair object containing the data to send
	                     *    to the server
	                     *  @param {function} callback to be called on completion of the data get
	                     *    process that will draw the data on the page.
	                     *  @param {object} settings DataTables settings object
	                     *
	                     *  @dtopt Callbacks
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.serverData
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "fnServerData": null,


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     *  It is often useful to send extra data to the server when making an Ajax
	                     * request - for example custom filtering information, and this callback
	                     * function makes it trivial to send extra information to the server. The
	                     * passed in parameter is the data set that has been constructed by
	                     * DataTables, and you can add to this or modify it as you require.
	                     *  @type function
	                     *  @param {array} data Data array (array of objects which are name/value
	                     *    pairs) that has been constructed by DataTables and will be sent to the
	                     *    server. In the case of Ajax sourced data with server-side processing
	                     *    this will be an empty array, for server-side processing there will be a
	                     *    significant number of parameters!
	                     *  @returns {undefined} Ensure that you modify the data array passed in,
	                     *    as this is passed by reference.
	                     *
	                     *  @dtopt Callbacks
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.serverParams
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "fnServerParams": null,


	                    /**
	                     * Load the table state. With this function you can define from where, and how, the
	                     * state of a table is loaded. By default DataTables will load from `localStorage`
	                     * but you might wish to use a server-side database or cookies.
	                     *  @type function
	                     *  @member
	                     *  @param {object} settings DataTables settings object
	                     *  @return {object} The DataTables state object to be loaded
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateLoadCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateLoadCallback": function (settings) {
	                     *          var o;
	                     *
	                     *          // Send an Ajax request to the server to get the data. Note that
	                     *          // this is a synchronous request.
	                     *          $.ajax( {
	                     *            "url": "/state_load",
	                     *            "async": false,
	                     *            "dataType": "json",
	                     *            "success": function (json) {
	                     *              o = json;
	                     *            }
	                     *          } );
	                     *
	                     *          return o;
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateLoadCallback": function (settings) {
	                        try {
	                            return JSON.parse(
	                                (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
	                                    'DataTables_' + settings.sInstance + '_' + location.pathname
	                                )
	                            );
	                        } catch (e) { }
	                    },


	                    /**
	                     * Callback which allows modification of the saved state prior to loading that state.
	                     * This callback is called when the table is loading state from the stored data, but
	                     * prior to the settings object being modified by the saved state. Note that for
	                     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
	                     * a plug-in.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} data The state object that is to be loaded
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateLoadParams
	                     *
	                     *  @example
	                     *    // Remove a saved filter, so filtering is never loaded
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateLoadParams": function (settings, data) {
	                     *          data.oSearch.sSearch = "";
	                     *        }
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Disallow state loading by returning false
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateLoadParams": function (settings, data) {
	                     *          return false;
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateLoadParams": null,


	                    /**
	                     * Callback that is called when the state has been loaded from the state saving method
	                     * and the DataTables settings object has been modified as a result of the loaded state.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} data The state object that was loaded
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateLoaded
	                     *
	                     *  @example
	                     *    // Show an alert with the filtering value that was saved
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateLoaded": function (settings, data) {
	                     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateLoaded": null,


	                    /**
	                     * Save the table state. This function allows you to define where and how the state
	                     * information for the table is stored By default DataTables will use `localStorage`
	                     * but you might wish to use a server-side database or cookies.
	                     *  @type function
	                     *  @member
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} data The state object to be saved
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateSaveCallback
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateSaveCallback": function (settings, data) {
	                     *          // Send an Ajax request to the server with the state object
	                     *          $.ajax( {
	                     *            "url": "/state_save",
	                     *            "data": data,
	                     *            "dataType": "json",
	                     *            "method": "POST"
	                     *            "success": function () {}
	                     *          } );
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateSaveCallback": function (settings, data) {
	                        try {
	                            (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
	                                'DataTables_' + settings.sInstance + '_' + location.pathname,
	                                JSON.stringify(data)
	                            );
	                        } catch (e) { }
	                    },


	                    /**
	                     * Callback which allows modification of the state to be saved. Called when the table
	                     * has changed state a new state save is required. This method allows modification of
	                     * the state saving object prior to actually doing the save, including addition or
	                     * other state properties or modification. Note that for plug-in authors, you should
	                     * use the `stateSaveParams` event to save parameters for a plug-in.
	                     *  @type function
	                     *  @param {object} settings DataTables settings object
	                     *  @param {object} data The state object to be saved
	                     *
	                     *  @dtopt Callbacks
	                     *  @name DataTable.defaults.stateSaveParams
	                     *
	                     *  @example
	                     *    // Remove a saved filter, so filtering is never saved
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateSave": true,
	                     *        "stateSaveParams": function (settings, data) {
	                     *          data.oSearch.sSearch = "";
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "fnStateSaveParams": null,


	                    /**
	                     * Duration for which the saved state information is considered valid. After this period
	                     * has elapsed the state will be returned to the default.
	                     * Value is given in seconds.
	                     *  @type int
	                     *  @default 7200 <i>(2 hours)</i>
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.stateDuration
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "stateDuration": 60*60*24; // 1 day
	                     *      } );
	                     *    } )
	                     */
	                    "iStateDuration": 7200,


	                    /**
	                     * When enabled DataTables will not make a request to the server for the first
	                     * page draw - rather it will use the data already on the page (no sorting etc
	                     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
	                     * is used to indicate that deferred loading is required, but it is also used
	                     * to tell DataTables how many records there are in the full table (allowing
	                     * the information element and pagination to be displayed correctly). In the case
	                     * where a filtering is applied to the table on initial load, this can be
	                     * indicated by giving the parameter as an array, where the first element is
	                     * the number of records available after filtering and the second element is the
	                     * number of records without filtering (allowing the table information element
	                     * to be shown correctly).
	                     *  @type int | array
	                     *  @default null
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.deferLoading
	                     *
	                     *  @example
	                     *    // 57 records available in the table, no filtering applied
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "serverSide": true,
	                     *        "ajax": "scripts/server_processing.php",
	                     *        "deferLoading": 57
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "serverSide": true,
	                     *        "ajax": "scripts/server_processing.php",
	                     *        "deferLoading": [ 57, 100 ],
	                     *        "search": {
	                     *          "search": "my_filter"
	                     *        }
	                     *      } );
	                     *    } );
	                     */
	                    "iDeferLoading": null,


	                    /**
	                     * Number of rows to display on a single page when using pagination. If
	                     * feature enabled (`lengthChange`) then the end user will be able to override
	                     * this to a custom setting using a pop-up menu.
	                     *  @type int
	                     *  @default 10
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.pageLength
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "pageLength": 50
	                     *      } );
	                     *    } )
	                     */
	                    "iDisplayLength": 10,


	                    /**
	                     * Define the starting point for data display when using DataTables with
	                     * pagination. Note that this parameter is the number of records, rather than
	                     * the page number, so if you have 10 records per page and want to start on
	                     * the third page, it should be "20".
	                     *  @type int
	                     *  @default 0
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.displayStart
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "displayStart": 20
	                     *      } );
	                     *    } )
	                     */
	                    "iDisplayStart": 0,


	                    /**
	                     * By default DataTables allows keyboard navigation of the table (sorting, paging,
	                     * and filtering) by adding a `tabindex` attribute to the required elements. This
	                     * allows you to tab through the controls and press the enter key to activate them.
	                     * The tabindex is default 0, meaning that the tab follows the flow of the document.
	                     * You can overrule this using this parameter if you wish. Use a value of -1 to
	                     * disable built-in keyboard navigation.
	                     *  @type int
	                     *  @default 0
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.tabIndex
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "tabIndex": 1
	                     *      } );
	                     *    } );
	                     */
	                    "iTabIndex": 0,


	                    /**
	                     * Classes that DataTables assigns to the various components and features
	                     * that it adds to the HTML table. This allows classes to be configured
	                     * during initialisation in addition to through the static
	                     * {@link DataTable.ext.oStdClasses} object).
	                     *  @namespace
	                     *  @name DataTable.defaults.classes
	                     */
	                    "oClasses": {},


	                    /**
	                     * All strings that DataTables uses in the user interface that it creates
	                     * are defined in this object, allowing you to modified them individually or
	                     * completely replace them all as required.
	                     *  @namespace
	                     *  @name DataTable.defaults.language
	                     */
	                    "oLanguage": {
	                        /**
	                         * Strings that are used for WAI-ARIA labels and controls only (these are not
	                         * actually visible on the page, but will be read by screenreaders, and thus
	                         * must be internationalised as well).
	                         *  @namespace
	                         *  @name DataTable.defaults.language.aria
	                         */
	                        "oAria": {
	                            /**
	                             * ARIA label that is added to the table headers when the column may be
	                             * sorted ascending by activing the column (click or return when focused).
	                             * Note that the column header is prefixed to this string.
	                             *  @type string
	                             *  @default : activate to sort column ascending
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.aria.sortAscending
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "aria": {
	                             *            "sortAscending": " - click/return to sort ascending"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sSortAscending": ": activate to sort column ascending",

	                            /**
	                             * ARIA label that is added to the table headers when the column may be
	                             * sorted descending by activing the column (click or return when focused).
	                             * Note that the column header is prefixed to this string.
	                             *  @type string
	                             *  @default : activate to sort column ascending
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.aria.sortDescending
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "aria": {
	                             *            "sortDescending": " - click/return to sort descending"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sSortDescending": ": activate to sort column descending"
	                        },

	                        /**
	                         * Pagination string used by DataTables for the built-in pagination
	                         * control types.
	                         *  @namespace
	                         *  @name DataTable.defaults.language.paginate
	                         */
	                        "oPaginate": {
	                            /**
	                             * Text to use when using the 'full_numbers' type of pagination for the
	                             * button to take the user to the first page.
	                             *  @type string
	                             *  @default First
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.paginate.first
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "paginate": {
	                             *            "first": "First page"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sFirst": "First",


	                            /**
	                             * Text to use when using the 'full_numbers' type of pagination for the
	                             * button to take the user to the last page.
	                             *  @type string
	                             *  @default Last
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.paginate.last
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "paginate": {
	                             *            "last": "Last page"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sLast": "Last",


	                            /**
	                             * Text to use for the 'next' pagination button (to take the user to the
	                             * next page).
	                             *  @type string
	                             *  @default Next
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.paginate.next
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "paginate": {
	                             *            "next": "Next page"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sNext": "Next",


	                            /**
	                             * Text to use for the 'previous' pagination button (to take the user to
	                             * the previous page).
	                             *  @type string
	                             *  @default Previous
	                             *
	                             *  @dtopt Language
	                             *  @name DataTable.defaults.language.paginate.previous
	                             *
	                             *  @example
	                             *    $(document).ready( function() {
	                             *      $('#example').dataTable( {
	                             *        "language": {
	                             *          "paginate": {
	                             *            "previous": "Previous page"
	                             *          }
	                             *        }
	                             *      } );
	                             *    } );
	                             */
	                            "sPrevious": "Previous"
	                        },

	                        /**
	                         * This string is shown in preference to `zeroRecords` when the table is
	                         * empty of data (regardless of filtering). Note that this is an optional
	                         * parameter - if it is not given, the value of `zeroRecords` will be used
	                         * instead (either the default or given value).
	                         *  @type string
	                         *  @default No data available in table
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.emptyTable
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "emptyTable": "No data available in table"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sEmptyTable": "No data available in table",


	                        /**
	                         * This string gives information to the end user about the information
	                         * that is current on display on the page. The following tokens can be
	                         * used in the string and will be dynamically replaced as the table
	                         * display updates. This tokens can be placed anywhere in the string, or
	                         * removed as needed by the language requires:
	                         *
	                         * * `\_START\_` - Display index of the first record on the current page
	                         * * `\_END\_` - Display index of the last record on the current page
	                         * * `\_TOTAL\_` - Number of records in the table after filtering
	                         * * `\_MAX\_` - Number of records in the table without filtering
	                         * * `\_PAGE\_` - Current page number
	                         * * `\_PAGES\_` - Total number of pages of data in the table
	                         *
	                         *  @type string
	                         *  @default Showing _START_ to _END_ of _TOTAL_ entries
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.info
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "info": "Showing page _PAGE_ of _PAGES_"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",


	                        /**
	                         * Display information string for when the table is empty. Typically the
	                         * format of this string should match `info`.
	                         *  @type string
	                         *  @default Showing 0 to 0 of 0 entries
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.infoEmpty
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "infoEmpty": "No entries to show"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sInfoEmpty": "Showing 0 to 0 of 0 entries",


	                        /**
	                         * When a user filters the information in a table, this string is appended
	                         * to the information (`info`) to give an idea of how strong the filtering
	                         * is. The variable _MAX_ is dynamically updated.
	                         *  @type string
	                         *  @default (filtered from _MAX_ total entries)
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.infoFiltered
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "infoFiltered": " - filtering from _MAX_ records"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sInfoFiltered": "(filtered from _MAX_ total entries)",


	                        /**
	                         * If can be useful to append extra information to the info string at times,
	                         * and this variable does exactly that. This information will be appended to
	                         * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
	                         * being used) at all times.
	                         *  @type string
	                         *  @default <i>Empty string</i>
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.infoPostFix
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "infoPostFix": "All records shown are derived from real information."
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sInfoPostFix": "",


	                        /**
	                         * This decimal place operator is a little different from the other
	                         * language options since DataTables doesn't output floating point
	                         * numbers, so it won't ever use this for display of a number. Rather,
	                         * what this parameter does is modify the sort methods of the table so
	                         * that numbers which are in a format which has a character other than
	                         * a period (`.`) as a decimal place will be sorted numerically.
	                         *
	                         * Note that numbers with different decimal places cannot be shown in
	                         * the same table and still be sortable, the table must be consistent.
	                         * However, multiple different tables on the page can use different
	                         * decimal place characters.
	                         *  @type string
	                         *  @default 
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.decimal
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "decimal": ","
	                         *          "thousands": "."
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sDecimal": "",


	                        /**
	                         * DataTables has a build in number formatter (`formatNumber`) which is
	                         * used to format large numbers that are used in the table information.
	                         * By default a comma is used, but this can be trivially changed to any
	                         * character you wish with this parameter.
	                         *  @type string
	                         *  @default ,
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.thousands
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "thousands": "'"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sThousands": ",",


	                        /**
	                         * Detail the action that will be taken when the drop down menu for the
	                         * pagination length option is changed. The '_MENU_' variable is replaced
	                         * with a default select list of 10, 25, 50 and 100, and can be replaced
	                         * with a custom select box if required.
	                         *  @type string
	                         *  @default Show _MENU_ entries
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.lengthMenu
	                         *
	                         *  @example
	                         *    // Language change only
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "lengthMenu": "Display _MENU_ records"
	                         *        }
	                         *      } );
	                         *    } );
	                         *
	                         *  @example
	                         *    // Language and options change
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "lengthMenu": 'Display <select>'+
	                         *            '<option value="10">10</option>'+
	                         *            '<option value="20">20</option>'+
	                         *            '<option value="30">30</option>'+
	                         *            '<option value="40">40</option>'+
	                         *            '<option value="50">50</option>'+
	                         *            '<option value="-1">All</option>'+
	                         *            '</select> records'
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sLengthMenu": "Show _MENU_ entries",


	                        /**
	                         * When using Ajax sourced data and during the first draw when DataTables is
	                         * gathering the data, this message is shown in an empty row in the table to
	                         * indicate to the end user the the data is being loaded. Note that this
	                         * parameter is not used when loading data by server-side processing, just
	                         * Ajax sourced data with client-side processing.
	                         *  @type string
	                         *  @default Loading...
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.loadingRecords
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "loadingRecords": "Please wait - loading..."
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sLoadingRecords": "Loading...",


	                        /**
	                         * Text which is displayed when the table is processing a user action
	                         * (usually a sort command or similar).
	                         *  @type string
	                         *  @default Processing...
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.processing
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "processing": "DataTables is currently busy"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sProcessing": "Processing...",


	                        /**
	                         * Details the actions that will be taken when the user types into the
	                         * filtering input text box. The variable "_INPUT_", if used in the string,
	                         * is replaced with the HTML text box for the filtering input allowing
	                         * control over where it appears in the string. If "_INPUT_" is not given
	                         * then the input box is appended to the string automatically.
	                         *  @type string
	                         *  @default Search:
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.search
	                         *
	                         *  @example
	                         *    // Input text box will be appended at the end automatically
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "search": "Filter records:"
	                         *        }
	                         *      } );
	                         *    } );
	                         *
	                         *  @example
	                         *    // Specify where the filter should appear
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "search": "Apply filter _INPUT_ to table"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sSearch": "Search:",


	                        /**
	                         * Assign a `placeholder` attribute to the search `input` element
	                         *  @type string
	                         *  @default 
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.searchPlaceholder
	                         */
	                        "sSearchPlaceholder": "",


	                        /**
	                         * All of the language information can be stored in a file on the
	                         * server-side, which DataTables will look up if this parameter is passed.
	                         * It must store the URL of the language file, which is in a JSON format,
	                         * and the object has the same properties as the oLanguage object in the
	                         * initialiser object (i.e. the above parameters). Please refer to one of
	                         * the example language files to see how this works in action.
	                         *  @type string
	                         *  @default <i>Empty string - i.e. disabled</i>
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.url
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "url": "http://www.sprymedia.co.uk/dataTables/lang.txt"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sUrl": "",


	                        /**
	                         * Text shown inside the table records when the is no information to be
	                         * displayed after filtering. `emptyTable` is shown when there is simply no
	                         * information in the table at all (regardless of filtering).
	                         *  @type string
	                         *  @default No matching records found
	                         *
	                         *  @dtopt Language
	                         *  @name DataTable.defaults.language.zeroRecords
	                         *
	                         *  @example
	                         *    $(document).ready( function() {
	                         *      $('#example').dataTable( {
	                         *        "language": {
	                         *          "zeroRecords": "No records to display"
	                         *        }
	                         *      } );
	                         *    } );
	                         */
	                        "sZeroRecords": "No matching records found"
	                    },


	                    /**
	                     * This parameter allows you to have define the global filtering state at
	                     * initialisation time. As an object the `search` parameter must be
	                     * defined, but all other parameters are optional. When `regex` is true,
	                     * the search string will be treated as a regular expression, when false
	                     * (default) it will be treated as a straight string. When `smart`
	                     * DataTables will use it's smart filtering methods (to word match at
	                     * any point in the data), when false this will not be done.
	                     *  @namespace
	                     *  @extends DataTable.models.oSearch
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.search
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "search": {"search": "Initial search"}
	                     *      } );
	                     *    } )
	                     */
	                    "oSearch": $.extend({}, DataTable.models.oSearch),


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     * By default DataTables will look for the property `data` (or `aaData` for
	                     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
	                     * source or for server-side processing - this parameter allows that
	                     * property to be changed. You can use Javascript dotted object notation to
	                     * get a data source for multiple levels of nesting.
	                     *  @type string
	                     *  @default data
	                     *
	                     *  @dtopt Options
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.ajaxDataProp
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "sAjaxDataProp": "data",


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     * You can instruct DataTables to load data from an external
	                     * source using this parameter (use aData if you want to pass data in you
	                     * already have). Simply provide a url a JSON object can be obtained from.
	                     *  @type string
	                     *  @default null
	                     *
	                     *  @dtopt Options
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.ajaxSource
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "sAjaxSource": null,


	                    /**
	                     * This initialisation variable allows you to specify exactly where in the
	                     * DOM you want DataTables to inject the various controls it adds to the page
	                     * (for example you might want the pagination controls at the top of the
	                     * table). DIV elements (with or without a custom class) can also be added to
	                     * aid styling. The follow syntax is used:
	                     *   <ul>
	                     *     <li>The following options are allowed:
	                     *       <ul>
	                     *         <li>'l' - Length changing</li>
	                     *         <li>'f' - Filtering input</li>
	                     *         <li>'t' - The table!</li>
	                     *         <li>'i' - Information</li>
	                     *         <li>'p' - Pagination</li>
	                     *         <li>'r' - pRocessing</li>
	                     *       </ul>
	                     *     </li>
	                     *     <li>The following constants are allowed:
	                     *       <ul>
	                     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
	                     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
	                     *       </ul>
	                     *     </li>
	                     *     <li>The following syntax is expected:
	                     *       <ul>
	                     *         <li>'&lt;' and '&gt;' - div elements</li>
	                     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
	                     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
	                     *       </ul>
	                     *     </li>
	                     *     <li>Examples:
	                     *       <ul>
	                     *         <li>'&lt;"wrapper"flipt&gt;'</li>
	                     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
	                     *       </ul>
	                     *     </li>
	                     *   </ul>
	                     *  @type string
	                     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
	                     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.dom
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
	                     *      } );
	                     *    } );
	                     */
	                    "sDom": "lfrtip",


	                    /**
	                     * Search delay option. This will throttle full table searches that use the
	                     * DataTables provided search input element (it does not effect calls to
	                     * `dt-api search()`, providing a delay before the search is made.
	                     *  @type integer
	                     *  @default 0
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.searchDelay
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "searchDelay": 200
	                     *      } );
	                     *    } )
	                     */
	                    "searchDelay": null,


	                    /**
	                     * DataTables features four different built-in options for the buttons to
	                     * display for pagination control:
	                     *
	                     * * `simple` - 'Previous' and 'Next' buttons only
	                     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
	                     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
	                     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus
	                     *   page numbers
	                     *  
	                     * Further methods can be added using {@link DataTable.ext.oPagination}.
	                     *  @type string
	                     *  @default simple_numbers
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.pagingType
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "pagingType": "full_numbers"
	                     *      } );
	                     *    } )
	                     */
	                    "sPaginationType": "simple_numbers",


	                    /**
	                     * Enable horizontal scrolling. When a table is too wide to fit into a
	                     * certain layout, or you have a large number of columns in the table, you
	                     * can enable x-scrolling to show the table in a viewport, which can be
	                     * scrolled. This property can be `true` which will allow the table to
	                     * scroll horizontally when needed, or any CSS unit, or a number (in which
	                     * case it will be treated as a pixel measurement). Setting as simply `true`
	                     * is recommended.
	                     *  @type boolean|string
	                     *  @default <i>blank string - i.e. disabled</i>
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.scrollX
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "scrollX": true,
	                     *        "scrollCollapse": true
	                     *      } );
	                     *    } );
	                     */
	                    "sScrollX": "",


	                    /**
	                     * This property can be used to force a DataTable to use more width than it
	                     * might otherwise do when x-scrolling is enabled. For example if you have a
	                     * table which requires to be well spaced, this parameter is useful for
	                     * "over-sizing" the table, and thus forcing scrolling. This property can by
	                     * any CSS unit, or a number (in which case it will be treated as a pixel
	                     * measurement).
	                     *  @type string
	                     *  @default <i>blank string - i.e. disabled</i>
	                     *
	                     *  @dtopt Options
	                     *  @name DataTable.defaults.scrollXInner
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "scrollX": "100%",
	                     *        "scrollXInner": "110%"
	                     *      } );
	                     *    } );
	                     */
	                    "sScrollXInner": "",


	                    /**
	                     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
	                     * to the given height, and enable scrolling for any data which overflows the
	                     * current viewport. This can be used as an alternative to paging to display
	                     * a lot of data in a small area (although paging and scrolling can both be
	                     * enabled at the same time). This property can be any CSS unit, or a number
	                     * (in which case it will be treated as a pixel measurement).
	                     *  @type string
	                     *  @default <i>blank string - i.e. disabled</i>
	                     *
	                     *  @dtopt Features
	                     *  @name DataTable.defaults.scrollY
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "scrollY": "200px",
	                     *        "paginate": false
	                     *      } );
	                     *    } );
	                     */
	                    "sScrollY": "",


	                    /**
	                     * __Deprecated__ The functionality provided by this parameter has now been
	                     * superseded by that provided through `ajax`, which should be used instead.
	                     *
	                     * Set the HTTP method that is used to make the Ajax call for server-side
	                     * processing or Ajax sourced data.
	                     *  @type string
	                     *  @default GET
	                     *
	                     *  @dtopt Options
	                     *  @dtopt Server-side
	                     *  @name DataTable.defaults.serverMethod
	                     *
	                     *  @deprecated 1.10. Please use `ajax` for this functionality now.
	                     */
	                    "sServerMethod": "GET",


	                    /**
	                     * DataTables makes use of renderers when displaying HTML elements for
	                     * a table. These renderers can be added or modified by plug-ins to
	                     * generate suitable mark-up for a site. For example the Bootstrap
	                     * integration plug-in for DataTables uses a paging button renderer to
	                     * display pagination buttons in the mark-up required by Bootstrap.
	                     *
	                     * For further information about the renderers available see
	                     * DataTable.ext.renderer
	                     *  @type string|object
	                     *  @default null
	                     *
	                     *  @name DataTable.defaults.renderer
	                     *
	                     */
	                    "renderer": null
	                };

	                _fnHungarianMap(DataTable.defaults);



	                /*
	                 * Developer note - See note in model.defaults.js about the use of Hungarian
	                 * notation and camel case.
	                 */

	                /**
	                 * Column options that can be given to DataTables at initialisation time.
	                 *  @namespace
	                 */
	                DataTable.defaults.column = {
	                    /**
	                     * Define which column(s) an order will occur on for this column. This
	                     * allows a column's ordering to take multiple columns into account when
	                     * doing a sort or use the data from a different column. For example first
	                     * name / last name columns make sense to do a multi-column sort over the
	                     * two columns.
	                     *  @type array|int
	                     *  @default null <i>Takes the value of the column index automatically</i>
	                     *
	                     *  @name DataTable.defaults.column.orderData
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
	                     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
	                     *          { "orderData": 2, "targets": [ 2 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "orderData": [ 0, 1 ] },
	                     *          { "orderData": [ 1, 0 ] },
	                     *          { "orderData": 2 },
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "aDataSort": null,
	                    "iDataSort": -1,


	                    /**
	                     * You can control the default ordering direction, and even alter the
	                     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
	                     * using this parameter.
	                     *  @type array
	                     *  @default [ 'asc', 'desc' ]
	                     *
	                     *  @name DataTable.defaults.column.orderSequence
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
	                     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
	                     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          null,
	                     *          { "orderSequence": [ "asc" ] },
	                     *          { "orderSequence": [ "desc", "asc", "asc" ] },
	                     *          { "orderSequence": [ "desc" ] },
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "asSorting": ['asc', 'desc'],


	                    /**
	                     * Enable or disable filtering on the data in this column.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @name DataTable.defaults.column.searchable
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "searchable": false, "targets": [ 0 ] }
	                     *        ] } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "searchable": false },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ] } );
	                     *    } );
	                     */
	                    "bSearchable": true,


	                    /**
	                     * Enable or disable ordering on this column.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @name DataTable.defaults.column.orderable
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "orderable": false, "targets": [ 0 ] }
	                     *        ] } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "orderable": false },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ] } );
	                     *    } );
	                     */
	                    "bSortable": true,


	                    /**
	                     * Enable or disable the display of this column.
	                     *  @type boolean
	                     *  @default true
	                     *
	                     *  @name DataTable.defaults.column.visible
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "visible": false, "targets": [ 0 ] }
	                     *        ] } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "visible": false },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ] } );
	                     *    } );
	                     */
	                    "bVisible": true,


	                    /**
	                     * Developer definable function that is called whenever a cell is created (Ajax source,
	                     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	                     * allowing you to modify the DOM element (add background colour for example) when the
	                     * element is available.
	                     *  @type function
	                     *  @param {element} td The TD node that has been created
	                     *  @param {*} cellData The Data for the cell
	                     *  @param {array|object} rowData The data for the whole row
	                     *  @param {int} row The row index for the aoData data store
	                     *  @param {int} col The column index for aoColumns
	                     *
	                     *  @name DataTable.defaults.column.createdCell
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [3],
	                     *          "createdCell": function (td, cellData, rowData, row, col) {
	                     *            if ( cellData == "1.7" ) {
	                     *              $(td).css('color', 'blue')
	                     *            }
	                     *          }
	                     *        } ]
	                     *      });
	                     *    } );
	                     */
	                    "fnCreatedCell": null,


	                    /**
	                     * This parameter has been replaced by `data` in DataTables to ensure naming
	                     * consistency. `dataProp` can still be used, as there is backwards
	                     * compatibility in DataTables for this option, but it is strongly
	                     * recommended that you use `data` in preference to `dataProp`.
	                     *  @name DataTable.defaults.column.dataProp
	                     */


	                    /**
	                     * This property can be used to read data from any data source property,
	                     * including deeply nested objects / properties. `data` can be given in a
	                     * number of different ways which effect its behaviour:
	                     *
	                     * * `integer` - treated as an array index for the data source. This is the
	                     *   default that DataTables uses (incrementally increased for each column).
	                     * * `string` - read an object property from the data source. There are
	                     *   three 'special' options that can be used in the string to alter how
	                     *   DataTables reads the data from the source object:
	                     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	                     *      Javascript to read from nested objects, so to can the options
	                     *      specified in `data`. For example: `browser.version` or
	                     *      `browser.name`. If your object parameter name contains a period, use
	                     *      `\\` to escape it - i.e. `first\\.name`.
	                     *    * `[]` - Array notation. DataTables can automatically combine data
	                     *      from and array source, joining the data with the characters provided
	                     *      between the two brackets. For example: `name[, ]` would provide a
	                     *      comma-space separated list from the source array. If no characters
	                     *      are provided between the brackets, the original array source is
	                     *      returned.
	                     *    * `()` - Function notation. Adding `()` to the end of a parameter will
	                     *      execute a function of the name given. For example: `browser()` for a
	                     *      simple function on the data source, `browser.version()` for a
	                     *      function in a nested property or even `browser().version` to get an
	                     *      object property if the function called returns an object. Note that
	                     *      function notation is recommended for use in `render` rather than
	                     *      `data` as it is much simpler to use as a renderer.
	                     * * `null` - use the original data source for the row rather than plucking
	                     *   data directly from it. This action has effects on two other
	                     *   initialisation options:
	                     *    * `defaultContent` - When null is given as the `data` option and
	                     *      `defaultContent` is specified for the column, the value defined by
	                     *      `defaultContent` will be used for the cell.
	                     *    * `render` - When null is used for the `data` option and the `render`
	                     *      option is specified for the column, the whole data source for the
	                     *      row is used for the renderer.
	                     * * `function` - the function given will be executed whenever DataTables
	                     *   needs to set or get the data for a cell in the column. The function
	                     *   takes three parameters:
	                     *    * Parameters:
	                     *      * `{array|object}` The data source for the row
	                     *      * `{string}` The type call data requested - this will be 'set' when
	                     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
	                     *        when gathering data. Note that when `undefined` is given for the
	                     *        type DataTables expects to get the raw data for the object back<
	                     *      * `{*}` Data to set when the second parameter is 'set'.
	                     *    * Return:
	                     *      * The return value from the function is not required when 'set' is
	                     *        the type of call, but otherwise the return is what will be used
	                     *        for the data requested.
	                     *
	                     * Note that `data` is a getter and setter option. If you just require
	                     * formatting of data for output, you will likely want to use `render` which
	                     * is simply a getter and thus simpler to use.
	                     *
	                     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
	                     * name change reflects the flexibility of this property and is consistent
	                     * with the naming of mRender. If 'mDataProp' is given, then it will still
	                     * be used by DataTables, as it automatically maps the old name to the new
	                     * if required.
	                     *
	                     *  @type string|int|function|null
	                     *  @default null <i>Use automatically calculated column index</i>
	                     *
	                     *  @name DataTable.defaults.column.data
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Read table data from objects
	                     *    // JSON structure for each row:
	                     *    //   {
	                     *    //      "engine": {value},
	                     *    //      "browser": {value},
	                     *    //      "platform": {value},
	                     *    //      "version": {value},
	                     *    //      "grade": {value}
	                     *    //   }
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "ajaxSource": "sources/objects.txt",
	                     *        "columns": [
	                     *          { "data": "engine" },
	                     *          { "data": "browser" },
	                     *          { "data": "platform" },
	                     *          { "data": "version" },
	                     *          { "data": "grade" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Read information from deeply nested objects
	                     *    // JSON structure for each row:
	                     *    //   {
	                     *    //      "engine": {value},
	                     *    //      "browser": {value},
	                     *    //      "platform": {
	                     *    //         "inner": {value}
	                     *    //      },
	                     *    //      "details": [
	                     *    //         {value}, {value}
	                     *    //      ]
	                     *    //   }
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "ajaxSource": "sources/deep.txt",
	                     *        "columns": [
	                     *          { "data": "engine" },
	                     *          { "data": "browser" },
	                     *          { "data": "platform.inner" },
	                     *          { "data": "platform.details.0" },
	                     *          { "data": "platform.details.1" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `data` as a function to provide different information for
	                     *    // sorting, filtering and display. In this case, currency (price)
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": function ( source, type, val ) {
	                     *            if (type === 'set') {
	                     *              source.price = val;
	                     *              // Store the computed dislay and filter values for efficiency
	                     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
	                     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
	                     *              return;
	                     *            }
	                     *            else if (type === 'display') {
	                     *              return source.price_display;
	                     *            }
	                     *            else if (type === 'filter') {
	                     *              return source.price_filter;
	                     *            }
	                     *            // 'sort', 'type' and undefined all just use the integer
	                     *            return source.price;
	                     *          }
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using default content
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": null,
	                     *          "defaultContent": "Click to edit"
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using array notation - outputting a list from an array
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": "name[, ]"
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     */
	                    "mData": null,


	                    /**
	                     * This property is the rendering partner to `data` and it is suggested that
	                     * when you want to manipulate data for display (including filtering,
	                     * sorting etc) without altering the underlying data for the table, use this
	                     * property. `render` can be considered to be the the read only companion to
	                     * `data` which is read / write (then as such more complex). Like `data`
	                     * this option can be given in a number of different ways to effect its
	                     * behaviour:
	                     *
	                     * * `integer` - treated as an array index for the data source. This is the
	                     *   default that DataTables uses (incrementally increased for each column).
	                     * * `string` - read an object property from the data source. There are
	                     *   three 'special' options that can be used in the string to alter how
	                     *   DataTables reads the data from the source object:
	                     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	                     *      Javascript to read from nested objects, so to can the options
	                     *      specified in `data`. For example: `browser.version` or
	                     *      `browser.name`. If your object parameter name contains a period, use
	                     *      `\\` to escape it - i.e. `first\\.name`.
	                     *    * `[]` - Array notation. DataTables can automatically combine data
	                     *      from and array source, joining the data with the characters provided
	                     *      between the two brackets. For example: `name[, ]` would provide a
	                     *      comma-space separated list from the source array. If no characters
	                     *      are provided between the brackets, the original array source is
	                     *      returned.
	                     *    * `()` - Function notation. Adding `()` to the end of a parameter will
	                     *      execute a function of the name given. For example: `browser()` for a
	                     *      simple function on the data source, `browser.version()` for a
	                     *      function in a nested property or even `browser().version` to get an
	                     *      object property if the function called returns an object.
	                     * * `object` - use different data for the different data types requested by
	                     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
	                     *   of the object is the data type the property refers to and the value can
	                     *   defined using an integer, string or function using the same rules as
	                     *   `render` normally does. Note that an `_` option _must_ be specified.
	                     *   This is the default value to use if you haven't specified a value for
	                     *   the data type requested by DataTables.
	                     * * `function` - the function given will be executed whenever DataTables
	                     *   needs to set or get the data for a cell in the column. The function
	                     *   takes three parameters:
	                     *    * Parameters:
	                     *      * {array|object} The data source for the row (based on `data`)
	                     *      * {string} The type call data requested - this will be 'filter',
	                     *        'display', 'type' or 'sort'.
	                     *      * {array|object} The full data source for the row (not based on
	                     *        `data`)
	                     *    * Return:
	                     *      * The return value from the function is what will be used for the
	                     *        data requested.
	                     *
	                     *  @type string|int|function|object|null
	                     *  @default null Use the data source value.
	                     *
	                     *  @name DataTable.defaults.column.render
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Create a comma separated list from an array of objects
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "ajaxSource": "sources/deep.txt",
	                     *        "columns": [
	                     *          { "data": "engine" },
	                     *          { "data": "browser" },
	                     *          {
	                     *            "data": "platform",
	                     *            "render": "[, ].name"
	                     *          }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Execute a function to obtain data
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": null, // Use the full data source object for the renderer's source
	                     *          "render": "browserName()"
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // As an object, extracting different data for the different types
	                     *    // This would be used with a data source such as:
	                     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
	                     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
	                     *    // (which has both forms) is used for filtering for if a user inputs either format, while
	                     *    // the formatted phone number is the one that is shown in the table.
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": null, // Use the full data source object for the renderer's source
	                     *          "render": {
	                     *            "_": "phone",
	                     *            "filter": "phone_filter",
	                     *            "display": "phone_display"
	                     *          }
	                     *        } ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Use as a function to create a link from the data source
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "data": "download_link",
	                     *          "render": function ( data, type, full ) {
	                     *            return '<a href="'+data+'">Download</a>';
	                     *          }
	                     *        } ]
	                     *      } );
	                     *    } );
	                     */
	                    "mRender": null,


	                    /**
	                     * Change the cell type created for the column - either TD cells or TH cells. This
	                     * can be useful as TH cells have semantic meaning in the table body, allowing them
	                     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
	                     *  @type string
	                     *  @default td
	                     *
	                     *  @name DataTable.defaults.column.cellType
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Make the first column use TH cells
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [ {
	                     *          "targets": [ 0 ],
	                     *          "cellType": "th"
	                     *        } ]
	                     *      } );
	                     *    } );
	                     */
	                    "sCellType": "td",


	                    /**
	                     * Class to give to each cell in this column.
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     *
	                     *  @name DataTable.defaults.column.class
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "class": "my_class", "targets": [ 0 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "class": "my_class" },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sClass": "",

	                    /**
	                     * When DataTables calculates the column widths to assign to each column,
	                     * it finds the longest string in each column and then constructs a
	                     * temporary table and reads the widths from that. The problem with this
	                     * is that "mmm" is much wider then "iiii", but the latter is a longer
	                     * string - thus the calculation can go wrong (doing it properly and putting
	                     * it into an DOM object and measuring that is horribly(!) slow). Thus as
	                     * a "work around" we provide this option. It will append its value to the
	                     * text that is found to be the longest string for the column - i.e. padding.
	                     * Generally you shouldn't need this!
	                     *  @type string
	                     *  @default <i>Empty string<i>
	                     *
	                     *  @name DataTable.defaults.column.contentPadding
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          {
	                     *            "contentPadding": "mmm"
	                     *          }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sContentPadding": "",


	                    /**
	                     * Allows a default value to be given for a column's data, and will be used
	                     * whenever a null data source is encountered (this can be because `data`
	                     * is set to null, or because the data source itself is null).
	                     *  @type string
	                     *  @default null
	                     *
	                     *  @name DataTable.defaults.column.defaultContent
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          {
	                     *            "data": null,
	                     *            "defaultContent": "Edit",
	                     *            "targets": [ -1 ]
	                     *          }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          {
	                     *            "data": null,
	                     *            "defaultContent": "Edit"
	                     *          }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sDefaultContent": null,


	                    /**
	                     * This parameter is only used in DataTables' server-side processing. It can
	                     * be exceptionally useful to know what columns are being displayed on the
	                     * client side, and to map these to database fields. When defined, the names
	                     * also allow DataTables to reorder information from the server if it comes
	                     * back in an unexpected order (i.e. if you switch your columns around on the
	                     * client-side, your server-side code does not also need updating).
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     *
	                     *  @name DataTable.defaults.column.name
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "name": "engine", "targets": [ 0 ] },
	                     *          { "name": "browser", "targets": [ 1 ] },
	                     *          { "name": "platform", "targets": [ 2 ] },
	                     *          { "name": "version", "targets": [ 3 ] },
	                     *          { "name": "grade", "targets": [ 4 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "name": "engine" },
	                     *          { "name": "browser" },
	                     *          { "name": "platform" },
	                     *          { "name": "version" },
	                     *          { "name": "grade" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sName": "",


	                    /**
	                     * Defines a data source type for the ordering which can be used to read
	                     * real-time information from the table (updating the internally cached
	                     * version) prior to ordering. This allows ordering to occur on user
	                     * editable elements such as form inputs.
	                     *  @type string
	                     *  @default std
	                     *
	                     *  @name DataTable.defaults.column.orderDataType
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
	                     *          { "type": "numeric", "targets": [ 3 ] },
	                     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
	                     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          null,
	                     *          null,
	                     *          { "orderDataType": "dom-text" },
	                     *          { "orderDataType": "dom-text", "type": "numeric" },
	                     *          { "orderDataType": "dom-select" },
	                     *          { "orderDataType": "dom-checkbox" }
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sSortDataType": "std",


	                    /**
	                     * The title of this column.
	                     *  @type string
	                     *  @default null <i>Derived from the 'TH' value for this column in the
	                     *    original HTML table.</i>
	                     *
	                     *  @name DataTable.defaults.column.title
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "title": "My column title", "targets": [ 0 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "title": "My column title" },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sTitle": null,


	                    /**
	                     * The type allows you to specify how the data for this column will be
	                     * ordered. Four types (string, numeric, date and html (which will strip
	                     * HTML tags before ordering)) are currently available. Note that only date
	                     * formats understood by Javascript's Date() object will be accepted as type
	                     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
	                     * 'numeric', 'date' or 'html' (by default). Further types can be adding
	                     * through plug-ins.
	                     *  @type string
	                     *  @default null <i>Auto-detected from raw data</i>
	                     *
	                     *  @name DataTable.defaults.column.type
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "type": "html", "targets": [ 0 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "type": "html" },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sType": null,


	                    /**
	                     * Defining the width of the column, this parameter may take any CSS value
	                     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
	                     * been given a specific width through this interface ensuring that the table
	                     * remains readable.
	                     *  @type string
	                     *  @default null <i>Automatic</i>
	                     *
	                     *  @name DataTable.defaults.column.width
	                     *  @dtopt Columns
	                     *
	                     *  @example
	                     *    // Using `columnDefs`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columnDefs": [
	                     *          { "width": "20%", "targets": [ 0 ] }
	                     *        ]
	                     *      } );
	                     *    } );
	                     *
	                     *  @example
	                     *    // Using `columns`
	                     *    $(document).ready( function() {
	                     *      $('#example').dataTable( {
	                     *        "columns": [
	                     *          { "width": "20%" },
	                     *          null,
	                     *          null,
	                     *          null,
	                     *          null
	                     *        ]
	                     *      } );
	                     *    } );
	                     */
	                    "sWidth": null
	                };

	                _fnHungarianMap(DataTable.defaults.column);



	                /**
	                 * DataTables settings object - this holds all the information needed for a
	                 * given table, including configuration, data and current application of the
	                 * table options. DataTables does not have a single instance for each DataTable
	                 * with the settings attached to that instance, but rather instances of the
	                 * DataTable "class" are created on-the-fly as needed (typically by a
	                 * $().dataTable() call) and the settings object is then applied to that
	                 * instance.
	                 *
	                 * Note that this object is related to {@link DataTable.defaults} but this
	                 * one is the internal data store for DataTables's cache of columns. It should
	                 * NOT be manipulated outside of DataTables. Any configuration should be done
	                 * through the initialisation options.
	                 *  @namespace
	                 *  @todo Really should attach the settings object to individual instances so we
	                 *    don't need to create new instances on each $().dataTable() call (if the
	                 *    table already exists). It would also save passing oSettings around and
	                 *    into every single function. However, this is a very significant
	                 *    architecture change for DataTables and will almost certainly break
	                 *    backwards compatibility with older installations. This is something that
	                 *    will be done in 2.0.
	                 */
	                DataTable.models.oSettings = {
	                    /**
	                     * Primary features of DataTables and their enablement state.
	                     *  @namespace
	                     */
	                    "oFeatures": {

	                        /**
	                         * Flag to say if DataTables should automatically try to calculate the
	                         * optimum table and columns widths (true) or not (false).
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bAutoWidth": null,

	                        /**
	                         * Delay the creation of TR and TD elements until they are actually
	                         * needed by a driven page draw. This can give a significant speed
	                         * increase for Ajax source and Javascript source data, but makes no
	                         * difference at all fro DOM and server-side processing tables.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bDeferRender": null,

	                        /**
	                         * Enable filtering on the table or not. Note that if this is disabled
	                         * then there is no filtering at all on the table, including fnFilter.
	                         * To just remove the filtering input use sDom and remove the 'f' option.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bFilter": null,

	                        /**
	                         * Table information element (the 'Showing x of y records' div) enable
	                         * flag.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bInfo": null,

	                        /**
	                         * Present a user control allowing the end user to change the page size
	                         * when pagination is enabled.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bLengthChange": null,

	                        /**
	                         * Pagination enabled or not. Note that if this is disabled then length
	                         * changing must also be disabled.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bPaginate": null,

	                        /**
	                         * Processing indicator enable flag whenever DataTables is enacting a
	                         * user request - typically an Ajax request for server-side processing.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bProcessing": null,

	                        /**
	                         * Server-side processing enabled flag - when enabled DataTables will
	                         * get all data from the server for every draw - there is no filtering,
	                         * sorting or paging done on the client-side.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bServerSide": null,

	                        /**
	                         * Sorting enablement flag.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bSort": null,

	                        /**
	                         * Multi-column sorting
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bSortMulti": null,

	                        /**
	                         * Apply a class to the columns which are being sorted to provide a
	                         * visual highlight or not. This can slow things down when enabled since
	                         * there is a lot of DOM interaction.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bSortClasses": null,

	                        /**
	                         * State saving enablement flag.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bStateSave": null
	                    },


	                    /**
	                     * Scrolling settings for a table.
	                     *  @namespace
	                     */
	                    "oScroll": {
	                        /**
	                         * When the table is shorter in height than sScrollY, collapse the
	                         * table container down to the height of the table (when true).
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type boolean
	                         */
	                        "bCollapse": null,

	                        /**
	                         * Width of the scrollbar for the web-browser's platform. Calculated
	                         * during table initialisation.
	                         *  @type int
	                         *  @default 0
	                         */
	                        "iBarWidth": 0,

	                        /**
	                         * Viewport width for horizontal scrolling. Horizontal scrolling is
	                         * disabled if an empty string.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type string
	                         */
	                        "sX": null,

	                        /**
	                         * Width to expand the table to when using x-scrolling. Typically you
	                         * should not need to use this.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type string
	                         *  @deprecated
	                         */
	                        "sXInner": null,

	                        /**
	                         * Viewport height for vertical scrolling. Vertical scrolling is disabled
	                         * if an empty string.
	                         * Note that this parameter will be set by the initialisation routine. To
	                         * set a default use {@link DataTable.defaults}.
	                         *  @type string
	                         */
	                        "sY": null
	                    },

	                    /**
	                     * Language information for the table.
	                     *  @namespace
	                     *  @extends DataTable.defaults.oLanguage
	                     */
	                    "oLanguage": {
	                        /**
	                         * Information callback function. See
	                         * {@link DataTable.defaults.fnInfoCallback}
	                         *  @type function
	                         *  @default null
	                         */
	                        "fnInfoCallback": null
	                    },

	                    /**
	                     * Browser support parameters
	                     *  @namespace
	                     */
	                    "oBrowser": {
	                        /**
	                         * Indicate if the browser incorrectly calculates width:100% inside a
	                         * scrolling element (IE6/7)
	                         *  @type boolean
	                         *  @default false
	                         */
	                        "bScrollOversize": false,

	                        /**
	                         * Determine if the vertical scrollbar is on the right or left of the
	                         * scrolling container - needed for rtl language layout, although not
	                         * all browsers move the scrollbar (Safari).
	                         *  @type boolean
	                         *  @default false
	                         */
	                        "bScrollbarLeft": false
	                    },


	                    "ajax": null,


	                    /**
	                     * Array referencing the nodes which are used for the features. The
	                     * parameters of this object match what is allowed by sDom - i.e.
	                     *   <ul>
	                     *     <li>'l' - Length changing</li>
	                     *     <li>'f' - Filtering input</li>
	                     *     <li>'t' - The table!</li>
	                     *     <li>'i' - Information</li>
	                     *     <li>'p' - Pagination</li>
	                     *     <li>'r' - pRocessing</li>
	                     *   </ul>
	                     *  @type array
	                     *  @default []
	                     */
	                    "aanFeatures": [],

	                    /**
	                     * Store data information - see {@link DataTable.models.oRow} for detailed
	                     * information.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoData": [],

	                    /**
	                     * Array of indexes which are in the current display (after filtering etc)
	                     *  @type array
	                     *  @default []
	                     */
	                    "aiDisplay": [],

	                    /**
	                     * Array of indexes for display - no filtering
	                     *  @type array
	                     *  @default []
	                     */
	                    "aiDisplayMaster": [],

	                    /**
	                     * Store information about each column that is in use
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoColumns": [],

	                    /**
	                     * Store information about the table's header
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoHeader": [],

	                    /**
	                     * Store information about the table's footer
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoFooter": [],

	                    /**
	                     * Store the applied global search information in case we want to force a
	                     * research or compare the old search to a new one.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @namespace
	                     *  @extends DataTable.models.oSearch
	                     */
	                    "oPreviousSearch": {},

	                    /**
	                     * Store the applied search for each column - see
	                     * {@link DataTable.models.oSearch} for the format that is used for the
	                     * filtering information for each column.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoPreSearchCols": [],

	                    /**
	                     * Sorting that is applied to the table. Note that the inner arrays are
	                     * used in the following manner:
	                     * <ul>
	                     *   <li>Index 0 - column number</li>
	                     *   <li>Index 1 - current sorting direction</li>
	                     * </ul>
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type array
	                     *  @todo These inner arrays should really be objects
	                     */
	                    "aaSorting": null,

	                    /**
	                     * Sorting that is always applied to the table (i.e. prefixed in front of
	                     * aaSorting).
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aaSortingFixed": [],

	                    /**
	                     * Classes to use for the striping of a table.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type array
	                     *  @default []
	                     */
	                    "asStripeClasses": null,

	                    /**
	                     * If restoring a table - we should restore its striping classes as well
	                     *  @type array
	                     *  @default []
	                     */
	                    "asDestroyStripes": [],

	                    /**
	                     * If restoring a table - we should restore its width
	                     *  @type int
	                     *  @default 0
	                     */
	                    "sDestroyWidth": 0,

	                    /**
	                     * Callback functions array for every time a row is inserted (i.e. on a draw).
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoRowCallback": [],

	                    /**
	                     * Callback functions for the header on each draw.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoHeaderCallback": [],

	                    /**
	                     * Callback function for the footer on each draw.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoFooterCallback": [],

	                    /**
	                     * Array of callback functions for draw callback functions
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoDrawCallback": [],

	                    /**
	                     * Array of callback functions for row created function
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoRowCreatedCallback": [],

	                    /**
	                     * Callback functions for just before the table is redrawn. A return of
	                     * false will be used to cancel the draw.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoPreDrawCallback": [],

	                    /**
	                     * Callback functions for when the table has been initialised.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoInitComplete": [],


	                    /**
	                     * Callbacks for modifying the settings to be stored for state saving, prior to
	                     * saving state.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateSaveParams": [],

	                    /**
	                     * Callbacks for modifying the settings that have been stored for state saving
	                     * prior to using the stored values to restore the state.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateLoadParams": [],

	                    /**
	                     * Callbacks for operating on the settings object once the saved state has been
	                     * loaded
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateLoaded": [],

	                    /**
	                     * Cache the table ID for quick access
	                     *  @type string
	                     *  @default <i>Empty string</i>
	                     */
	                    "sTableId": "",

	                    /**
	                     * The TABLE node for the main table
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTable": null,

	                    /**
	                     * Permanent ref to the thead element
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTHead": null,

	                    /**
	                     * Permanent ref to the tfoot element - if it exists
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTFoot": null,

	                    /**
	                     * Permanent ref to the tbody element
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTBody": null,

	                    /**
	                     * Cache the wrapper node (contains all DataTables controlled elements)
	                     *  @type node
	                     *  @default null
	                     */
	                    "nTableWrapper": null,

	                    /**
	                     * Indicate if when using server-side processing the loading of data
	                     * should be deferred until the second draw.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type boolean
	                     *  @default false
	                     */
	                    "bDeferLoading": false,

	                    /**
	                     * Indicate if all required information has been read in
	                     *  @type boolean
	                     *  @default false
	                     */
	                    "bInitialised": false,

	                    /**
	                     * Information about open rows. Each object in the array has the parameters
	                     * 'nTr' and 'nParent'
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoOpenRows": [],

	                    /**
	                     * Dictate the positioning of DataTables' control elements - see
	                     * {@link DataTable.model.oInit.sDom}.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     *  @default null
	                     */
	                    "sDom": null,

	                    /**
	                     * Search delay (in mS)
	                     *  @type integer
	                     *  @default null
	                     */
	                    "searchDelay": null,

	                    /**
	                     * Which type of pagination should be used.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     *  @default two_button
	                     */
	                    "sPaginationType": "two_button",

	                    /**
	                     * The state duration (for `stateSave`) in seconds.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type int
	                     *  @default 0
	                     */
	                    "iStateDuration": 0,

	                    /**
	                     * Array of callback functions for state saving. Each array element is an
	                     * object with the following parameters:
	                     *   <ul>
	                     *     <li>function:fn - function to call. Takes two parameters, oSettings
	                     *       and the JSON string to save that has been thus far created. Returns
	                     *       a JSON string to be inserted into a json object
	                     *       (i.e. '"param": [ 0, 1, 2]')</li>
	                     *     <li>string:sName - name of callback</li>
	                     *   </ul>
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateSave": [],

	                    /**
	                     * Array of callback functions for state loading. Each array element is an
	                     * object with the following parameters:
	                     *   <ul>
	                     *     <li>function:fn - function to call. Takes two parameters, oSettings
	                     *       and the object stored. May return false to cancel state loading</li>
	                     *     <li>string:sName - name of callback</li>
	                     *   </ul>
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoStateLoad": [],

	                    /**
	                     * State that was saved. Useful for back reference
	                     *  @type object
	                     *  @default null
	                     */
	                    "oSavedState": null,

	                    /**
	                     * State that was loaded. Useful for back reference
	                     *  @type object
	                     *  @default null
	                     */
	                    "oLoadedState": null,

	                    /**
	                     * Source url for AJAX data for the table.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     *  @default null
	                     */
	                    "sAjaxSource": null,

	                    /**
	                     * Property from a given object from which to read the table data from. This
	                     * can be an empty string (when not server-side processing), in which case
	                     * it is  assumed an an array is given directly.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     */
	                    "sAjaxDataProp": null,

	                    /**
	                     * Note if draw should be blocked while getting data
	                     *  @type boolean
	                     *  @default true
	                     */
	                    "bAjaxDataGet": true,

	                    /**
	                     * The last jQuery XHR object that was used for server-side data gathering.
	                     * This can be used for working with the XHR information in one of the
	                     * callbacks
	                     *  @type object
	                     *  @default null
	                     */
	                    "jqXHR": null,

	                    /**
	                     * JSON returned from the server in the last Ajax request
	                     *  @type object
	                     *  @default undefined
	                     */
	                    "json": undefined,

	                    /**
	                     * Data submitted as part of the last Ajax request
	                     *  @type object
	                     *  @default undefined
	                     */
	                    "oAjaxData": undefined,

	                    /**
	                     * Function to get the server-side data.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type function
	                     */
	                    "fnServerData": null,

	                    /**
	                     * Functions which are called prior to sending an Ajax request so extra
	                     * parameters can easily be sent to the server
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoServerParams": [],

	                    /**
	                     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
	                     * required).
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type string
	                     */
	                    "sServerMethod": null,

	                    /**
	                     * Format numbers for display.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type function
	                     */
	                    "fnFormatNumber": null,

	                    /**
	                     * List of options that can be used for the user selectable length menu.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aLengthMenu": null,

	                    /**
	                     * Counter for the draws that the table does. Also used as a tracker for
	                     * server-side processing
	                     *  @type int
	                     *  @default 0
	                     */
	                    "iDraw": 0,

	                    /**
	                     * Indicate if a redraw is being done - useful for Ajax
	                     *  @type boolean
	                     *  @default false
	                     */
	                    "bDrawing": false,

	                    /**
	                     * Draw index (iDraw) of the last error when parsing the returned data
	                     *  @type int
	                     *  @default -1
	                     */
	                    "iDrawError": -1,

	                    /**
	                     * Paging display length
	                     *  @type int
	                     *  @default 10
	                     */
	                    "_iDisplayLength": 10,

	                    /**
	                     * Paging start point - aiDisplay index
	                     *  @type int
	                     *  @default 0
	                     */
	                    "_iDisplayStart": 0,

	                    /**
	                     * Server-side processing - number of records in the result set
	                     * (i.e. before filtering), Use fnRecordsTotal rather than
	                     * this property to get the value of the number of records, regardless of
	                     * the server-side processing setting.
	                     *  @type int
	                     *  @default 0
	                     *  @private
	                     */
	                    "_iRecordsTotal": 0,

	                    /**
	                     * Server-side processing - number of records in the current display set
	                     * (i.e. after filtering). Use fnRecordsDisplay rather than
	                     * this property to get the value of the number of records, regardless of
	                     * the server-side processing setting.
	                     *  @type boolean
	                     *  @default 0
	                     *  @private
	                     */
	                    "_iRecordsDisplay": 0,

	                    /**
	                     * Flag to indicate if jQuery UI marking and classes should be used.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type boolean
	                     */
	                    "bJUI": null,

	                    /**
	                     * The classes to use for the table
	                     *  @type object
	                     *  @default {}
	                     */
	                    "oClasses": {},

	                    /**
	                     * Flag attached to the settings object so you can check in the draw
	                     * callback if filtering has been done in the draw. Deprecated in favour of
	                     * events.
	                     *  @type boolean
	                     *  @default false
	                     *  @deprecated
	                     */
	                    "bFiltered": false,

	                    /**
	                     * Flag attached to the settings object so you can check in the draw
	                     * callback if sorting has been done in the draw. Deprecated in favour of
	                     * events.
	                     *  @type boolean
	                     *  @default false
	                     *  @deprecated
	                     */
	                    "bSorted": false,

	                    /**
	                     * Indicate that if multiple rows are in the header and there is more than
	                     * one unique cell per column, if the top one (true) or bottom one (false)
	                     * should be used for sorting / title by DataTables.
	                     * Note that this parameter will be set by the initialisation routine. To
	                     * set a default use {@link DataTable.defaults}.
	                     *  @type boolean
	                     */
	                    "bSortCellsTop": null,

	                    /**
	                     * Initialisation object that is used for the table
	                     *  @type object
	                     *  @default null
	                     */
	                    "oInit": null,

	                    /**
	                     * Destroy callback functions - for plug-ins to attach themselves to the
	                     * destroy so they can clean up markup and events.
	                     *  @type array
	                     *  @default []
	                     */
	                    "aoDestroyCallback": [],


	                    /**
	                     * Get the number of records in the current record set, before filtering
	                     *  @type function
	                     */
	                    "fnRecordsTotal": function () {
	                        return _fnDataSource(this) == 'ssp' ?
	                            this._iRecordsTotal * 1 :
	                            this.aiDisplayMaster.length;
	                    },

	                    /**
	                     * Get the number of records in the current record set, after filtering
	                     *  @type function
	                     */
	                    "fnRecordsDisplay": function () {
	                        return _fnDataSource(this) == 'ssp' ?
	                            this._iRecordsDisplay * 1 :
	                            this.aiDisplay.length;
	                    },

	                    /**
	                     * Get the display end point - aiDisplay index
	                     *  @type function
	                     */
	                    "fnDisplayEnd": function () {
	                        var
	                            len = this._iDisplayLength,
	                            start = this._iDisplayStart,
	                            calc = start + len,
	                            records = this.aiDisplay.length,
	                            features = this.oFeatures,
	                            paginate = features.bPaginate;

	                        if (features.bServerSide) {
	                            return paginate === false || len === -1 ?
	                                start + records :
	                                Math.min(start + len, this._iRecordsDisplay);
	                        }
	                        else {
	                            return !paginate || calc > records || len === -1 ?
	                                records :
	                                calc;
	                        }
	                    },

	                    /**
	                     * The DataTables object for this table
	                     *  @type object
	                     *  @default null
	                     */
	                    "oInstance": null,

	                    /**
	                     * Unique identifier for each instance of the DataTables object. If there
	                     * is an ID on the table node, then it takes that value, otherwise an
	                     * incrementing internal counter is used.
	                     *  @type string
	                     *  @default null
	                     */
	                    "sInstance": null,

	                    /**
	                     * tabindex attribute value that is added to DataTables control elements, allowing
	                     * keyboard navigation of the table and its controls.
	                     */
	                    "iTabIndex": 0,

	                    /**
	                     * DIV container for the footer scrolling table if scrolling
	                     */
	                    "nScrollHead": null,

	                    /**
	                     * DIV container for the footer scrolling table if scrolling
	                     */
	                    "nScrollFoot": null,

	                    /**
	                     * Last applied sort
	                     *  @type array
	                     *  @default []
	                     */
	                    "aLastSort": [],

	                    /**
	                     * Stored plug-in instances
	                     *  @type object
	                     *  @default {}
	                     */
	                    "oPlugins": {}
	                };

	                /**
	                 * Extension object for DataTables that is used to provide all extension
	                 * options.
	                 *
	                 * Note that the `DataTable.ext` object is available through
	                 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
	                 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
	                 *  @namespace
	                 *  @extends DataTable.models.ext
	                 */


	                /**
	                 * DataTables extensions
	                 * 
	                 * This namespace acts as a collection area for plug-ins that can be used to
	                 * extend DataTables capabilities. Indeed many of the build in methods
	                 * use this method to provide their own capabilities (sorting methods for
	                 * example).
	                 *
	                 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
	                 * reasons
	                 *
	                 *  @namespace
	                 */
	                DataTable.ext = _ext = {
	                    /**
	                     * Buttons. For use with the Buttons extension for DataTables. This is
	                     * defined here so other extensions can define buttons regardless of load
	                     * order. It is _not_ used by DataTables core.
	                     *
	                     *  @type object
	                     *  @default {}
	                     */
	                    buttons: {},


	                    /**
	                     * Element class names
	                     *
	                     *  @type object
	                     *  @default {}
	                     */
	                    classes: {},


	                    /**
	                     * Error reporting.
	                     * 
	                     * How should DataTables report an error. Can take the value 'alert',
	                     * 'throw', 'none' or a function.
	                     *
	                     *  @type string|function
	                     *  @default alert
	                     */
	                    errMode: "alert",


	                    /**
	                     * Feature plug-ins.
	                     * 
	                     * This is an array of objects which describe the feature plug-ins that are
	                     * available to DataTables. These feature plug-ins are then available for
	                     * use through the `dom` initialisation option.
	                     * 
	                     * Each feature plug-in is described by an object which must have the
	                     * following properties:
	                     * 
	                     * * `fnInit` - function that is used to initialise the plug-in,
	                     * * `cFeature` - a character so the feature can be enabled by the `dom`
	                     *   instillation option. This is case sensitive.
	                     *
	                     * The `fnInit` function has the following input parameters:
	                     *
	                     * 1. `{object}` DataTables settings object: see
	                     *    {@link DataTable.models.oSettings}
	                     *
	                     * And the following return is expected:
	                     * 
	                     * * {node|null} The element which contains your feature. Note that the
	                     *   return may also be void if your plug-in does not require to inject any
	                     *   DOM elements into DataTables control (`dom`) - for example this might
	                     *   be useful when developing a plug-in which allows table control via
	                     *   keyboard entry
	                     *
	                     *  @type array
	                     *
	                     *  @example
	                     *    $.fn.dataTable.ext.features.push( {
	                     *      "fnInit": function( oSettings ) {
	                     *        return new TableTools( { "oDTSettings": oSettings } );
	                     *      },
	                     *      "cFeature": "T"
	                     *    } );
	                     */
	                    feature: [],


	                    /**
	                     * Row searching.
	                     * 
	                     * This method of searching is complimentary to the default type based
	                     * searching, and a lot more comprehensive as it allows you complete control
	                     * over the searching logic. Each element in this array is a function
	                     * (parameters described below) that is called for every row in the table,
	                     * and your logic decides if it should be included in the searching data set
	                     * or not.
	                     *
	                     * Searching functions have the following input parameters:
	                     *
	                     * 1. `{object}` DataTables settings object: see
	                     *    {@link DataTable.models.oSettings}
	                     * 2. `{array|object}` Data for the row to be processed (same as the
	                     *    original format that was passed in as the data source, or an array
	                     *    from a DOM data source
	                     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
	                     *    can be useful to retrieve the `TR` element if you need DOM interaction.
	                     *
	                     * And the following return is expected:
	                     *
	                     * * {boolean} Include the row in the searched result set (true) or not
	                     *   (false)
	                     *
	                     * Note that as with the main search ability in DataTables, technically this
	                     * is "filtering", since it is subtractive. However, for consistency in
	                     * naming we call it searching here.
	                     *
	                     *  @type array
	                     *  @default []
	                     *
	                     *  @example
	                     *    // The following example shows custom search being applied to the
	                     *    // fourth column (i.e. the data[3] index) based on two input values
	                     *    // from the end-user, matching the data in a certain range.
	                     *    $.fn.dataTable.ext.search.push(
	                     *      function( settings, data, dataIndex ) {
	                     *        var min = document.getElementById('min').value * 1;
	                     *        var max = document.getElementById('max').value * 1;
	                     *        var version = data[3] == "-" ? 0 : data[3]*1;
	                     *
	                     *        if ( min == "" && max == "" ) {
	                     *          return true;
	                     *        }
	                     *        else if ( min == "" && version < max ) {
	                     *          return true;
	                     *        }
	                     *        else if ( min < version && "" == max ) {
	                     *          return true;
	                     *        }
	                     *        else if ( min < version && version < max ) {
	                     *          return true;
	                     *        }
	                     *        return false;
	                     *      }
	                     *    );
	                     */
	                    search: [],


	                    /**
	                     * Selector extensions
	                     *
	                     * The `selector` option can be used to extend the options available for the
	                     * selector modifier options (`selector-modifier` object data type) that
	                     * each of the three built in selector types offer (row, column and cell +
	                     * their plural counterparts). For example the Select extension uses this
	                     * mechanism to provide an option to select only rows, columns and cells
	                     * that have been marked as selected by the end user (`{selected: true}`),
	                     * which can be used in conjunction with the existing built in selector
	                     * options.
	                     *
	                     * Each property is an array to which functions can be pushed. The functions
	                     * take three attributes:
	                     *
	                     * * Settings object for the host table
	                     * * Options object (`selector-modifier` object type)
	                     * * Array of selected item indexes
	                     *
	                     * The return is an array of the resulting item indexes after the custom
	                     * selector has been applied.
	                     *
	                     *  @type object
	                     */
	                    selector: {
	                        cell: [],
	                        column: [],
	                        row: []
	                    },


	                    /**
	                     * Internal functions, exposed for used in plug-ins.
	                     * 
	                     * Please note that you should not need to use the internal methods for
	                     * anything other than a plug-in (and even then, try to avoid if possible).
	                     * The internal function may change between releases.
	                     *
	                     *  @type object
	                     *  @default {}
	                     */
	                    internal: {},


	                    /**
	                     * Legacy configuration options. Enable and disable legacy options that
	                     * are available in DataTables.
	                     *
	                     *  @type object
	                     */
	                    legacy: {
	                        /**
	                         * Enable / disable DataTables 1.9 compatible server-side processing
	                         * requests
	                         *
	                         *  @type boolean
	                         *  @default null
	                         */
	                        ajax: null
	                    },


	                    /**
	                     * Pagination plug-in methods.
	                     * 
	                     * Each entry in this object is a function and defines which buttons should
	                     * be shown by the pagination rendering method that is used for the table:
	                     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
	                     * buttons are displayed in the document, while the functions here tell it
	                     * what buttons to display. This is done by returning an array of button
	                     * descriptions (what each button will do).
	                     *
	                     * Pagination types (the four built in options and any additional plug-in
	                     * options defined here) can be used through the `paginationType`
	                     * initialisation parameter.
	                     *
	                     * The functions defined take two parameters:
	                     *
	                     * 1. `{int} page` The current page index
	                     * 2. `{int} pages` The number of pages in the table
	                     *
	                     * Each function is expected to return an array where each element of the
	                     * array can be one of:
	                     *
	                     * * `first` - Jump to first page when activated
	                     * * `last` - Jump to last page when activated
	                     * * `previous` - Show previous page when activated
	                     * * `next` - Show next page when activated
	                     * * `{int}` - Show page of the index given
	                     * * `{array}` - A nested array containing the above elements to add a
	                     *   containing 'DIV' element (might be useful for styling).
	                     *
	                     * Note that DataTables v1.9- used this object slightly differently whereby
	                     * an object with two functions would be defined for each plug-in. That
	                     * ability is still supported by DataTables 1.10+ to provide backwards
	                     * compatibility, but this option of use is now decremented and no longer
	                     * documented in DataTables 1.10+.
	                     *
	                     *  @type object
	                     *  @default {}
	                     *
	                     *  @example
	                     *    // Show previous, next and current page buttons only
	                     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
	                     *      return [ 'previous', page, 'next' ];
	                     *    };
	                     */
	                    pager: {},


	                    renderer: {
	                        pageButton: {},
	                        header: {}
	                    },


	                    /**
	                     * Ordering plug-ins - custom data source
	                     * 
	                     * The extension options for ordering of data available here is complimentary
	                     * to the default type based ordering that DataTables typically uses. It
	                     * allows much greater control over the the data that is being used to
	                     * order a column, but is necessarily therefore more complex.
	                     * 
	                     * This type of ordering is useful if you want to do ordering based on data
	                     * live from the DOM (for example the contents of an 'input' element) rather
	                     * than just the static string that DataTables knows of.
	                     * 
	                     * The way these plug-ins work is that you create an array of the values you
	                     * wish to be ordering for the column in question and then return that
	                     * array. The data in the array much be in the index order of the rows in
	                     * the table (not the currently ordering order!). Which order data gathering
	                     * function is run here depends on the `dt-init columns.orderDataType`
	                     * parameter that is used for the column (if any).
	                     *
	                     * The functions defined take two parameters:
	                     *
	                     * 1. `{object}` DataTables settings object: see
	                     *    {@link DataTable.models.oSettings}
	                     * 2. `{int}` Target column index
	                     *
	                     * Each function is expected to return an array:
	                     *
	                     * * `{array}` Data for the column to be ordering upon
	                     *
	                     *  @type array
	                     *
	                     *  @example
	                     *    // Ordering using `input` node values
	                     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
	                     *    {
	                     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
	                     *        return $('input', td).val();
	                     *      } );
	                     *    }
	                     */
	                    order: {},


	                    /**
	                     * Type based plug-ins.
	                     *
	                     * Each column in DataTables has a type assigned to it, either by automatic
	                     * detection or by direct assignment using the `type` option for the column.
	                     * The type of a column will effect how it is ordering and search (plug-ins
	                     * can also make use of the column type if required).
	                     *
	                     * @namespace
	                     */
	                    type: {
	                        /**
	                         * Type detection functions.
	                         *
	                         * The functions defined in this object are used to automatically detect
	                         * a column's type, making initialisation of DataTables super easy, even
	                         * when complex data is in the table.
	                         *
	                         * The functions defined take two parameters:
	                         *
	                         *  1. `{*}` Data from the column cell to be analysed
	                         *  2. `{settings}` DataTables settings object. This can be used to
	                         *     perform context specific type detection - for example detection
	                         *     based on language settings such as using a comma for a decimal
	                         *     place. Generally speaking the options from the settings will not
	                         *     be required
	                         *
	                         * Each function is expected to return:
	                         *
	                         * * `{string|null}` Data type detected, or null if unknown (and thus
	                         *   pass it on to the other type detection functions.
	                         *
	                         *  @type array
	                         *
	                         *  @example
	                         *    // Currency type detection plug-in:
	                         *    $.fn.dataTable.ext.type.detect.push(
	                         *      function ( data, settings ) {
	                         *        // Check the numeric part
	                         *        if ( ! $.isNumeric( data.substring(1) ) ) {
	                         *          return null;
	                         *        }
	                         *
	                         *        // Check prefixed by currency
	                         *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
	                         *          return 'currency';
	                         *        }
	                         *        return null;
	                         *      }
	                         *    );
	                         */
	                        detect: [],


	                        /**
	                         * Type based search formatting.
	                         *
	                         * The type based searching functions can be used to pre-format the
	                         * data to be search on. For example, it can be used to strip HTML
	                         * tags or to de-format telephone numbers for numeric only searching.
	                         *
	                         * Note that is a search is not defined for a column of a given type,
	                         * no search formatting will be performed.
	                         * 
	                         * Pre-processing of searching data plug-ins - When you assign the sType
	                         * for a column (or have it automatically detected for you by DataTables
	                         * or a type detection plug-in), you will typically be using this for
	                         * custom sorting, but it can also be used to provide custom searching
	                         * by allowing you to pre-processing the data and returning the data in
	                         * the format that should be searched upon. This is done by adding
	                         * functions this object with a parameter name which matches the sType
	                         * for that target column. This is the corollary of <i>afnSortData</i>
	                         * for searching data.
	                         *
	                         * The functions defined take a single parameter:
	                         *
	                         *  1. `{*}` Data from the column cell to be prepared for searching
	                         *
	                         * Each function is expected to return:
	                         *
	                         * * `{string|null}` Formatted string that will be used for the searching.
	                         *
	                         *  @type object
	                         *  @default {}
	                         *
	                         *  @example
	                         *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
	                         *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
	                         *    }
	                         */
	                        search: {},


	                        /**
	                         * Type based ordering.
	                         *
	                         * The column type tells DataTables what ordering to apply to the table
	                         * when a column is sorted upon. The order for each type that is defined,
	                         * is defined by the functions available in this object.
	                         *
	                         * Each ordering option can be described by three properties added to
	                         * this object:
	                         *
	                         * * `{type}-pre` - Pre-formatting function
	                         * * `{type}-asc` - Ascending order function
	                         * * `{type}-desc` - Descending order function
	                         *
	                         * All three can be used together, only `{type}-pre` or only
	                         * `{type}-asc` and `{type}-desc` together. It is generally recommended
	                         * that only `{type}-pre` is used, as this provides the optimal
	                         * implementation in terms of speed, although the others are provided
	                         * for compatibility with existing Javascript sort functions.
	                         *
	                         * `{type}-pre`: Functions defined take a single parameter:
	                         *
	                         *  1. `{*}` Data from the column cell to be prepared for ordering
	                         *
	                         * And return:
	                         *
	                         * * `{*}` Data to be sorted upon
	                         *
	                         * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
	                         * functions, taking two parameters:
	                         *
	                         *  1. `{*}` Data to compare to the second parameter
	                         *  2. `{*}` Data to compare to the first parameter
	                         *
	                         * And returning:
	                         *
	                         * * `{*}` Ordering match: <0 if first parameter should be sorted lower
	                         *   than the second parameter, ===0 if the two parameters are equal and
	                         *   >0 if the first parameter should be sorted height than the second
	                         *   parameter.
	                         * 
	                         *  @type object
	                         *  @default {}
	                         *
	                         *  @example
	                         *    // Numeric ordering of formatted numbers with a pre-formatter
	                         *    $.extend( $.fn.dataTable.ext.type.order, {
	                         *      "string-pre": function(x) {
	                         *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
	                         *        return parseFloat( a );
	                         *      }
	                         *    } );
	                         *
	                         *  @example
	                         *    // Case-sensitive string ordering, with no pre-formatting method
	                         *    $.extend( $.fn.dataTable.ext.order, {
	                         *      "string-case-asc": function(x,y) {
	                         *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
	                         *      },
	                         *      "string-case-desc": function(x,y) {
	                         *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
	                         *      }
	                         *    } );
	                         */
	                        order: {}
	                    },

	                    /**
	                     * Unique DataTables instance counter
	                     *
	                     * @type int
	                     * @private
	                     */
	                    _unique: 0,


	                    //
	                    // Depreciated
	                    // The following properties are retained for backwards compatiblity only.
	                    // The should not be used in new projects and will be removed in a future
	                    // version
	                    //

	                    /**
	                     * Version check function.
	                     *  @type function
	                     *  @depreciated Since 1.10
	                     */
	                    fnVersionCheck: DataTable.fnVersionCheck,


	                    /**
	                     * Index for what 'this' index API functions should use
	                     *  @type int
	                     *  @deprecated Since v1.10
	                     */
	                    iApiIndex: 0,


	                    /**
	                     * jQuery UI class container
	                     *  @type object
	                     *  @deprecated Since v1.10
	                     */
	                    oJUIClasses: {},


	                    /**
	                     * Software version
	                     *  @type string
	                     *  @deprecated Since v1.10
	                     */
	                    sVersion: DataTable.version
	                };


	                //
	                // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
	                //
	                $.extend(_ext, {
	                    afnFiltering: _ext.search,
	                    aTypes: _ext.type.detect,
	                    ofnSearch: _ext.type.search,
	                    oSort: _ext.type.order,
	                    afnSortData: _ext.order,
	                    aoFeatures: _ext.feature,
	                    oApi: _ext.internal,
	                    oStdClasses: _ext.classes,
	                    oPagination: _ext.pager
	                });


	                $.extend(DataTable.ext.classes, {
	                    "sTable": "dataTable",
	                    "sNoFooter": "no-footer",

	                    /* Paging buttons */
	                    "sPageButton": "paginate_button",
	                    "sPageButtonActive": "current",
	                    "sPageButtonDisabled": "disabled",

	                    /* Striping classes */
	                    "sStripeOdd": "odd",
	                    "sStripeEven": "even",

	                    /* Empty row */
	                    "sRowEmpty": "dataTables_empty",

	                    /* Features */
	                    "sWrapper": "dataTables_wrapper",
	                    "sFilter": "dataTables_filter",
	                    "sInfo": "dataTables_info",
	                    "sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
	                    "sLength": "dataTables_length",
	                    "sProcessing": "dataTables_processing",

	                    /* Sorting */
	                    "sSortAsc": "sorting_asc",
	                    "sSortDesc": "sorting_desc",
	                    "sSortable": "sorting", /* Sortable in both directions */
	                    "sSortableAsc": "sorting_asc_disabled",
	                    "sSortableDesc": "sorting_desc_disabled",
	                    "sSortableNone": "sorting_disabled",
	                    "sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */

	                    /* Filtering */
	                    "sFilterInput": "",

	                    /* Page length */
	                    "sLengthSelect": "",

	                    /* Scrolling */
	                    "sScrollWrapper": "dataTables_scroll",
	                    "sScrollHead": "dataTables_scrollHead",
	                    "sScrollHeadInner": "dataTables_scrollHeadInner",
	                    "sScrollBody": "dataTables_scrollBody",
	                    "sScrollFoot": "dataTables_scrollFoot",
	                    "sScrollFootInner": "dataTables_scrollFootInner",

	                    /* Misc */
	                    "sHeaderTH": "",
	                    "sFooterTH": "",

	                    // Deprecated
	                    "sSortJUIAsc": "",
	                    "sSortJUIDesc": "",
	                    "sSortJUI": "",
	                    "sSortJUIAscAllowed": "",
	                    "sSortJUIDescAllowed": "",
	                    "sSortJUIWrapper": "",
	                    "sSortIcon": "",
	                    "sJUIHeader": "",
	                    "sJUIFooter": ""
	                });


	                (function () {

	                    // Reused strings for better compression. Closure compiler appears to have a
	                    // weird edge case where it is trying to expand strings rather than use the
	                    // variable version. This results in about 200 bytes being added, for very
	                    // little preference benefit since it this run on script load only.
	                    var _empty = '';
	                    _empty = '';

	                    var _stateDefault = _empty + 'ui-state-default';
	                    var _sortIcon = _empty + 'css_right ui-icon ui-icon-';
	                    var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix';

	                    $.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {
	                        /* Full numbers paging buttons */
	                        "sPageButton": "fg-button ui-button " + _stateDefault,
	                        "sPageButtonActive": "ui-state-disabled",
	                        "sPageButtonDisabled": "ui-state-disabled",

	                        /* Features */
	                        "sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi " +
	                            "ui-buttonset-multi paging_", /* Note that the type is postfixed */

	                        /* Sorting */
	                        "sSortAsc": _stateDefault + " sorting_asc",
	                        "sSortDesc": _stateDefault + " sorting_desc",
	                        "sSortable": _stateDefault + " sorting",
	                        "sSortableAsc": _stateDefault + " sorting_asc_disabled",
	                        "sSortableDesc": _stateDefault + " sorting_desc_disabled",
	                        "sSortableNone": _stateDefault + " sorting_disabled",
	                        "sSortJUIAsc": _sortIcon + "triangle-1-n",
	                        "sSortJUIDesc": _sortIcon + "triangle-1-s",
	                        "sSortJUI": _sortIcon + "carat-2-n-s",
	                        "sSortJUIAscAllowed": _sortIcon + "carat-1-n",
	                        "sSortJUIDescAllowed": _sortIcon + "carat-1-s",
	                        "sSortJUIWrapper": "DataTables_sort_wrapper",
	                        "sSortIcon": "DataTables_sort_icon",

	                        /* Scrolling */
	                        "sScrollHead": "dataTables_scrollHead " + _stateDefault,
	                        "sScrollFoot": "dataTables_scrollFoot " + _stateDefault,

	                        /* Misc */
	                        "sHeaderTH": _stateDefault,
	                        "sFooterTH": _stateDefault,
	                        "sJUIHeader": _headerFooter + " ui-corner-tl ui-corner-tr",
	                        "sJUIFooter": _headerFooter + " ui-corner-bl ui-corner-br"
	                    });

	                }());



	                var extPagination = DataTable.ext.pager;

	                function _numbers(page, pages) {
	                    var
	                        numbers = [],
	                        buttons = extPagination.numbers_length,
	                        half = Math.floor(buttons / 2),
	                        i = 1;

	                    if (pages <= buttons) {
	                        numbers = _range(0, pages);
	                    }
	                    else if (page <= half) {
	                        numbers = _range(0, buttons - 2);
	                        numbers.push('ellipsis');
	                        numbers.push(pages - 1);
	                    }
	                    else if (page >= pages - 1 - half) {
	                        numbers = _range(pages - (buttons - 2), pages);
	                        numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6
	                        numbers.splice(0, 0, 0);
	                    }
	                    else {
	                        numbers = _range(page - half + 2, page + half - 1);
	                        numbers.push('ellipsis');
	                        numbers.push(pages - 1);
	                        numbers.splice(0, 0, 'ellipsis');
	                        numbers.splice(0, 0, 0);
	                    }

	                    numbers.DT_el = 'span';
	                    return numbers;
	                }


	                $.extend(extPagination, {
	                    simple: function (page, pages) {
	                        return ['previous', 'next'];
	                    },

	                    full: function (page, pages) {
	                        return ['first', 'previous', 'next', 'last'];
	                    },

	                    simple_numbers: function (page, pages) {
	                        return ['previous', _numbers(page, pages), 'next'];
	                    },

	                    full_numbers: function (page, pages) {
	                        return ['first', 'previous', _numbers(page, pages), 'next', 'last'];
	                    },

	                    // For testing and plug-ins to use
	                    _numbers: _numbers,

	                    // Number of number buttons (including ellipsis) to show. _Must be odd!_
	                    numbers_length: 7
	                });


	                $.extend(true, DataTable.ext.renderer, {
	                    pageButton: {
	                        _: function (settings, host, idx, buttons, page, pages) {
	                            var classes = settings.oClasses;
	                            var lang = settings.oLanguage.oPaginate;
	                            var btnDisplay, btnClass, counter = 0;

	                            var attach = function (container, buttons) {
	                                var i, ien, node, button;
	                                var clickHandler = function (e) {
	                                    _fnPageChange(settings, e.data.action, true);
	                                };

	                                for (i = 0, ien = buttons.length ; i < ien ; i++) {
	                                    button = buttons[i];

	                                    if ($.isArray(button)) {
	                                        var inner = $('<' + (button.DT_el || 'div') + '/>')
	                                            .appendTo(container);
	                                        attach(inner, button);
	                                    }
	                                    else {
	                                        btnDisplay = '';
	                                        btnClass = '';

	                                        switch (button) {
	                                            case 'ellipsis':
	                                                container.append('<span class="ellipsis">&#x2026;</span>');
	                                                break;

	                                            case 'first':
	                                                btnDisplay = lang.sFirst;
	                                                btnClass = button + (page > 0 ?
	                                                    '' : ' ' + classes.sPageButtonDisabled);
	                                                break;

	                                            case 'previous':
	                                                btnDisplay = lang.sPrevious;
	                                                btnClass = button + (page > 0 ?
	                                                    '' : ' ' + classes.sPageButtonDisabled);
	                                                break;

	                                            case 'next':
	                                                btnDisplay = lang.sNext;
	                                                btnClass = button + (page < pages - 1 ?
	                                                    '' : ' ' + classes.sPageButtonDisabled);
	                                                break;

	                                            case 'last':
	                                                btnDisplay = lang.sLast;
	                                                btnClass = button + (page < pages - 1 ?
	                                                    '' : ' ' + classes.sPageButtonDisabled);
	                                                break;

	                                            default:
	                                                btnDisplay = button + 1;
	                                                btnClass = page === button ?
	                                                    classes.sPageButtonActive : '';
	                                                break;
	                                        }

	                                        if (btnDisplay) {
	                                            node = $('<a>', {
	                                                'class': classes.sPageButton + ' ' + btnClass,
	                                                'aria-controls': settings.sTableId,
	                                                'data-dt-idx': counter,
	                                                'tabindex': settings.iTabIndex,
	                                                'id': idx === 0 && typeof button === 'string' ?
	                                                    settings.sTableId + '_' + button :
	                                                    null
	                                            })
	                                                .html(btnDisplay)
	                                                .appendTo(container);

	                                            _fnBindAction(
	                                                node, { action: button }, clickHandler
	                                            );

	                                            counter++;
	                                        }
	                                    }
	                                }
	                            };

	                            // IE9 throws an 'unknown error' if document.activeElement is used
	                            // inside an iframe or frame. Try / catch the error. Not good for
	                            // accessibility, but neither are frames.
	                            var activeEl;

	                            try {
	                                // Because this approach is destroying and recreating the paging
	                                // elements, focus is lost on the select button which is bad for
	                                // accessibility. So we want to restore focus once the draw has
	                                // completed
	                                activeEl = $(document.activeElement).data('dt-idx');
	                            }
	                            catch (e) { }

	                            attach($(host).empty(), buttons);

	                            if (activeEl) {
	                                $(host).find('[data-dt-idx=' + activeEl + ']').focus();
	                            }
	                        }
	                    }
	                });



	                // Built in type detection. See model.ext.aTypes for information about
	                // what is required from this methods.
	                $.extend(DataTable.ext.type.detect, [
	                    // Plain numbers - first since V8 detects some plain numbers as dates
	                    // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
	                    function (d, settings) {
	                        var decimal = settings.oLanguage.sDecimal;
	                        return _isNumber(d, decimal) ? 'num' + decimal : null;
	                    },

	                    // Dates (only those recognised by the browser's Date.parse)
	                    function (d, settings) {
	                        // V8 will remove any unknown characters at the start and end of the
	                        // expression, leading to false matches such as `$245.12` or `10%` being
	                        // a valid date. See forum thread 18941 for detail.
	                        if (d && !(d instanceof Date) && (!_re_date_start.test(d) || !_re_date_end.test(d))) {
	                            return null;
	                        }
	                        var parsed = Date.parse(d);
	                        return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;
	                    },

	                    // Formatted numbers
	                    function (d, settings) {
	                        var decimal = settings.oLanguage.sDecimal;
	                        return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;
	                    },

	                    // HTML numeric
	                    function (d, settings) {
	                        var decimal = settings.oLanguage.sDecimal;
	                        return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;
	                    },

	                    // HTML numeric, formatted
	                    function (d, settings) {
	                        var decimal = settings.oLanguage.sDecimal;
	                        return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;
	                    },

	                    // HTML (this is strict checking - there must be html)
	                    function (d, settings) {
	                        return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ?
	                            'html' : null;
	                    }
	                ]);



	                // Filter formatting functions. See model.ext.ofnSearch for information about
	                // what is required from these methods.
	                // 
	                // Note that additional search methods are added for the html numbers and
	                // html formatted numbers by `_addNumericSort()` when we know what the decimal
	                // place is


	                $.extend(DataTable.ext.type.search, {
	                    html: function (data) {
	                        return _empty(data) ?
	                            data :
	                            typeof data === 'string' ?
	                                data
	                                    .replace(_re_new_lines, " ")
	                                    .replace(_re_html, "") :
	                                '';
	                    },

	                    string: function (data) {
	                        return _empty(data) ?
	                            data :
	                            typeof data === 'string' ?
	                                data.replace(_re_new_lines, " ") :
	                                data;
	                    }
	                });



	                var __numericReplace = function (d, decimalPlace, re1, re2) {
	                    if (d !== 0 && (!d || d === '-')) {
	                        return -Infinity;
	                    }

	                    // If a decimal place other than `.` is used, it needs to be given to the
	                    // function so we can detect it and replace with a `.` which is the only
	                    // decimal place Javascript recognises - it is not locale aware.
	                    if (decimalPlace) {
	                        d = _numToDecimal(d, decimalPlace);
	                    }

	                    if (d.replace) {
	                        if (re1) {
	                            d = d.replace(re1, '');
	                        }

	                        if (re2) {
	                            d = d.replace(re2, '');
	                        }
	                    }

	                    return d * 1;
	                };


	                // Add the numeric 'deformatting' functions for sorting and search. This is done
	                // in a function to provide an easy ability for the language options to add
	                // additional methods if a non-period decimal place is used.
	                function _addNumericSort(decimalPlace) {
	                    $.each(
	                        {
	                            // Plain numbers
	                            "num": function (d) {
	                                return __numericReplace(d, decimalPlace);
	                            },

	                            // Formatted numbers
	                            "num-fmt": function (d) {
	                                return __numericReplace(d, decimalPlace, _re_formatted_numeric);
	                            },

	                            // HTML numeric
	                            "html-num": function (d) {
	                                return __numericReplace(d, decimalPlace, _re_html);
	                            },

	                            // HTML numeric, formatted
	                            "html-num-fmt": function (d) {
	                                return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);
	                            }
	                        },
	                        function (key, fn) {
	                            // Add the ordering method
	                            _ext.type.order[key + decimalPlace + '-pre'] = fn;

	                            // For HTML types add a search formatter that will strip the HTML
	                            if (key.match(/^html\-/)) {
	                                _ext.type.search[key + decimalPlace] = _ext.type.search.html;
	                            }
	                        }
	                    );
	                }


	                // Default sort methods
	                $.extend(_ext.type.order, {
	                    // Dates
	                    "date-pre": function (d) {
	                        return Date.parse(d) || 0;
	                    },

	                    // html
	                    "html-pre": function (a) {
	                        return _empty(a) ?
	                            '' :
	                            a.replace ?
	                                a.replace(/<.*?>/g, "").toLowerCase() :
	                                a + '';
	                    },

	                    // string
	                    "string-pre": function (a) {
	                        // This is a little complex, but faster than always calling toString,
	                        // http://jsperf.com/tostring-v-check
	                        return _empty(a) ?
	                            '' :
	                            typeof a === 'string' ?
	                                a.toLowerCase() :
	                                !a.toString ?
	                                    '' :
	                                    a.toString();
	                    },

	                    // string-asc and -desc are retained only for compatibility with the old
	                    // sort methods
	                    "string-asc": function (x, y) {
	                        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
	                    },

	                    "string-desc": function (x, y) {
	                        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
	                    }
	                });


	                // Numeric sorting types - order doesn't matter here
	                _addNumericSort('');


	                $.extend(true, DataTable.ext.renderer, {
	                    header: {
	                        _: function (settings, cell, column, classes) {
	                            // No additional mark-up required
	                            // Attach a sort listener to update on sort - note that using the
	                            // `DT` namespace will allow the event to be removed automatically
	                            // on destroy, while the `dt` namespaced event is the one we are
	                            // listening for
	                            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
	                                if (settings !== ctx) { // need to check this this is the host
	                                    return;               // table, not a nested one
	                                }

	                                var colIdx = column.idx;

	                                cell
	                                    .removeClass(
	                                        column.sSortingClass + ' ' +
	                                        classes.sSortAsc + ' ' +
	                                        classes.sSortDesc
	                                    )
	                                    .addClass(columns[colIdx] == 'asc' ?
	                                        classes.sSortAsc : columns[colIdx] == 'desc' ?
	                                            classes.sSortDesc :
	                                            column.sSortingClass
	                                    );
	                            });
	                        },

	                        jqueryui: function (settings, cell, column, classes) {
	                            $('<div/>')
	                                .addClass(classes.sSortJUIWrapper)
	                                .append(cell.contents())
	                                .append($('<span/>')
	                                    .addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)
	                                )
	                                .appendTo(cell);

	                            // Attach a sort listener to update on sort
	                            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {
	                                if (settings !== ctx) {
	                                    return;
	                                }

	                                var colIdx = column.idx;

	                                cell
	                                    .removeClass(classes.sSortAsc + " " + classes.sSortDesc)
	                                    .addClass(columns[colIdx] == 'asc' ?
	                                        classes.sSortAsc : columns[colIdx] == 'desc' ?
	                                            classes.sSortDesc :
	                                            column.sSortingClass
	                                    );

	                                cell
	                                    .find('span.' + classes.sSortIcon)
	                                    .removeClass(
	                                        classes.sSortJUIAsc + " " +
	                                        classes.sSortJUIDesc + " " +
	                                        classes.sSortJUI + " " +
	                                        classes.sSortJUIAscAllowed + " " +
	                                        classes.sSortJUIDescAllowed
	                                    )
	                                    .addClass(columns[colIdx] == 'asc' ?
	                                        classes.sSortJUIAsc : columns[colIdx] == 'desc' ?
	                                            classes.sSortJUIDesc :
	                                            column.sSortingClassJUI
	                                    );
	                            });
	                        }
	                    }
	                });

	                /*
	                 * Public helper functions. These aren't used internally by DataTables, or
	                 * called by any of the options passed into DataTables, but they can be used
	                 * externally by developers working with DataTables. They are helper functions
	                 * to make working with DataTables a little bit easier.
	                 */

	                /**
	                 * Helpers for `columns.render`.
	                 *
	                 * The options defined here can be used with the `columns.render` initialisation
	                 * option to provide a display renderer. The following functions are defined:
	                 *
	                 * * `number` - Will format numeric data (defined by `columns.data`) for
	                 *   display, retaining the original unformatted data for sorting and filtering.
	                 *   It takes 4 parameters:
	                 *   * `string` - Thousands grouping separator
	                 *   * `string` - Decimal point indicator
	                 *   * `integer` - Number of decimal points to show
	                 *   * `string` (optional) - Prefix.
	                 *
	                 * @example
	                 *   // Column definition using the number renderer
	                 *   {
	                 *     data: "salary",
	                 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
	                 *   }
	                 *
	                 * @namespace
	                 */
	                DataTable.render = {
	                    number: function (thousands, decimal, precision, prefix) {
	                        return {
	                            display: function (d) {
	                                if (typeof d !== 'number' && typeof d !== 'string') {
	                                    return d;
	                                }

	                                var negative = d < 0 ? '-' : '';
	                                d = Math.abs(parseFloat(d));

	                                var intPart = parseInt(d, 10);
	                                var floatPart = precision ?
	                                    decimal + (d - intPart).toFixed(precision).substring(2) :
	                                    '';

	                                return negative + (prefix || '') +
	                                    intPart.toString().replace(
	                                        /\B(?=(\d{3})+(?!\d))/g, thousands
	                                    ) +
	                                    floatPart;
	                            }
	                        };
	                    }
	                };


	                /*
	                 * This is really a good bit rubbish this method of exposing the internal methods
	                 * publicly... - To be fixed in 2.0 using methods on the prototype
	                 */


	                /**
	                 * Create a wrapper function for exporting an internal functions to an external API.
	                 *  @param {string} fn API function name
	                 *  @returns {function} wrapped function
	                 *  @memberof DataTable#internal
	                 */
	                function _fnExternApiFunc(fn) {
	                    return function () {
	                        var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
	                            Array.prototype.slice.call(arguments)
	                        );
	                        return DataTable.ext.internal[fn].apply(this, args);
	                    };
	                }


	                /**
	                 * Reference to internal functions for use by plug-in developers. Note that
	                 * these methods are references to internal functions and are considered to be
	                 * private. If you use these methods, be aware that they are liable to change
	                 * between versions.
	                 *  @namespace
	                 */
	                $.extend(DataTable.ext.internal, {
	                    _fnExternApiFunc: _fnExternApiFunc,
	                    _fnBuildAjax: _fnBuildAjax,
	                    _fnAjaxUpdate: _fnAjaxUpdate,
	                    _fnAjaxParameters: _fnAjaxParameters,
	                    _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
	                    _fnAjaxDataSrc: _fnAjaxDataSrc,
	                    _fnAddColumn: _fnAddColumn,
	                    _fnColumnOptions: _fnColumnOptions,
	                    _fnAdjustColumnSizing: _fnAdjustColumnSizing,
	                    _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
	                    _fnColumnIndexToVisible: _fnColumnIndexToVisible,
	                    _fnVisbleColumns: _fnVisbleColumns,
	                    _fnGetColumns: _fnGetColumns,
	                    _fnColumnTypes: _fnColumnTypes,
	                    _fnApplyColumnDefs: _fnApplyColumnDefs,
	                    _fnHungarianMap: _fnHungarianMap,
	                    _fnCamelToHungarian: _fnCamelToHungarian,
	                    _fnLanguageCompat: _fnLanguageCompat,
	                    _fnBrowserDetect: _fnBrowserDetect,
	                    _fnAddData: _fnAddData,
	                    _fnAddTr: _fnAddTr,
	                    _fnNodeToDataIndex: _fnNodeToDataIndex,
	                    _fnNodeToColumnIndex: _fnNodeToColumnIndex,
	                    _fnGetCellData: _fnGetCellData,
	                    _fnSetCellData: _fnSetCellData,
	                    _fnSplitObjNotation: _fnSplitObjNotation,
	                    _fnGetObjectDataFn: _fnGetObjectDataFn,
	                    _fnSetObjectDataFn: _fnSetObjectDataFn,
	                    _fnGetDataMaster: _fnGetDataMaster,
	                    _fnClearTable: _fnClearTable,
	                    _fnDeleteIndex: _fnDeleteIndex,
	                    _fnInvalidate: _fnInvalidate,
	                    _fnGetRowElements: _fnGetRowElements,
	                    _fnCreateTr: _fnCreateTr,
	                    _fnBuildHead: _fnBuildHead,
	                    _fnDrawHead: _fnDrawHead,
	                    _fnDraw: _fnDraw,
	                    _fnReDraw: _fnReDraw,
	                    _fnAddOptionsHtml: _fnAddOptionsHtml,
	                    _fnDetectHeader: _fnDetectHeader,
	                    _fnGetUniqueThs: _fnGetUniqueThs,
	                    _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
	                    _fnFilterComplete: _fnFilterComplete,
	                    _fnFilterCustom: _fnFilterCustom,
	                    _fnFilterColumn: _fnFilterColumn,
	                    _fnFilter: _fnFilter,
	                    _fnFilterCreateSearch: _fnFilterCreateSearch,
	                    _fnEscapeRegex: _fnEscapeRegex,
	                    _fnFilterData: _fnFilterData,
	                    _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
	                    _fnUpdateInfo: _fnUpdateInfo,
	                    _fnInfoMacros: _fnInfoMacros,
	                    _fnInitialise: _fnInitialise,
	                    _fnInitComplete: _fnInitComplete,
	                    _fnLengthChange: _fnLengthChange,
	                    _fnFeatureHtmlLength: _fnFeatureHtmlLength,
	                    _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
	                    _fnPageChange: _fnPageChange,
	                    _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
	                    _fnProcessingDisplay: _fnProcessingDisplay,
	                    _fnFeatureHtmlTable: _fnFeatureHtmlTable,
	                    _fnScrollDraw: _fnScrollDraw,
	                    _fnApplyToChildren: _fnApplyToChildren,
	                    _fnCalculateColumnWidths: _fnCalculateColumnWidths,
	                    _fnThrottle: _fnThrottle,
	                    _fnConvertToWidth: _fnConvertToWidth,
	                    _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,
	                    _fnGetWidestNode: _fnGetWidestNode,
	                    _fnGetMaxLenString: _fnGetMaxLenString,
	                    _fnStringToCss: _fnStringToCss,
	                    _fnScrollBarWidth: _fnScrollBarWidth,
	                    _fnSortFlatten: _fnSortFlatten,
	                    _fnSort: _fnSort,
	                    _fnSortAria: _fnSortAria,
	                    _fnSortListener: _fnSortListener,
	                    _fnSortAttachListener: _fnSortAttachListener,
	                    _fnSortingClasses: _fnSortingClasses,
	                    _fnSortData: _fnSortData,
	                    _fnSaveState: _fnSaveState,
	                    _fnLoadState: _fnLoadState,
	                    _fnSettingsFromNode: _fnSettingsFromNode,
	                    _fnLog: _fnLog,
	                    _fnMap: _fnMap,
	                    _fnBindAction: _fnBindAction,
	                    _fnCallbackReg: _fnCallbackReg,
	                    _fnCallbackFire: _fnCallbackFire,
	                    _fnLengthOverflow: _fnLengthOverflow,
	                    _fnRenderer: _fnRenderer,
	                    _fnDataSource: _fnDataSource,
	                    _fnRowAttributes: _fnRowAttributes,
	                    _fnCalculateEnd: function () { } // Used by a lot of plug-ins, but redundant
	                    // in 1.10, so this dead-end function is
	                    // added to prevent errors
	                });


	                // jQuery access
	                $.fn.dataTable = DataTable;

	                // Legacy aliases
	                $.fn.dataTableSettings = DataTable.settings;
	                $.fn.dataTableExt = DataTable.ext;

	                // With a capital `D` we return a DataTables API instance rather than a
	                // jQuery object
	                $.fn.DataTable = function (opts) {
	                    return $(this).dataTable(opts).api();
	                };

	                // All properties that are available to $.fn.dataTable should also be
	                // available on $.fn.DataTable
	                $.each(DataTable, function (prop, val) {
	                    $.fn.DataTable[prop] = val;
	                });


	                // Information about events fired by DataTables - for documentation.
	                /**
	                 * Draw event, fired whenever the table is redrawn on the page, at the same
	                 * point as fnDrawCallback. This may be useful for binding events or
	                 * performing calculations when the table is altered at all.
	                 *  @name DataTable#draw.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Search event, fired when the searching applied to the table (using the
	                 * built-in global search, or column filters) is altered.
	                 *  @name DataTable#search.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Page change event, fired when the paging of the table is altered.
	                 *  @name DataTable#page.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Order event, fired when the ordering applied to the table is altered.
	                 *  @name DataTable#order.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * DataTables initialisation complete event, fired when the table is fully
	                 * drawn, including Ajax data loaded, if Ajax data is required.
	                 *  @name DataTable#init.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {object} json The JSON object request from the server - only
	                 *    present if client-side Ajax sourced data is used</li></ol>
	                 */

	                /**
	                 * State save event, fired when the table has changed state a new state save
	                 * is required. This event allows modification of the state saving object
	                 * prior to actually doing the save, including addition or other state
	                 * properties (for plug-ins) or modification of a DataTables core property.
	                 *  @name DataTable#stateSaveParams.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {object} json The state information to be saved
	                 */

	                /**
	                 * State load event, fired when the table is loading state from the stored
	                 * data, but prior to the settings object being modified by the saved state
	                 * - allowing modification of the saved state is required or loading of
	                 * state for a plug-in.
	                 *  @name DataTable#stateLoadParams.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {object} json The saved state information
	                 */

	                /**
	                 * State loaded event, fired when state has been loaded from stored data and
	                 * the settings object has been modified by the loaded data.
	                 *  @name DataTable#stateLoaded.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {object} json The saved state information
	                 */

	                /**
	                 * Processing event, fired when DataTables is doing some kind of processing
	                 * (be it, order, searcg or anything else). It can be used to indicate to
	                 * the end user that there is something happening, or that something has
	                 * finished.
	                 *  @name DataTable#processing.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} oSettings DataTables settings object
	                 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
	                 */

	                /**
	                 * Ajax (XHR) event, fired whenever an Ajax request is completed from a
	                 * request to made to the server for new data. This event is called before
	                 * DataTables processed the returned data, so it can also be used to pre-
	                 * process the data returned from the server, if needed.
	                 *
	                 * Note that this trigger is called in `fnServerData`, if you override
	                 * `fnServerData` and which to use this event, you need to trigger it in you
	                 * success function.
	                 *  @name DataTable#xhr.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 *  @param {object} json JSON returned from the server
	                 *
	                 *  @example
	                 *     // Use a custom property returned from the server in another DOM element
	                 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	                 *       $('#status').html( json.status );
	                 *     } );
	                 *
	                 *  @example
	                 *     // Pre-process the data returned from the server
	                 *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {
	                 *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {
	                 *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;
	                 *       }
	                 *       // Note no return - manipulate the data directly in the JSON object.
	                 *     } );
	                 */

	                /**
	                 * Destroy event, fired when the DataTable is destroyed by calling fnDestroy
	                 * or passing the bDestroy:true parameter in the initialisation object. This
	                 * can be used to remove bound events, added DOM nodes, etc.
	                 *  @name DataTable#destroy.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Page length change event, fired when number of records to show on each
	                 * page (the length) is changed.
	                 *  @name DataTable#length.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 *  @param {integer} len New length
	                 */

	                /**
	                 * Column sizing has changed.
	                 *  @name DataTable#column-sizing.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 */

	                /**
	                 * Column visibility has changed.
	                 *  @name DataTable#column-visibility.dt
	                 *  @event
	                 *  @param {event} e jQuery event object
	                 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	                 *  @param {int} column Column index
	                 *  @param {bool} vis `false` if column now hidden, or `true` if visible
	                 */

	                return $.fn.dataTable;
	            }));

	        }(window, document));
	               
	    },
	    RunDataTable: function (CSSidselector) {

	        this.jqueryTableInit();

	        $(CSSidselector).DataTable({
	            "language": svlanguageSettings
	        });

	    }
	}

	let svlanguageSettings = {
	    "sEmptyTable": "Tabellen inneh" + String.fromCharCode(229) + "ller ingen data",
	    "sInfo": "Visar _START_ till _END_ av totalt _TOTAL_ rader",
	    "sInfoEmpty": "Visar 0 till 0 av totalt 0 rader",
	    "sInfoFiltered": "(filtrerade fr" + String.fromCharCode(229) + "n totalt _MAX_ rader)",
	    "sInfoPostFix": "",
	    "sInfoThousands": " ",
	    "sLengthMenu": "Visa _MENU_ rader",
	    "sLoadingRecords": "Laddar...",
	    "sProcessing": "Bearbetar...",
	    "sSearch": "S" + String.fromCharCode(246) + "k:",
	    "sZeroRecords": "Hittade inga matchande resultat",
	    "oPaginate": {
	        "sFirst": "F" + String.fromCharCode(246) + "rsta",
	        "sLast": "Sista",
	        "sNext": "N" + String.fromCharCode(228) + "sta",
	        "sPrevious": "F" + String.fromCharCode(246) + "reg" + String.fromCharCode(229) + "ende"
	    },
	    "oAria": {
	        "sSortAscending": ": aktivera f" + String.fromCharCode(246) + "r att sortera kolumnen i stigande ordning",
	        "sSortDescending": ": aktivera f" + String.fromCharCode(246) + "r att sortera kolumnen i fallande ordning"
	    }
	};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	let fillobj = __webpack_require__(5);
	let autocompleteobj2 = __webpack_require__(9);
	let servicecall = __webpack_require__(10);
	let $ = __webpack_require__(2);

	module.exports = {
	    init: function () {
	        this.cacheDom();
	        this.bindEvent();
	        this.render();
	        //autocompleteobj2.init('#bb_aj_cur_title');
	    },
	    cacheDom: function () {
	        this.$body = $('body');
	        this.$bb_aj_approve = $(".bb_aj_approve");
	        this.$bb_aj_modalContainer = $("#bb_aj_modalContainer");
	        this.$bb_aj_boktipformsavedata = $('#bb_aj_boktipformsavedata');
	        this.$bb_aj_cur_title= $("#bb_aj_cur_title");
	    },
	    bindEvent: function (userid) {
	        let that = this;        

	        this.$body.on('click', '.bb_aj_approve', function (e) {
	            let id = $(this).attr('data-tipid');            

	            fillobj.getCurrentItem(id, function () {
	                that.$bb_aj_modalContainer.show();
	                autocompleteobj2.init('#bb_aj_cur_title');
	            });
	                        
	            return false;
	        });

	        this.$body.on('click', '.bb_aj_delete', function (e) {
	            let id = $(this).attr('data-tipid');
	            fillobj.deleteitemBox(id);
	            that.$bb_aj_modalContainer.show();
	            return false;
	        });
	       
	        this.$body.on('change', '.bb_aj_valtboktips', function (e) {
	            let id = $(this).attr('data-tipid');
	            let val = 0;
	            
	            if (this.checked) {
	               val = 1;               
	            }
	            if (servicecall.approvetip(id, val)) {
	                console.log("approved json");
	            };

	            $(this).val(this.checked); 
	            return false;
	        });

	        this.$body.on('click', '#bb_aj_SaveEditToServer', function (e) {
	            
	            let bb_aj_boktipformsavedata = $('#bb_aj_boktipformsavedata');
	            let bb_aj_cur_title = $("#bb_aj_cur_title");

	            let savedata = {
	                TipID: $(this).attr('data-tipid'),
	                Title: bb_aj_cur_title.val(),
	                LowAge: bb_aj_boktipformsavedata.attr("data-low"),
	                HighAge: bb_aj_boktipformsavedata.attr("data-high"),
	                Category: bb_aj_boktipformsavedata.attr("data-cat"),
	                Userid: bb_aj_boktipformsavedata.attr("data-userid"),
	                Bookid: bb_aj_boktipformsavedata.attr("data-bookid"),
	                Review: tinyMCE.activeEditor.getContent()
	            }

	            if (savedata.Title && savedata.TipID > 0) {
	                fillobj.saveitemBox(savedata);
	                that.$bb_aj_modalContainer.show();

	            } else {
	                alert("Ange titel!");
	                bb_aj_cur_title.focus();
	            };           
	            
	            return false;
	        });
	               
	        this.$body.on('click', '.bb_aj_closeModal', function (e) {
	            that.$bb_aj_modalContainer.hide();
	            return false;
	        });

	        this.$body.on('change', '#drpBoktipSuitableAgeMin', function (e) {
	            let minage = $(this).val();
	            let bb_aj_boktipformsavedata = $('#bb_aj_boktipformsavedata');
	            bb_aj_boktipformsavedata.attr("data-low", minage);
	            console.log(minage);
	        });

	        this.$body.on('change', '#drpBoktipSuitableAgeMax', function (e) {
	            let maxage = $(this).val();
	            let bb_aj_boktipformsavedata = $('#bb_aj_boktipformsavedata');
	            bb_aj_boktipformsavedata.attr("data-high", maxage);
	            console.log(maxage);
	        });

	        this.$body.on('change', '#drpBoktipAmnen', function (e) {
	            let cat = $(this).val();
	            let bb_aj_boktipformsavedata = $('#bb_aj_boktipformsavedata');
	            bb_aj_boktipformsavedata.attr("data-cat", cat);
	            console.log(cat);
	        });
	       
	    },
	    render: function () {

	    }
	}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	let _hh = __webpack_require__(6)
	let edt = __webpack_require__(7);
	let appsettingsobject = __webpack_require__(8);
	let appsettings = appsettingsobject.config;

	module.exports = {
	    
	    getCurrentItem: function (id,callback) {
	        let _currentobj = appsettings.dataset.currentdatalist;

	        let currobj = _currentobj.Boktips.filter(item => item.TipID == id);
	                
	        _hh.injecthtmltemplate("#bb_aj_modalContainer", appsettings.handlebartemplate.hb_editor_tmp, currobj, function () {
	            edt.remove();
	            edt.init("#bb_aj_modalbody");
	                       
	            callback();
	        });             
	    },
	    saveitemBox: function (saveObj) {        
	        appsettings.dataset.saveboktipObj = saveObj;

	        _hh.injecthtmltemplate("#bb_aj_modalContainer", appsettings.handlebartemplate.hb_savebox_tmp, saveObj, function () {
	            return true;
	        });
	    },
	    deleteitemBox: function (tipid) {
	        let obj = { "TipID": tipid };

	        _hh.injecthtmltemplate("#bb_aj_modalContainer", appsettings.handlebartemplate.hb_delbox_tmp, obj, function () {            
	            return true;
	        });    
	    },
	    editcontent: function () {
	        //edt.activeEditor.getContent('');
	    },

	} //end moduleexport


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(2);

	module.exports = {
	    injecthtmltemplate: function (targetClass, usetemplateName, currentdata, callback) {
	        
	        $.get(usetemplateName, function (data) {
	            var temptpl = Handlebars.compile(data);
	            $(targetClass).html(temptpl(currentdata));
	            callback();
	        }, 'html');
	    }
	}

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	
	module.exports = {
	    _editorn: tinyMCE,
	    init: function (CSSidselector) {
	                   
	        this._editorn.init({
	            selector: CSSidselector,
	            menubar: false,
	            toolbar: 'undo redo | styleselect | bold italic | link image'
	        });

	    },//end init
	    remove: function () {
	        this._editorn.remove();
	    },
	    clear: function () {
	        this._editorn.activeEditor.setContent('');
	    },
	    setcontent: function (content) {
	        this._editorn.activeEditor.setContent(content);
	    }
	} //end moduleexport

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	
	module.exports = {
	    config: (function () {
	        let _apiserver = "http://localhost:59015";
	        let _dnnURL = "http://localdev.kivdev.se";
	        //let _apiserver = "http://dev1.barnensbibliotek.se:8080";
	        //let _dnnURL = "http://dev1.barnensbibliotek.se";
	        //let _apiserver = "http://dev1.barnensbibliotek.se:8080";
	        //let _dnnURL = "http://nytt.barnensbibliotek.se";
	        //let _apiserver = "https://www2.barnensbibliotek.se";
	        //let _dnnURL = "https://www.barnensbibliotek.se";
	        let _devkey = "alf";
	        let _apidevkeyend = "/devkey/" + _devkey + "/?type=jsonp&callback=?";
	        let _htmltemplateURL = "/DesktopModules/bb_aj_Boktips_Admin/template/";        
	        let _currentdatalist;
	        //// template
	        
	        let _hb_booktipList_template = _htmltemplateURL + "template_datatableRow.txt";   
	        let _hb_editor_template = _htmltemplateURL + "template_editor.txt"; 
	        let _hb_savebox_template = _htmltemplateURL + "template_save.txt";
	        let _hb_deletebox_template = _htmltemplateURL + "template_tabort.txt";
	        
	        // användarens senaste boktips
	        let _fn_booktipList = function (userid) {
	            return _apiserver + "/Api_v1/boktips/bylatest/1/devkey/" + _devkey + "/?type=json";
	        }
	        let _fn_booktipSave = function () {
	            return _apiserver + "/Api_v3.1/boktips/typ/editboktips/devkey/" + _devkey + "/?type=jsonp";
	        }
	        let _fn_booktipDelete = function () {            
	            return _apiserver + "/Api_v3.1/boktips/typ/deleteboktips/devkey/" + _devkey + "/?type=json";
	        }
	        let _fn_booktipApprove = function (tipid, val) {
	            return _apiserver + "/Api_v3.1/boktips/typ/approve/val/" + tipid + "/txtval/" + val + "/devkey/" + _devkey + "/?type=json";
	        }
	        let _fn_booktipListToAprove = function () {
	            return _apiserver + "/Api_v3.1/boktips/typ/toapprove/val/0/txtval/0/devkey/" + _devkey + "/?type=json";
	        }
	        let _fn_booktipListAll = function () {
	            return _apiserver + "/Api_v3.1/boktips/typ/getall/val/0/txtval/0/devkey/" + _devkey + "/?type=json";
	        }
	        // autocompleteURL
	        let _fn_autocompleteURL = function (antal) {
	            return _apiserver + "/Api_v3.1/katalogen/cmdtyp/autocomplete/antal/" + antal + "/devkey/" + _devkey + "/?type=json";
	        };
	           
	        return {
	            apiserver: _apiserver,
	            dnnURL: _dnnURL,
	            htmltemplateurl: _dnnURL + _htmltemplateURL,
	            devkey: _devkey,
	            handlebartemplate: {
	                hb_booktipList_tmp: _hb_booktipList_template,
	                hb_editor_tmp: _hb_editor_template,
	                hb_savebox_tmp: _hb_savebox_template,
	                hb_delbox_tmp: _hb_deletebox_template
	            },
	            api: {                
	                boktipslistor: {
	                    getboktipslistToApprove: _fn_booktipListToAprove,
	                    getboktipslistAll: _fn_booktipListAll
	                },
	                approve: _fn_booktipApprove,
	                save: _fn_booktipSave,
	                delete: _fn_booktipDelete,
	                autocomplete: {
	                    geturl: _fn_autocompleteURL
	                },                
	                devkeyend: _apidevkeyend
	            },
	            dataset: {
	                currentdatalist: _currentdatalist,
	                saveboktipObj: {}
	            },

	            debug: "false"
	        }
	    })(),
	    
	}



/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(2);
	var appsettingsobject = __webpack_require__(8);
	var appsettings = appsettingsobject.config;

	module.exports = {
	    init: function (ControlID) {
	        let autocomp = new autoComplete({
	            selector: ControlID,
	            minChars: 2,
	            source: function (term, response) {
	                let url = appsettings.api.autocomplete.geturl;
	                let test = url(10);
	                let searchdata = { "Searchstr": term };
	                $.ajax({
	                    async: true,
	                    type: "post",
	                    dataType: 'json',
	                    data:searchdata,
	                    url: url(10),
	                    success: function (data) {
	                        let suggestions = [];

	                        $.each(data.BookList, function (item, val) {
	                            
	                            suggestions.push([val.Title,val.Bookid]);
	                            
	                        });
	                        
	                        response(suggestions);
	                    },
	                    error: function (xhr, ajaxOptions, thrownError) {
	                        alert("Nått blev fel vid hämtning av arrangemang!");
	                    }
	                })

	            },
	            renderItem: function (item, search){
	                //search = search.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	                //var re = new RegExp("(" + search.split(' ').join('|') + ")", "gi");
	                // return '<div class="autocomplete-suggestion" data-bookid="' + item[1] + '">' + item[0].replace(re, "<b>$1</b>") + '</div>';
	                return '<div class="autocomplete-suggestion" data-bookid="' + item[1] + '">' + item[0] + '</div>';

	            },
	            onSelect: function (e, term, item) {
	                                
	                $('#bb_aj_cur_title').val(item.innerHTML);
	                $('.bb_aj_bookid').html(item.dataset.bookid);
	                $('#bb_aj_boktipformsavedata').attr("data-bookid", item.dataset.bookid);
	                                
	                return false;
	            }
	        });
	    }
	};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	let _service_old = __webpack_require__(11);
	let _service = __webpack_require__(12);
	let appsettingsobject = __webpack_require__(8);
	let appsettings = appsettingsobject.config;

	module.exports = {
	    approvetip: function (tipid, val) {
	        let jsondatapromise = _service.getjsondata(appsettings.api.approve(tipid, val));

	        jsondatapromise
	            .then(jsondata => { return true; })
	            .catch(err => false);
	    },
	    deletetip: function (tipid, callback) {
	        let dataopt = {           
	            "TipID": tipid
	        }

	        _service_old.postjsondata(appsettings.api.delete(), dataopt, function (data) {
	            callback(data);
	        });      

	    },
	    savetip: function (tipid, rubrik, content, callback) {
	        let dataopt = appsettings.dataset.saveboktipObj;

	        if (tipid === dataopt.TipID) {
	            _service_old.postjsondata(appsettings.api.save(), dataopt, function (data) {
	                    callback(data);
	            });
	        };
	    }
	}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(2);

	module.exports = {
	    getjsondata: function (url, callback) {
	        if (!url) {
	            return false;
	        } else {
	            //console.log("Searchservicen hämtar Arrangemangdata");
	            $.ajax({
	                async: true,
	                type: "get",
	                dataType: 'jsonp',
	                url: url,
	                success: function (data) {
	                    console.log("Search Detalj arrangemang hämtat: ");
	                    callback(data);
	                },
	                error: function (xhr, ajaxOptions, thrownError) {
	                    alert("Nått blev fel vid hämtning av arrangemang!");
	                }
	            })
	        };
	    },
	    postjsondata: function (url, postdata, callback) {
	        if (!url) {
	            return false;
	        } else {
	            //console.log("Searchservicen hämtar Arrangemangdata");
	            $.ajax({
	                async: true,

	                type: "post",
	                url: url,
	                data: postdata,
	                success: function (data) {
	                    console.log("Hämtar Data: ");
	                    callback(data);
	                },
	                error: function (xhr, ajaxOptions, thrownError) {
	                    alert("Nått blev fel vid hämtning av POST json!");
	                }
	            })
	        };
	    }
	}

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	
	module.exports = {
	    getjsondata: function (url) {
	        return fetch(url)
	            .then(res => res.json())
	            .then(jsondata => jsondata)
	            
	    },
	    postjsondata: function (url, postdata) {

	        const option = {
	            method: 'POST', 
	            mode:"no-cors",
	            body: JSON.stringify(postdata),
	            headers: {
	                "Content-Type": "application/json"
	            }

	        }
	        return fetch(url, option)
	            .then(res => res.json())
	            .then(jsondata => jsondata)

	    },
	    fetchjsonpdata: function (url, postdata) {
	        //postdata= { data: medskick, merdata: mera }
	        const option = {
	            method: 'POST',
	            header: 'application/json',
	            body: JSON.stringify(postdata)

	        }
	        return fetch(url, option)
	            .then(res => res.responseText())
	            .then(jsonText => JSON.parse(jsonText))

	    }
	}


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	
	let appsettingsobject = __webpack_require__(8);
	let appsettings = appsettingsobject.config;

	module.exports = {
	    init: function () {

	        Handlebars.registerHelper('checkapproved', function (Approve) {                        
	            if (Approve==1) {
	               return  "checked";
	            };            
	        });
	        Handlebars.registerHelper('filloptions', function (sel) {
	            let retopt,i;

	            for (i = 1; i < 20; i++) {
	                if (i == sel) {
	                    retopt += '<option value="' + i + '" selected >' + i + '</option>';
	                } else {
	                    retopt += '<option value="' + i + '">' + i + '</option>';
	                };
	            }
	            return retopt;
	        });
	        Handlebars.registerHelper('fillcat', function (sel) {
	            let retopt, i;

	            for (i = 0; i < 23; i++) {
	                if (i == sel) {
	                    retopt += '<option value="' + i + '" selected >' + i + '</option>';
	                } else {
	                    retopt += '<option value="' + i + '">' + i + '</option>';
	                };
	            }
	            return retopt;
	        });
	       
	    }
	}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhhbmRsZWJhcnMuanMiLCJhdXRvLWNvbXBsZXRlLmpzIiwiYWpfYmJfYm9rdGlwc2FkbWluX0tyeXBpbmJ1bmRsZVdlYnBhY2suMS4wLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdnVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYWpfYmJfYm9rdGlwc2FkbWluX2J1bmRsZS4xLjAuMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiFcclxuQU5EUkVBUyBIQU5ETEVCQVJTXHJcbiBAbGljZW5zZVxyXG4gaGFuZGxlYmFycyB2NC4wLjEwXHJcblxyXG5Db3B5cmlnaHQgKEMpIDIwMTEtMjAxNiBieSBZZWh1ZGEgS2F0elxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG5USEUgU09GVFdBUkUuXHJcblxyXG4qL1xyXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcclxuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcclxuXHRcdGV4cG9ydHNbXCJIYW5kbGViYXJzXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJIYW5kbGViYXJzXCJdID0gZmFjdG9yeSgpO1xyXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcclxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXAgQU5EUkVBUyBIQU5ETEVCQVJTXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcblxyXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xyXG5cclxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxyXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG5cclxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXHJcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxyXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2VcclxuLyoqKioqKi8gXHRcdH07XHJcblxyXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcclxuXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcclxuXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuXHJcblxyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG5cclxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XHJcblxyXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xyXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG4vKioqKioqLyB9KVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKioqKioqLyAoW1xyXG4vKiAwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc1J1bnRpbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFuZGxlYmFyc1J1bnRpbWUpO1xyXG5cclxuXHQvLyBDb21waWxlciBpbXBvcnRzXHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0NvbXBpbGVyQXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0NvbXBpbGVyQXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNDb21waWxlckFzdCk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0NvbXBpbGVyQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNDb21waWxlckNvbXBpbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0NvbXBpbGVySmF2YXNjcmlwdENvbXBpbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0NvbXBpbGVySmF2YXNjcmlwdENvbXBpbGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hhbmRsZWJhcnNDb21waWxlckphdmFzY3JpcHRDb21waWxlcik7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0NvbXBpbGVyVmlzaXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG5cclxuXHR2YXIgX2hhbmRsZWJhcnNDb21waWxlclZpc2l0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFuZGxlYmFyc0NvbXBpbGVyVmlzaXRvcik7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc05vQ29uZmxpY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzTm9Db25mbGljdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzTm9Db25mbGljdCk7XHJcblxyXG5cdHZhciBfY3JlYXRlID0gX2hhbmRsZWJhcnNSdW50aW1lMlsnZGVmYXVsdCddLmNyZWF0ZTtcclxuXHRmdW5jdGlvbiBjcmVhdGUoKSB7XHJcblx0ICB2YXIgaGIgPSBfY3JlYXRlKCk7XHJcblxyXG5cdCAgaGIuY29tcGlsZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xyXG5cdCAgICByZXR1cm4gX2hhbmRsZWJhcnNDb21waWxlckNvbXBpbGVyLmNvbXBpbGUoaW5wdXQsIG9wdGlvbnMsIGhiKTtcclxuXHQgIH07XHJcblx0ICBoYi5wcmVjb21waWxlID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XHJcblx0ICAgIHJldHVybiBfaGFuZGxlYmFyc0NvbXBpbGVyQ29tcGlsZXIucHJlY29tcGlsZShpbnB1dCwgb3B0aW9ucywgaGIpO1xyXG5cdCAgfTtcclxuXHJcblx0ICBoYi5BU1QgPSBfaGFuZGxlYmFyc0NvbXBpbGVyQXN0MlsnZGVmYXVsdCddO1xyXG5cdCAgaGIuQ29tcGlsZXIgPSBfaGFuZGxlYmFyc0NvbXBpbGVyQ29tcGlsZXIuQ29tcGlsZXI7XHJcblx0ICBoYi5KYXZhU2NyaXB0Q29tcGlsZXIgPSBfaGFuZGxlYmFyc0NvbXBpbGVySmF2YXNjcmlwdENvbXBpbGVyMlsnZGVmYXVsdCddO1xyXG5cdCAgaGIuUGFyc2VyID0gX2hhbmRsZWJhcnNDb21waWxlckJhc2UucGFyc2VyO1xyXG5cdCAgaGIucGFyc2UgPSBfaGFuZGxlYmFyc0NvbXBpbGVyQmFzZS5wYXJzZTtcclxuXHJcblx0ICByZXR1cm4gaGI7XHJcblx0fVxyXG5cclxuXHR2YXIgaW5zdCA9IGNyZWF0ZSgpO1xyXG5cdGluc3QuY3JlYXRlID0gY3JlYXRlO1xyXG5cclxuXHRfaGFuZGxlYmFyc05vQ29uZmxpY3QyWydkZWZhdWx0J10oaW5zdCk7XHJcblxyXG5cdGluc3QuVmlzaXRvciA9IF9oYW5kbGViYXJzQ29tcGlsZXJWaXNpdG9yMlsnZGVmYXVsdCddO1xyXG5cclxuXHRpbnN0WydkZWZhdWx0J10gPSBpbnN0O1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBpbnN0O1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRcInVzZSBzdHJpY3RcIjtcclxuXHJcblx0ZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0ICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xyXG5cdCAgICBcImRlZmF1bHRcIjogb2JqXHJcblx0ICB9O1xyXG5cdH07XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKVsnZGVmYXVsdCddO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcblxyXG5cdHZhciBiYXNlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2hhbmRsZWJhcnNCYXNlKTtcclxuXHJcblx0Ly8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxyXG5cdC8vIChUaGlzIGlzIGRvbmUgdG8gZWFzaWx5IHNoYXJlIGNvZGUgYmV0d2VlbiBjb21tb25qcyBhbmQgYnJvd3NlIGVudnMpXHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc1NhZmVTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzU2FmZVN0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzU2FmZVN0cmluZyk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc0V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzRXhjZXB0aW9uKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzVXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHR2YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaGFuZGxlYmFyc1V0aWxzKTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG5cclxuXHR2YXIgcnVudGltZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9oYW5kbGViYXJzUnVudGltZSk7XHJcblxyXG5cdHZhciBfaGFuZGxlYmFyc05vQ29uZmxpY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxuXHJcblx0dmFyIF9oYW5kbGViYXJzTm9Db25mbGljdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYW5kbGViYXJzTm9Db25mbGljdCk7XHJcblxyXG5cdC8vIEZvciBjb21wYXRpYmlsaXR5IGFuZCB1c2FnZSBvdXRzaWRlIG9mIG1vZHVsZSBzeXN0ZW1zLCBtYWtlIHRoZSBIYW5kbGViYXJzIG9iamVjdCBhIG5hbWVzcGFjZVxyXG5cdGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuXHQgIHZhciBoYiA9IG5ldyBiYXNlLkhhbmRsZWJhcnNFbnZpcm9ubWVudCgpO1xyXG5cclxuXHQgIFV0aWxzLmV4dGVuZChoYiwgYmFzZSk7XHJcblx0ICBoYi5TYWZlU3RyaW5nID0gX2hhbmRsZWJhcnNTYWZlU3RyaW5nMlsnZGVmYXVsdCddO1xyXG5cdCAgaGIuRXhjZXB0aW9uID0gX2hhbmRsZWJhcnNFeGNlcHRpb24yWydkZWZhdWx0J107XHJcblx0ICBoYi5VdGlscyA9IFV0aWxzO1xyXG5cdCAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XHJcblxyXG5cdCAgaGIuVk0gPSBydW50aW1lO1xyXG5cdCAgaGIudGVtcGxhdGUgPSBmdW5jdGlvbiAoc3BlYykge1xyXG5cdCAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XHJcblx0ICB9O1xyXG5cclxuXHQgIHJldHVybiBoYjtcclxuXHR9XHJcblxyXG5cdHZhciBpbnN0ID0gY3JlYXRlKCk7XHJcblx0aW5zdC5jcmVhdGUgPSBjcmVhdGU7XHJcblxyXG5cdF9oYW5kbGViYXJzTm9Db25mbGljdDJbJ2RlZmF1bHQnXShpbnN0KTtcclxuXHJcblx0aW5zdFsnZGVmYXVsdCddID0gaW5zdDtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gaW5zdDtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKG9iaikge1xyXG5cdCAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xyXG5cdCAgICByZXR1cm4gb2JqO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgdmFyIG5ld09iaiA9IHt9O1xyXG5cclxuXHQgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblx0ICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG5cdCAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xyXG5cdCAgICByZXR1cm4gbmV3T2JqO1xyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG4vKioqLyB9KSxcclxuLyogNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0ZXhwb3J0cy5IYW5kbGViYXJzRW52aXJvbm1lbnQgPSBIYW5kbGViYXJzRW52aXJvbm1lbnQ7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XHJcblxyXG5cdHZhciBfaGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cclxuXHR2YXIgX2RlY29yYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxuXHJcblx0dmFyIF9sb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxuXHJcblx0dmFyIF9sb2dnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9nZ2VyKTtcclxuXHJcblx0dmFyIFZFUlNJT04gPSAnNC4wLjEwJztcclxuXHRleHBvcnRzLlZFUlNJT04gPSBWRVJTSU9OO1xyXG5cdHZhciBDT01QSUxFUl9SRVZJU0lPTiA9IDc7XHJcblxyXG5cdGV4cG9ydHMuQ09NUElMRVJfUkVWSVNJT04gPSBDT01QSUxFUl9SRVZJU0lPTjtcclxuXHR2YXIgUkVWSVNJT05fQ0hBTkdFUyA9IHtcclxuXHQgIDE6ICc8PSAxLjAucmMuMicsIC8vIDEuMC5yYy4yIGlzIGFjdHVhbGx5IHJldjIgYnV0IGRvZXNuJ3QgcmVwb3J0IGl0XHJcblx0ICAyOiAnPT0gMS4wLjAtcmMuMycsXHJcblx0ICAzOiAnPT0gMS4wLjAtcmMuNCcsXHJcblx0ICA0OiAnPT0gMS54LngnLFxyXG5cdCAgNTogJz09IDIuMC4wLWFscGhhLngnLFxyXG5cdCAgNjogJz49IDIuMC4wLWJldGEuMScsXHJcblx0ICA3OiAnPj0gNC4wLjAnXHJcblx0fTtcclxuXHJcblx0ZXhwb3J0cy5SRVZJU0lPTl9DSEFOR0VTID0gUkVWSVNJT05fQ0hBTkdFUztcclxuXHR2YXIgb2JqZWN0VHlwZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5cclxuXHRmdW5jdGlvbiBIYW5kbGViYXJzRW52aXJvbm1lbnQoaGVscGVycywgcGFydGlhbHMsIGRlY29yYXRvcnMpIHtcclxuXHQgIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XHJcblx0ICB0aGlzLnBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XHJcblx0ICB0aGlzLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzIHx8IHt9O1xyXG5cclxuXHQgIF9oZWxwZXJzLnJlZ2lzdGVyRGVmYXVsdEhlbHBlcnModGhpcyk7XHJcblx0ICBfZGVjb3JhdG9ycy5yZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKHRoaXMpO1xyXG5cdH1cclxuXHJcblx0SGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcclxuXHQgIGNvbnN0cnVjdG9yOiBIYW5kbGViYXJzRW52aXJvbm1lbnQsXHJcblxyXG5cdCAgbG9nZ2VyOiBfbG9nZ2VyMlsnZGVmYXVsdCddLFxyXG5cdCAgbG9nOiBfbG9nZ2VyMlsnZGVmYXVsdCddLmxvZyxcclxuXHJcblx0ICByZWdpc3RlckhlbHBlcjogZnVuY3Rpb24gcmVnaXN0ZXJIZWxwZXIobmFtZSwgZm4pIHtcclxuXHQgICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XHJcblx0ICAgICAgaWYgKGZuKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIF91dGlscy5leHRlbmQodGhpcy5oZWxwZXJzLCBuYW1lKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uIHVucmVnaXN0ZXJIZWxwZXIobmFtZSkge1xyXG5cdCAgICBkZWxldGUgdGhpcy5oZWxwZXJzW25hbWVdO1xyXG5cdCAgfSxcclxuXHJcblx0ICByZWdpc3RlclBhcnRpYWw6IGZ1bmN0aW9uIHJlZ2lzdGVyUGFydGlhbChuYW1lLCBwYXJ0aWFsKSB7XHJcblx0ICAgIGlmIChfdXRpbHMudG9TdHJpbmcuY2FsbChuYW1lKSA9PT0gb2JqZWN0VHlwZSkge1xyXG5cdCAgICAgIF91dGlscy5leHRlbmQodGhpcy5wYXJ0aWFscywgbmFtZSk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykge1xyXG5cdCAgICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ0F0dGVtcHRpbmcgdG8gcmVnaXN0ZXIgYSBwYXJ0aWFsIGNhbGxlZCBcIicgKyBuYW1lICsgJ1wiIGFzIHVuZGVmaW5lZCcpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIHVucmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbiB1bnJlZ2lzdGVyUGFydGlhbChuYW1lKSB7XHJcblx0ICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xyXG5cdCAgfSxcclxuXHJcblx0ICByZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24gcmVnaXN0ZXJEZWNvcmF0b3IobmFtZSwgZm4pIHtcclxuXHQgICAgaWYgKF91dGlscy50b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XHJcblx0ICAgICAgaWYgKGZuKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBkZWNvcmF0b3JzJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIF91dGlscy5leHRlbmQodGhpcy5kZWNvcmF0b3JzLCBuYW1lKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uIHVucmVnaXN0ZXJEZWNvcmF0b3IobmFtZSkge1xyXG5cdCAgICBkZWxldGUgdGhpcy5kZWNvcmF0b3JzW25hbWVdO1xyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdHZhciBsb2cgPSBfbG9nZ2VyMlsnZGVmYXVsdCddLmxvZztcclxuXHJcblx0ZXhwb3J0cy5sb2cgPSBsb2c7XHJcblx0ZXhwb3J0cy5jcmVhdGVGcmFtZSA9IF91dGlscy5jcmVhdGVGcmFtZTtcclxuXHRleHBvcnRzLmxvZ2dlciA9IF9sb2dnZXIyWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcclxuXHRleHBvcnRzLmluZGV4T2YgPSBpbmRleE9mO1xyXG5cdGV4cG9ydHMuZXNjYXBlRXhwcmVzc2lvbiA9IGVzY2FwZUV4cHJlc3Npb247XHJcblx0ZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtcclxuXHRleHBvcnRzLmNyZWF0ZUZyYW1lID0gY3JlYXRlRnJhbWU7XHJcblx0ZXhwb3J0cy5ibG9ja1BhcmFtcyA9IGJsb2NrUGFyYW1zO1xyXG5cdGV4cG9ydHMuYXBwZW5kQ29udGV4dFBhdGggPSBhcHBlbmRDb250ZXh0UGF0aDtcclxuXHR2YXIgZXNjYXBlID0ge1xyXG5cdCAgJyYnOiAnJmFtcDsnLFxyXG5cdCAgJzwnOiAnJmx0OycsXHJcblx0ICAnPic6ICcmZ3Q7JyxcclxuXHQgICdcIic6ICcmcXVvdDsnLFxyXG5cdCAgXCInXCI6ICcmI3gyNzsnLFxyXG5cdCAgJ2AnOiAnJiN4NjA7JyxcclxuXHQgICc9JzogJyYjeDNEOydcclxuXHR9O1xyXG5cclxuXHR2YXIgYmFkQ2hhcnMgPSAvWyY8PlwiJ2A9XS9nLFxyXG5cdCAgICBwb3NzaWJsZSA9IC9bJjw+XCInYD1dLztcclxuXHJcblx0ZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcclxuXHQgIHJldHVybiBlc2NhcGVbY2hyXTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGV4dGVuZChvYmogLyogLCAuLi5zb3VyY2UgKi8pIHtcclxuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbaV0pIHtcclxuXHQgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tpXSwga2V5KSkge1xyXG5cdCAgICAgICAgb2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4gb2JqO1xyXG5cdH1cclxuXHJcblx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuXHJcblx0ZXhwb3J0cy50b1N0cmluZyA9IHRvU3RyaW5nO1xyXG5cdC8vIFNvdXJjZWQgZnJvbSBsb2Rhc2hcclxuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvbG9kYXNoL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XHJcblx0LyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xyXG5cdHZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xyXG5cdCAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcclxuXHR9O1xyXG5cdC8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxyXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0aWYgKGlzRnVuY3Rpb24oL3gvKSkge1xyXG5cdCAgZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG5cdCAgfTtcclxuXHR9XHJcblx0ZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcclxuXHJcblx0LyogZXNsaW50LWVuYWJsZSBmdW5jLXN0eWxlICovXHJcblxyXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0dmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG5cdCAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyA6IGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdGV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XHJcblx0Ly8gT2xkZXIgSUUgdmVyc2lvbnMgZG8gbm90IGRpcmVjdGx5IHN1cHBvcnQgaW5kZXhPZiBzbyB3ZSBtdXN0IGltcGxlbWVudCBvdXIgb3duLCBzYWRseS5cclxuXHJcblx0ZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcclxuXHQgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XHJcblx0ICAgICAgcmV0dXJuIGk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHQgIHJldHVybiAtMTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGVzY2FwZUV4cHJlc3Npb24oc3RyaW5nKSB7XHJcblx0ICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcclxuXHQgICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxyXG5cdCAgICBpZiAoc3RyaW5nICYmIHN0cmluZy50b0hUTUwpIHtcclxuXHQgICAgICByZXR1cm4gc3RyaW5nLnRvSFRNTCgpO1xyXG5cdCAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XHJcblx0ICAgICAgcmV0dXJuICcnO1xyXG5cdCAgICB9IGVsc2UgaWYgKCFzdHJpbmcpIHtcclxuXHQgICAgICByZXR1cm4gc3RyaW5nICsgJyc7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIEZvcmNlIGEgc3RyaW5nIGNvbnZlcnNpb24gYXMgdGhpcyB3aWxsIGJlIGRvbmUgYnkgdGhlIGFwcGVuZCByZWdhcmRsZXNzIGFuZFxyXG5cdCAgICAvLyB0aGUgcmVnZXggdGVzdCB3aWxsIGRvIHRoaXMgdHJhbnNwYXJlbnRseSBiZWhpbmQgdGhlIHNjZW5lcywgY2F1c2luZyBpc3N1ZXMgaWZcclxuXHQgICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXHJcblx0ICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmICghcG9zc2libGUudGVzdChzdHJpbmcpKSB7XHJcblx0ICAgIHJldHVybiBzdHJpbmc7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYmFkQ2hhcnMsIGVzY2FwZUNoYXIpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xyXG5cdCAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlRnJhbWUob2JqZWN0KSB7XHJcblx0ICB2YXIgZnJhbWUgPSBleHRlbmQoe30sIG9iamVjdCk7XHJcblx0ICBmcmFtZS5fcGFyZW50ID0gb2JqZWN0O1xyXG5cdCAgcmV0dXJuIGZyYW1lO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYmxvY2tQYXJhbXMocGFyYW1zLCBpZHMpIHtcclxuXHQgIHBhcmFtcy5wYXRoID0gaWRzO1xyXG5cdCAgcmV0dXJuIHBhcmFtcztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFwcGVuZENvbnRleHRQYXRoKGNvbnRleHRQYXRoLCBpZCkge1xyXG5cdCAgcmV0dXJuIChjb250ZXh0UGF0aCA/IGNvbnRleHRQYXRoICsgJy4nIDogJycpICsgaWQ7XHJcblx0fVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XHJcblxyXG5cdGZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XHJcblx0ICB2YXIgbG9jID0gbm9kZSAmJiBub2RlLmxvYyxcclxuXHQgICAgICBsaW5lID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgIGNvbHVtbiA9IHVuZGVmaW5lZDtcclxuXHQgIGlmIChsb2MpIHtcclxuXHQgICAgbGluZSA9IGxvYy5zdGFydC5saW5lO1xyXG5cdCAgICBjb2x1bW4gPSBsb2Muc3RhcnQuY29sdW1uO1xyXG5cclxuXHQgICAgbWVzc2FnZSArPSAnIC0gJyArIGxpbmUgKyAnOicgKyBjb2x1bW47XHJcblx0ICB9XHJcblxyXG5cdCAgdmFyIHRtcCA9IEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xyXG5cclxuXHQgIC8vIFVuZm9ydHVuYXRlbHkgZXJyb3JzIGFyZSBub3QgZW51bWVyYWJsZSBpbiBDaHJvbWUgKGF0IGxlYXN0KSwgc28gYGZvciBwcm9wIGluIHRtcGAgZG9lc24ndCB3b3JrLlxyXG5cdCAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XHJcblx0ICAgIHRoaXNbZXJyb3JQcm9wc1tpZHhdXSA9IHRtcFtlcnJvclByb3BzW2lkeF1dO1xyXG5cdCAgfVxyXG5cclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuXHQgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXhjZXB0aW9uKTtcclxuXHQgIH1cclxuXHJcblx0ICB0cnkge1xyXG5cdCAgICBpZiAobG9jKSB7XHJcblx0ICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcclxuXHJcblx0ICAgICAgLy8gV29yayBhcm91bmQgaXNzdWUgdW5kZXIgc2FmYXJpIHdoZXJlIHdlIGNhbid0IGRpcmVjdGx5IHNldCB0aGUgY29sdW1uIHZhbHVlXHJcblx0ICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgICBpZiAoX09iamVjdCRkZWZpbmVQcm9wZXJ0eSkge1xyXG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2x1bW4nLCB7XHJcblx0ICAgICAgICAgIHZhbHVlOiBjb2x1bW4sXHJcblx0ICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0gY2F0Y2ggKG5vcCkge1xyXG5cdCAgICAvKiBJZ25vcmUgaWYgdGhlIGJyb3dzZXIgaXMgdmVyeSBwYXJ0aWN1bGFyICovXHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHRFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IEV4Y2VwdGlvbjtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLCBfX2VzTW9kdWxlOiB0cnVlIH07XHJcblxyXG4vKioqLyB9KSxcclxuLyogOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xyXG5cdCAgcmV0dXJuICQuc2V0RGVzYyhpdCwga2V5LCBkZXNjKTtcclxuXHR9O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHR2YXIgJE9iamVjdCA9IE9iamVjdDtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgIGNyZWF0ZTogICAgICRPYmplY3QuY3JlYXRlLFxyXG5cdCAgZ2V0UHJvdG86ICAgJE9iamVjdC5nZXRQcm90b3R5cGVPZixcclxuXHQgIGlzRW51bTogICAgIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLFxyXG5cdCAgZ2V0RGVzYzogICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXHJcblx0ICBzZXREZXNjOiAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5LFxyXG5cdCAgc2V0RGVzY3M6ICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxyXG5cdCAgZ2V0S2V5czogICAgJE9iamVjdC5rZXlzLFxyXG5cdCAgZ2V0TmFtZXM6ICAgJE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxyXG5cdCAgZ2V0U3ltYm9sczogJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXHJcblx0ICBlYWNoOiAgICAgICBbXS5mb3JFYWNoXHJcblx0fTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0ZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRIZWxwZXJzID0gcmVnaXN0ZXJEZWZhdWx0SGVscGVycztcclxuXHJcblx0dmFyIF9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblxyXG5cdHZhciBfaGVscGVyc0Jsb2NrSGVscGVyTWlzc2luZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzQmxvY2tIZWxwZXJNaXNzaW5nKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNFYWNoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNFYWNoKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzSGVscGVyTWlzc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNIZWxwZXJNaXNzaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNIZWxwZXJNaXNzaW5nKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzSWYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuXHJcblx0dmFyIF9oZWxwZXJzSWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVyc0lmKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzTG9nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblxyXG5cdHZhciBfaGVscGVyc0xvZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzTG9nKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzTG9va3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcblxyXG5cdHZhciBfaGVscGVyc0xvb2t1cDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzTG9va3VwKTtcclxuXHJcblx0dmFyIF9oZWxwZXJzV2l0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnNXaXRoMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hlbHBlcnNXaXRoKTtcclxuXHJcblx0ZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0SGVscGVycyhpbnN0YW5jZSkge1xyXG5cdCAgX2hlbHBlcnNCbG9ja0hlbHBlck1pc3NpbmcyWydkZWZhdWx0J10oaW5zdGFuY2UpO1xyXG5cdCAgX2hlbHBlcnNFYWNoMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzSGVscGVyTWlzc2luZzJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XHJcblx0ICBfaGVscGVyc0lmMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzTG9nMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzTG9va3VwMlsnZGVmYXVsdCddKGluc3RhbmNlKTtcclxuXHQgIF9oZWxwZXJzV2l0aDJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XHJcblx0fVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignYmxvY2tIZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcclxuXHQgICAgdmFyIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXHJcblx0ICAgICAgICBmbiA9IG9wdGlvbnMuZm47XHJcblxyXG5cdCAgICBpZiAoY29udGV4dCA9PT0gdHJ1ZSkge1xyXG5cdCAgICAgIHJldHVybiBmbih0aGlzKTtcclxuXHQgICAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBmYWxzZSB8fCBjb250ZXh0ID09IG51bGwpIHtcclxuXHQgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcclxuXHQgICAgfSBlbHNlIGlmIChfdXRpbHMuaXNBcnJheShjb250ZXh0KSkge1xyXG5cdCAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgIGlmIChvcHRpb25zLmlkcykge1xyXG5cdCAgICAgICAgICBvcHRpb25zLmlkcyA9IFtvcHRpb25zLm5hbWVdO1xyXG5cdCAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHJldHVybiBpbnZlcnNlKHRoaXMpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XHJcblx0ICAgICAgICB2YXIgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xyXG5cdCAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IF91dGlscy5hcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMubmFtZSk7XHJcblx0ICAgICAgICBvcHRpb25zID0geyBkYXRhOiBkYXRhIH07XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XHJcblx0ICAgIGlmICghb3B0aW9ucykge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdNdXN0IHBhc3MgaXRlcmF0b3IgdG8gI2VhY2gnKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGZuID0gb3B0aW9ucy5mbixcclxuXHQgICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXHJcblx0ICAgICAgICBpID0gMCxcclxuXHQgICAgICAgIHJldCA9ICcnLFxyXG5cdCAgICAgICAgZGF0YSA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGNvbnRleHRQYXRoID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xyXG5cdCAgICAgIGNvbnRleHRQYXRoID0gX3V0aWxzLmFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoX3V0aWxzLmlzRnVuY3Rpb24oY29udGV4dCkpIHtcclxuXHQgICAgICBjb250ZXh0ID0gY29udGV4dC5jYWxsKHRoaXMpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAob3B0aW9ucy5kYXRhKSB7XHJcblx0ICAgICAgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBmdW5jdGlvbiBleGVjSXRlcmF0aW9uKGZpZWxkLCBpbmRleCwgbGFzdCkge1xyXG5cdCAgICAgIGlmIChkYXRhKSB7XHJcblx0ICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xyXG5cdCAgICAgICAgZGF0YS5pbmRleCA9IGluZGV4O1xyXG5cdCAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xyXG5cdCAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xyXG5cclxuXHQgICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xyXG5cdCAgICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gY29udGV4dFBhdGggKyBmaWVsZDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XHJcblx0ICAgICAgICBkYXRhOiBkYXRhLFxyXG5cdCAgICAgICAgYmxvY2tQYXJhbXM6IF91dGlscy5ibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoY29udGV4dCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcclxuXHQgICAgICBpZiAoX3V0aWxzLmlzQXJyYXkoY29udGV4dCkpIHtcclxuXHQgICAgICAgIGZvciAodmFyIGogPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdCAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XHJcblx0ICAgICAgICAgICAgZXhlY0l0ZXJhdGlvbihpLCBpLCBpID09PSBjb250ZXh0Lmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHZhciBwcmlvcktleSA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dCkge1xyXG5cdCAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0ICAgICAgICAgICAgLy8gV2UncmUgcnVubmluZyB0aGUgaXRlcmF0aW9ucyBvbmUgc3RlcCBvdXQgb2Ygc3luYyBzbyB3ZSBjYW4gZGV0ZWN0XHJcblx0ICAgICAgICAgICAgLy8gdGhlIGxhc3QgaXRlcmF0aW9uIHdpdGhvdXQgaGF2ZSB0byBzY2FuIHRoZSBvYmplY3QgdHdpY2UgYW5kIGNyZWF0ZVxyXG5cdCAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXHJcblx0ICAgICAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcHJpb3JLZXkgPSBrZXk7XHJcblx0ICAgICAgICAgICAgaSsrO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoaSA9PT0gMCkge1xyXG5cdCAgICAgIHJldCA9IGludmVyc2UodGhpcyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9KTtcclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaGVscGVyTWlzc2luZycsIGZ1bmN0aW9uICgpIC8qIFthcmdzLCBdb3B0aW9ucyAqL3tcclxuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcclxuXHQgICAgICAvLyBBIG1pc3NpbmcgZmllbGQgaW4gYSB7e2Zvb319IGNvbnN0cnVjdC5cclxuXHQgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIC8vIFNvbWVvbmUgaXMgYWN0dWFsbHkgdHJ5aW5nIHRvIGNhbGwgc29tZXRoaW5nLCBibG93IHVwLlxyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdNaXNzaW5nIGhlbHBlcjogXCInICsgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXS5uYW1lICsgJ1wiJyk7XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaWYnLCBmdW5jdGlvbiAoY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcclxuXHQgICAgaWYgKF91dGlscy5pc0Z1bmN0aW9uKGNvbmRpdGlvbmFsKSkge1xyXG5cdCAgICAgIGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuY2FsbCh0aGlzKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxyXG5cdCAgICAvLyBUaGUgYGluY2x1ZGVaZXJvYCBvcHRpb24gbWF5IGJlIHNldCB0byB0cmVhdCB0aGUgY29uZHRpb25hbCBhcyBwdXJlbHkgbm90IGVtcHR5IGJhc2VkIG9uIHRoZVxyXG5cdCAgICAvLyBiZWhhdmlvciBvZiBpc0VtcHR5LiBFZmZlY3RpdmVseSB0aGlzIGRldGVybWluZXMgaWYgMCBpcyBoYW5kbGVkIGJ5IHRoZSBwb3NpdGl2ZSBwYXRoIG9yIG5lZ2F0aXZlLlxyXG5cdCAgICBpZiAoIW9wdGlvbnMuaGFzaC5pbmNsdWRlWmVybyAmJiAhY29uZGl0aW9uYWwgfHwgX3V0aWxzLmlzRW1wdHkoY29uZGl0aW9uYWwpKSB7XHJcblx0ICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcclxuXHQgICAgfVxyXG5cdCAgfSk7XHJcblxyXG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3VubGVzcycsIGZ1bmN0aW9uIChjb25kaXRpb25hbCwgb3B0aW9ucykge1xyXG5cdCAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7IGZuOiBvcHRpb25zLmludmVyc2UsIGludmVyc2U6IG9wdGlvbnMuZm4sIGhhc2g6IG9wdGlvbnMuaGFzaCB9KTtcclxuXHQgIH0pO1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuXHQgIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdsb2cnLCBmdW5jdGlvbiAoKSAvKiBtZXNzYWdlLCBvcHRpb25zICove1xyXG5cdCAgICB2YXIgYXJncyA9IFt1bmRlZmluZWRdLFxyXG5cdCAgICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xyXG5cdCAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgbGV2ZWwgPSAxO1xyXG5cdCAgICBpZiAob3B0aW9ucy5oYXNoLmxldmVsICE9IG51bGwpIHtcclxuXHQgICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcclxuXHQgICAgfSBlbHNlIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhLmxldmVsICE9IG51bGwpIHtcclxuXHQgICAgICBsZXZlbCA9IG9wdGlvbnMuZGF0YS5sZXZlbDtcclxuXHQgICAgfVxyXG5cdCAgICBhcmdzWzBdID0gbGV2ZWw7XHJcblxyXG5cdCAgICBpbnN0YW5jZS5sb2cuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xyXG5cdCAgfSk7XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG5cdCAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvb2t1cCcsIGZ1bmN0aW9uIChvYmosIGZpZWxkKSB7XHJcblx0ICAgIHJldHVybiBvYmogJiYgb2JqW2ZpZWxkXTtcclxuXHQgIH0pO1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignd2l0aCcsIGZ1bmN0aW9uIChjb250ZXh0LCBvcHRpb25zKSB7XHJcblx0ICAgIGlmIChfdXRpbHMuaXNGdW5jdGlvbihjb250ZXh0KSkge1xyXG5cdCAgICAgIGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBmbiA9IG9wdGlvbnMuZm47XHJcblxyXG5cdCAgICBpZiAoIV91dGlscy5pc0VtcHR5KGNvbnRleHQpKSB7XHJcblx0ICAgICAgdmFyIGRhdGEgPSBvcHRpb25zLmRhdGE7XHJcblx0ICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xyXG5cdCAgICAgICAgZGF0YSA9IF91dGlscy5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xyXG5cdCAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IF91dGlscy5hcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMuaWRzWzBdKTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHJldHVybiBmbihjb250ZXh0LCB7XHJcblx0ICAgICAgICBkYXRhOiBkYXRhLFxyXG5cdCAgICAgICAgYmxvY2tQYXJhbXM6IF91dGlscy5ibG9ja1BhcmFtcyhbY29udGV4dF0sIFtkYXRhICYmIGRhdGEuY29udGV4dFBhdGhdKVxyXG5cdCAgICAgIH0pO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XHJcblx0ICAgIH1cclxuXHQgIH0pO1xyXG5cdH07XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnMgPSByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzO1xyXG5cclxuXHR2YXIgX2RlY29yYXRvcnNJbmxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuXHJcblx0dmFyIF9kZWNvcmF0b3JzSW5saW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlY29yYXRvcnNJbmxpbmUpO1xyXG5cclxuXHRmdW5jdGlvbiByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKGluc3RhbmNlKSB7XHJcblx0ICBfZGVjb3JhdG9yc0lubGluZTJbJ2RlZmF1bHQnXShpbnN0YW5jZSk7XHJcblx0fVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcblx0ICBpbnN0YW5jZS5yZWdpc3RlckRlY29yYXRvcignaW5saW5lJywgZnVuY3Rpb24gKGZuLCBwcm9wcywgY29udGFpbmVyLCBvcHRpb25zKSB7XHJcblx0ICAgIHZhciByZXQgPSBmbjtcclxuXHQgICAgaWYgKCFwcm9wcy5wYXJ0aWFscykge1xyXG5cdCAgICAgIHByb3BzLnBhcnRpYWxzID0ge307XHJcblx0ICAgICAgcmV0ID0gZnVuY3Rpb24gKGNvbnRleHQsIG9wdGlvbnMpIHtcclxuXHQgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxyXG5cdCAgICAgICAgdmFyIG9yaWdpbmFsID0gY29udGFpbmVyLnBhcnRpYWxzO1xyXG5cdCAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gX3V0aWxzLmV4dGVuZCh7fSwgb3JpZ2luYWwsIHByb3BzLnBhcnRpYWxzKTtcclxuXHQgICAgICAgIHZhciByZXQgPSBmbihjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IG9yaWdpbmFsO1xyXG5cdCAgICAgICAgcmV0dXJuIHJldDtcclxuXHQgICAgICB9O1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBwcm9wcy5wYXJ0aWFsc1tvcHRpb25zLmFyZ3NbMF1dID0gb3B0aW9ucy5mbjtcclxuXHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9KTtcclxuXHR9O1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBsb2dnZXIgPSB7XHJcblx0ICBtZXRob2RNYXA6IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10sXHJcblx0ICBsZXZlbDogJ2luZm8nLFxyXG5cclxuXHQgIC8vIE1hcHMgYSBnaXZlbiBsZXZlbCB2YWx1ZSB0byB0aGUgYG1ldGhvZE1hcGAgaW5kZXhlcyBhYm92ZS5cclxuXHQgIGxvb2t1cExldmVsOiBmdW5jdGlvbiBsb29rdXBMZXZlbChsZXZlbCkge1xyXG5cdCAgICBpZiAodHlwZW9mIGxldmVsID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgIHZhciBsZXZlbE1hcCA9IF91dGlscy5pbmRleE9mKGxvZ2dlci5tZXRob2RNYXAsIGxldmVsLnRvTG93ZXJDYXNlKCkpO1xyXG5cdCAgICAgIGlmIChsZXZlbE1hcCA+PSAwKSB7XHJcblx0ICAgICAgICBsZXZlbCA9IGxldmVsTWFwO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBsZXZlbCA9IHBhcnNlSW50KGxldmVsLCAxMCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gbGV2ZWw7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIENhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XHJcblx0ICBsb2c6IGZ1bmN0aW9uIGxvZyhsZXZlbCkge1xyXG5cdCAgICBsZXZlbCA9IGxvZ2dlci5sb29rdXBMZXZlbChsZXZlbCk7XHJcblxyXG5cdCAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGxvZ2dlci5sb29rdXBMZXZlbChsb2dnZXIubGV2ZWwpIDw9IGxldmVsKSB7XHJcblx0ICAgICAgdmFyIG1ldGhvZCA9IGxvZ2dlci5tZXRob2RNYXBbbGV2ZWxdO1xyXG5cdCAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7XHJcblx0ICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcclxuXHQgICAgICAgIG1ldGhvZCA9ICdsb2cnO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2UgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcblx0ICAgICAgICBtZXNzYWdlW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIGNvbnNvbGVbbWV0aG9kXS5hcHBseShjb25zb2xlLCBtZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBsb2dnZXI7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHQvLyBCdWlsZCBvdXQgb3VyIGJhc2ljIFNhZmVTdHJpbmcgdHlwZVxyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRmdW5jdGlvbiBTYWZlU3RyaW5nKHN0cmluZykge1xyXG5cdCAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XHJcblx0fVxyXG5cclxuXHRTYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IFNhZmVTdHJpbmcucHJvdG90eXBlLnRvSFRNTCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xyXG5cdH07XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNhZmVTdHJpbmc7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMjIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfT2JqZWN0JHNlYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKVsnZGVmYXVsdCddO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpWydkZWZhdWx0J107XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGV4cG9ydHMuY2hlY2tSZXZpc2lvbiA9IGNoZWNrUmV2aXNpb247XHJcblx0ZXhwb3J0cy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xyXG5cdGV4cG9ydHMud3JhcFByb2dyYW0gPSB3cmFwUHJvZ3JhbTtcclxuXHRleHBvcnRzLnJlc29sdmVQYXJ0aWFsID0gcmVzb2x2ZVBhcnRpYWw7XHJcblx0ZXhwb3J0cy5pbnZva2VQYXJ0aWFsID0gaW52b2tlUGFydGlhbDtcclxuXHRleHBvcnRzLm5vb3AgPSBub29wO1xyXG5cclxuXHR2YXIgX3V0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuXHJcblx0dmFyIFV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX3V0aWxzKTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9leGNlcHRpb24pO1xyXG5cclxuXHR2YXIgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxuXHRmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xyXG5cdCAgdmFyIGNvbXBpbGVyUmV2aXNpb24gPSBjb21waWxlckluZm8gJiYgY29tcGlsZXJJbmZvWzBdIHx8IDEsXHJcblx0ICAgICAgY3VycmVudFJldmlzaW9uID0gX2Jhc2UuQ09NUElMRVJfUkVWSVNJT047XHJcblxyXG5cdCAgaWYgKGNvbXBpbGVyUmV2aXNpb24gIT09IGN1cnJlbnRSZXZpc2lvbikge1xyXG5cdCAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xyXG5cdCAgICAgIHZhciBydW50aW1lVmVyc2lvbnMgPSBfYmFzZS5SRVZJU0lPTl9DSEFOR0VTW2N1cnJlbnRSZXZpc2lvbl0sXHJcblx0ICAgICAgICAgIGNvbXBpbGVyVmVyc2lvbnMgPSBfYmFzZS5SRVZJU0lPTl9DSEFOR0VTW2NvbXBpbGVyUmV2aXNpb25dO1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICsgJ1BsZWFzZSB1cGRhdGUgeW91ciBwcmVjb21waWxlciB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBydW50aW1lVmVyc2lvbnMgKyAnKSBvciBkb3duZ3JhZGUgeW91ciBydW50aW1lIHRvIGFuIG9sZGVyIHZlcnNpb24gKCcgKyBjb21waWxlclZlcnNpb25zICsgJykuJyk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArICdQbGVhc2UgdXBkYXRlIHlvdXIgcnVudGltZSB0byBhIG5ld2VyIHZlcnNpb24gKCcgKyBjb21waWxlckluZm9bMV0gKyAnKS4nKTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICBpZiAoIWVudikge1xyXG5cdCAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnTm8gZW52aXJvbm1lbnQgcGFzc2VkIHRvIHRlbXBsYXRlJyk7XHJcblx0ICB9XHJcblx0ICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcclxuXHQgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XHJcblx0ICB9XHJcblxyXG5cdCAgdGVtcGxhdGVTcGVjLm1haW4uZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjLm1haW5fZDtcclxuXHJcblx0ICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xyXG5cdCAgLy8gZm9yIGV4dGVybmFsIHVzZXJzIHRvIG92ZXJyaWRlIHRoZXNlIGFzIHBzdWVkby1zdXBwb3J0ZWQgQVBJcy5cclxuXHQgIGVudi5WTS5jaGVja1JldmlzaW9uKHRlbXBsYXRlU3BlYy5jb21waWxlcik7XHJcblxyXG5cdCAgZnVuY3Rpb24gaW52b2tlUGFydGlhbFdyYXBwZXIocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xyXG5cdCAgICBpZiAob3B0aW9ucy5oYXNoKSB7XHJcblx0ICAgICAgY29udGV4dCA9IFV0aWxzLmV4dGVuZCh7fSwgY29udGV4dCwgb3B0aW9ucy5oYXNoKTtcclxuXHQgICAgICBpZiAob3B0aW9ucy5pZHMpIHtcclxuXHQgICAgICAgIG9wdGlvbnMuaWRzWzBdID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgICAgdmFyIHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XHJcblxyXG5cdCAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcclxuXHQgICAgICBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0gPSBlbnYuY29tcGlsZShwYXJ0aWFsLCB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJPcHRpb25zLCBlbnYpO1xyXG5cdCAgICAgIHJlc3VsdCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXShjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcclxuXHQgICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcclxuXHQgICAgICAgIHZhciBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XHJcblx0ICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgIGxpbmVzW2ldID0gb3B0aW9ucy5pbmRlbnQgKyBsaW5lc1tpXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgY29tcGlsZWQgd2hlbiBydW5uaW5nIGluIHJ1bnRpbWUtb25seSBtb2RlJyk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICAvLyBKdXN0IGFkZCB3YXRlclxyXG5cdCAgdmFyIGNvbnRhaW5lciA9IHtcclxuXHQgICAgc3RyaWN0OiBmdW5jdGlvbiBzdHJpY3Qob2JqLCBuYW1lKSB7XHJcblx0ICAgICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XHJcblx0ICAgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnXCInICsgbmFtZSArICdcIiBub3QgZGVmaW5lZCBpbiAnICsgb2JqKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgcmV0dXJuIG9ialtuYW1lXTtcclxuXHQgICAgfSxcclxuXHQgICAgbG9va3VwOiBmdW5jdGlvbiBsb29rdXAoZGVwdGhzLCBuYW1lKSB7XHJcblx0ICAgICAgdmFyIGxlbiA9IGRlcHRocy5sZW5ndGg7XHJcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgICAgaWYgKGRlcHRoc1tpXSAmJiBkZXB0aHNbaV1bbmFtZV0gIT0gbnVsbCkge1xyXG5cdCAgICAgICAgICByZXR1cm4gZGVwdGhzW2ldW25hbWVdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfSxcclxuXHQgICAgbGFtYmRhOiBmdW5jdGlvbiBsYW1iZGEoY3VycmVudCwgY29udGV4dCkge1xyXG5cdCAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxyXG5cdCAgICBpbnZva2VQYXJ0aWFsOiBpbnZva2VQYXJ0aWFsV3JhcHBlcixcclxuXHJcblx0ICAgIGZuOiBmdW5jdGlvbiBmbihpKSB7XHJcblx0ICAgICAgdmFyIHJldCA9IHRlbXBsYXRlU3BlY1tpXTtcclxuXHQgICAgICByZXQuZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjW2kgKyAnX2QnXTtcclxuXHQgICAgICByZXR1cm4gcmV0O1xyXG5cdCAgICB9LFxyXG5cclxuXHQgICAgcHJvZ3JhbXM6IFtdLFxyXG5cdCAgICBwcm9ncmFtOiBmdW5jdGlvbiBwcm9ncmFtKGksIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcclxuXHQgICAgICB2YXIgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldLFxyXG5cdCAgICAgICAgICBmbiA9IHRoaXMuZm4oaSk7XHJcblx0ICAgICAgaWYgKGRhdGEgfHwgZGVwdGhzIHx8IGJsb2NrUGFyYW1zIHx8IGRlY2xhcmVkQmxvY2tQYXJhbXMpIHtcclxuXHQgICAgICAgIHByb2dyYW1XcmFwcGVyID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xyXG5cdCAgICAgIH0gZWxzZSBpZiAoIXByb2dyYW1XcmFwcGVyKSB7XHJcblx0ICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbik7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHJldHVybiBwcm9ncmFtV3JhcHBlcjtcclxuXHQgICAgfSxcclxuXHJcblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEodmFsdWUsIGRlcHRoKSB7XHJcblx0ICAgICAgd2hpbGUgKHZhbHVlICYmIGRlcHRoLS0pIHtcclxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcclxuXHQgICAgICB9XHJcblx0ICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICB9LFxyXG5cdCAgICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UocGFyYW0sIGNvbW1vbikge1xyXG5cdCAgICAgIHZhciBvYmogPSBwYXJhbSB8fCBjb21tb247XHJcblxyXG5cdCAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgcGFyYW0gIT09IGNvbW1vbikge1xyXG5cdCAgICAgICAgb2JqID0gVXRpbHMuZXh0ZW5kKHt9LCBjb21tb24sIHBhcmFtKTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHJldHVybiBvYmo7XHJcblx0ICAgIH0sXHJcblx0ICAgIC8vIEFuIGVtcHR5IG9iamVjdCB0byB1c2UgYXMgcmVwbGFjZW1lbnQgZm9yIG51bGwtY29udGV4dHNcclxuXHQgICAgbnVsbENvbnRleHQ6IF9PYmplY3Qkc2VhbCh7fSksXHJcblxyXG5cdCAgICBub29wOiBlbnYuVk0ubm9vcCxcclxuXHQgICAgY29tcGlsZXJJbmZvOiB0ZW1wbGF0ZVNwZWMuY29tcGlsZXJcclxuXHQgIH07XHJcblxyXG5cdCAgZnVuY3Rpb24gcmV0KGNvbnRleHQpIHtcclxuXHQgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcclxuXHJcblx0ICAgIHZhciBkYXRhID0gb3B0aW9ucy5kYXRhO1xyXG5cclxuXHQgICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcclxuXHQgICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcclxuXHQgICAgICBkYXRhID0gaW5pdERhdGEoY29udGV4dCwgZGF0YSk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIGRlcHRocyA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGJsb2NrUGFyYW1zID0gdGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zID8gW10gOiB1bmRlZmluZWQ7XHJcblx0ICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XHJcblx0ICAgICAgICBkZXB0aHMgPSBjb250ZXh0ICE9IG9wdGlvbnMuZGVwdGhzWzBdID8gW2NvbnRleHRdLmNvbmNhdChvcHRpb25zLmRlcHRocykgOiBvcHRpb25zLmRlcHRocztcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgZGVwdGhzID0gW2NvbnRleHRdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgZnVuY3Rpb24gbWFpbihjb250ZXh0IC8qLCBvcHRpb25zKi8pIHtcclxuXHQgICAgICByZXR1cm4gJycgKyB0ZW1wbGF0ZVNwZWMubWFpbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xyXG5cdCAgICB9XHJcblx0ICAgIG1haW4gPSBleGVjdXRlRGVjb3JhdG9ycyh0ZW1wbGF0ZVNwZWMubWFpbiwgbWFpbiwgY29udGFpbmVyLCBvcHRpb25zLmRlcHRocyB8fCBbXSwgZGF0YSwgYmxvY2tQYXJhbXMpO1xyXG5cdCAgICByZXR1cm4gbWFpbihjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgIH1cclxuXHQgIHJldC5pc1RvcCA9IHRydWU7XHJcblxyXG5cdCAgcmV0Ll9zZXR1cCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsKSB7XHJcblx0ICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XHJcblxyXG5cdCAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCkge1xyXG5cdCAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMucGFydGlhbHMsIGVudi5wYXJ0aWFscyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCB8fCB0ZW1wbGF0ZVNwZWMudXNlRGVjb3JhdG9ycykge1xyXG5cdCAgICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5kZWNvcmF0b3JzLCBlbnYuZGVjb3JhdG9ycyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIGNvbnRhaW5lci5oZWxwZXJzID0gb3B0aW9ucy5oZWxwZXJzO1xyXG5cdCAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IG9wdGlvbnMucGFydGlhbHM7XHJcblx0ICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBvcHRpb25zLmRlY29yYXRvcnM7XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblxyXG5cdCAgcmV0Ll9jaGlsZCA9IGZ1bmN0aW9uIChpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XHJcblx0ICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgJiYgIWJsb2NrUGFyYW1zKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ211c3QgcGFzcyBibG9jayBwYXJhbXMnKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocyAmJiAhZGVwdGhzKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ211c3QgcGFzcyBwYXJlbnQgZGVwdGhzJyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiB3cmFwUHJvZ3JhbShjb250YWluZXIsIGksIHRlbXBsYXRlU3BlY1tpXSwgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XHJcblx0ICB9O1xyXG5cdCAgcmV0dXJuIHJldDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHdyYXBQcm9ncmFtKGNvbnRhaW5lciwgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcclxuXHQgIGZ1bmN0aW9uIHByb2coY29udGV4dCkge1xyXG5cdCAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xyXG5cclxuXHQgICAgdmFyIGN1cnJlbnREZXB0aHMgPSBkZXB0aHM7XHJcblx0ICAgIGlmIChkZXB0aHMgJiYgY29udGV4dCAhPSBkZXB0aHNbMF0gJiYgIShjb250ZXh0ID09PSBjb250YWluZXIubnVsbENvbnRleHQgJiYgZGVwdGhzWzBdID09PSBudWxsKSkge1xyXG5cdCAgICAgIGN1cnJlbnREZXB0aHMgPSBbY29udGV4dF0uY29uY2F0KGRlcHRocyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiBmbihjb250YWluZXIsIGNvbnRleHQsIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsIG9wdGlvbnMuZGF0YSB8fCBkYXRhLCBibG9ja1BhcmFtcyAmJiBbb3B0aW9ucy5ibG9ja1BhcmFtc10uY29uY2F0KGJsb2NrUGFyYW1zKSwgY3VycmVudERlcHRocyk7XHJcblx0ICB9XHJcblxyXG5cdCAgcHJvZyA9IGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpO1xyXG5cclxuXHQgIHByb2cucHJvZ3JhbSA9IGk7XHJcblx0ICBwcm9nLmRlcHRoID0gZGVwdGhzID8gZGVwdGhzLmxlbmd0aCA6IDA7XHJcblx0ICBwcm9nLmJsb2NrUGFyYW1zID0gZGVjbGFyZWRCbG9ja1BhcmFtcyB8fCAwO1xyXG5cdCAgcmV0dXJuIHByb2c7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XHJcblx0ICBpZiAoIXBhcnRpYWwpIHtcclxuXHQgICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gJ0BwYXJ0aWFsLWJsb2NrJykge1xyXG5cdCAgICAgIHBhcnRpYWwgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xyXG5cdCAgICB9XHJcblx0ICB9IGVsc2UgaWYgKCFwYXJ0aWFsLmNhbGwgJiYgIW9wdGlvbnMubmFtZSkge1xyXG5cdCAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwYXJ0aWFsIHRoYXQgcmV0dXJuZWQgYSBzdHJpbmdcclxuXHQgICAgb3B0aW9ucy5uYW1lID0gcGFydGlhbDtcclxuXHQgICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbcGFydGlhbF07XHJcblx0ICB9XHJcblx0ICByZXR1cm4gcGFydGlhbDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xyXG5cdCAgLy8gVXNlIHRoZSBjdXJyZW50IGNsb3N1cmUgY29udGV4dCB0byBzYXZlIHRoZSBwYXJ0aWFsLWJsb2NrIGlmIHRoaXMgcGFydGlhbFxyXG5cdCAgdmFyIGN1cnJlbnRQYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ107XHJcblx0ICBvcHRpb25zLnBhcnRpYWwgPSB0cnVlO1xyXG5cdCAgaWYgKG9wdGlvbnMuaWRzKSB7XHJcblx0ICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCA9IG9wdGlvbnMuaWRzWzBdIHx8IG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aDtcclxuXHQgIH1cclxuXHJcblx0ICB2YXIgcGFydGlhbEJsb2NrID0gdW5kZWZpbmVkO1xyXG5cdCAgaWYgKG9wdGlvbnMuZm4gJiYgb3B0aW9ucy5mbiAhPT0gbm9vcCkge1xyXG5cdCAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgIG9wdGlvbnMuZGF0YSA9IF9iYXNlLmNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XHJcblx0ICAgICAgLy8gV3JhcHBlciBmdW5jdGlvbiB0byBnZXQgYWNjZXNzIHRvIGN1cnJlbnRQYXJ0aWFsQmxvY2sgZnJvbSB0aGUgY2xvc3VyZVxyXG5cdCAgICAgIHZhciBmbiA9IG9wdGlvbnMuZm47XHJcblx0ICAgICAgcGFydGlhbEJsb2NrID0gb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBmdW5jdGlvbiBwYXJ0aWFsQmxvY2tXcmFwcGVyKGNvbnRleHQpIHtcclxuXHQgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XHJcblxyXG5cdCAgICAgICAgLy8gUmVzdG9yZSB0aGUgcGFydGlhbC1ibG9jayBmcm9tIHRoZSBjbG9zdXJlIGZvciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBibG9ja1xyXG5cdCAgICAgICAgLy8gaS5lLiB0aGUgcGFydCBpbnNpZGUgdGhlIGJsb2NrIG9mIHRoZSBwYXJ0aWFsIGNhbGwuXHJcblx0ICAgICAgICBvcHRpb25zLmRhdGEgPSBfYmFzZS5jcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xyXG5cdCAgICAgICAgb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBjdXJyZW50UGFydGlhbEJsb2NrO1xyXG5cdCAgICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xyXG5cdCAgICAgIH07XHJcblx0ICAgICAgaWYgKGZuLnBhcnRpYWxzKSB7XHJcblx0ICAgICAgICBvcHRpb25zLnBhcnRpYWxzID0gVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnBhcnRpYWxzLCBmbi5wYXJ0aWFscyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9KSgpO1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChwYXJ0aWFsID09PSB1bmRlZmluZWQgJiYgcGFydGlhbEJsb2NrKSB7XHJcblx0ICAgIHBhcnRpYWwgPSBwYXJ0aWFsQmxvY2s7XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGZvdW5kJyk7XHJcblx0ICB9IGVsc2UgaWYgKHBhcnRpYWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG5cdCAgICByZXR1cm4gcGFydGlhbChjb250ZXh0LCBvcHRpb25zKTtcclxuXHQgIH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG5vb3AoKSB7XHJcblx0ICByZXR1cm4gJyc7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0RGF0YShjb250ZXh0LCBkYXRhKSB7XHJcblx0ICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcclxuXHQgICAgZGF0YSA9IGRhdGEgPyBfYmFzZS5jcmVhdGVGcmFtZShkYXRhKSA6IHt9O1xyXG5cdCAgICBkYXRhLnJvb3QgPSBjb250ZXh0O1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIGRhdGE7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKSB7XHJcblx0ICBpZiAoZm4uZGVjb3JhdG9yKSB7XHJcblx0ICAgIHZhciBwcm9wcyA9IHt9O1xyXG5cdCAgICBwcm9nID0gZm4uZGVjb3JhdG9yKHByb2csIHByb3BzLCBjb250YWluZXIsIGRlcHRocyAmJiBkZXB0aHNbMF0sIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xyXG5cdCAgICBVdGlscy5leHRlbmQocHJvZywgcHJvcHMpO1xyXG5cdCAgfVxyXG5cdCAgcmV0dXJuIHByb2c7XHJcblx0fVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKS5PYmplY3Quc2VhbDtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIDE5LjEuMi4xNyBPYmplY3Quc2VhbChPKVxyXG5cdHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xyXG5cclxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSgnc2VhbCcsIGZ1bmN0aW9uKCRzZWFsKXtcclxuXHQgIHJldHVybiBmdW5jdGlvbiBzZWFsKGl0KXtcclxuXHQgICAgcmV0dXJuICRzZWFsICYmIGlzT2JqZWN0KGl0KSA/ICRzZWFsKGl0KSA6IGl0O1xyXG5cdCAgfTtcclxuXHR9KTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xyXG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcclxuXHR9O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0Ly8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXHJcblx0dmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KVxyXG5cdCAgLCBjb3JlICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMClcclxuXHQgICwgZmFpbHMgICA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcclxuXHQgIHZhciBmbiAgPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV1cclxuXHQgICAgLCBleHAgPSB7fTtcclxuXHQgIGV4cFtLRVldID0gZXhlYyhmbik7XHJcblx0ICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XHJcblx0fTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdHZhciBnbG9iYWwgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KVxyXG5cdCAgLCBjb3JlICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKVxyXG5cdCAgLCBjdHggICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKVxyXG5cdCAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcclxuXHJcblx0dmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xyXG5cdCAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcclxuXHQgICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXHJcblx0ICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xyXG5cdCAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcclxuXHQgICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXHJcblx0ICAgICwgSVNfV1JBUCAgID0gdHlwZSAmICRleHBvcnQuV1xyXG5cdCAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXHJcblx0ICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxyXG5cdCAgICAsIGtleSwgb3duLCBvdXQ7XHJcblx0ICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcclxuXHQgIGZvcihrZXkgaW4gc291cmNlKXtcclxuXHQgICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXHJcblx0ICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XHJcblx0ICAgIGlmKG93biAmJiBrZXkgaW4gZXhwb3J0cyljb250aW51ZTtcclxuXHQgICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcclxuXHQgICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcclxuXHQgICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXHJcblx0ICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXHJcblx0ICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XHJcblx0ICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXHJcblx0ICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XHJcblx0ICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XHJcblx0ICAgICAgdmFyIEYgPSBmdW5jdGlvbihwYXJhbSl7XHJcblx0ICAgICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIEMgPyBuZXcgQyhwYXJhbSkgOiBDKHBhcmFtKTtcclxuXHQgICAgICB9O1xyXG5cdCAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcclxuXHQgICAgICByZXR1cm4gRjtcclxuXHQgICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXHJcblx0ICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcclxuXHQgICAgaWYoSVNfUFJPVE8pKGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pKVtrZXldID0gb3V0O1xyXG5cdCAgfVxyXG5cdH07XHJcblx0Ly8gdHlwZSBiaXRtYXBcclxuXHQkZXhwb3J0LkYgPSAxOyAgLy8gZm9yY2VkXHJcblx0JGV4cG9ydC5HID0gMjsgIC8vIGdsb2JhbFxyXG5cdCRleHBvcnQuUyA9IDQ7ICAvLyBzdGF0aWNcclxuXHQkZXhwb3J0LlAgPSA4OyAgLy8gcHJvdG9cclxuXHQkZXhwb3J0LkIgPSAxNjsgLy8gYmluZFxyXG5cdCRleHBvcnQuVyA9IDMyOyAvLyB3cmFwXHJcblx0bW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcclxuXHR2YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcclxuXHQgID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcclxuXHRpZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0dmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMS4yLjYnfTtcclxuXHRpZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xyXG5cdHZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xyXG5cdCAgYUZ1bmN0aW9uKGZuKTtcclxuXHQgIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XHJcblx0ICBzd2l0Y2gobGVuZ3RoKXtcclxuXHQgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XHJcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XHJcblx0ICAgIH07XHJcblx0ICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xyXG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcclxuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcclxuXHQgICAgfTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcclxuXHQgICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XHJcblx0ICB9O1xyXG5cdH07XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcclxuXHQgIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XHJcblx0ICByZXR1cm4gaXQ7XHJcblx0fTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XHJcblx0ICB0cnkge1xyXG5cdCAgICByZXR1cm4gISFleGVjKCk7XHJcblx0ICB9IGNhdGNoKGUpe1xyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH1cclxuXHR9O1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGdsb2JhbCB3aW5kb3cgKi9cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZ1bmN0aW9uIChIYW5kbGViYXJzKSB7XHJcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcclxuXHQgICAgICAkSGFuZGxlYmFycyA9IHJvb3QuSGFuZGxlYmFycztcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICBIYW5kbGViYXJzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgIGlmIChyb290LkhhbmRsZWJhcnMgPT09IEhhbmRsZWJhcnMpIHtcclxuXHQgICAgICByb290LkhhbmRsZWJhcnMgPSAkSGFuZGxlYmFycztcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gSGFuZGxlYmFycztcclxuXHQgIH07XHJcblx0fTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSkpKVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdHZhciBBU1QgPSB7XHJcblx0ICAvLyBQdWJsaWMgQVBJIHVzZWQgdG8gZXZhbHVhdGUgZGVyaXZlZCBhdHRyaWJ1dGVzIHJlZ2FyZGluZyBBU1Qgbm9kZXNcclxuXHQgIGhlbHBlcnM6IHtcclxuXHQgICAgLy8gYSBtdXN0YWNoZSBpcyBkZWZpbml0ZWx5IGEgaGVscGVyIGlmOlxyXG5cdCAgICAvLyAqIGl0IGlzIGFuIGVsaWdpYmxlIGhlbHBlciwgYW5kXHJcblx0ICAgIC8vICogaXQgaGFzIGF0IGxlYXN0IG9uZSBwYXJhbWV0ZXIgb3IgaGFzaCBzZWdtZW50XHJcblx0ICAgIGhlbHBlckV4cHJlc3Npb246IGZ1bmN0aW9uIGhlbHBlckV4cHJlc3Npb24obm9kZSkge1xyXG5cdCAgICAgIHJldHVybiBub2RlLnR5cGUgPT09ICdTdWJFeHByZXNzaW9uJyB8fCAobm9kZS50eXBlID09PSAnTXVzdGFjaGVTdGF0ZW1lbnQnIHx8IG5vZGUudHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50JykgJiYgISEobm9kZS5wYXJhbXMgJiYgbm9kZS5wYXJhbXMubGVuZ3RoIHx8IG5vZGUuaGFzaCk7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICBzY29wZWRJZDogZnVuY3Rpb24gc2NvcGVkSWQocGF0aCkge1xyXG5cdCAgICAgIHJldHVybiAoL15cXC58dGhpc1xcYi8udGVzdChwYXRoLm9yaWdpbmFsKVxyXG5cdCAgICAgICk7XHJcblx0ICAgIH0sXHJcblxyXG5cdCAgICAvLyBhbiBJRCBpcyBzaW1wbGUgaWYgaXQgb25seSBoYXMgb25lIHBhcnQsIGFuZCB0aGF0IHBhcnQgaXMgbm90XHJcblx0ICAgIC8vIGAuLmAgb3IgYHRoaXNgLlxyXG5cdCAgICBzaW1wbGVJZDogZnVuY3Rpb24gc2ltcGxlSWQocGF0aCkge1xyXG5cdCAgICAgIHJldHVybiBwYXRoLnBhcnRzLmxlbmd0aCA9PT0gMSAmJiAhQVNULmhlbHBlcnMuc2NvcGVkSWQocGF0aCkgJiYgIXBhdGguZGVwdGg7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHR9O1xyXG5cclxuXHQvLyBNdXN0IGJlIGV4cG9ydGVkIGFzIGFuIG9iamVjdCByYXRoZXIgdGhhbiB0aGUgcm9vdCBvZiB0aGUgbW9kdWxlIGFzIHRoZSBqaXNvbiBsZXhlclxyXG5cdC8vIG11c3QgbW9kaWZ5IHRoZSBvYmplY3QgdG8gb3BlcmF0ZSBwcm9wZXJseS5cclxuXHRleHBvcnRzWydkZWZhdWx0J10gPSBBU1Q7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpWydkZWZhdWx0J107XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xyXG5cclxuXHR2YXIgX3BhcnNlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG5cclxuXHR2YXIgX3BhcnNlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJzZXIpO1xyXG5cclxuXHR2YXIgX3doaXRlc3BhY2VDb250cm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcblxyXG5cdHZhciBfd2hpdGVzcGFjZUNvbnRyb2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2hpdGVzcGFjZUNvbnRyb2wpO1xyXG5cclxuXHR2YXIgX2hlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxuXHJcblx0dmFyIEhlbHBlcnMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfaGVscGVycyk7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHRleHBvcnRzLnBhcnNlciA9IF9wYXJzZXIyWydkZWZhdWx0J107XHJcblxyXG5cdHZhciB5eSA9IHt9O1xyXG5cdF91dGlscy5leHRlbmQoeXksIEhlbHBlcnMpO1xyXG5cclxuXHRmdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xyXG5cdCAgLy8gSnVzdCByZXR1cm4gaWYgYW4gYWxyZWFkeS1jb21waWxlZCBBU1Qgd2FzIHBhc3NlZCBpbi5cclxuXHQgIGlmIChpbnB1dC50eXBlID09PSAnUHJvZ3JhbScpIHtcclxuXHQgICAgcmV0dXJuIGlucHV0O1xyXG5cdCAgfVxyXG5cclxuXHQgIF9wYXJzZXIyWydkZWZhdWx0J10ueXkgPSB5eTtcclxuXHJcblx0ICAvLyBBbHRlcmluZyB0aGUgc2hhcmVkIG9iamVjdCBoZXJlLCBidXQgdGhpcyBpcyBvayBhcyBwYXJzZXIgaXMgYSBzeW5jIG9wZXJhdGlvblxyXG5cdCAgeXkubG9jSW5mbyA9IGZ1bmN0aW9uIChsb2NJbmZvKSB7XHJcblx0ICAgIHJldHVybiBuZXcgeXkuU291cmNlTG9jYXRpb24ob3B0aW9ucyAmJiBvcHRpb25zLnNyY05hbWUsIGxvY0luZm8pO1xyXG5cdCAgfTtcclxuXHJcblx0ICB2YXIgc3RyaXAgPSBuZXcgX3doaXRlc3BhY2VDb250cm9sMlsnZGVmYXVsdCddKG9wdGlvbnMpO1xyXG5cdCAgcmV0dXJuIHN0cmlwLmFjY2VwdChfcGFyc2VyMlsnZGVmYXVsdCddLnBhcnNlKGlucHV0KSk7XHJcblx0fVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblx0Ly8gRmlsZSBpZ25vcmVkIGluIGNvdmVyYWdlIHRlc3RzIHZpYSBzZXR0aW5nIGluIC5pc3RhbmJ1bC55bWxcclxuXHQvKiBKaXNvbiBnZW5lcmF0ZWQgcGFyc2VyICovXHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcblx0dmFyIGhhbmRsZWJhcnMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICB2YXIgcGFyc2VyID0geyB0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7fSxcclxuXHQgICAgICAgIHl5OiB7fSxcclxuXHQgICAgICAgIHN5bWJvbHNfOiB7IFwiZXJyb3JcIjogMiwgXCJyb290XCI6IDMsIFwicHJvZ3JhbVwiOiA0LCBcIkVPRlwiOiA1LCBcInByb2dyYW1fcmVwZXRpdGlvbjBcIjogNiwgXCJzdGF0ZW1lbnRcIjogNywgXCJtdXN0YWNoZVwiOiA4LCBcImJsb2NrXCI6IDksIFwicmF3QmxvY2tcIjogMTAsIFwicGFydGlhbFwiOiAxMSwgXCJwYXJ0aWFsQmxvY2tcIjogMTIsIFwiY29udGVudFwiOiAxMywgXCJDT01NRU5UXCI6IDE0LCBcIkNPTlRFTlRcIjogMTUsIFwib3BlblJhd0Jsb2NrXCI6IDE2LCBcInJhd0Jsb2NrX3JlcGV0aXRpb25fcGx1czBcIjogMTcsIFwiRU5EX1JBV19CTE9DS1wiOiAxOCwgXCJPUEVOX1JBV19CTE9DS1wiOiAxOSwgXCJoZWxwZXJOYW1lXCI6IDIwLCBcIm9wZW5SYXdCbG9ja19yZXBldGl0aW9uMFwiOiAyMSwgXCJvcGVuUmF3QmxvY2tfb3B0aW9uMFwiOiAyMiwgXCJDTE9TRV9SQVdfQkxPQ0tcIjogMjMsIFwib3BlbkJsb2NrXCI6IDI0LCBcImJsb2NrX29wdGlvbjBcIjogMjUsIFwiY2xvc2VCbG9ja1wiOiAyNiwgXCJvcGVuSW52ZXJzZVwiOiAyNywgXCJibG9ja19vcHRpb24xXCI6IDI4LCBcIk9QRU5fQkxPQ0tcIjogMjksIFwib3BlbkJsb2NrX3JlcGV0aXRpb24wXCI6IDMwLCBcIm9wZW5CbG9ja19vcHRpb24wXCI6IDMxLCBcIm9wZW5CbG9ja19vcHRpb24xXCI6IDMyLCBcIkNMT1NFXCI6IDMzLCBcIk9QRU5fSU5WRVJTRVwiOiAzNCwgXCJvcGVuSW52ZXJzZV9yZXBldGl0aW9uMFwiOiAzNSwgXCJvcGVuSW52ZXJzZV9vcHRpb24wXCI6IDM2LCBcIm9wZW5JbnZlcnNlX29wdGlvbjFcIjogMzcsIFwib3BlbkludmVyc2VDaGFpblwiOiAzOCwgXCJPUEVOX0lOVkVSU0VfQ0hBSU5cIjogMzksIFwib3BlbkludmVyc2VDaGFpbl9yZXBldGl0aW9uMFwiOiA0MCwgXCJvcGVuSW52ZXJzZUNoYWluX29wdGlvbjBcIjogNDEsIFwib3BlbkludmVyc2VDaGFpbl9vcHRpb24xXCI6IDQyLCBcImludmVyc2VBbmRQcm9ncmFtXCI6IDQzLCBcIklOVkVSU0VcIjogNDQsIFwiaW52ZXJzZUNoYWluXCI6IDQ1LCBcImludmVyc2VDaGFpbl9vcHRpb24wXCI6IDQ2LCBcIk9QRU5fRU5EQkxPQ0tcIjogNDcsIFwiT1BFTlwiOiA0OCwgXCJtdXN0YWNoZV9yZXBldGl0aW9uMFwiOiA0OSwgXCJtdXN0YWNoZV9vcHRpb24wXCI6IDUwLCBcIk9QRU5fVU5FU0NBUEVEXCI6IDUxLCBcIm11c3RhY2hlX3JlcGV0aXRpb24xXCI6IDUyLCBcIm11c3RhY2hlX29wdGlvbjFcIjogNTMsIFwiQ0xPU0VfVU5FU0NBUEVEXCI6IDU0LCBcIk9QRU5fUEFSVElBTFwiOiA1NSwgXCJwYXJ0aWFsTmFtZVwiOiA1NiwgXCJwYXJ0aWFsX3JlcGV0aXRpb24wXCI6IDU3LCBcInBhcnRpYWxfb3B0aW9uMFwiOiA1OCwgXCJvcGVuUGFydGlhbEJsb2NrXCI6IDU5LCBcIk9QRU5fUEFSVElBTF9CTE9DS1wiOiA2MCwgXCJvcGVuUGFydGlhbEJsb2NrX3JlcGV0aXRpb24wXCI6IDYxLCBcIm9wZW5QYXJ0aWFsQmxvY2tfb3B0aW9uMFwiOiA2MiwgXCJwYXJhbVwiOiA2MywgXCJzZXhwclwiOiA2NCwgXCJPUEVOX1NFWFBSXCI6IDY1LCBcInNleHByX3JlcGV0aXRpb24wXCI6IDY2LCBcInNleHByX29wdGlvbjBcIjogNjcsIFwiQ0xPU0VfU0VYUFJcIjogNjgsIFwiaGFzaFwiOiA2OSwgXCJoYXNoX3JlcGV0aXRpb25fcGx1czBcIjogNzAsIFwiaGFzaFNlZ21lbnRcIjogNzEsIFwiSURcIjogNzIsIFwiRVFVQUxTXCI6IDczLCBcImJsb2NrUGFyYW1zXCI6IDc0LCBcIk9QRU5fQkxPQ0tfUEFSQU1TXCI6IDc1LCBcImJsb2NrUGFyYW1zX3JlcGV0aXRpb25fcGx1czBcIjogNzYsIFwiQ0xPU0VfQkxPQ0tfUEFSQU1TXCI6IDc3LCBcInBhdGhcIjogNzgsIFwiZGF0YU5hbWVcIjogNzksIFwiU1RSSU5HXCI6IDgwLCBcIk5VTUJFUlwiOiA4MSwgXCJCT09MRUFOXCI6IDgyLCBcIlVOREVGSU5FRFwiOiA4MywgXCJOVUxMXCI6IDg0LCBcIkRBVEFcIjogODUsIFwicGF0aFNlZ21lbnRzXCI6IDg2LCBcIlNFUFwiOiA4NywgXCIkYWNjZXB0XCI6IDAsIFwiJGVuZFwiOiAxIH0sXHJcblx0ICAgICAgICB0ZXJtaW5hbHNfOiB7IDI6IFwiZXJyb3JcIiwgNTogXCJFT0ZcIiwgMTQ6IFwiQ09NTUVOVFwiLCAxNTogXCJDT05URU5UXCIsIDE4OiBcIkVORF9SQVdfQkxPQ0tcIiwgMTk6IFwiT1BFTl9SQVdfQkxPQ0tcIiwgMjM6IFwiQ0xPU0VfUkFXX0JMT0NLXCIsIDI5OiBcIk9QRU5fQkxPQ0tcIiwgMzM6IFwiQ0xPU0VcIiwgMzQ6IFwiT1BFTl9JTlZFUlNFXCIsIDM5OiBcIk9QRU5fSU5WRVJTRV9DSEFJTlwiLCA0NDogXCJJTlZFUlNFXCIsIDQ3OiBcIk9QRU5fRU5EQkxPQ0tcIiwgNDg6IFwiT1BFTlwiLCA1MTogXCJPUEVOX1VORVNDQVBFRFwiLCA1NDogXCJDTE9TRV9VTkVTQ0FQRURcIiwgNTU6IFwiT1BFTl9QQVJUSUFMXCIsIDYwOiBcIk9QRU5fUEFSVElBTF9CTE9DS1wiLCA2NTogXCJPUEVOX1NFWFBSXCIsIDY4OiBcIkNMT1NFX1NFWFBSXCIsIDcyOiBcIklEXCIsIDczOiBcIkVRVUFMU1wiLCA3NTogXCJPUEVOX0JMT0NLX1BBUkFNU1wiLCA3NzogXCJDTE9TRV9CTE9DS19QQVJBTVNcIiwgODA6IFwiU1RSSU5HXCIsIDgxOiBcIk5VTUJFUlwiLCA4MjogXCJCT09MRUFOXCIsIDgzOiBcIlVOREVGSU5FRFwiLCA4NDogXCJOVUxMXCIsIDg1OiBcIkRBVEFcIiwgODc6IFwiU0VQXCIgfSxcclxuXHQgICAgICAgIHByb2R1Y3Rpb25zXzogWzAsIFszLCAyXSwgWzQsIDFdLCBbNywgMV0sIFs3LCAxXSwgWzcsIDFdLCBbNywgMV0sIFs3LCAxXSwgWzcsIDFdLCBbNywgMV0sIFsxMywgMV0sIFsxMCwgM10sIFsxNiwgNV0sIFs5LCA0XSwgWzksIDRdLCBbMjQsIDZdLCBbMjcsIDZdLCBbMzgsIDZdLCBbNDMsIDJdLCBbNDUsIDNdLCBbNDUsIDFdLCBbMjYsIDNdLCBbOCwgNV0sIFs4LCA1XSwgWzExLCA1XSwgWzEyLCAzXSwgWzU5LCA1XSwgWzYzLCAxXSwgWzYzLCAxXSwgWzY0LCA1XSwgWzY5LCAxXSwgWzcxLCAzXSwgWzc0LCAzXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzIwLCAxXSwgWzU2LCAxXSwgWzU2LCAxXSwgWzc5LCAyXSwgWzc4LCAxXSwgWzg2LCAzXSwgWzg2LCAxXSwgWzYsIDBdLCBbNiwgMl0sIFsxNywgMV0sIFsxNywgMl0sIFsyMSwgMF0sIFsyMSwgMl0sIFsyMiwgMF0sIFsyMiwgMV0sIFsyNSwgMF0sIFsyNSwgMV0sIFsyOCwgMF0sIFsyOCwgMV0sIFszMCwgMF0sIFszMCwgMl0sIFszMSwgMF0sIFszMSwgMV0sIFszMiwgMF0sIFszMiwgMV0sIFszNSwgMF0sIFszNSwgMl0sIFszNiwgMF0sIFszNiwgMV0sIFszNywgMF0sIFszNywgMV0sIFs0MCwgMF0sIFs0MCwgMl0sIFs0MSwgMF0sIFs0MSwgMV0sIFs0MiwgMF0sIFs0MiwgMV0sIFs0NiwgMF0sIFs0NiwgMV0sIFs0OSwgMF0sIFs0OSwgMl0sIFs1MCwgMF0sIFs1MCwgMV0sIFs1MiwgMF0sIFs1MiwgMl0sIFs1MywgMF0sIFs1MywgMV0sIFs1NywgMF0sIFs1NywgMl0sIFs1OCwgMF0sIFs1OCwgMV0sIFs2MSwgMF0sIFs2MSwgMl0sIFs2MiwgMF0sIFs2MiwgMV0sIFs2NiwgMF0sIFs2NiwgMl0sIFs2NywgMF0sIFs2NywgMV0sIFs3MCwgMV0sIFs3MCwgMl0sIFs3NiwgMV0sIFs3NiwgMl1dLFxyXG5cdCAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJFxyXG5cdCAgICAgICAgLyoqLykge1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAoeXlzdGF0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCRbJDAgLSAxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlUHJvZ3JhbSgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ29tbWVudFN0YXRlbWVudCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHl5LnN0cmlwQ29tbWVudCgkJFskMF0pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwXSwgJCRbJDBdKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NvbnRlbnRTdGF0ZW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsOiAkJFskMF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICQkWyQwXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTE6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlUmF3QmxvY2soJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBwYXRoOiAkJFskMCAtIDNdLCBwYXJhbXM6ICQkWyQwIC0gMl0sIGhhc2g6ICQkWyQwIC0gMV0gfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZUJsb2NrKCQkWyQwIC0gM10sICQkWyQwIC0gMl0sICQkWyQwIC0gMV0sICQkWyQwXSwgZmFsc2UsIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlQmxvY2soJCRbJDAgLSAzXSwgJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCB0cnVlLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBvcGVuOiAkJFskMCAtIDVdLCBwYXRoOiAkJFskMCAtIDRdLCBwYXJhbXM6ICQkWyQwIC0gM10sIGhhc2g6ICQkWyQwIC0gMl0sIGJsb2NrUGFyYW1zOiAkJFskMCAtIDFdLCBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDVdLCAkJFskMF0pIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxNjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgcGF0aDogJCRbJDAgLSA0XSwgcGFyYW1zOiAkJFskMCAtIDNdLCBoYXNoOiAkJFskMCAtIDJdLCBibG9ja1BhcmFtczogJCRbJDAgLSAxXSwgc3RyaXA6IHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA1XSwgJCRbJDBdKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTc6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHBhdGg6ICQkWyQwIC0gNF0sIHBhcmFtczogJCRbJDAgLSAzXSwgaGFzaDogJCRbJDAgLSAyXSwgYmxvY2tQYXJhbXM6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNV0sICQkWyQwXSkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDFdLCAkJFskMCAtIDFdKSwgcHJvZ3JhbTogJCRbJDBdIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnZlcnNlID0geXkucHJlcGFyZUJsb2NrKCQkWyQwIC0gMl0sICQkWyQwIC0gMV0sICQkWyQwXSwgJCRbJDBdLCBmYWxzZSwgdGhpcy5fJCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbSA9IHl5LnByZXBhcmVQcm9ncmFtKFtpbnZlcnNlXSwgJCRbJDAgLSAxXS5sb2MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbS5jaGFpbmVkID0gdHJ1ZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHN0cmlwOiAkJFskMCAtIDJdLnN0cmlwLCBwcm9ncmFtOiBwcm9ncmFtLCBjaGFpbjogdHJ1ZSB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDIwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjE6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHBhdGg6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gMl0sICQkWyQwXSkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDIyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geXkucHJlcGFyZU11c3RhY2hlKCQkWyQwIC0gM10sICQkWyQwIC0gMl0sICQkWyQwIC0gMV0sICQkWyQwIC0gNF0sIHl5LnN0cmlwRmxhZ3MoJCRbJDAgLSA0XSwgJCRbJDBdKSwgdGhpcy5fJCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyMzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVNdXN0YWNoZSgkJFskMCAtIDNdLCAkJFskMCAtIDJdLCAkJFskMCAtIDFdLCAkJFskMCAtIDRdLCB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNF0sICQkWyQwXSksIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BhcnRpYWxTdGF0ZW1lbnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICQkWyQwIC0gM10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiAkJFskMCAtIDJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6ICQkWyQwIC0gMV0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiAnJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJpcDogeXkuc3RyaXBGbGFncygkJFskMCAtIDRdLCAkJFskMF0pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyNTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LnByZXBhcmVQYXJ0aWFsQmxvY2soJCRbJDAgLSAyXSwgJCRbJDAgLSAxXSwgJCRbJDBdLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI2OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyBwYXRoOiAkJFskMCAtIDNdLCBwYXJhbXM6ICQkWyQwIC0gMl0sIGhhc2g6ICQkWyQwIC0gMV0sIHN0cmlwOiB5eS5zdHJpcEZsYWdzKCQkWyQwIC0gNF0sICQkWyQwXSkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjg6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU3ViRXhwcmVzc2lvbicsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJCRbJDAgLSAzXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6ICQkWyQwIC0gMl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogJCRbJDAgLSAxXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHl5LmxvY0luZm8odGhpcy5fJClcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdIYXNoJywgcGFpcnM6ICQkWyQwXSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHsgdHlwZTogJ0hhc2hQYWlyJywga2V5OiB5eS5pZCgkJFskMCAtIDJdKSwgdmFsdWU6ICQkWyQwXSwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IHl5LmlkKCQkWyQwIC0gMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzM6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSAkJFskMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnU3RyaW5nTGl0ZXJhbCcsIHZhbHVlOiAkJFskMF0sIG9yaWdpbmFsOiAkJFskMF0sIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzY6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdOdW1iZXJMaXRlcmFsJywgdmFsdWU6IE51bWJlcigkJFskMF0pLCBvcmlnaW5hbDogTnVtYmVyKCQkWyQwXSksIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzc6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdCb29sZWFuTGl0ZXJhbCcsIHZhbHVlOiAkJFskMF0gPT09ICd0cnVlJywgb3JpZ2luYWw6ICQkWyQwXSA9PT0gJ3RydWUnLCBsb2M6IHl5LmxvY0luZm8odGhpcy5fJCkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0geyB0eXBlOiAnVW5kZWZpbmVkTGl0ZXJhbCcsIG9yaWdpbmFsOiB1bmRlZmluZWQsIHZhbHVlOiB1bmRlZmluZWQsIGxvYzogeXkubG9jSW5mbyh0aGlzLl8kKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzk6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB7IHR5cGU6ICdOdWxsTGl0ZXJhbCcsIG9yaWdpbmFsOiBudWxsLCB2YWx1ZTogbnVsbCwgbG9jOiB5eS5sb2NJbmZvKHRoaXMuXyQpIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0MDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gJCRbJDBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlUGF0aCh0cnVlLCAkJFskMF0sIHRoaXMuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDM6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSB5eS5wcmVwYXJlUGF0aChmYWxzZSwgJCRbJDBdLCB0aGlzLl8kKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAyXS5wdXNoKHsgcGFydDogeXkuaWQoJCRbJDBdKSwgb3JpZ2luYWw6ICQkWyQwXSwgc2VwYXJhdG9yOiAkJFskMCAtIDFdIH0pO3RoaXMuJCA9ICQkWyQwIC0gMl07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0NTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFt7IHBhcnQ6IHl5LmlkKCQkWyQwXSksIG9yaWdpbmFsOiAkJFskMF0gfV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0NjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gWyQkWyQwXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0OTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDUxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA1ODpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTk6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDY0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA2NTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDcxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA3ODpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzk6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDgyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA4MzpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgODY6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDg3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5MDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTE6XHJcblx0ICAgICAgICAgICAgICAgICAgICAkJFskMCAtIDFdLnB1c2goJCRbJDBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDk0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy4kID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5NTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgOTg6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbJCRbJDBdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDk5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgJCRbJDAgLSAxXS5wdXNoKCQkWyQwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxMDA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLiQgPSBbJCRbJDBdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEwMTpcclxuXHQgICAgICAgICAgICAgICAgICAgICQkWyQwIC0gMV0ucHVzaCgkJFskMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRhYmxlOiBbeyAzOiAxLCA0OiAyLCA1OiBbMiwgNDZdLCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDQ4OiBbMiwgNDZdLCA1MTogWzIsIDQ2XSwgNTU6IFsyLCA0Nl0sIDYwOiBbMiwgNDZdIH0sIHsgMTogWzNdIH0sIHsgNTogWzEsIDRdIH0sIHsgNTogWzIsIDJdLCA3OiA1LCA4OiA2LCA5OiA3LCAxMDogOCwgMTE6IDksIDEyOiAxMCwgMTM6IDExLCAxNDogWzEsIDEyXSwgMTU6IFsxLCAyMF0sIDE2OiAxNywgMTk6IFsxLCAyM10sIDI0OiAxNSwgMjc6IDE2LCAyOTogWzEsIDIxXSwgMzQ6IFsxLCAyMl0sIDM5OiBbMiwgMl0sIDQ0OiBbMiwgMl0sIDQ3OiBbMiwgMl0sIDQ4OiBbMSwgMTNdLCA1MTogWzEsIDE0XSwgNTU6IFsxLCAxOF0sIDU5OiAxOSwgNjA6IFsxLCAyNF0gfSwgeyAxOiBbMiwgMV0gfSwgeyA1OiBbMiwgNDddLCAxNDogWzIsIDQ3XSwgMTU6IFsyLCA0N10sIDE5OiBbMiwgNDddLCAyOTogWzIsIDQ3XSwgMzQ6IFsyLCA0N10sIDM5OiBbMiwgNDddLCA0NDogWzIsIDQ3XSwgNDc6IFsyLCA0N10sIDQ4OiBbMiwgNDddLCA1MTogWzIsIDQ3XSwgNTU6IFsyLCA0N10sIDYwOiBbMiwgNDddIH0sIHsgNTogWzIsIDNdLCAxNDogWzIsIDNdLCAxNTogWzIsIDNdLCAxOTogWzIsIDNdLCAyOTogWzIsIDNdLCAzNDogWzIsIDNdLCAzOTogWzIsIDNdLCA0NDogWzIsIDNdLCA0NzogWzIsIDNdLCA0ODogWzIsIDNdLCA1MTogWzIsIDNdLCA1NTogWzIsIDNdLCA2MDogWzIsIDNdIH0sIHsgNTogWzIsIDRdLCAxNDogWzIsIDRdLCAxNTogWzIsIDRdLCAxOTogWzIsIDRdLCAyOTogWzIsIDRdLCAzNDogWzIsIDRdLCAzOTogWzIsIDRdLCA0NDogWzIsIDRdLCA0NzogWzIsIDRdLCA0ODogWzIsIDRdLCA1MTogWzIsIDRdLCA1NTogWzIsIDRdLCA2MDogWzIsIDRdIH0sIHsgNTogWzIsIDVdLCAxNDogWzIsIDVdLCAxNTogWzIsIDVdLCAxOTogWzIsIDVdLCAyOTogWzIsIDVdLCAzNDogWzIsIDVdLCAzOTogWzIsIDVdLCA0NDogWzIsIDVdLCA0NzogWzIsIDVdLCA0ODogWzIsIDVdLCA1MTogWzIsIDVdLCA1NTogWzIsIDVdLCA2MDogWzIsIDVdIH0sIHsgNTogWzIsIDZdLCAxNDogWzIsIDZdLCAxNTogWzIsIDZdLCAxOTogWzIsIDZdLCAyOTogWzIsIDZdLCAzNDogWzIsIDZdLCAzOTogWzIsIDZdLCA0NDogWzIsIDZdLCA0NzogWzIsIDZdLCA0ODogWzIsIDZdLCA1MTogWzIsIDZdLCA1NTogWzIsIDZdLCA2MDogWzIsIDZdIH0sIHsgNTogWzIsIDddLCAxNDogWzIsIDddLCAxNTogWzIsIDddLCAxOTogWzIsIDddLCAyOTogWzIsIDddLCAzNDogWzIsIDddLCAzOTogWzIsIDddLCA0NDogWzIsIDddLCA0NzogWzIsIDddLCA0ODogWzIsIDddLCA1MTogWzIsIDddLCA1NTogWzIsIDddLCA2MDogWzIsIDddIH0sIHsgNTogWzIsIDhdLCAxNDogWzIsIDhdLCAxNTogWzIsIDhdLCAxOTogWzIsIDhdLCAyOTogWzIsIDhdLCAzNDogWzIsIDhdLCAzOTogWzIsIDhdLCA0NDogWzIsIDhdLCA0NzogWzIsIDhdLCA0ODogWzIsIDhdLCA1MTogWzIsIDhdLCA1NTogWzIsIDhdLCA2MDogWzIsIDhdIH0sIHsgNTogWzIsIDldLCAxNDogWzIsIDldLCAxNTogWzIsIDldLCAxOTogWzIsIDldLCAyOTogWzIsIDldLCAzNDogWzIsIDldLCAzOTogWzIsIDldLCA0NDogWzIsIDldLCA0NzogWzIsIDldLCA0ODogWzIsIDldLCA1MTogWzIsIDldLCA1NTogWzIsIDldLCA2MDogWzIsIDldIH0sIHsgMjA6IDI1LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiAzNiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiAzNywgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCAzOTogWzIsIDQ2XSwgNDQ6IFsyLCA0Nl0sIDQ3OiBbMiwgNDZdLCA0ODogWzIsIDQ2XSwgNTE6IFsyLCA0Nl0sIDU1OiBbMiwgNDZdLCA2MDogWzIsIDQ2XSB9LCB7IDQ6IDM4LCA2OiAzLCAxNDogWzIsIDQ2XSwgMTU6IFsyLCA0Nl0sIDE5OiBbMiwgNDZdLCAyOTogWzIsIDQ2XSwgMzQ6IFsyLCA0Nl0sIDQ0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyAxMzogNDAsIDE1OiBbMSwgMjBdLCAxNzogMzkgfSwgeyAyMDogNDIsIDU2OiA0MSwgNjQ6IDQzLCA2NTogWzEsIDQ0XSwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiA0NSwgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyA1OiBbMiwgMTBdLCAxNDogWzIsIDEwXSwgMTU6IFsyLCAxMF0sIDE4OiBbMiwgMTBdLCAxOTogWzIsIDEwXSwgMjk6IFsyLCAxMF0sIDM0OiBbMiwgMTBdLCAzOTogWzIsIDEwXSwgNDQ6IFsyLCAxMF0sIDQ3OiBbMiwgMTBdLCA0ODogWzIsIDEwXSwgNTE6IFsyLCAxMF0sIDU1OiBbMiwgMTBdLCA2MDogWzIsIDEwXSB9LCB7IDIwOiA0NiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyMDogNDcsIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDQ4LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA0MiwgNTY6IDQ5LCA2NDogNDMsIDY1OiBbMSwgNDRdLCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDMzOiBbMiwgNzhdLCA0OTogNTAsIDY1OiBbMiwgNzhdLCA3MjogWzIsIDc4XSwgODA6IFsyLCA3OF0sIDgxOiBbMiwgNzhdLCA4MjogWzIsIDc4XSwgODM6IFsyLCA3OF0sIDg0OiBbMiwgNzhdLCA4NTogWzIsIDc4XSB9LCB7IDIzOiBbMiwgMzNdLCAzMzogWzIsIDMzXSwgNTQ6IFsyLCAzM10sIDY1OiBbMiwgMzNdLCA2ODogWzIsIDMzXSwgNzI6IFsyLCAzM10sIDc1OiBbMiwgMzNdLCA4MDogWzIsIDMzXSwgODE6IFsyLCAzM10sIDgyOiBbMiwgMzNdLCA4MzogWzIsIDMzXSwgODQ6IFsyLCAzM10sIDg1OiBbMiwgMzNdIH0sIHsgMjM6IFsyLCAzNF0sIDMzOiBbMiwgMzRdLCA1NDogWzIsIDM0XSwgNjU6IFsyLCAzNF0sIDY4OiBbMiwgMzRdLCA3MjogWzIsIDM0XSwgNzU6IFsyLCAzNF0sIDgwOiBbMiwgMzRdLCA4MTogWzIsIDM0XSwgODI6IFsyLCAzNF0sIDgzOiBbMiwgMzRdLCA4NDogWzIsIDM0XSwgODU6IFsyLCAzNF0gfSwgeyAyMzogWzIsIDM1XSwgMzM6IFsyLCAzNV0sIDU0OiBbMiwgMzVdLCA2NTogWzIsIDM1XSwgNjg6IFsyLCAzNV0sIDcyOiBbMiwgMzVdLCA3NTogWzIsIDM1XSwgODA6IFsyLCAzNV0sIDgxOiBbMiwgMzVdLCA4MjogWzIsIDM1XSwgODM6IFsyLCAzNV0sIDg0OiBbMiwgMzVdLCA4NTogWzIsIDM1XSB9LCB7IDIzOiBbMiwgMzZdLCAzMzogWzIsIDM2XSwgNTQ6IFsyLCAzNl0sIDY1OiBbMiwgMzZdLCA2ODogWzIsIDM2XSwgNzI6IFsyLCAzNl0sIDc1OiBbMiwgMzZdLCA4MDogWzIsIDM2XSwgODE6IFsyLCAzNl0sIDgyOiBbMiwgMzZdLCA4MzogWzIsIDM2XSwgODQ6IFsyLCAzNl0sIDg1OiBbMiwgMzZdIH0sIHsgMjM6IFsyLCAzN10sIDMzOiBbMiwgMzddLCA1NDogWzIsIDM3XSwgNjU6IFsyLCAzN10sIDY4OiBbMiwgMzddLCA3MjogWzIsIDM3XSwgNzU6IFsyLCAzN10sIDgwOiBbMiwgMzddLCA4MTogWzIsIDM3XSwgODI6IFsyLCAzN10sIDgzOiBbMiwgMzddLCA4NDogWzIsIDM3XSwgODU6IFsyLCAzN10gfSwgeyAyMzogWzIsIDM4XSwgMzM6IFsyLCAzOF0sIDU0OiBbMiwgMzhdLCA2NTogWzIsIDM4XSwgNjg6IFsyLCAzOF0sIDcyOiBbMiwgMzhdLCA3NTogWzIsIDM4XSwgODA6IFsyLCAzOF0sIDgxOiBbMiwgMzhdLCA4MjogWzIsIDM4XSwgODM6IFsyLCAzOF0sIDg0OiBbMiwgMzhdLCA4NTogWzIsIDM4XSB9LCB7IDIzOiBbMiwgMzldLCAzMzogWzIsIDM5XSwgNTQ6IFsyLCAzOV0sIDY1OiBbMiwgMzldLCA2ODogWzIsIDM5XSwgNzI6IFsyLCAzOV0sIDc1OiBbMiwgMzldLCA4MDogWzIsIDM5XSwgODE6IFsyLCAzOV0sIDgyOiBbMiwgMzldLCA4MzogWzIsIDM5XSwgODQ6IFsyLCAzOV0sIDg1OiBbMiwgMzldIH0sIHsgMjM6IFsyLCA0M10sIDMzOiBbMiwgNDNdLCA1NDogWzIsIDQzXSwgNjU6IFsyLCA0M10sIDY4OiBbMiwgNDNdLCA3MjogWzIsIDQzXSwgNzU6IFsyLCA0M10sIDgwOiBbMiwgNDNdLCA4MTogWzIsIDQzXSwgODI6IFsyLCA0M10sIDgzOiBbMiwgNDNdLCA4NDogWzIsIDQzXSwgODU6IFsyLCA0M10sIDg3OiBbMSwgNTFdIH0sIHsgNzI6IFsxLCAzNV0sIDg2OiA1MiB9LCB7IDIzOiBbMiwgNDVdLCAzMzogWzIsIDQ1XSwgNTQ6IFsyLCA0NV0sIDY1OiBbMiwgNDVdLCA2ODogWzIsIDQ1XSwgNzI6IFsyLCA0NV0sIDc1OiBbMiwgNDVdLCA4MDogWzIsIDQ1XSwgODE6IFsyLCA0NV0sIDgyOiBbMiwgNDVdLCA4MzogWzIsIDQ1XSwgODQ6IFsyLCA0NV0sIDg1OiBbMiwgNDVdLCA4NzogWzIsIDQ1XSB9LCB7IDUyOiA1MywgNTQ6IFsyLCA4Ml0sIDY1OiBbMiwgODJdLCA3MjogWzIsIDgyXSwgODA6IFsyLCA4Ml0sIDgxOiBbMiwgODJdLCA4MjogWzIsIDgyXSwgODM6IFsyLCA4Ml0sIDg0OiBbMiwgODJdLCA4NTogWzIsIDgyXSB9LCB7IDI1OiA1NCwgMzg6IDU2LCAzOTogWzEsIDU4XSwgNDM6IDU3LCA0NDogWzEsIDU5XSwgNDU6IDU1LCA0NzogWzIsIDU0XSB9LCB7IDI4OiA2MCwgNDM6IDYxLCA0NDogWzEsIDU5XSwgNDc6IFsyLCA1Nl0gfSwgeyAxMzogNjMsIDE1OiBbMSwgMjBdLCAxODogWzEsIDYyXSB9LCB7IDE1OiBbMiwgNDhdLCAxODogWzIsIDQ4XSB9LCB7IDMzOiBbMiwgODZdLCA1NzogNjQsIDY1OiBbMiwgODZdLCA3MjogWzIsIDg2XSwgODA6IFsyLCA4Nl0sIDgxOiBbMiwgODZdLCA4MjogWzIsIDg2XSwgODM6IFsyLCA4Nl0sIDg0OiBbMiwgODZdLCA4NTogWzIsIDg2XSB9LCB7IDMzOiBbMiwgNDBdLCA2NTogWzIsIDQwXSwgNzI6IFsyLCA0MF0sIDgwOiBbMiwgNDBdLCA4MTogWzIsIDQwXSwgODI6IFsyLCA0MF0sIDgzOiBbMiwgNDBdLCA4NDogWzIsIDQwXSwgODU6IFsyLCA0MF0gfSwgeyAzMzogWzIsIDQxXSwgNjU6IFsyLCA0MV0sIDcyOiBbMiwgNDFdLCA4MDogWzIsIDQxXSwgODE6IFsyLCA0MV0sIDgyOiBbMiwgNDFdLCA4MzogWzIsIDQxXSwgODQ6IFsyLCA0MV0sIDg1OiBbMiwgNDFdIH0sIHsgMjA6IDY1LCA3MjogWzEsIDM1XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDI2OiA2NiwgNDc6IFsxLCA2N10gfSwgeyAzMDogNjgsIDMzOiBbMiwgNThdLCA2NTogWzIsIDU4XSwgNzI6IFsyLCA1OF0sIDc1OiBbMiwgNThdLCA4MDogWzIsIDU4XSwgODE6IFsyLCA1OF0sIDgyOiBbMiwgNThdLCA4MzogWzIsIDU4XSwgODQ6IFsyLCA1OF0sIDg1OiBbMiwgNThdIH0sIHsgMzM6IFsyLCA2NF0sIDM1OiA2OSwgNjU6IFsyLCA2NF0sIDcyOiBbMiwgNjRdLCA3NTogWzIsIDY0XSwgODA6IFsyLCA2NF0sIDgxOiBbMiwgNjRdLCA4MjogWzIsIDY0XSwgODM6IFsyLCA2NF0sIDg0OiBbMiwgNjRdLCA4NTogWzIsIDY0XSB9LCB7IDIxOiA3MCwgMjM6IFsyLCA1MF0sIDY1OiBbMiwgNTBdLCA3MjogWzIsIDUwXSwgODA6IFsyLCA1MF0sIDgxOiBbMiwgNTBdLCA4MjogWzIsIDUwXSwgODM6IFsyLCA1MF0sIDg0OiBbMiwgNTBdLCA4NTogWzIsIDUwXSB9LCB7IDMzOiBbMiwgOTBdLCA2MTogNzEsIDY1OiBbMiwgOTBdLCA3MjogWzIsIDkwXSwgODA6IFsyLCA5MF0sIDgxOiBbMiwgOTBdLCA4MjogWzIsIDkwXSwgODM6IFsyLCA5MF0sIDg0OiBbMiwgOTBdLCA4NTogWzIsIDkwXSB9LCB7IDIwOiA3NSwgMzM6IFsyLCA4MF0sIDUwOiA3MiwgNjM6IDczLCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2OTogNzQsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDcyOiBbMSwgODBdIH0sIHsgMjM6IFsyLCA0Ml0sIDMzOiBbMiwgNDJdLCA1NDogWzIsIDQyXSwgNjU6IFsyLCA0Ml0sIDY4OiBbMiwgNDJdLCA3MjogWzIsIDQyXSwgNzU6IFsyLCA0Ml0sIDgwOiBbMiwgNDJdLCA4MTogWzIsIDQyXSwgODI6IFsyLCA0Ml0sIDgzOiBbMiwgNDJdLCA4NDogWzIsIDQyXSwgODU6IFsyLCA0Ml0sIDg3OiBbMSwgNTFdIH0sIHsgMjA6IDc1LCA1MzogODEsIDU0OiBbMiwgODRdLCA2MzogODIsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA4MywgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjY6IDg0LCA0NzogWzEsIDY3XSB9LCB7IDQ3OiBbMiwgNTVdIH0sIHsgNDogODUsIDY6IDMsIDE0OiBbMiwgNDZdLCAxNTogWzIsIDQ2XSwgMTk6IFsyLCA0Nl0sIDI5OiBbMiwgNDZdLCAzNDogWzIsIDQ2XSwgMzk6IFsyLCA0Nl0sIDQ0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyA0NzogWzIsIDIwXSB9LCB7IDIwOiA4NiwgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyA0OiA4NywgNjogMywgMTQ6IFsyLCA0Nl0sIDE1OiBbMiwgNDZdLCAxOTogWzIsIDQ2XSwgMjk6IFsyLCA0Nl0sIDM0OiBbMiwgNDZdLCA0NzogWzIsIDQ2XSwgNDg6IFsyLCA0Nl0sIDUxOiBbMiwgNDZdLCA1NTogWzIsIDQ2XSwgNjA6IFsyLCA0Nl0gfSwgeyAyNjogODgsIDQ3OiBbMSwgNjddIH0sIHsgNDc6IFsyLCA1N10gfSwgeyA1OiBbMiwgMTFdLCAxNDogWzIsIDExXSwgMTU6IFsyLCAxMV0sIDE5OiBbMiwgMTFdLCAyOTogWzIsIDExXSwgMzQ6IFsyLCAxMV0sIDM5OiBbMiwgMTFdLCA0NDogWzIsIDExXSwgNDc6IFsyLCAxMV0sIDQ4OiBbMiwgMTFdLCA1MTogWzIsIDExXSwgNTU6IFsyLCAxMV0sIDYwOiBbMiwgMTFdIH0sIHsgMTU6IFsyLCA0OV0sIDE4OiBbMiwgNDldIH0sIHsgMjA6IDc1LCAzMzogWzIsIDg4XSwgNTg6IDg5LCA2MzogOTAsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA5MSwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNjU6IFsyLCA5NF0sIDY2OiA5MiwgNjg6IFsyLCA5NF0sIDcyOiBbMiwgOTRdLCA4MDogWzIsIDk0XSwgODE6IFsyLCA5NF0sIDgyOiBbMiwgOTRdLCA4MzogWzIsIDk0XSwgODQ6IFsyLCA5NF0sIDg1OiBbMiwgOTRdIH0sIHsgNTogWzIsIDI1XSwgMTQ6IFsyLCAyNV0sIDE1OiBbMiwgMjVdLCAxOTogWzIsIDI1XSwgMjk6IFsyLCAyNV0sIDM0OiBbMiwgMjVdLCAzOTogWzIsIDI1XSwgNDQ6IFsyLCAyNV0sIDQ3OiBbMiwgMjVdLCA0ODogWzIsIDI1XSwgNTE6IFsyLCAyNV0sIDU1OiBbMiwgMjVdLCA2MDogWzIsIDI1XSB9LCB7IDIwOiA5MywgNzI6IFsxLCAzNV0sIDc4OiAyNiwgNzk6IDI3LCA4MDogWzEsIDI4XSwgODE6IFsxLCAyOV0sIDgyOiBbMSwgMzBdLCA4MzogWzEsIDMxXSwgODQ6IFsxLCAzMl0sIDg1OiBbMSwgMzRdLCA4NjogMzMgfSwgeyAyMDogNzUsIDMxOiA5NCwgMzM6IFsyLCA2MF0sIDYzOiA5NSwgNjQ6IDc2LCA2NTogWzEsIDQ0XSwgNjk6IDk2LCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc1OiBbMiwgNjBdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMjA6IDc1LCAzMzogWzIsIDY2XSwgMzY6IDk3LCA2MzogOTgsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiA5OSwgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3NTogWzIsIDY2XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA3NSwgMjI6IDEwMCwgMjM6IFsyLCA1Ml0sIDYzOiAxMDEsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiAxMDIsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDIwOiA3NSwgMzM6IFsyLCA5Ml0sIDYyOiAxMDMsIDYzOiAxMDQsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDY5OiAxMDUsIDcwOiA3NywgNzE6IDc4LCA3MjogWzEsIDc5XSwgNzg6IDI2LCA3OTogMjcsIDgwOiBbMSwgMjhdLCA4MTogWzEsIDI5XSwgODI6IFsxLCAzMF0sIDgzOiBbMSwgMzFdLCA4NDogWzEsIDMyXSwgODU6IFsxLCAzNF0sIDg2OiAzMyB9LCB7IDMzOiBbMSwgMTA2XSB9LCB7IDMzOiBbMiwgNzldLCA2NTogWzIsIDc5XSwgNzI6IFsyLCA3OV0sIDgwOiBbMiwgNzldLCA4MTogWzIsIDc5XSwgODI6IFsyLCA3OV0sIDgzOiBbMiwgNzldLCA4NDogWzIsIDc5XSwgODU6IFsyLCA3OV0gfSwgeyAzMzogWzIsIDgxXSB9LCB7IDIzOiBbMiwgMjddLCAzMzogWzIsIDI3XSwgNTQ6IFsyLCAyN10sIDY1OiBbMiwgMjddLCA2ODogWzIsIDI3XSwgNzI6IFsyLCAyN10sIDc1OiBbMiwgMjddLCA4MDogWzIsIDI3XSwgODE6IFsyLCAyN10sIDgyOiBbMiwgMjddLCA4MzogWzIsIDI3XSwgODQ6IFsyLCAyN10sIDg1OiBbMiwgMjddIH0sIHsgMjM6IFsyLCAyOF0sIDMzOiBbMiwgMjhdLCA1NDogWzIsIDI4XSwgNjU6IFsyLCAyOF0sIDY4OiBbMiwgMjhdLCA3MjogWzIsIDI4XSwgNzU6IFsyLCAyOF0sIDgwOiBbMiwgMjhdLCA4MTogWzIsIDI4XSwgODI6IFsyLCAyOF0sIDgzOiBbMiwgMjhdLCA4NDogWzIsIDI4XSwgODU6IFsyLCAyOF0gfSwgeyAyMzogWzIsIDMwXSwgMzM6IFsyLCAzMF0sIDU0OiBbMiwgMzBdLCA2ODogWzIsIDMwXSwgNzE6IDEwNywgNzI6IFsxLCAxMDhdLCA3NTogWzIsIDMwXSB9LCB7IDIzOiBbMiwgOThdLCAzMzogWzIsIDk4XSwgNTQ6IFsyLCA5OF0sIDY4OiBbMiwgOThdLCA3MjogWzIsIDk4XSwgNzU6IFsyLCA5OF0gfSwgeyAyMzogWzIsIDQ1XSwgMzM6IFsyLCA0NV0sIDU0OiBbMiwgNDVdLCA2NTogWzIsIDQ1XSwgNjg6IFsyLCA0NV0sIDcyOiBbMiwgNDVdLCA3MzogWzEsIDEwOV0sIDc1OiBbMiwgNDVdLCA4MDogWzIsIDQ1XSwgODE6IFsyLCA0NV0sIDgyOiBbMiwgNDVdLCA4MzogWzIsIDQ1XSwgODQ6IFsyLCA0NV0sIDg1OiBbMiwgNDVdLCA4NzogWzIsIDQ1XSB9LCB7IDIzOiBbMiwgNDRdLCAzMzogWzIsIDQ0XSwgNTQ6IFsyLCA0NF0sIDY1OiBbMiwgNDRdLCA2ODogWzIsIDQ0XSwgNzI6IFsyLCA0NF0sIDc1OiBbMiwgNDRdLCA4MDogWzIsIDQ0XSwgODE6IFsyLCA0NF0sIDgyOiBbMiwgNDRdLCA4MzogWzIsIDQ0XSwgODQ6IFsyLCA0NF0sIDg1OiBbMiwgNDRdLCA4NzogWzIsIDQ0XSB9LCB7IDU0OiBbMSwgMTEwXSB9LCB7IDU0OiBbMiwgODNdLCA2NTogWzIsIDgzXSwgNzI6IFsyLCA4M10sIDgwOiBbMiwgODNdLCA4MTogWzIsIDgzXSwgODI6IFsyLCA4M10sIDgzOiBbMiwgODNdLCA4NDogWzIsIDgzXSwgODU6IFsyLCA4M10gfSwgeyA1NDogWzIsIDg1XSB9LCB7IDU6IFsyLCAxM10sIDE0OiBbMiwgMTNdLCAxNTogWzIsIDEzXSwgMTk6IFsyLCAxM10sIDI5OiBbMiwgMTNdLCAzNDogWzIsIDEzXSwgMzk6IFsyLCAxM10sIDQ0OiBbMiwgMTNdLCA0NzogWzIsIDEzXSwgNDg6IFsyLCAxM10sIDUxOiBbMiwgMTNdLCA1NTogWzIsIDEzXSwgNjA6IFsyLCAxM10gfSwgeyAzODogNTYsIDM5OiBbMSwgNThdLCA0MzogNTcsIDQ0OiBbMSwgNTldLCA0NTogMTEyLCA0NjogMTExLCA0NzogWzIsIDc2XSB9LCB7IDMzOiBbMiwgNzBdLCA0MDogMTEzLCA2NTogWzIsIDcwXSwgNzI6IFsyLCA3MF0sIDc1OiBbMiwgNzBdLCA4MDogWzIsIDcwXSwgODE6IFsyLCA3MF0sIDgyOiBbMiwgNzBdLCA4MzogWzIsIDcwXSwgODQ6IFsyLCA3MF0sIDg1OiBbMiwgNzBdIH0sIHsgNDc6IFsyLCAxOF0gfSwgeyA1OiBbMiwgMTRdLCAxNDogWzIsIDE0XSwgMTU6IFsyLCAxNF0sIDE5OiBbMiwgMTRdLCAyOTogWzIsIDE0XSwgMzQ6IFsyLCAxNF0sIDM5OiBbMiwgMTRdLCA0NDogWzIsIDE0XSwgNDc6IFsyLCAxNF0sIDQ4OiBbMiwgMTRdLCA1MTogWzIsIDE0XSwgNTU6IFsyLCAxNF0sIDYwOiBbMiwgMTRdIH0sIHsgMzM6IFsxLCAxMTRdIH0sIHsgMzM6IFsyLCA4N10sIDY1OiBbMiwgODddLCA3MjogWzIsIDg3XSwgODA6IFsyLCA4N10sIDgxOiBbMiwgODddLCA4MjogWzIsIDg3XSwgODM6IFsyLCA4N10sIDg0OiBbMiwgODddLCA4NTogWzIsIDg3XSB9LCB7IDMzOiBbMiwgODldIH0sIHsgMjA6IDc1LCA2MzogMTE2LCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2NzogMTE1LCA2ODogWzIsIDk2XSwgNjk6IDExNywgNzA6IDc3LCA3MTogNzgsIDcyOiBbMSwgNzldLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgMzM6IFsxLCAxMThdIH0sIHsgMzI6IDExOSwgMzM6IFsyLCA2Ml0sIDc0OiAxMjAsIDc1OiBbMSwgMTIxXSB9LCB7IDMzOiBbMiwgNTldLCA2NTogWzIsIDU5XSwgNzI6IFsyLCA1OV0sIDc1OiBbMiwgNTldLCA4MDogWzIsIDU5XSwgODE6IFsyLCA1OV0sIDgyOiBbMiwgNTldLCA4MzogWzIsIDU5XSwgODQ6IFsyLCA1OV0sIDg1OiBbMiwgNTldIH0sIHsgMzM6IFsyLCA2MV0sIDc1OiBbMiwgNjFdIH0sIHsgMzM6IFsyLCA2OF0sIDM3OiAxMjIsIDc0OiAxMjMsIDc1OiBbMSwgMTIxXSB9LCB7IDMzOiBbMiwgNjVdLCA2NTogWzIsIDY1XSwgNzI6IFsyLCA2NV0sIDc1OiBbMiwgNjVdLCA4MDogWzIsIDY1XSwgODE6IFsyLCA2NV0sIDgyOiBbMiwgNjVdLCA4MzogWzIsIDY1XSwgODQ6IFsyLCA2NV0sIDg1OiBbMiwgNjVdIH0sIHsgMzM6IFsyLCA2N10sIDc1OiBbMiwgNjddIH0sIHsgMjM6IFsxLCAxMjRdIH0sIHsgMjM6IFsyLCA1MV0sIDY1OiBbMiwgNTFdLCA3MjogWzIsIDUxXSwgODA6IFsyLCA1MV0sIDgxOiBbMiwgNTFdLCA4MjogWzIsIDUxXSwgODM6IFsyLCA1MV0sIDg0OiBbMiwgNTFdLCA4NTogWzIsIDUxXSB9LCB7IDIzOiBbMiwgNTNdIH0sIHsgMzM6IFsxLCAxMjVdIH0sIHsgMzM6IFsyLCA5MV0sIDY1OiBbMiwgOTFdLCA3MjogWzIsIDkxXSwgODA6IFsyLCA5MV0sIDgxOiBbMiwgOTFdLCA4MjogWzIsIDkxXSwgODM6IFsyLCA5MV0sIDg0OiBbMiwgOTFdLCA4NTogWzIsIDkxXSB9LCB7IDMzOiBbMiwgOTNdIH0sIHsgNTogWzIsIDIyXSwgMTQ6IFsyLCAyMl0sIDE1OiBbMiwgMjJdLCAxOTogWzIsIDIyXSwgMjk6IFsyLCAyMl0sIDM0OiBbMiwgMjJdLCAzOTogWzIsIDIyXSwgNDQ6IFsyLCAyMl0sIDQ3OiBbMiwgMjJdLCA0ODogWzIsIDIyXSwgNTE6IFsyLCAyMl0sIDU1OiBbMiwgMjJdLCA2MDogWzIsIDIyXSB9LCB7IDIzOiBbMiwgOTldLCAzMzogWzIsIDk5XSwgNTQ6IFsyLCA5OV0sIDY4OiBbMiwgOTldLCA3MjogWzIsIDk5XSwgNzU6IFsyLCA5OV0gfSwgeyA3MzogWzEsIDEwOV0gfSwgeyAyMDogNzUsIDYzOiAxMjYsIDY0OiA3NiwgNjU6IFsxLCA0NF0sIDcyOiBbMSwgMzVdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNTogWzIsIDIzXSwgMTQ6IFsyLCAyM10sIDE1OiBbMiwgMjNdLCAxOTogWzIsIDIzXSwgMjk6IFsyLCAyM10sIDM0OiBbMiwgMjNdLCAzOTogWzIsIDIzXSwgNDQ6IFsyLCAyM10sIDQ3OiBbMiwgMjNdLCA0ODogWzIsIDIzXSwgNTE6IFsyLCAyM10sIDU1OiBbMiwgMjNdLCA2MDogWzIsIDIzXSB9LCB7IDQ3OiBbMiwgMTldIH0sIHsgNDc6IFsyLCA3N10gfSwgeyAyMDogNzUsIDMzOiBbMiwgNzJdLCA0MTogMTI3LCA2MzogMTI4LCA2NDogNzYsIDY1OiBbMSwgNDRdLCA2OTogMTI5LCA3MDogNzcsIDcxOiA3OCwgNzI6IFsxLCA3OV0sIDc1OiBbMiwgNzJdLCA3ODogMjYsIDc5OiAyNywgODA6IFsxLCAyOF0sIDgxOiBbMSwgMjldLCA4MjogWzEsIDMwXSwgODM6IFsxLCAzMV0sIDg0OiBbMSwgMzJdLCA4NTogWzEsIDM0XSwgODY6IDMzIH0sIHsgNTogWzIsIDI0XSwgMTQ6IFsyLCAyNF0sIDE1OiBbMiwgMjRdLCAxOTogWzIsIDI0XSwgMjk6IFsyLCAyNF0sIDM0OiBbMiwgMjRdLCAzOTogWzIsIDI0XSwgNDQ6IFsyLCAyNF0sIDQ3OiBbMiwgMjRdLCA0ODogWzIsIDI0XSwgNTE6IFsyLCAyNF0sIDU1OiBbMiwgMjRdLCA2MDogWzIsIDI0XSB9LCB7IDY4OiBbMSwgMTMwXSB9LCB7IDY1OiBbMiwgOTVdLCA2ODogWzIsIDk1XSwgNzI6IFsyLCA5NV0sIDgwOiBbMiwgOTVdLCA4MTogWzIsIDk1XSwgODI6IFsyLCA5NV0sIDgzOiBbMiwgOTVdLCA4NDogWzIsIDk1XSwgODU6IFsyLCA5NV0gfSwgeyA2ODogWzIsIDk3XSB9LCB7IDU6IFsyLCAyMV0sIDE0OiBbMiwgMjFdLCAxNTogWzIsIDIxXSwgMTk6IFsyLCAyMV0sIDI5OiBbMiwgMjFdLCAzNDogWzIsIDIxXSwgMzk6IFsyLCAyMV0sIDQ0OiBbMiwgMjFdLCA0NzogWzIsIDIxXSwgNDg6IFsyLCAyMV0sIDUxOiBbMiwgMjFdLCA1NTogWzIsIDIxXSwgNjA6IFsyLCAyMV0gfSwgeyAzMzogWzEsIDEzMV0gfSwgeyAzMzogWzIsIDYzXSB9LCB7IDcyOiBbMSwgMTMzXSwgNzY6IDEzMiB9LCB7IDMzOiBbMSwgMTM0XSB9LCB7IDMzOiBbMiwgNjldIH0sIHsgMTU6IFsyLCAxMl0gfSwgeyAxNDogWzIsIDI2XSwgMTU6IFsyLCAyNl0sIDE5OiBbMiwgMjZdLCAyOTogWzIsIDI2XSwgMzQ6IFsyLCAyNl0sIDQ3OiBbMiwgMjZdLCA0ODogWzIsIDI2XSwgNTE6IFsyLCAyNl0sIDU1OiBbMiwgMjZdLCA2MDogWzIsIDI2XSB9LCB7IDIzOiBbMiwgMzFdLCAzMzogWzIsIDMxXSwgNTQ6IFsyLCAzMV0sIDY4OiBbMiwgMzFdLCA3MjogWzIsIDMxXSwgNzU6IFsyLCAzMV0gfSwgeyAzMzogWzIsIDc0XSwgNDI6IDEzNSwgNzQ6IDEzNiwgNzU6IFsxLCAxMjFdIH0sIHsgMzM6IFsyLCA3MV0sIDY1OiBbMiwgNzFdLCA3MjogWzIsIDcxXSwgNzU6IFsyLCA3MV0sIDgwOiBbMiwgNzFdLCA4MTogWzIsIDcxXSwgODI6IFsyLCA3MV0sIDgzOiBbMiwgNzFdLCA4NDogWzIsIDcxXSwgODU6IFsyLCA3MV0gfSwgeyAzMzogWzIsIDczXSwgNzU6IFsyLCA3M10gfSwgeyAyMzogWzIsIDI5XSwgMzM6IFsyLCAyOV0sIDU0OiBbMiwgMjldLCA2NTogWzIsIDI5XSwgNjg6IFsyLCAyOV0sIDcyOiBbMiwgMjldLCA3NTogWzIsIDI5XSwgODA6IFsyLCAyOV0sIDgxOiBbMiwgMjldLCA4MjogWzIsIDI5XSwgODM6IFsyLCAyOV0sIDg0OiBbMiwgMjldLCA4NTogWzIsIDI5XSB9LCB7IDE0OiBbMiwgMTVdLCAxNTogWzIsIDE1XSwgMTk6IFsyLCAxNV0sIDI5OiBbMiwgMTVdLCAzNDogWzIsIDE1XSwgMzk6IFsyLCAxNV0sIDQ0OiBbMiwgMTVdLCA0NzogWzIsIDE1XSwgNDg6IFsyLCAxNV0sIDUxOiBbMiwgMTVdLCA1NTogWzIsIDE1XSwgNjA6IFsyLCAxNV0gfSwgeyA3MjogWzEsIDEzOF0sIDc3OiBbMSwgMTM3XSB9LCB7IDcyOiBbMiwgMTAwXSwgNzc6IFsyLCAxMDBdIH0sIHsgMTQ6IFsyLCAxNl0sIDE1OiBbMiwgMTZdLCAxOTogWzIsIDE2XSwgMjk6IFsyLCAxNl0sIDM0OiBbMiwgMTZdLCA0NDogWzIsIDE2XSwgNDc6IFsyLCAxNl0sIDQ4OiBbMiwgMTZdLCA1MTogWzIsIDE2XSwgNTU6IFsyLCAxNl0sIDYwOiBbMiwgMTZdIH0sIHsgMzM6IFsxLCAxMzldIH0sIHsgMzM6IFsyLCA3NV0gfSwgeyAzMzogWzIsIDMyXSB9LCB7IDcyOiBbMiwgMTAxXSwgNzc6IFsyLCAxMDFdIH0sIHsgMTQ6IFsyLCAxN10sIDE1OiBbMiwgMTddLCAxOTogWzIsIDE3XSwgMjk6IFsyLCAxN10sIDM0OiBbMiwgMTddLCAzOTogWzIsIDE3XSwgNDQ6IFsyLCAxN10sIDQ3OiBbMiwgMTddLCA0ODogWzIsIDE3XSwgNTE6IFsyLCAxN10sIDU1OiBbMiwgMTddLCA2MDogWzIsIDE3XSB9XSxcclxuXHQgICAgICAgIGRlZmF1bHRBY3Rpb25zOiB7IDQ6IFsyLCAxXSwgNTU6IFsyLCA1NV0sIDU3OiBbMiwgMjBdLCA2MTogWzIsIDU3XSwgNzQ6IFsyLCA4MV0sIDgzOiBbMiwgODVdLCA4NzogWzIsIDE4XSwgOTE6IFsyLCA4OV0sIDEwMjogWzIsIDUzXSwgMTA1OiBbMiwgOTNdLCAxMTE6IFsyLCAxOV0sIDExMjogWzIsIDc3XSwgMTE3OiBbMiwgOTddLCAxMjA6IFsyLCA2M10sIDEyMzogWzIsIDY5XSwgMTI0OiBbMiwgMTJdLCAxMzY6IFsyLCA3NV0sIDEzNzogWzIsIDMyXSB9LFxyXG5cdCAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcclxuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcclxuXHQgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrID0gWzBdLFxyXG5cdCAgICAgICAgICAgICAgICB2c3RhY2sgPSBbbnVsbF0sXHJcblx0ICAgICAgICAgICAgICAgIGxzdGFjayA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICB0YWJsZSA9IHRoaXMudGFibGUsXHJcblx0ICAgICAgICAgICAgICAgIHl5dGV4dCA9IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgIHl5bGluZW5vID0gMCxcclxuXHQgICAgICAgICAgICAgICAgeXlsZW5nID0gMCxcclxuXHQgICAgICAgICAgICAgICAgcmVjb3ZlcmluZyA9IDAsXHJcblx0ICAgICAgICAgICAgICAgIFRFUlJPUiA9IDIsXHJcblx0ICAgICAgICAgICAgICAgIEVPRiA9IDE7XHJcblx0ICAgICAgICAgICAgdGhpcy5sZXhlci5zZXRJbnB1dChpbnB1dCk7XHJcblx0ICAgICAgICAgICAgdGhpcy5sZXhlci55eSA9IHRoaXMueXk7XHJcblx0ICAgICAgICAgICAgdGhpcy55eS5sZXhlciA9IHRoaXMubGV4ZXI7XHJcblx0ICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIgPSB0aGlzO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5sZXhlci55eWxsb2MgPT0gXCJ1bmRlZmluZWRcIikgdGhpcy5sZXhlci55eWxsb2MgPSB7fTtcclxuXHQgICAgICAgICAgICB2YXIgeXlsb2MgPSB0aGlzLmxleGVyLnl5bGxvYztcclxuXHQgICAgICAgICAgICBsc3RhY2sucHVzaCh5eWxvYyk7XHJcblx0ICAgICAgICAgICAgdmFyIHJhbmdlcyA9IHRoaXMubGV4ZXIub3B0aW9ucyAmJiB0aGlzLmxleGVyLm9wdGlvbnMucmFuZ2VzO1xyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy55eS5wYXJzZUVycm9yID09PSBcImZ1bmN0aW9uXCIpIHRoaXMucGFyc2VFcnJvciA9IHRoaXMueXkucGFyc2VFcnJvcjtcclxuXHQgICAgICAgICAgICBmdW5jdGlvbiBwb3BTdGFjayhuKSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IHN0YWNrLmxlbmd0aCAtIDIgKiBuO1xyXG5cdCAgICAgICAgICAgICAgICB2c3RhY2subGVuZ3RoID0gdnN0YWNrLmxlbmd0aCAtIG47XHJcblx0ICAgICAgICAgICAgICAgIGxzdGFjay5sZW5ndGggPSBsc3RhY2subGVuZ3RoIC0gbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZnVuY3Rpb24gbGV4KCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW47XHJcblx0ICAgICAgICAgICAgICAgIHRva2VuID0gc2VsZi5sZXhlci5sZXgoKSB8fCAxO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSBcIm51bWJlclwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdmFyIHN5bWJvbCxcclxuXHQgICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wsXHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlLFxyXG5cdCAgICAgICAgICAgICAgICBhY3Rpb24sXHJcblx0ICAgICAgICAgICAgICAgIGEsXHJcblx0ICAgICAgICAgICAgICAgIHIsXHJcblx0ICAgICAgICAgICAgICAgIHl5dmFsID0ge30sXHJcblx0ICAgICAgICAgICAgICAgIHAsXHJcblx0ICAgICAgICAgICAgICAgIGxlbixcclxuXHQgICAgICAgICAgICAgICAgbmV3U3RhdGUsXHJcblx0ICAgICAgICAgICAgICAgIGV4cGVjdGVkO1xyXG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcblx0ICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gdGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV07XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcInVuZGVmaW5lZFwiIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlcnJTdHIgPSBcIlwiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNvdmVyaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHAgaW4gdGFibGVbc3RhdGVdKSBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiAyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goXCInXCIgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyBcIidcIik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxleGVyLnNob3dQb3NpdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSBcIlBhcnNlIGVycm9yIG9uIGxpbmUgXCIgKyAoeXlsaW5lbm8gKyAxKSArIFwiOlxcblwiICsgdGhpcy5sZXhlci5zaG93UG9zaXRpb24oKSArIFwiXFxuRXhwZWN0aW5nIFwiICsgZXhwZWN0ZWQuam9pbihcIiwgXCIpICsgXCIsIGdvdCAnXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyclN0ciA9IFwiUGFyc2UgZXJyb3Igb24gbGluZSBcIiArICh5eWxpbmVubyArIDEpICsgXCI6IFVuZXhwZWN0ZWQgXCIgKyAoc3ltYm9sID09IDEgPyBcImVuZCBvZiBpbnB1dFwiIDogXCInXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwgeyB0ZXh0OiB0aGlzLmxleGVyLm1hdGNoLCB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLCBsaW5lOiB0aGlzLmxleGVyLnl5bGluZW5vLCBsb2M6IHl5bG9jLCBleHBlY3RlZDogZXhwZWN0ZWQgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogXCIgKyBzdGF0ZSArIFwiLCB0b2tlbjogXCIgKyBzeW1ib2wpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZzdGFjay5wdXNoKHRoaXMubGV4ZXIueXl0ZXh0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsc3RhY2sucHVzaCh0aGlzLmxleGVyLnl5bGxvYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB5eWxlbmcgPSB0aGlzLmxleGVyLnl5bGVuZztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXl0ZXh0ID0gdGhpcy5sZXhlci55eXRleHQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHl5bGluZW5vID0gdGhpcy5sZXhlci55eWxpbmVubztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXlsb2MgPSB0aGlzLmxleGVyLnl5bGxvYztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY292ZXJpbmcgPiAwKSByZWNvdmVyaW5nLS07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gcHJlRXJyb3JTeW1ib2w7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZUVycm9yU3ltYm9sID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHl5dmFsLl8kID0geyBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLCBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHl5dmFsLCB5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHRoaXMueXksIGFjdGlvblsxXSwgdnN0YWNrLCBsc3RhY2spO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHQgICAgLyogSmlzb24gZ2VuZXJhdGVkIGxleGVyICovXHJcblx0ICAgIHZhciBsZXhlciA9IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB2YXIgbGV4ZXIgPSB7IEVPRjogMSxcclxuXHQgICAgICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24gc2V0SW5wdXQoaW5wdXQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2xlc3MgPSB0aGlzLmRvbmUgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MgPSB7IGZpcnN0X2xpbmU6IDEsIGZpcnN0X2NvbHVtbjogMCwgbGFzdF9saW5lOiAxLCBsYXN0X2NvbHVtbjogMCB9O1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwgMF07XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy55eWxlbmcrKztcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQrKztcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChsaW5lcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNoO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgdW5wdXQ6IGZ1bmN0aW9uIHVucHV0KGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsZW4gPSBjaC5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbiAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAvL3RoaXMueXlsZW5nIC09IGxlbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLm1hdGNoLnN1YnN0cigwLCB0aGlzLm1hdGNoLmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XHJcblx0ICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYyA9IHsgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXHJcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgbW9yZTogZnVuY3Rpb24gbW9yZSgpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgbGVzczogZnVuY3Rpb24gbGVzcyhuKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uIHBhc3RJbnB1dCgpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbiB1cGNvbWluZ0lucHV0KCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChuZXh0Lmxlbmd0aCA8IDIwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMCAtIG5leHQubGVuZ3RoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsIDIwKSArIChuZXh0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24gc2hvd1Bvc2l0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW5wdXQpIHRoaXMuZG9uZSA9IHRydWU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgdG9rZW4sIG1hdGNoLCB0ZW1wTWF0Y2gsIGluZGV4LCBjb2wsIGxpbmVzO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVzKSB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jID0geyBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9yZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBydWxlc1tpbmRleF0sIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kb25lICYmIHRoaXMuX2lucHV0KSB0aGlzLmRvbmUgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbikgcmV0dXJuIHRva2VuO2Vsc2UgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHsgdGV4dDogXCJcIiwgdG9rZW46IG51bGwsIGxpbmU6IHRoaXMueXlsaW5lbm8gfSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGxleDogZnVuY3Rpb24gbGV4KCkge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcjtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBiZWdpbjogZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uIHBvcFN0YXRlKCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbiB0b3BTdGF0ZSgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAyXTtcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcclxuXHQgICAgICAgICAgICB9IH07XHJcblx0ICAgICAgICBsZXhlci5vcHRpb25zID0ge307XHJcblx0ICAgICAgICBsZXhlci5wZXJmb3JtQWN0aW9uID0gZnVuY3Rpb24gYW5vbnltb3VzKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUXHJcblx0ICAgICAgICAvKiovKSB7XHJcblxyXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHN0cmlwKHN0YXJ0LCBlbmQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cihzdGFydCwgeXlfLnl5bGVuZyAtIGVuZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB2YXIgWVlTVEFURSA9IFlZX1NUQVJUO1xyXG5cdCAgICAgICAgICAgIHN3aXRjaCAoJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoeXlfLnl5dGV4dC5zbGljZSgtMikgPT09IFwiXFxcXFxcXFxcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwKDAsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJtdVwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeXlfLnl5dGV4dC5zbGljZSgtMSkgPT09IFwiXFxcXFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXAoMCwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihcImVtdVwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbihcIm11XCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHl5Xy55eXRleHQpIHJldHVybiAxNTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbigncmF3Jyk7cmV0dXJuIDE1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSB1c2luZyBgdGhpcy50b3BTdGF0ZSgpYCBiZWxvdywgYnV0IGl0IGN1cnJlbnRseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0aGUgc2Vjb25kIHRvcCBpbnN0ZWFkIG9mIHRoZSBmaXJzdCB0b3AuIE9wZW5lZCBhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaXNzdWUgYWJvdXQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL3phYWNoL2ppc29uL2lzc3Vlcy8yOTFcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0gPT09ICdyYXcnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE1O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoNSwgeXlfLnl5bGVuZyAtIDkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnRU5EX1JBV19CTE9DSyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxNTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDY6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA2NTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDg6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNjg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE5O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTA6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luKCdyYXcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAyMztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxMTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA1NTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDYwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTM6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMjk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA0NztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiA0NDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE2OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiA0NDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDE3OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTg6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMzk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAxOTpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA1MTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDIwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQ4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjE6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnVucHV0KHl5Xy55eXRleHQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpbignY29tJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjM6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA3MztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDcyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjY6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzI7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAyNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHdoaXRlc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDI5OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiA1NDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDMwOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO3JldHVybiAzMztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDMxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgeXlfLnl5dGV4dCA9IHN0cmlwKDEsIDIpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKTtyZXR1cm4gODA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzMjpcclxuXHQgICAgICAgICAgICAgICAgICAgIHl5Xy55eXRleHQgPSBzdHJpcCgxLCAyKS5yZXBsYWNlKC9cXFxcJy9nLCBcIidcIik7cmV0dXJuIDgwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzM6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gODU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA4MjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM1OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDgyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzY6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gODM7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSAzNzpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA4NDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDM4OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDgxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzk6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNzU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgY2FzZSA0MDpcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiA3NztcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICBjYXNlIDQxOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDcyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDI6XHJcblx0ICAgICAgICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5yZXBsYWNlKC9cXFxcKFtcXFxcXFxdXSkvZywgJyQxJyk7cmV0dXJuIDcyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDM6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0lOVkFMSUQnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH07XHJcblx0ICAgICAgICBsZXhlci5ydWxlcyA9IFsvXig/OlteXFx4MDBdKj8oPz0oXFx7XFx7KSkpLywgL14oPzpbXlxceDAwXSspLywgL14oPzpbXlxceDAwXXsyLH0/KD89KFxce1xce3xcXFxcXFx7XFx7fFxcXFxcXFxcXFx7XFx7fCQpKSkvLCAvXig/Olxce1xce1xce1xceyg/PVteXFwvXSkpLywgL14oPzpcXHtcXHtcXHtcXHtcXC9bXlxccyFcIiMlLSxcXC5cXC87LT5AXFxbLVxcXmBcXHstfl0rKD89Wz19XFxzXFwvLl0pXFx9XFx9XFx9XFx9KS8sIC9eKD86W15cXHgwMF0qPyg/PShcXHtcXHtcXHtcXHspKSkvLCAvXig/OltcXHNcXFNdKj8tLSh+KT9cXH1cXH0pLywgL14oPzpcXCgpLywgL14oPzpcXCkpLywgL14oPzpcXHtcXHtcXHtcXHspLywgL14oPzpcXH1cXH1cXH1cXH0pLywgL14oPzpcXHtcXHsofik/PikvLCAvXig/Olxce1xceyh+KT8jPikvLCAvXig/Olxce1xceyh+KT8jXFwqPykvLCAvXig/Olxce1xceyh+KT9cXC8pLywgL14oPzpcXHtcXHsofik/XFxeXFxzKih+KT9cXH1cXH0pLywgL14oPzpcXHtcXHsofik/XFxzKmVsc2VcXHMqKH4pP1xcfVxcfSkvLCAvXig/Olxce1xceyh+KT9cXF4pLywgL14oPzpcXHtcXHsofik/XFxzKmVsc2VcXGIpLywgL14oPzpcXHtcXHsofik/XFx7KS8sIC9eKD86XFx7XFx7KH4pPyYpLywgL14oPzpcXHtcXHsofik/IS0tKS8sIC9eKD86XFx7XFx7KH4pPyFbXFxzXFxTXSo/XFx9XFx9KS8sIC9eKD86XFx7XFx7KH4pP1xcKj8pLywgL14oPzo9KS8sIC9eKD86XFwuXFwuKS8sIC9eKD86XFwuKD89KFs9fn1cXHNcXC8uKXxdKSkpLywgL14oPzpbXFwvLl0pLywgL14oPzpcXHMrKS8sIC9eKD86XFx9KH4pP1xcfVxcfSkvLCAvXig/Oih+KT9cXH1cXH0pLywgL14oPzpcIihcXFxcW1wiXXxbXlwiXSkqXCIpLywgL14oPzonKFxcXFxbJ118W14nXSkqJykvLCAvXig/OkApLywgL14oPzp0cnVlKD89KFt+fVxccyldKSkpLywgL14oPzpmYWxzZSg/PShbfn1cXHMpXSkpKS8sIC9eKD86dW5kZWZpbmVkKD89KFt+fVxccyldKSkpLywgL14oPzpudWxsKD89KFt+fVxccyldKSkpLywgL14oPzotP1swLTldKyg/OlxcLlswLTldKyk/KD89KFt+fVxccyldKSkpLywgL14oPzphc1xccytcXHwpLywgL14oPzpcXHwpLywgL14oPzooW15cXHMhXCIjJS0sXFwuXFwvOy0+QFxcWy1cXF5gXFx7LX5dKyg/PShbPX59XFxzXFwvLil8XSkpKSkvLCAvXig/OlxcWyhcXFxcXFxdfFteXFxdXSkqXFxdKS8sIC9eKD86LikvLCAvXig/OiQpL107XHJcblx0ICAgICAgICBsZXhlci5jb25kaXRpb25zID0geyBcIm11XCI6IHsgXCJydWxlc1wiOiBbNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0XSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJlbXVcIjogeyBcInJ1bGVzXCI6IFsyXSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJjb21cIjogeyBcInJ1bGVzXCI6IFs2XSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJyYXdcIjogeyBcInJ1bGVzXCI6IFszLCA0LCA1XSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJJTklUSUFMXCI6IHsgXCJydWxlc1wiOiBbMCwgMSwgNDRdLCBcImluY2x1c2l2ZVwiOiB0cnVlIH0gfTtcclxuXHQgICAgICAgIHJldHVybiBsZXhlcjtcclxuXHQgICAgfSkoKTtcclxuXHQgICAgcGFyc2VyLmxleGVyID0gbGV4ZXI7XHJcblx0ICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcclxuXHQgICAgICAgIHRoaXMueXkgPSB7fTtcclxuXHQgICAgfVBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcclxuXHQgICAgcmV0dXJuIG5ldyBQYXJzZXIoKTtcclxuXHR9KSgpO2V4cG9ydHNbXCJkZWZhdWx0XCJdID0gaGFuZGxlYmFycztcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF92aXNpdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcblxyXG5cdHZhciBfdmlzaXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92aXNpdG9yKTtcclxuXHJcblx0ZnVuY3Rpb24gV2hpdGVzcGFjZUNvbnRyb2woKSB7XHJcblx0ICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xyXG5cclxuXHQgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0fVxyXG5cdFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZSA9IG5ldyBfdmlzaXRvcjJbJ2RlZmF1bHQnXSgpO1xyXG5cclxuXHRXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XHJcblx0ICB2YXIgZG9TdGFuZGFsb25lID0gIXRoaXMub3B0aW9ucy5pZ25vcmVTdGFuZGFsb25lO1xyXG5cclxuXHQgIHZhciBpc1Jvb3QgPSAhdGhpcy5pc1Jvb3RTZWVuO1xyXG5cdCAgdGhpcy5pc1Jvb3RTZWVuID0gdHJ1ZTtcclxuXHJcblx0ICB2YXIgYm9keSA9IHByb2dyYW0uYm9keTtcclxuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gYm9keS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgdmFyIGN1cnJlbnQgPSBib2R5W2ldLFxyXG5cdCAgICAgICAgc3RyaXAgPSB0aGlzLmFjY2VwdChjdXJyZW50KTtcclxuXHJcblx0ICAgIGlmICghc3RyaXApIHtcclxuXHQgICAgICBjb250aW51ZTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIF9pc1ByZXZXaGl0ZXNwYWNlID0gaXNQcmV2V2hpdGVzcGFjZShib2R5LCBpLCBpc1Jvb3QpLFxyXG5cdCAgICAgICAgX2lzTmV4dFdoaXRlc3BhY2UgPSBpc05leHRXaGl0ZXNwYWNlKGJvZHksIGksIGlzUm9vdCksXHJcblx0ICAgICAgICBvcGVuU3RhbmRhbG9uZSA9IHN0cmlwLm9wZW5TdGFuZGFsb25lICYmIF9pc1ByZXZXaGl0ZXNwYWNlLFxyXG5cdCAgICAgICAgY2xvc2VTdGFuZGFsb25lID0gc3RyaXAuY2xvc2VTdGFuZGFsb25lICYmIF9pc05leHRXaGl0ZXNwYWNlLFxyXG5cdCAgICAgICAgaW5saW5lU3RhbmRhbG9uZSA9IHN0cmlwLmlubGluZVN0YW5kYWxvbmUgJiYgX2lzUHJldldoaXRlc3BhY2UgJiYgX2lzTmV4dFdoaXRlc3BhY2U7XHJcblxyXG5cdCAgICBpZiAoc3RyaXAuY2xvc2UpIHtcclxuXHQgICAgICBvbWl0UmlnaHQoYm9keSwgaSwgdHJ1ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHN0cmlwLm9wZW4pIHtcclxuXHQgICAgICBvbWl0TGVmdChib2R5LCBpLCB0cnVlKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKGRvU3RhbmRhbG9uZSAmJiBpbmxpbmVTdGFuZGFsb25lKSB7XHJcblx0ICAgICAgb21pdFJpZ2h0KGJvZHksIGkpO1xyXG5cclxuXHQgICAgICBpZiAob21pdExlZnQoYm9keSwgaSkpIHtcclxuXHQgICAgICAgIC8vIElmIHdlIGFyZSBvbiBhIHN0YW5kYWxvbmUgbm9kZSwgc2F2ZSB0aGUgaW5kZW50IGluZm8gZm9yIHBhcnRpYWxzXHJcblx0ICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSAnUGFydGlhbFN0YXRlbWVudCcpIHtcclxuXHQgICAgICAgICAgLy8gUHVsbCBvdXQgdGhlIHdoaXRlc3BhY2UgZnJvbSB0aGUgZmluYWwgbGluZVxyXG5cdCAgICAgICAgICBjdXJyZW50LmluZGVudCA9IC8oWyBcXHRdKyQpLy5leGVjKGJvZHlbaSAtIDFdLm9yaWdpbmFsKVsxXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGRvU3RhbmRhbG9uZSAmJiBvcGVuU3RhbmRhbG9uZSkge1xyXG5cdCAgICAgIG9taXRSaWdodCgoY3VycmVudC5wcm9ncmFtIHx8IGN1cnJlbnQuaW52ZXJzZSkuYm9keSk7XHJcblxyXG5cdCAgICAgIC8vIFN0cmlwIG91dCB0aGUgcHJldmlvdXMgY29udGVudCBub2RlIGlmIGl0J3Mgd2hpdGVzcGFjZSBvbmx5XHJcblx0ICAgICAgb21pdExlZnQoYm9keSwgaSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGRvU3RhbmRhbG9uZSAmJiBjbG9zZVN0YW5kYWxvbmUpIHtcclxuXHQgICAgICAvLyBBbHdheXMgc3RyaXAgdGhlIG5leHQgbm9kZVxyXG5cdCAgICAgIG9taXRSaWdodChib2R5LCBpKTtcclxuXHJcblx0ICAgICAgb21pdExlZnQoKGN1cnJlbnQuaW52ZXJzZSB8fCBjdXJyZW50LnByb2dyYW0pLmJvZHkpO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblxyXG5cdCAgcmV0dXJuIHByb2dyYW07XHJcblx0fTtcclxuXHJcblx0V2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkJsb2NrU3RhdGVtZW50ID0gV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLkRlY29yYXRvckJsb2NrID0gV2hpdGVzcGFjZUNvbnRyb2wucHJvdG90eXBlLlBhcnRpYWxCbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIChibG9jaykge1xyXG5cdCAgdGhpcy5hY2NlcHQoYmxvY2sucHJvZ3JhbSk7XHJcblx0ICB0aGlzLmFjY2VwdChibG9jay5pbnZlcnNlKTtcclxuXHJcblx0ICAvLyBGaW5kIHRoZSBpbnZlcnNlIHByb2dyYW0gdGhhdCBpcyBpbnZvbGVkIHdpdGggd2hpdGVzcGFjZSBzdHJpcHBpbmcuXHJcblx0ICB2YXIgcHJvZ3JhbSA9IGJsb2NrLnByb2dyYW0gfHwgYmxvY2suaW52ZXJzZSxcclxuXHQgICAgICBpbnZlcnNlID0gYmxvY2sucHJvZ3JhbSAmJiBibG9jay5pbnZlcnNlLFxyXG5cdCAgICAgIGZpcnN0SW52ZXJzZSA9IGludmVyc2UsXHJcblx0ICAgICAgbGFzdEludmVyc2UgPSBpbnZlcnNlO1xyXG5cclxuXHQgIGlmIChpbnZlcnNlICYmIGludmVyc2UuY2hhaW5lZCkge1xyXG5cdCAgICBmaXJzdEludmVyc2UgPSBpbnZlcnNlLmJvZHlbMF0ucHJvZ3JhbTtcclxuXHJcblx0ICAgIC8vIFdhbGsgdGhlIGludmVyc2UgY2hhaW4gdG8gZmluZCB0aGUgbGFzdCBpbnZlcnNlIHRoYXQgaXMgYWN0dWFsbHkgaW4gdGhlIGNoYWluLlxyXG5cdCAgICB3aGlsZSAobGFzdEludmVyc2UuY2hhaW5lZCkge1xyXG5cdCAgICAgIGxhc3RJbnZlcnNlID0gbGFzdEludmVyc2UuYm9keVtsYXN0SW52ZXJzZS5ib2R5Lmxlbmd0aCAtIDFdLnByb2dyYW07XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICB2YXIgc3RyaXAgPSB7XHJcblx0ICAgIG9wZW46IGJsb2NrLm9wZW5TdHJpcC5vcGVuLFxyXG5cdCAgICBjbG9zZTogYmxvY2suY2xvc2VTdHJpcC5jbG9zZSxcclxuXHJcblx0ICAgIC8vIERldGVybWluZSB0aGUgc3RhbmRhbG9uZSBjYW5kaWFjeS4gQmFzaWNhbGx5IGZsYWcgb3VyIGNvbnRlbnQgYXMgYmVpbmcgcG9zc2libHkgc3RhbmRhbG9uZVxyXG5cdCAgICAvLyBzbyBvdXIgcGFyZW50IGNhbiBkZXRlcm1pbmUgaWYgd2UgYWN0dWFsbHkgYXJlIHN0YW5kYWxvbmVcclxuXHQgICAgb3BlblN0YW5kYWxvbmU6IGlzTmV4dFdoaXRlc3BhY2UocHJvZ3JhbS5ib2R5KSxcclxuXHQgICAgY2xvc2VTdGFuZGFsb25lOiBpc1ByZXZXaGl0ZXNwYWNlKChmaXJzdEludmVyc2UgfHwgcHJvZ3JhbSkuYm9keSlcclxuXHQgIH07XHJcblxyXG5cdCAgaWYgKGJsb2NrLm9wZW5TdHJpcC5jbG9zZSkge1xyXG5cdCAgICBvbWl0UmlnaHQocHJvZ3JhbS5ib2R5LCBudWxsLCB0cnVlKTtcclxuXHQgIH1cclxuXHJcblx0ICBpZiAoaW52ZXJzZSkge1xyXG5cdCAgICB2YXIgaW52ZXJzZVN0cmlwID0gYmxvY2suaW52ZXJzZVN0cmlwO1xyXG5cclxuXHQgICAgaWYgKGludmVyc2VTdHJpcC5vcGVuKSB7XHJcblx0ICAgICAgb21pdExlZnQocHJvZ3JhbS5ib2R5LCBudWxsLCB0cnVlKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKGludmVyc2VTdHJpcC5jbG9zZSkge1xyXG5cdCAgICAgIG9taXRSaWdodChmaXJzdEludmVyc2UuYm9keSwgbnVsbCwgdHJ1ZSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGJsb2NrLmNsb3NlU3RyaXAub3Blbikge1xyXG5cdCAgICAgIG9taXRMZWZ0KGxhc3RJbnZlcnNlLmJvZHksIG51bGwsIHRydWUpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBGaW5kIHN0YW5kYWxvbmUgZWxzZSBzdGF0bWVudHNcclxuXHQgICAgaWYgKCF0aGlzLm9wdGlvbnMuaWdub3JlU3RhbmRhbG9uZSAmJiBpc1ByZXZXaGl0ZXNwYWNlKHByb2dyYW0uYm9keSkgJiYgaXNOZXh0V2hpdGVzcGFjZShmaXJzdEludmVyc2UuYm9keSkpIHtcclxuXHQgICAgICBvbWl0TGVmdChwcm9ncmFtLmJvZHkpO1xyXG5cdCAgICAgIG9taXRSaWdodChmaXJzdEludmVyc2UuYm9keSk7XHJcblx0ICAgIH1cclxuXHQgIH0gZWxzZSBpZiAoYmxvY2suY2xvc2VTdHJpcC5vcGVuKSB7XHJcblx0ICAgIG9taXRMZWZ0KHByb2dyYW0uYm9keSwgbnVsbCwgdHJ1ZSk7XHJcblx0ICB9XHJcblxyXG5cdCAgcmV0dXJuIHN0cmlwO1xyXG5cdH07XHJcblxyXG5cdFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5EZWNvcmF0b3IgPSBXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuTXVzdGFjaGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAobXVzdGFjaGUpIHtcclxuXHQgIHJldHVybiBtdXN0YWNoZS5zdHJpcDtcclxuXHR9O1xyXG5cclxuXHRXaGl0ZXNwYWNlQ29udHJvbC5wcm90b3R5cGUuUGFydGlhbFN0YXRlbWVudCA9IFdoaXRlc3BhY2VDb250cm9sLnByb3RvdHlwZS5Db21tZW50U3RhdGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuXHQgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICB2YXIgc3RyaXAgPSBub2RlLnN0cmlwIHx8IHt9O1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgaW5saW5lU3RhbmRhbG9uZTogdHJ1ZSxcclxuXHQgICAgb3Blbjogc3RyaXAub3BlbixcclxuXHQgICAgY2xvc2U6IHN0cmlwLmNsb3NlXHJcblx0ICB9O1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGlzUHJldldoaXRlc3BhY2UoYm9keSwgaSwgaXNSb290KSB7XHJcblx0ICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgIGkgPSBib2R5Lmxlbmd0aDtcclxuXHQgIH1cclxuXHJcblx0ICAvLyBOb2RlcyB0aGF0IGVuZCB3aXRoIG5ld2xpbmVzIGFyZSBjb25zaWRlcmVkIHdoaXRlc3BhY2UgKGJ1dCBhcmUgc3BlY2lhbFxyXG5cdCAgLy8gY2FzZWQgZm9yIHN0cmlwIG9wZXJhdGlvbnMpXHJcblx0ICB2YXIgcHJldiA9IGJvZHlbaSAtIDFdLFxyXG5cdCAgICAgIHNpYmxpbmcgPSBib2R5W2kgLSAyXTtcclxuXHQgIGlmICghcHJldikge1xyXG5cdCAgICByZXR1cm4gaXNSb290O1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChwcmV2LnR5cGUgPT09ICdDb250ZW50U3RhdGVtZW50Jykge1xyXG5cdCAgICByZXR1cm4gKHNpYmxpbmcgfHwgIWlzUm9vdCA/IC9cXHI/XFxuXFxzKj8kLyA6IC8oXnxcXHI/XFxuKVxccyo/JC8pLnRlc3QocHJldi5vcmlnaW5hbCk7XHJcblx0ICB9XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGlzTmV4dFdoaXRlc3BhY2UoYm9keSwgaSwgaXNSb290KSB7XHJcblx0ICBpZiAoaSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgIGkgPSAtMTtcclxuXHQgIH1cclxuXHJcblx0ICB2YXIgbmV4dCA9IGJvZHlbaSArIDFdLFxyXG5cdCAgICAgIHNpYmxpbmcgPSBib2R5W2kgKyAyXTtcclxuXHQgIGlmICghbmV4dCkge1xyXG5cdCAgICByZXR1cm4gaXNSb290O1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChuZXh0LnR5cGUgPT09ICdDb250ZW50U3RhdGVtZW50Jykge1xyXG5cdCAgICByZXR1cm4gKHNpYmxpbmcgfHwgIWlzUm9vdCA/IC9eXFxzKj9cXHI/XFxuLyA6IC9eXFxzKj8oXFxyP1xcbnwkKS8pLnRlc3QobmV4dC5vcmlnaW5hbCk7XHJcblx0ICB9XHJcblx0fVxyXG5cclxuXHQvLyBNYXJrcyB0aGUgbm9kZSB0byB0aGUgcmlnaHQgb2YgdGhlIHBvc2l0aW9uIGFzIG9taXR0ZWQuXHJcblx0Ly8gSS5lLiB7e2Zvb319JyAnIHdpbGwgbWFyayB0aGUgJyAnIG5vZGUgYXMgb21pdHRlZC5cclxuXHQvL1xyXG5cdC8vIElmIGkgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIG1hcmtlZCBhcyBzdWNoLlxyXG5cdC8vXHJcblx0Ly8gSWYgbXVsaXRwbGUgaXMgdHJ1dGh5IHRoZW4gYWxsIHdoaXRlc3BhY2Ugd2lsbCBiZSBzdHJpcHBlZCBvdXQgdW50aWwgbm9uLXdoaXRlc3BhY2VcclxuXHQvLyBjb250ZW50IGlzIG1ldC5cclxuXHRmdW5jdGlvbiBvbWl0UmlnaHQoYm9keSwgaSwgbXVsdGlwbGUpIHtcclxuXHQgIHZhciBjdXJyZW50ID0gYm9keVtpID09IG51bGwgPyAwIDogaSArIDFdO1xyXG5cdCAgaWYgKCFjdXJyZW50IHx8IGN1cnJlbnQudHlwZSAhPT0gJ0NvbnRlbnRTdGF0ZW1lbnQnIHx8ICFtdWx0aXBsZSAmJiBjdXJyZW50LnJpZ2h0U3RyaXBwZWQpIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cclxuXHQgIHZhciBvcmlnaW5hbCA9IGN1cnJlbnQudmFsdWU7XHJcblx0ICBjdXJyZW50LnZhbHVlID0gY3VycmVudC52YWx1ZS5yZXBsYWNlKG11bHRpcGxlID8gL15cXHMrLyA6IC9eWyBcXHRdKlxccj9cXG4/LywgJycpO1xyXG5cdCAgY3VycmVudC5yaWdodFN0cmlwcGVkID0gY3VycmVudC52YWx1ZSAhPT0gb3JpZ2luYWw7XHJcblx0fVxyXG5cclxuXHQvLyBNYXJrcyB0aGUgbm9kZSB0byB0aGUgbGVmdCBvZiB0aGUgcG9zaXRpb24gYXMgb21pdHRlZC5cclxuXHQvLyBJLmUuICcgJ3t7Zm9vfX0gd2lsbCBtYXJrIHRoZSAnICcgbm9kZSBhcyBvbWl0dGVkLlxyXG5cdC8vXHJcblx0Ly8gSWYgaSBpcyB1bmRlZmluZWQgdGhlbiB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlIG1hcmtlZCBhcyBzdWNoLlxyXG5cdC8vXHJcblx0Ly8gSWYgbXVsaXRwbGUgaXMgdHJ1dGh5IHRoZW4gYWxsIHdoaXRlc3BhY2Ugd2lsbCBiZSBzdHJpcHBlZCBvdXQgdW50aWwgbm9uLXdoaXRlc3BhY2VcclxuXHQvLyBjb250ZW50IGlzIG1ldC5cclxuXHRmdW5jdGlvbiBvbWl0TGVmdChib2R5LCBpLCBtdWx0aXBsZSkge1xyXG5cdCAgdmFyIGN1cnJlbnQgPSBib2R5W2kgPT0gbnVsbCA/IGJvZHkubGVuZ3RoIC0gMSA6IGkgLSAxXTtcclxuXHQgIGlmICghY3VycmVudCB8fCBjdXJyZW50LnR5cGUgIT09ICdDb250ZW50U3RhdGVtZW50JyB8fCAhbXVsdGlwbGUgJiYgY3VycmVudC5sZWZ0U3RyaXBwZWQpIHtcclxuXHQgICAgcmV0dXJuO1xyXG5cdCAgfVxyXG5cclxuXHQgIC8vIFdlIG9taXQgdGhlIGxhc3Qgbm9kZSBpZiBpdCdzIHdoaXRlc3BhY2Ugb25seSBhbmQgbm90IHByZWNlZWRlZCBieSBhIG5vbi1jb250ZW50IG5vZGUuXHJcblx0ICB2YXIgb3JpZ2luYWwgPSBjdXJyZW50LnZhbHVlO1xyXG5cdCAgY3VycmVudC52YWx1ZSA9IGN1cnJlbnQudmFsdWUucmVwbGFjZShtdWx0aXBsZSA/IC9cXHMrJC8gOiAvWyBcXHRdKyQvLCAnJyk7XHJcblx0ICBjdXJyZW50LmxlZnRTdHJpcHBlZCA9IGN1cnJlbnQudmFsdWUgIT09IG9yaWdpbmFsO1xyXG5cdCAgcmV0dXJuIGN1cnJlbnQubGVmdFN0cmlwcGVkO1xyXG5cdH1cclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gV2hpdGVzcGFjZUNvbnRyb2w7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XHJcblxyXG5cdGZ1bmN0aW9uIFZpc2l0b3IoKSB7XHJcblx0ICB0aGlzLnBhcmVudHMgPSBbXTtcclxuXHR9XHJcblxyXG5cdFZpc2l0b3IucHJvdG90eXBlID0ge1xyXG5cdCAgY29uc3RydWN0b3I6IFZpc2l0b3IsXHJcblx0ICBtdXRhdGluZzogZmFsc2UsXHJcblxyXG5cdCAgLy8gVmlzaXRzIGEgZ2l2ZW4gdmFsdWUuIElmIG11dGF0aW5nLCB3aWxsIHJlcGxhY2UgdGhlIHZhbHVlIGlmIG5lY2Vzc2FyeS5cclxuXHQgIGFjY2VwdEtleTogZnVuY3Rpb24gYWNjZXB0S2V5KG5vZGUsIG5hbWUpIHtcclxuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5hY2NlcHQobm9kZVtuYW1lXSk7XHJcblx0ICAgIGlmICh0aGlzLm11dGF0aW5nKSB7XHJcblx0ICAgICAgLy8gSGFja3kgc2FuaXR5IGNoZWNrOiBUaGlzIG1heSBoYXZlIGEgZmV3IGZhbHNlIHBvc2l0aXZlcyBmb3IgdHlwZSBmb3IgdGhlIGhlbHBlclxyXG5cdCAgICAgIC8vIG1ldGhvZHMgYnV0IHdpbGwgZ2VuZXJhbGx5IGRvIHRoZSByaWdodCB0aGluZyB3aXRob3V0IGEgbG90IG9mIG92ZXJoZWFkLlxyXG5cdCAgICAgIGlmICh2YWx1ZSAmJiAhVmlzaXRvci5wcm90b3R5cGVbdmFsdWUudHlwZV0pIHtcclxuXHQgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIicgKyB2YWx1ZS50eXBlICsgJ1wiIGZvdW5kIHdoZW4gYWNjZXB0aW5nICcgKyBuYW1lICsgJyBvbiAnICsgbm9kZS50eXBlKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgbm9kZVtuYW1lXSA9IHZhbHVlO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFBlcmZvcm1zIGFuIGFjY2VwdCBvcGVyYXRpb24gd2l0aCBhZGRlZCBzYW5pdHkgY2hlY2sgdG8gZW5zdXJlXHJcblx0ICAvLyByZXF1aXJlZCBrZXlzIGFyZSBub3QgcmVtb3ZlZC5cclxuXHQgIGFjY2VwdFJlcXVpcmVkOiBmdW5jdGlvbiBhY2NlcHRSZXF1aXJlZChub2RlLCBuYW1lKSB7XHJcblx0ICAgIHRoaXMuYWNjZXB0S2V5KG5vZGUsIG5hbWUpO1xyXG5cclxuXHQgICAgaWYgKCFub2RlW25hbWVdKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10obm9kZS50eXBlICsgJyByZXF1aXJlcyAnICsgbmFtZSk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gVHJhdmVyc2VzIGEgZ2l2ZW4gYXJyYXkuIElmIG11dGF0aW5nLCBlbXB0eSByZXNwbnNlcyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgIC8vIGZvciBjaGlsZCBlbGVtZW50cy5cclxuXHQgIGFjY2VwdEFycmF5OiBmdW5jdGlvbiBhY2NlcHRBcnJheShhcnJheSkge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgIHRoaXMuYWNjZXB0S2V5KGFycmF5LCBpKTtcclxuXHJcblx0ICAgICAgaWYgKCFhcnJheVtpXSkge1xyXG5cdCAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgaS0tO1xyXG5cdCAgICAgICAgbC0tO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBhY2NlcHQ6IGZ1bmN0aW9uIGFjY2VwdChvYmplY3QpIHtcclxuXHQgICAgaWYgKCFvYmplY3QpIHtcclxuXHQgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBTYW5pdHkgY29kZSAqL1xyXG5cdCAgICBpZiAoIXRoaXNbb2JqZWN0LnR5cGVdKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1Vua25vd24gdHlwZTogJyArIG9iamVjdC50eXBlLCBvYmplY3QpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAodGhpcy5jdXJyZW50KSB7XHJcblx0ICAgICAgdGhpcy5wYXJlbnRzLnVuc2hpZnQodGhpcy5jdXJyZW50KTtcclxuXHQgICAgfVxyXG5cdCAgICB0aGlzLmN1cnJlbnQgPSBvYmplY3Q7XHJcblxyXG5cdCAgICB2YXIgcmV0ID0gdGhpc1tvYmplY3QudHlwZV0ob2JqZWN0KTtcclxuXHJcblx0ICAgIHRoaXMuY3VycmVudCA9IHRoaXMucGFyZW50cy5zaGlmdCgpO1xyXG5cclxuXHQgICAgaWYgKCF0aGlzLm11dGF0aW5nIHx8IHJldCkge1xyXG5cdCAgICAgIHJldHVybiByZXQ7XHJcblx0ICAgIH0gZWxzZSBpZiAocmV0ICE9PSBmYWxzZSkge1xyXG5cdCAgICAgIHJldHVybiBvYmplY3Q7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgUHJvZ3JhbTogZnVuY3Rpb24gUHJvZ3JhbShwcm9ncmFtKSB7XHJcblx0ICAgIHRoaXMuYWNjZXB0QXJyYXkocHJvZ3JhbS5ib2R5KTtcclxuXHQgIH0sXHJcblxyXG5cdCAgTXVzdGFjaGVTdGF0ZW1lbnQ6IHZpc2l0U3ViRXhwcmVzc2lvbixcclxuXHQgIERlY29yYXRvcjogdmlzaXRTdWJFeHByZXNzaW9uLFxyXG5cclxuXHQgIEJsb2NrU3RhdGVtZW50OiB2aXNpdEJsb2NrLFxyXG5cdCAgRGVjb3JhdG9yQmxvY2s6IHZpc2l0QmxvY2ssXHJcblxyXG5cdCAgUGFydGlhbFN0YXRlbWVudDogdmlzaXRQYXJ0aWFsLFxyXG5cdCAgUGFydGlhbEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbiBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbCkge1xyXG5cdCAgICB2aXNpdFBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsKTtcclxuXHJcblx0ICAgIHRoaXMuYWNjZXB0S2V5KHBhcnRpYWwsICdwcm9ncmFtJyk7XHJcblx0ICB9LFxyXG5cclxuXHQgIENvbnRlbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIENvbnRlbnRTdGF0ZW1lbnQoKSAvKiBjb250ZW50ICove30sXHJcblx0ICBDb21tZW50U3RhdGVtZW50OiBmdW5jdGlvbiBDb21tZW50U3RhdGVtZW50KCkgLyogY29tbWVudCAqL3t9LFxyXG5cclxuXHQgIFN1YkV4cHJlc3Npb246IHZpc2l0U3ViRXhwcmVzc2lvbixcclxuXHJcblx0ICBQYXRoRXhwcmVzc2lvbjogZnVuY3Rpb24gUGF0aEV4cHJlc3Npb24oKSAvKiBwYXRoICove30sXHJcblxyXG5cdCAgU3RyaW5nTGl0ZXJhbDogZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbCgpIC8qIHN0cmluZyAqL3t9LFxyXG5cdCAgTnVtYmVyTGl0ZXJhbDogZnVuY3Rpb24gTnVtYmVyTGl0ZXJhbCgpIC8qIG51bWJlciAqL3t9LFxyXG5cdCAgQm9vbGVhbkxpdGVyYWw6IGZ1bmN0aW9uIEJvb2xlYW5MaXRlcmFsKCkgLyogYm9vbCAqL3t9LFxyXG5cdCAgVW5kZWZpbmVkTGl0ZXJhbDogZnVuY3Rpb24gVW5kZWZpbmVkTGl0ZXJhbCgpIC8qIGxpdGVyYWwgKi97fSxcclxuXHQgIE51bGxMaXRlcmFsOiBmdW5jdGlvbiBOdWxsTGl0ZXJhbCgpIC8qIGxpdGVyYWwgKi97fSxcclxuXHJcblx0ICBIYXNoOiBmdW5jdGlvbiBIYXNoKGhhc2gpIHtcclxuXHQgICAgdGhpcy5hY2NlcHRBcnJheShoYXNoLnBhaXJzKTtcclxuXHQgIH0sXHJcblx0ICBIYXNoUGFpcjogZnVuY3Rpb24gSGFzaFBhaXIocGFpcikge1xyXG5cdCAgICB0aGlzLmFjY2VwdFJlcXVpcmVkKHBhaXIsICd2YWx1ZScpO1xyXG5cdCAgfVxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHZpc2l0U3ViRXhwcmVzc2lvbihtdXN0YWNoZSkge1xyXG5cdCAgdGhpcy5hY2NlcHRSZXF1aXJlZChtdXN0YWNoZSwgJ3BhdGgnKTtcclxuXHQgIHRoaXMuYWNjZXB0QXJyYXkobXVzdGFjaGUucGFyYW1zKTtcclxuXHQgIHRoaXMuYWNjZXB0S2V5KG11c3RhY2hlLCAnaGFzaCcpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiB2aXNpdEJsb2NrKGJsb2NrKSB7XHJcblx0ICB2aXNpdFN1YkV4cHJlc3Npb24uY2FsbCh0aGlzLCBibG9jayk7XHJcblxyXG5cdCAgdGhpcy5hY2NlcHRLZXkoYmxvY2ssICdwcm9ncmFtJyk7XHJcblx0ICB0aGlzLmFjY2VwdEtleShibG9jaywgJ2ludmVyc2UnKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gdmlzaXRQYXJ0aWFsKHBhcnRpYWwpIHtcclxuXHQgIHRoaXMuYWNjZXB0UmVxdWlyZWQocGFydGlhbCwgJ25hbWUnKTtcclxuXHQgIHRoaXMuYWNjZXB0QXJyYXkocGFydGlhbC5wYXJhbXMpO1xyXG5cdCAgdGhpcy5hY2NlcHRLZXkocGFydGlhbCwgJ2hhc2gnKTtcclxuXHR9XHJcblxyXG5cdGV4cG9ydHNbJ2RlZmF1bHQnXSA9IFZpc2l0b3I7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cdGV4cG9ydHMuU291cmNlTG9jYXRpb24gPSBTb3VyY2VMb2NhdGlvbjtcclxuXHRleHBvcnRzLmlkID0gaWQ7XHJcblx0ZXhwb3J0cy5zdHJpcEZsYWdzID0gc3RyaXBGbGFncztcclxuXHRleHBvcnRzLnN0cmlwQ29tbWVudCA9IHN0cmlwQ29tbWVudDtcclxuXHRleHBvcnRzLnByZXBhcmVQYXRoID0gcHJlcGFyZVBhdGg7XHJcblx0ZXhwb3J0cy5wcmVwYXJlTXVzdGFjaGUgPSBwcmVwYXJlTXVzdGFjaGU7XHJcblx0ZXhwb3J0cy5wcmVwYXJlUmF3QmxvY2sgPSBwcmVwYXJlUmF3QmxvY2s7XHJcblx0ZXhwb3J0cy5wcmVwYXJlQmxvY2sgPSBwcmVwYXJlQmxvY2s7XHJcblx0ZXhwb3J0cy5wcmVwYXJlUHJvZ3JhbSA9IHByZXBhcmVQcm9ncmFtO1xyXG5cdGV4cG9ydHMucHJlcGFyZVBhcnRpYWxCbG9jayA9IHByZXBhcmVQYXJ0aWFsQmxvY2s7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcblx0dmFyIF9leGNlcHRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXhjZXB0aW9uKTtcclxuXHJcblx0ZnVuY3Rpb24gdmFsaWRhdGVDbG9zZShvcGVuLCBjbG9zZSkge1xyXG5cdCAgY2xvc2UgPSBjbG9zZS5wYXRoID8gY2xvc2UucGF0aC5vcmlnaW5hbCA6IGNsb3NlO1xyXG5cclxuXHQgIGlmIChvcGVuLnBhdGgub3JpZ2luYWwgIT09IGNsb3NlKSB7XHJcblx0ICAgIHZhciBlcnJvck5vZGUgPSB7IGxvYzogb3Blbi5wYXRoLmxvYyB9O1xyXG5cclxuXHQgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10ob3Blbi5wYXRoLm9yaWdpbmFsICsgXCIgZG9lc24ndCBtYXRjaCBcIiArIGNsb3NlLCBlcnJvck5vZGUpO1xyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gU291cmNlTG9jYXRpb24oc291cmNlLCBsb2NJbmZvKSB7XHJcblx0ICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuXHQgIHRoaXMuc3RhcnQgPSB7XHJcblx0ICAgIGxpbmU6IGxvY0luZm8uZmlyc3RfbGluZSxcclxuXHQgICAgY29sdW1uOiBsb2NJbmZvLmZpcnN0X2NvbHVtblxyXG5cdCAgfTtcclxuXHQgIHRoaXMuZW5kID0ge1xyXG5cdCAgICBsaW5lOiBsb2NJbmZvLmxhc3RfbGluZSxcclxuXHQgICAgY29sdW1uOiBsb2NJbmZvLmxhc3RfY29sdW1uXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaWQodG9rZW4pIHtcclxuXHQgIGlmICgvXlxcWy4qXFxdJC8udGVzdCh0b2tlbikpIHtcclxuXHQgICAgcmV0dXJuIHRva2VuLnN1YnN0cigxLCB0b2tlbi5sZW5ndGggLSAyKTtcclxuXHQgIH0gZWxzZSB7XHJcblx0ICAgIHJldHVybiB0b2tlbjtcclxuXHQgIH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHN0cmlwRmxhZ3Mob3BlbiwgY2xvc2UpIHtcclxuXHQgIHJldHVybiB7XHJcblx0ICAgIG9wZW46IG9wZW4uY2hhckF0KDIpID09PSAnficsXHJcblx0ICAgIGNsb3NlOiBjbG9zZS5jaGFyQXQoY2xvc2UubGVuZ3RoIC0gMykgPT09ICd+J1xyXG5cdCAgfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHN0cmlwQ29tbWVudChjb21tZW50KSB7XHJcblx0ICByZXR1cm4gY29tbWVudC5yZXBsYWNlKC9eXFx7XFx7fj9cXCEtPy0/LywgJycpLnJlcGxhY2UoLy0/LT9+P1xcfVxcfSQvLCAnJyk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVwYXJlUGF0aChkYXRhLCBwYXJ0cywgbG9jKSB7XHJcblx0ICBsb2MgPSB0aGlzLmxvY0luZm8obG9jKTtcclxuXHJcblx0ICB2YXIgb3JpZ2luYWwgPSBkYXRhID8gJ0AnIDogJycsXHJcblx0ICAgICAgZGlnID0gW10sXHJcblx0ICAgICAgZGVwdGggPSAwLFxyXG5cdCAgICAgIGRlcHRoU3RyaW5nID0gJyc7XHJcblxyXG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXS5wYXJ0LFxyXG5cclxuXHQgICAgLy8gSWYgd2UgaGF2ZSBbXSBzeW50YXggdGhlbiB3ZSBkbyBub3QgdHJlYXQgcGF0aCByZWZlcmVuY2VzIGFzIG9wZXJhdG9ycyxcclxuXHQgICAgLy8gaS5lLiBmb28uW3RoaXNdIHJlc29sdmVzIHRvIGFwcHJveGltYXRlbHkgY29udGV4dC5mb29bJ3RoaXMnXVxyXG5cdCAgICBpc0xpdGVyYWwgPSBwYXJ0c1tpXS5vcmlnaW5hbCAhPT0gcGFydDtcclxuXHQgICAgb3JpZ2luYWwgKz0gKHBhcnRzW2ldLnNlcGFyYXRvciB8fCAnJykgKyBwYXJ0O1xyXG5cclxuXHQgICAgaWYgKCFpc0xpdGVyYWwgJiYgKHBhcnQgPT09ICcuLicgfHwgcGFydCA9PT0gJy4nIHx8IHBhcnQgPT09ICd0aGlzJykpIHtcclxuXHQgICAgICBpZiAoZGlnLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdJbnZhbGlkIHBhdGg6ICcgKyBvcmlnaW5hbCwgeyBsb2M6IGxvYyB9KTtcclxuXHQgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcclxuXHQgICAgICAgIGRlcHRoKys7XHJcblx0ICAgICAgICBkZXB0aFN0cmluZyArPSAnLi4vJztcclxuXHQgICAgICB9XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgZGlnLnB1c2gocGFydCk7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB0eXBlOiAnUGF0aEV4cHJlc3Npb24nLFxyXG5cdCAgICBkYXRhOiBkYXRhLFxyXG5cdCAgICBkZXB0aDogZGVwdGgsXHJcblx0ICAgIHBhcnRzOiBkaWcsXHJcblx0ICAgIG9yaWdpbmFsOiBvcmlnaW5hbCxcclxuXHQgICAgbG9jOiBsb2NcclxuXHQgIH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVwYXJlTXVzdGFjaGUocGF0aCwgcGFyYW1zLCBoYXNoLCBvcGVuLCBzdHJpcCwgbG9jSW5mbykge1xyXG5cdCAgLy8gTXVzdCB1c2UgY2hhckF0IHRvIHN1cHBvcnQgSUUgcHJlLTEwXHJcblx0ICB2YXIgZXNjYXBlRmxhZyA9IG9wZW4uY2hhckF0KDMpIHx8IG9wZW4uY2hhckF0KDIpLFxyXG5cdCAgICAgIGVzY2FwZWQgPSBlc2NhcGVGbGFnICE9PSAneycgJiYgZXNjYXBlRmxhZyAhPT0gJyYnO1xyXG5cclxuXHQgIHZhciBkZWNvcmF0b3IgPSAvXFwqLy50ZXN0KG9wZW4pO1xyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgdHlwZTogZGVjb3JhdG9yID8gJ0RlY29yYXRvcicgOiAnTXVzdGFjaGVTdGF0ZW1lbnQnLFxyXG5cdCAgICBwYXRoOiBwYXRoLFxyXG5cdCAgICBwYXJhbXM6IHBhcmFtcyxcclxuXHQgICAgaGFzaDogaGFzaCxcclxuXHQgICAgZXNjYXBlZDogZXNjYXBlZCxcclxuXHQgICAgc3RyaXA6IHN0cmlwLFxyXG5cdCAgICBsb2M6IHRoaXMubG9jSW5mbyhsb2NJbmZvKVxyXG5cdCAgfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVSYXdCbG9jayhvcGVuUmF3QmxvY2ssIGNvbnRlbnRzLCBjbG9zZSwgbG9jSW5mbykge1xyXG5cdCAgdmFsaWRhdGVDbG9zZShvcGVuUmF3QmxvY2ssIGNsb3NlKTtcclxuXHJcblx0ICBsb2NJbmZvID0gdGhpcy5sb2NJbmZvKGxvY0luZm8pO1xyXG5cdCAgdmFyIHByb2dyYW0gPSB7XHJcblx0ICAgIHR5cGU6ICdQcm9ncmFtJyxcclxuXHQgICAgYm9keTogY29udGVudHMsXHJcblx0ICAgIHN0cmlwOiB7fSxcclxuXHQgICAgbG9jOiBsb2NJbmZvXHJcblx0ICB9O1xyXG5cclxuXHQgIHJldHVybiB7XHJcblx0ICAgIHR5cGU6ICdCbG9ja1N0YXRlbWVudCcsXHJcblx0ICAgIHBhdGg6IG9wZW5SYXdCbG9jay5wYXRoLFxyXG5cdCAgICBwYXJhbXM6IG9wZW5SYXdCbG9jay5wYXJhbXMsXHJcblx0ICAgIGhhc2g6IG9wZW5SYXdCbG9jay5oYXNoLFxyXG5cdCAgICBwcm9ncmFtOiBwcm9ncmFtLFxyXG5cdCAgICBvcGVuU3RyaXA6IHt9LFxyXG5cdCAgICBpbnZlcnNlU3RyaXA6IHt9LFxyXG5cdCAgICBjbG9zZVN0cmlwOiB7fSxcclxuXHQgICAgbG9jOiBsb2NJbmZvXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcHJlcGFyZUJsb2NrKG9wZW5CbG9jaywgcHJvZ3JhbSwgaW52ZXJzZUFuZFByb2dyYW0sIGNsb3NlLCBpbnZlcnRlZCwgbG9jSW5mbykge1xyXG5cdCAgaWYgKGNsb3NlICYmIGNsb3NlLnBhdGgpIHtcclxuXHQgICAgdmFsaWRhdGVDbG9zZShvcGVuQmxvY2ssIGNsb3NlKTtcclxuXHQgIH1cclxuXHJcblx0ICB2YXIgZGVjb3JhdG9yID0gL1xcKi8udGVzdChvcGVuQmxvY2sub3Blbik7XHJcblxyXG5cdCAgcHJvZ3JhbS5ibG9ja1BhcmFtcyA9IG9wZW5CbG9jay5ibG9ja1BhcmFtcztcclxuXHJcblx0ICB2YXIgaW52ZXJzZSA9IHVuZGVmaW5lZCxcclxuXHQgICAgICBpbnZlcnNlU3RyaXAgPSB1bmRlZmluZWQ7XHJcblxyXG5cdCAgaWYgKGludmVyc2VBbmRQcm9ncmFtKSB7XHJcblx0ICAgIGlmIChkZWNvcmF0b3IpIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnVW5leHBlY3RlZCBpbnZlcnNlIGJsb2NrIG9uIGRlY29yYXRvcicsIGludmVyc2VBbmRQcm9ncmFtKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKGludmVyc2VBbmRQcm9ncmFtLmNoYWluKSB7XHJcblx0ICAgICAgaW52ZXJzZUFuZFByb2dyYW0ucHJvZ3JhbS5ib2R5WzBdLmNsb3NlU3RyaXAgPSBjbG9zZS5zdHJpcDtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaW52ZXJzZVN0cmlwID0gaW52ZXJzZUFuZFByb2dyYW0uc3RyaXA7XHJcblx0ICAgIGludmVyc2UgPSBpbnZlcnNlQW5kUHJvZ3JhbS5wcm9ncmFtO1xyXG5cdCAgfVxyXG5cclxuXHQgIGlmIChpbnZlcnRlZCkge1xyXG5cdCAgICBpbnZlcnRlZCA9IGludmVyc2U7XHJcblx0ICAgIGludmVyc2UgPSBwcm9ncmFtO1xyXG5cdCAgICBwcm9ncmFtID0gaW52ZXJ0ZWQ7XHJcblx0ICB9XHJcblxyXG5cdCAgcmV0dXJuIHtcclxuXHQgICAgdHlwZTogZGVjb3JhdG9yID8gJ0RlY29yYXRvckJsb2NrJyA6ICdCbG9ja1N0YXRlbWVudCcsXHJcblx0ICAgIHBhdGg6IG9wZW5CbG9jay5wYXRoLFxyXG5cdCAgICBwYXJhbXM6IG9wZW5CbG9jay5wYXJhbXMsXHJcblx0ICAgIGhhc2g6IG9wZW5CbG9jay5oYXNoLFxyXG5cdCAgICBwcm9ncmFtOiBwcm9ncmFtLFxyXG5cdCAgICBpbnZlcnNlOiBpbnZlcnNlLFxyXG5cdCAgICBvcGVuU3RyaXA6IG9wZW5CbG9jay5zdHJpcCxcclxuXHQgICAgaW52ZXJzZVN0cmlwOiBpbnZlcnNlU3RyaXAsXHJcblx0ICAgIGNsb3NlU3RyaXA6IGNsb3NlICYmIGNsb3NlLnN0cmlwLFxyXG5cdCAgICBsb2M6IHRoaXMubG9jSW5mbyhsb2NJbmZvKVxyXG5cdCAgfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmVQcm9ncmFtKHN0YXRlbWVudHMsIGxvYykge1xyXG5cdCAgaWYgKCFsb2MgJiYgc3RhdGVtZW50cy5sZW5ndGgpIHtcclxuXHQgICAgdmFyIGZpcnN0TG9jID0gc3RhdGVtZW50c1swXS5sb2MsXHJcblx0ICAgICAgICBsYXN0TG9jID0gc3RhdGVtZW50c1tzdGF0ZW1lbnRzLmxlbmd0aCAtIDFdLmxvYztcclxuXHJcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcblx0ICAgIGlmIChmaXJzdExvYyAmJiBsYXN0TG9jKSB7XHJcblx0ICAgICAgbG9jID0ge1xyXG5cdCAgICAgICAgc291cmNlOiBmaXJzdExvYy5zb3VyY2UsXHJcblx0ICAgICAgICBzdGFydDoge1xyXG5cdCAgICAgICAgICBsaW5lOiBmaXJzdExvYy5zdGFydC5saW5lLFxyXG5cdCAgICAgICAgICBjb2x1bW46IGZpcnN0TG9jLnN0YXJ0LmNvbHVtblxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGVuZDoge1xyXG5cdCAgICAgICAgICBsaW5lOiBsYXN0TG9jLmVuZC5saW5lLFxyXG5cdCAgICAgICAgICBjb2x1bW46IGxhc3RMb2MuZW5kLmNvbHVtblxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH07XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB0eXBlOiAnUHJvZ3JhbScsXHJcblx0ICAgIGJvZHk6IHN0YXRlbWVudHMsXHJcblx0ICAgIHN0cmlwOiB7fSxcclxuXHQgICAgbG9jOiBsb2NcclxuXHQgIH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcmVwYXJlUGFydGlhbEJsb2NrKG9wZW4sIHByb2dyYW0sIGNsb3NlLCBsb2NJbmZvKSB7XHJcblx0ICB2YWxpZGF0ZUNsb3NlKG9wZW4sIGNsb3NlKTtcclxuXHJcblx0ICByZXR1cm4ge1xyXG5cdCAgICB0eXBlOiAnUGFydGlhbEJsb2NrU3RhdGVtZW50JyxcclxuXHQgICAgbmFtZTogb3Blbi5wYXRoLFxyXG5cdCAgICBwYXJhbXM6IG9wZW4ucGFyYW1zLFxyXG5cdCAgICBoYXNoOiBvcGVuLmhhc2gsXHJcblx0ICAgIHByb2dyYW06IHByb2dyYW0sXHJcblx0ICAgIG9wZW5TdHJpcDogb3Blbi5zdHJpcCxcclxuXHQgICAgY2xvc2VTdHJpcDogY2xvc2UgJiYgY2xvc2Uuc3RyaXAsXHJcblx0ICAgIGxvYzogdGhpcy5sb2NJbmZvKGxvY0luZm8pXHJcblx0ICB9O1xyXG5cdH1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cdC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi9cclxuXHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cclxuXHR2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMSlbJ2RlZmF1bHQnXTtcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHRleHBvcnRzLkNvbXBpbGVyID0gQ29tcGlsZXI7XHJcblx0ZXhwb3J0cy5wcmVjb21waWxlID0gcHJlY29tcGlsZTtcclxuXHRleHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHR2YXIgX2FzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG5cclxuXHR2YXIgX2FzdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3QpO1xyXG5cclxuXHR2YXIgc2xpY2UgPSBbXS5zbGljZTtcclxuXHJcblx0ZnVuY3Rpb24gQ29tcGlsZXIoKSB7fVxyXG5cclxuXHQvLyB0aGUgZm91bmRIZWxwZXIgcmVnaXN0ZXIgd2lsbCBkaXNhbWJpZ3VhdGUgaGVscGVyIGxvb2t1cCBmcm9tIGZpbmRpbmcgYVxyXG5cdC8vIGZ1bmN0aW9uIGluIGEgY29udGV4dC4gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIG11c3RhY2hlIGNvbXBhdGliaWxpdHksIHdoaWNoXHJcblx0Ly8gcmVxdWlyZXMgdGhhdCBjb250ZXh0IGZ1bmN0aW9ucyBpbiBibG9ja3MgYXJlIGV2YWx1YXRlZCBieSBibG9ja0hlbHBlck1pc3NpbmcsXHJcblx0Ly8gYW5kIHRoZW4gcHJvY2VlZCBhcyBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIHdhcyBwcm92aWRlZCB0byBibG9ja0hlbHBlck1pc3NpbmcuXHJcblxyXG5cdENvbXBpbGVyLnByb3RvdHlwZSA9IHtcclxuXHQgIGNvbXBpbGVyOiBDb21waWxlcixcclxuXHJcblx0ICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG5cdCAgICB2YXIgbGVuID0gdGhpcy5vcGNvZGVzLmxlbmd0aDtcclxuXHQgICAgaWYgKG90aGVyLm9wY29kZXMubGVuZ3RoICE9PSBsZW4pIHtcclxuXHQgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICB2YXIgb3Bjb2RlID0gdGhpcy5vcGNvZGVzW2ldLFxyXG5cdCAgICAgICAgICBvdGhlck9wY29kZSA9IG90aGVyLm9wY29kZXNbaV07XHJcblx0ICAgICAgaWYgKG9wY29kZS5vcGNvZGUgIT09IG90aGVyT3Bjb2RlLm9wY29kZSB8fCAhYXJnRXF1YWxzKG9wY29kZS5hcmdzLCBvdGhlck9wY29kZS5hcmdzKSkge1xyXG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgLy8gV2Uga25vdyB0aGF0IGxlbmd0aCBpcyB0aGUgc2FtZSBiZXR3ZWVuIHRoZSB0d28gYXJyYXlzIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgdGllZFxyXG5cdCAgICAvLyB0byB0aGUgb3Bjb2RlIGJlaGF2aW9yIGFib3ZlLlxyXG5cdCAgICBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIGlmICghdGhpcy5jaGlsZHJlbltpXS5lcXVhbHMob3RoZXIuY2hpbGRyZW5baV0pKSB7XHJcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH0sXHJcblxyXG5cdCAgZ3VpZDogMCxcclxuXHJcblx0ICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHByb2dyYW0sIG9wdGlvbnMpIHtcclxuXHQgICAgdGhpcy5zb3VyY2VOb2RlID0gW107XHJcblx0ICAgIHRoaXMub3Bjb2RlcyA9IFtdO1xyXG5cdCAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcblx0ICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0ICAgIHRoaXMuc3RyaW5nUGFyYW1zID0gb3B0aW9ucy5zdHJpbmdQYXJhbXM7XHJcblx0ICAgIHRoaXMudHJhY2tJZHMgPSBvcHRpb25zLnRyYWNrSWRzO1xyXG5cclxuXHQgICAgb3B0aW9ucy5ibG9ja1BhcmFtcyA9IG9wdGlvbnMuYmxvY2tQYXJhbXMgfHwgW107XHJcblxyXG5cdCAgICAvLyBUaGVzZSBjaGFuZ2VzIHdpbGwgcHJvcGFnYXRlIHRvIHRoZSBvdGhlciBjb21waWxlciBjb21wb25lbnRzXHJcblx0ICAgIHZhciBrbm93bkhlbHBlcnMgPSBvcHRpb25zLmtub3duSGVscGVycztcclxuXHQgICAgb3B0aW9ucy5rbm93bkhlbHBlcnMgPSB7XHJcblx0ICAgICAgJ2hlbHBlck1pc3NpbmcnOiB0cnVlLFxyXG5cdCAgICAgICdibG9ja0hlbHBlck1pc3NpbmcnOiB0cnVlLFxyXG5cdCAgICAgICdlYWNoJzogdHJ1ZSxcclxuXHQgICAgICAnaWYnOiB0cnVlLFxyXG5cdCAgICAgICd1bmxlc3MnOiB0cnVlLFxyXG5cdCAgICAgICd3aXRoJzogdHJ1ZSxcclxuXHQgICAgICAnbG9nJzogdHJ1ZSxcclxuXHQgICAgICAnbG9va3VwJzogdHJ1ZVxyXG5cdCAgICB9O1xyXG5cdCAgICBpZiAoa25vd25IZWxwZXJzKSB7XHJcblx0ICAgICAgZm9yICh2YXIgX25hbWUgaW4ga25vd25IZWxwZXJzKSB7XHJcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG5cdCAgICAgICAgaWYgKF9uYW1lIGluIGtub3duSGVscGVycykge1xyXG5cdCAgICAgICAgICB0aGlzLm9wdGlvbnMua25vd25IZWxwZXJzW19uYW1lXSA9IGtub3duSGVscGVyc1tfbmFtZV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICByZXR1cm4gdGhpcy5hY2NlcHQocHJvZ3JhbSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIGNvbXBpbGVQcm9ncmFtOiBmdW5jdGlvbiBjb21waWxlUHJvZ3JhbShwcm9ncmFtKSB7XHJcblx0ICAgIHZhciBjaGlsZENvbXBpbGVyID0gbmV3IHRoaXMuY29tcGlsZXIoKSxcclxuXHQgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxyXG5cdCAgICByZXN1bHQgPSBjaGlsZENvbXBpbGVyLmNvbXBpbGUocHJvZ3JhbSwgdGhpcy5vcHRpb25zKSxcclxuXHQgICAgICAgIGd1aWQgPSB0aGlzLmd1aWQrKztcclxuXHJcblx0ICAgIHRoaXMudXNlUGFydGlhbCA9IHRoaXMudXNlUGFydGlhbCB8fCByZXN1bHQudXNlUGFydGlhbDtcclxuXHJcblx0ICAgIHRoaXMuY2hpbGRyZW5bZ3VpZF0gPSByZXN1bHQ7XHJcblx0ICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgcmVzdWx0LnVzZURlcHRocztcclxuXHJcblx0ICAgIHJldHVybiBndWlkO1xyXG5cdCAgfSxcclxuXHJcblx0ICBhY2NlcHQ6IGZ1bmN0aW9uIGFjY2VwdChub2RlKSB7XHJcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBTYW5pdHkgY29kZSAqL1xyXG5cdCAgICBpZiAoIXRoaXNbbm9kZS50eXBlXSkge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdVbmtub3duIHR5cGU6ICcgKyBub2RlLnR5cGUsIG5vZGUpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLnNvdXJjZU5vZGUudW5zaGlmdChub2RlKTtcclxuXHQgICAgdmFyIHJldCA9IHRoaXNbbm9kZS50eXBlXShub2RlKTtcclxuXHQgICAgdGhpcy5zb3VyY2VOb2RlLnNoaWZ0KCk7XHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9LFxyXG5cclxuXHQgIFByb2dyYW06IGZ1bmN0aW9uIFByb2dyYW0ocHJvZ3JhbSkge1xyXG5cdCAgICB0aGlzLm9wdGlvbnMuYmxvY2tQYXJhbXMudW5zaGlmdChwcm9ncmFtLmJsb2NrUGFyYW1zKTtcclxuXHJcblx0ICAgIHZhciBib2R5ID0gcHJvZ3JhbS5ib2R5LFxyXG5cdCAgICAgICAgYm9keUxlbmd0aCA9IGJvZHkubGVuZ3RoO1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHlMZW5ndGg7IGkrKykge1xyXG5cdCAgICAgIHRoaXMuYWNjZXB0KGJvZHlbaV0pO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLm9wdGlvbnMuYmxvY2tQYXJhbXMuc2hpZnQoKTtcclxuXHJcblx0ICAgIHRoaXMuaXNTaW1wbGUgPSBib2R5TGVuZ3RoID09PSAxO1xyXG5cdCAgICB0aGlzLmJsb2NrUGFyYW1zID0gcHJvZ3JhbS5ibG9ja1BhcmFtcyA/IHByb2dyYW0uYmxvY2tQYXJhbXMubGVuZ3RoIDogMDtcclxuXHJcblx0ICAgIHJldHVybiB0aGlzO1xyXG5cdCAgfSxcclxuXHJcblx0ICBCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gQmxvY2tTdGF0ZW1lbnQoYmxvY2spIHtcclxuXHQgICAgdHJhbnNmb3JtTGl0ZXJhbFRvUGF0aChibG9jayk7XHJcblxyXG5cdCAgICB2YXIgcHJvZ3JhbSA9IGJsb2NrLnByb2dyYW0sXHJcblx0ICAgICAgICBpbnZlcnNlID0gYmxvY2suaW52ZXJzZTtcclxuXHJcblx0ICAgIHByb2dyYW0gPSBwcm9ncmFtICYmIHRoaXMuY29tcGlsZVByb2dyYW0ocHJvZ3JhbSk7XHJcblx0ICAgIGludmVyc2UgPSBpbnZlcnNlICYmIHRoaXMuY29tcGlsZVByb2dyYW0oaW52ZXJzZSk7XHJcblxyXG5cdCAgICB2YXIgdHlwZSA9IHRoaXMuY2xhc3NpZnlTZXhwcihibG9jayk7XHJcblxyXG5cdCAgICBpZiAodHlwZSA9PT0gJ2hlbHBlcicpIHtcclxuXHQgICAgICB0aGlzLmhlbHBlclNleHByKGJsb2NrLCBwcm9ncmFtLCBpbnZlcnNlKTtcclxuXHQgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc2ltcGxlJykge1xyXG5cdCAgICAgIHRoaXMuc2ltcGxlU2V4cHIoYmxvY2spO1xyXG5cclxuXHQgICAgICAvLyBub3cgdGhhdCB0aGUgc2ltcGxlIG11c3RhY2hlIGlzIHJlc29sdmVkLCB3ZSBuZWVkIHRvXHJcblx0ICAgICAgLy8gZXZhbHVhdGUgaXQgYnkgZXhlY3V0aW5nIGBibG9ja0hlbHBlck1pc3NpbmdgXHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgaW52ZXJzZSk7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2VtcHR5SGFzaCcpO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdibG9ja1ZhbHVlJywgYmxvY2sucGF0aC5vcmlnaW5hbCk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5hbWJpZ3VvdXNTZXhwcihibG9jaywgcHJvZ3JhbSwgaW52ZXJzZSk7XHJcblxyXG5cdCAgICAgIC8vIG5vdyB0aGF0IHRoZSBzaW1wbGUgbXVzdGFjaGUgaXMgcmVzb2x2ZWQsIHdlIG5lZWQgdG9cclxuXHQgICAgICAvLyBldmFsdWF0ZSBpdCBieSBleGVjdXRpbmcgYGJsb2NrSGVscGVyTWlzc2luZ2BcclxuXHQgICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBwcm9ncmFtKTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnZW1wdHlIYXNoJyk7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2FtYmlndW91c0Jsb2NrVmFsdWUnKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5vcGNvZGUoJ2FwcGVuZCcpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBEZWNvcmF0b3JCbG9jazogZnVuY3Rpb24gRGVjb3JhdG9yQmxvY2soZGVjb3JhdG9yKSB7XHJcblx0ICAgIHZhciBwcm9ncmFtID0gZGVjb3JhdG9yLnByb2dyYW0gJiYgdGhpcy5jb21waWxlUHJvZ3JhbShkZWNvcmF0b3IucHJvZ3JhbSk7XHJcblx0ICAgIHZhciBwYXJhbXMgPSB0aGlzLnNldHVwRnVsbE11c3RhY2hlUGFyYW1zKGRlY29yYXRvciwgcHJvZ3JhbSwgdW5kZWZpbmVkKSxcclxuXHQgICAgICAgIHBhdGggPSBkZWNvcmF0b3IucGF0aDtcclxuXHJcblx0ICAgIHRoaXMudXNlRGVjb3JhdG9ycyA9IHRydWU7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdyZWdpc3RlckRlY29yYXRvcicsIHBhcmFtcy5sZW5ndGgsIHBhdGgub3JpZ2luYWwpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBQYXJ0aWFsU3RhdGVtZW50OiBmdW5jdGlvbiBQYXJ0aWFsU3RhdGVtZW50KHBhcnRpYWwpIHtcclxuXHQgICAgdGhpcy51c2VQYXJ0aWFsID0gdHJ1ZTtcclxuXHJcblx0ICAgIHZhciBwcm9ncmFtID0gcGFydGlhbC5wcm9ncmFtO1xyXG5cdCAgICBpZiAocHJvZ3JhbSkge1xyXG5cdCAgICAgIHByb2dyYW0gPSB0aGlzLmNvbXBpbGVQcm9ncmFtKHBhcnRpYWwucHJvZ3JhbSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBwYXJhbXMgPSBwYXJ0aWFsLnBhcmFtcztcclxuXHQgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAxKSB7XHJcblx0ICAgICAgdGhyb3cgbmV3IF9leGNlcHRpb24yWydkZWZhdWx0J10oJ1Vuc3VwcG9ydGVkIG51bWJlciBvZiBwYXJ0aWFsIGFyZ3VtZW50czogJyArIHBhcmFtcy5sZW5ndGgsIHBhcnRpYWwpO1xyXG5cdCAgICB9IGVsc2UgaWYgKCFwYXJhbXMubGVuZ3RoKSB7XHJcblx0ICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHBsaWNpdFBhcnRpYWxDb250ZXh0KSB7XHJcblx0ICAgICAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCAndW5kZWZpbmVkJyk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHBhcmFtcy5wdXNoKHsgdHlwZTogJ1BhdGhFeHByZXNzaW9uJywgcGFydHM6IFtdLCBkZXB0aDogMCB9KTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBwYXJ0aWFsTmFtZSA9IHBhcnRpYWwubmFtZS5vcmlnaW5hbCxcclxuXHQgICAgICAgIGlzRHluYW1pYyA9IHBhcnRpYWwubmFtZS50eXBlID09PSAnU3ViRXhwcmVzc2lvbic7XHJcblx0ICAgIGlmIChpc0R5bmFtaWMpIHtcclxuXHQgICAgICB0aGlzLmFjY2VwdChwYXJ0aWFsLm5hbWUpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLnNldHVwRnVsbE11c3RhY2hlUGFyYW1zKHBhcnRpYWwsIHByb2dyYW0sIHVuZGVmaW5lZCwgdHJ1ZSk7XHJcblxyXG5cdCAgICB2YXIgaW5kZW50ID0gcGFydGlhbC5pbmRlbnQgfHwgJyc7XHJcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMucHJldmVudEluZGVudCAmJiBpbmRlbnQpIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnYXBwZW5kQ29udGVudCcsIGluZGVudCk7XHJcblx0ICAgICAgaW5kZW50ID0gJyc7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMub3Bjb2RlKCdpbnZva2VQYXJ0aWFsJywgaXNEeW5hbWljLCBwYXJ0aWFsTmFtZSwgaW5kZW50KTtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ2FwcGVuZCcpO1xyXG5cdCAgfSxcclxuXHQgIFBhcnRpYWxCbG9ja1N0YXRlbWVudDogZnVuY3Rpb24gUGFydGlhbEJsb2NrU3RhdGVtZW50KHBhcnRpYWxCbG9jaykge1xyXG5cdCAgICB0aGlzLlBhcnRpYWxTdGF0ZW1lbnQocGFydGlhbEJsb2NrKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgTXVzdGFjaGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIE11c3RhY2hlU3RhdGVtZW50KG11c3RhY2hlKSB7XHJcblx0ICAgIHRoaXMuU3ViRXhwcmVzc2lvbihtdXN0YWNoZSk7XHJcblxyXG5cdCAgICBpZiAobXVzdGFjaGUuZXNjYXBlZCAmJiAhdGhpcy5vcHRpb25zLm5vRXNjYXBlKSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2FwcGVuZEVzY2FwZWQnKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnYXBwZW5kJyk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblx0ICBEZWNvcmF0b3I6IGZ1bmN0aW9uIERlY29yYXRvcihkZWNvcmF0b3IpIHtcclxuXHQgICAgdGhpcy5EZWNvcmF0b3JCbG9jayhkZWNvcmF0b3IpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBDb250ZW50U3RhdGVtZW50OiBmdW5jdGlvbiBDb250ZW50U3RhdGVtZW50KGNvbnRlbnQpIHtcclxuXHQgICAgaWYgKGNvbnRlbnQudmFsdWUpIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnYXBwZW5kQ29udGVudCcsIGNvbnRlbnQudmFsdWUpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIENvbW1lbnRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIENvbW1lbnRTdGF0ZW1lbnQoKSB7fSxcclxuXHJcblx0ICBTdWJFeHByZXNzaW9uOiBmdW5jdGlvbiBTdWJFeHByZXNzaW9uKHNleHByKSB7XHJcblx0ICAgIHRyYW5zZm9ybUxpdGVyYWxUb1BhdGgoc2V4cHIpO1xyXG5cdCAgICB2YXIgdHlwZSA9IHRoaXMuY2xhc3NpZnlTZXhwcihzZXhwcik7XHJcblxyXG5cdCAgICBpZiAodHlwZSA9PT0gJ3NpbXBsZScpIHtcclxuXHQgICAgICB0aGlzLnNpbXBsZVNleHByKHNleHByKTtcclxuXHQgICAgfSBlbHNlIGlmICh0eXBlID09PSAnaGVscGVyJykge1xyXG5cdCAgICAgIHRoaXMuaGVscGVyU2V4cHIoc2V4cHIpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMuYW1iaWd1b3VzU2V4cHIoc2V4cHIpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cdCAgYW1iaWd1b3VzU2V4cHI6IGZ1bmN0aW9uIGFtYmlndW91c1NleHByKHNleHByLCBwcm9ncmFtLCBpbnZlcnNlKSB7XHJcblx0ICAgIHZhciBwYXRoID0gc2V4cHIucGF0aCxcclxuXHQgICAgICAgIG5hbWUgPSBwYXRoLnBhcnRzWzBdLFxyXG5cdCAgICAgICAgaXNCbG9jayA9IHByb2dyYW0gIT0gbnVsbCB8fCBpbnZlcnNlICE9IG51bGw7XHJcblxyXG5cdCAgICB0aGlzLm9wY29kZSgnZ2V0Q29udGV4dCcsIHBhdGguZGVwdGgpO1xyXG5cclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hQcm9ncmFtJywgcHJvZ3JhbSk7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIGludmVyc2UpO1xyXG5cclxuXHQgICAgcGF0aC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICB0aGlzLmFjY2VwdChwYXRoKTtcclxuXHJcblx0ICAgIHRoaXMub3Bjb2RlKCdpbnZva2VBbWJpZ3VvdXMnLCBuYW1lLCBpc0Jsb2NrKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgc2ltcGxlU2V4cHI6IGZ1bmN0aW9uIHNpbXBsZVNleHByKHNleHByKSB7XHJcblx0ICAgIHZhciBwYXRoID0gc2V4cHIucGF0aDtcclxuXHQgICAgcGF0aC5zdHJpY3QgPSB0cnVlO1xyXG5cdCAgICB0aGlzLmFjY2VwdChwYXRoKTtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3Jlc29sdmVQb3NzaWJsZUxhbWJkYScpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBoZWxwZXJTZXhwcjogZnVuY3Rpb24gaGVscGVyU2V4cHIoc2V4cHIsIHByb2dyYW0sIGludmVyc2UpIHtcclxuXHQgICAgdmFyIHBhcmFtcyA9IHRoaXMuc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXMoc2V4cHIsIHByb2dyYW0sIGludmVyc2UpLFxyXG5cdCAgICAgICAgcGF0aCA9IHNleHByLnBhdGgsXHJcblx0ICAgICAgICBuYW1lID0gcGF0aC5wYXJ0c1swXTtcclxuXHJcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMua25vd25IZWxwZXJzW25hbWVdKSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2ludm9rZUtub3duSGVscGVyJywgcGFyYW1zLmxlbmd0aCwgbmFtZSk7XHJcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmtub3duSGVscGVyc09ubHkpIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnWW91IHNwZWNpZmllZCBrbm93bkhlbHBlcnNPbmx5LCBidXQgdXNlZCB0aGUgdW5rbm93biBoZWxwZXIgJyArIG5hbWUsIHNleHByKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICBwYXRoLnN0cmljdCA9IHRydWU7XHJcblx0ICAgICAgcGF0aC5mYWxzeSA9IHRydWU7XHJcblxyXG5cdCAgICAgIHRoaXMuYWNjZXB0KHBhdGgpO1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdpbnZva2VIZWxwZXInLCBwYXJhbXMubGVuZ3RoLCBwYXRoLm9yaWdpbmFsLCBfYXN0MlsnZGVmYXVsdCddLmhlbHBlcnMuc2ltcGxlSWQocGF0aCkpO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIFBhdGhFeHByZXNzaW9uOiBmdW5jdGlvbiBQYXRoRXhwcmVzc2lvbihwYXRoKSB7XHJcblx0ICAgIHRoaXMuYWRkRGVwdGgocGF0aC5kZXB0aCk7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdnZXRDb250ZXh0JywgcGF0aC5kZXB0aCk7XHJcblxyXG5cdCAgICB2YXIgbmFtZSA9IHBhdGgucGFydHNbMF0sXHJcblx0ICAgICAgICBzY29wZWQgPSBfYXN0MlsnZGVmYXVsdCddLmhlbHBlcnMuc2NvcGVkSWQocGF0aCksXHJcblx0ICAgICAgICBibG9ja1BhcmFtSWQgPSAhcGF0aC5kZXB0aCAmJiAhc2NvcGVkICYmIHRoaXMuYmxvY2tQYXJhbUluZGV4KG5hbWUpO1xyXG5cclxuXHQgICAgaWYgKGJsb2NrUGFyYW1JZCkge1xyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdsb29rdXBCbG9ja1BhcmFtJywgYmxvY2tQYXJhbUlkLCBwYXRoLnBhcnRzKTtcclxuXHQgICAgfSBlbHNlIGlmICghbmFtZSkge1xyXG5cdCAgICAgIC8vIENvbnRleHQgcmVmZXJlbmNlLCBpLmUuIGB7e2ZvbyAufX1gIG9yIGB7e2ZvbyAuLn19YFxyXG5cdCAgICAgIHRoaXMub3Bjb2RlKCdwdXNoQ29udGV4dCcpO1xyXG5cdCAgICB9IGVsc2UgaWYgKHBhdGguZGF0YSkge1xyXG5cdCAgICAgIHRoaXMub3B0aW9ucy5kYXRhID0gdHJ1ZTtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnbG9va3VwRGF0YScsIHBhdGguZGVwdGgsIHBhdGgucGFydHMsIHBhdGguc3RyaWN0KTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLm9wY29kZSgnbG9va3VwT25Db250ZXh0JywgcGF0aC5wYXJ0cywgcGF0aC5mYWxzeSwgcGF0aC5zdHJpY3QsIHNjb3BlZCk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgU3RyaW5nTGl0ZXJhbDogZnVuY3Rpb24gU3RyaW5nTGl0ZXJhbChzdHJpbmcpIHtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hTdHJpbmcnLCBzdHJpbmcudmFsdWUpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBOdW1iZXJMaXRlcmFsOiBmdW5jdGlvbiBOdW1iZXJMaXRlcmFsKG51bWJlcikge1xyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCBudW1iZXIudmFsdWUpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBCb29sZWFuTGl0ZXJhbDogZnVuY3Rpb24gQm9vbGVhbkxpdGVyYWwoYm9vbCkge1xyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaExpdGVyYWwnLCBib29sLnZhbHVlKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgVW5kZWZpbmVkTGl0ZXJhbDogZnVuY3Rpb24gVW5kZWZpbmVkTGl0ZXJhbCgpIHtcclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hMaXRlcmFsJywgJ3VuZGVmaW5lZCcpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBOdWxsTGl0ZXJhbDogZnVuY3Rpb24gTnVsbExpdGVyYWwoKSB7XHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoTGl0ZXJhbCcsICdudWxsJyk7XHJcblx0ICB9LFxyXG5cclxuXHQgIEhhc2g6IGZ1bmN0aW9uIEhhc2goaGFzaCkge1xyXG5cdCAgICB2YXIgcGFpcnMgPSBoYXNoLnBhaXJzLFxyXG5cdCAgICAgICAgaSA9IDAsXHJcblx0ICAgICAgICBsID0gcGFpcnMubGVuZ3RoO1xyXG5cclxuXHQgICAgdGhpcy5vcGNvZGUoJ3B1c2hIYXNoJyk7XHJcblxyXG5cdCAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgIHRoaXMucHVzaFBhcmFtKHBhaXJzW2ldLnZhbHVlKTtcclxuXHQgICAgfVxyXG5cdCAgICB3aGlsZSAoaS0tKSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2Fzc2lnblRvSGFzaCcsIHBhaXJzW2ldLmtleSk7XHJcblx0ICAgIH1cclxuXHQgICAgdGhpcy5vcGNvZGUoJ3BvcEhhc2gnKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gSEVMUEVSU1xyXG5cdCAgb3Bjb2RlOiBmdW5jdGlvbiBvcGNvZGUobmFtZSkge1xyXG5cdCAgICB0aGlzLm9wY29kZXMucHVzaCh7IG9wY29kZTogbmFtZSwgYXJnczogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBsb2M6IHRoaXMuc291cmNlTm9kZVswXS5sb2MgfSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIGFkZERlcHRoOiBmdW5jdGlvbiBhZGREZXB0aChkZXB0aCkge1xyXG5cdCAgICBpZiAoIWRlcHRoKSB7XHJcblx0ICAgICAgcmV0dXJuO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLnVzZURlcHRocyA9IHRydWU7XHJcblx0ICB9LFxyXG5cclxuXHQgIGNsYXNzaWZ5U2V4cHI6IGZ1bmN0aW9uIGNsYXNzaWZ5U2V4cHIoc2V4cHIpIHtcclxuXHQgICAgdmFyIGlzU2ltcGxlID0gX2FzdDJbJ2RlZmF1bHQnXS5oZWxwZXJzLnNpbXBsZUlkKHNleHByLnBhdGgpO1xyXG5cclxuXHQgICAgdmFyIGlzQmxvY2tQYXJhbSA9IGlzU2ltcGxlICYmICEhdGhpcy5ibG9ja1BhcmFtSW5kZXgoc2V4cHIucGF0aC5wYXJ0c1swXSk7XHJcblxyXG5cdCAgICAvLyBhIG11c3RhY2hlIGlzIGFuIGVsaWdpYmxlIGhlbHBlciBpZjpcclxuXHQgICAgLy8gKiBpdHMgaWQgaXMgc2ltcGxlIChhIHNpbmdsZSBwYXJ0LCBub3QgYHRoaXNgIG9yIGAuLmApXHJcblx0ICAgIHZhciBpc0hlbHBlciA9ICFpc0Jsb2NrUGFyYW0gJiYgX2FzdDJbJ2RlZmF1bHQnXS5oZWxwZXJzLmhlbHBlckV4cHJlc3Npb24oc2V4cHIpO1xyXG5cclxuXHQgICAgLy8gaWYgYSBtdXN0YWNoZSBpcyBhbiBlbGlnaWJsZSBoZWxwZXIgYnV0IG5vdCBhIGRlZmluaXRlXHJcblx0ICAgIC8vIGhlbHBlciwgaXQgaXMgYW1iaWd1b3VzLCBhbmQgd2lsbCBiZSByZXNvbHZlZCBpbiBhIGxhdGVyXHJcblx0ICAgIC8vIHBhc3Mgb3IgYXQgcnVudGltZS5cclxuXHQgICAgdmFyIGlzRWxpZ2libGUgPSAhaXNCbG9ja1BhcmFtICYmIChpc0hlbHBlciB8fCBpc1NpbXBsZSk7XHJcblxyXG5cdCAgICAvLyBpZiBhbWJpZ3VvdXMsIHdlIGNhbiBwb3NzaWJseSByZXNvbHZlIHRoZSBhbWJpZ3VpdHkgbm93XHJcblx0ICAgIC8vIEFuIGVsaWdpYmxlIGhlbHBlciBpcyBvbmUgdGhhdCBkb2VzIG5vdCBoYXZlIGEgY29tcGxleCBwYXRoLCBpLmUuIGB0aGlzLmZvb2AsIGAuLi9mb29gIGV0Yy5cclxuXHQgICAgaWYgKGlzRWxpZ2libGUgJiYgIWlzSGVscGVyKSB7XHJcblx0ICAgICAgdmFyIF9uYW1lMiA9IHNleHByLnBhdGgucGFydHNbMF0sXHJcblx0ICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdCAgICAgIGlmIChvcHRpb25zLmtub3duSGVscGVyc1tfbmFtZTJdKSB7XHJcblx0ICAgICAgICBpc0hlbHBlciA9IHRydWU7XHJcblx0ICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmtub3duSGVscGVyc09ubHkpIHtcclxuXHQgICAgICAgIGlzRWxpZ2libGUgPSBmYWxzZTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmIChpc0hlbHBlcikge1xyXG5cdCAgICAgIHJldHVybiAnaGVscGVyJztcclxuXHQgICAgfSBlbHNlIGlmIChpc0VsaWdpYmxlKSB7XHJcblx0ICAgICAgcmV0dXJuICdhbWJpZ3VvdXMnO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiAnc2ltcGxlJztcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBwdXNoUGFyYW1zOiBmdW5jdGlvbiBwdXNoUGFyYW1zKHBhcmFtcykge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgICB0aGlzLnB1c2hQYXJhbShwYXJhbXNbaV0pO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIHB1c2hQYXJhbTogZnVuY3Rpb24gcHVzaFBhcmFtKHZhbCkge1xyXG5cdCAgICB2YXIgdmFsdWUgPSB2YWwudmFsdWUgIT0gbnVsbCA/IHZhbC52YWx1ZSA6IHZhbC5vcmlnaW5hbCB8fCAnJztcclxuXHJcblx0ICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xyXG5cdCAgICAgIGlmICh2YWx1ZS5yZXBsYWNlKSB7XHJcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oXFwuP1xcLlxcLykqL2csICcnKS5yZXBsYWNlKC9cXC8vZywgJy4nKTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIGlmICh2YWwuZGVwdGgpIHtcclxuXHQgICAgICAgIHRoaXMuYWRkRGVwdGgodmFsLmRlcHRoKTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2dldENvbnRleHQnLCB2YWwuZGVwdGggfHwgMCk7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hTdHJpbmdQYXJhbScsIHZhbHVlLCB2YWwudHlwZSk7XHJcblxyXG5cdCAgICAgIGlmICh2YWwudHlwZSA9PT0gJ1N1YkV4cHJlc3Npb24nKSB7XHJcblx0ICAgICAgICAvLyBTdWJFeHByZXNzaW9ucyBnZXQgZXZhbHVhdGVkIGFuZCBwYXNzZWQgaW5cclxuXHQgICAgICAgIC8vIGluIHN0cmluZyBwYXJhbXMgbW9kZS5cclxuXHQgICAgICAgIHRoaXMuYWNjZXB0KHZhbCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XHJcblx0ICAgICAgICB2YXIgYmxvY2tQYXJhbUluZGV4ID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgaWYgKHZhbC5wYXJ0cyAmJiAhX2FzdDJbJ2RlZmF1bHQnXS5oZWxwZXJzLnNjb3BlZElkKHZhbCkgJiYgIXZhbC5kZXB0aCkge1xyXG5cdCAgICAgICAgICBibG9ja1BhcmFtSW5kZXggPSB0aGlzLmJsb2NrUGFyYW1JbmRleCh2YWwucGFydHNbMF0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGJsb2NrUGFyYW1JbmRleCkge1xyXG5cdCAgICAgICAgICB2YXIgYmxvY2tQYXJhbUNoaWxkID0gdmFsLnBhcnRzLnNsaWNlKDEpLmpvaW4oJy4nKTtcclxuXHQgICAgICAgICAgdGhpcy5vcGNvZGUoJ3B1c2hJZCcsICdCbG9ja1BhcmFtJywgYmxvY2tQYXJhbUluZGV4LCBibG9ja1BhcmFtQ2hpbGQpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgdmFsdWUgPSB2YWwub3JpZ2luYWwgfHwgdmFsdWU7XHJcblx0ICAgICAgICAgIGlmICh2YWx1ZS5yZXBsYWNlKSB7XHJcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9edGhpcyg/OlxcLnwkKS8sICcnKS5yZXBsYWNlKC9eXFwuXFwvLywgJycpLnJlcGxhY2UoL15cXC4kLywgJycpO1xyXG5cdCAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICB0aGlzLm9wY29kZSgncHVzaElkJywgdmFsLnR5cGUsIHZhbHVlKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgICAgdGhpcy5hY2NlcHQodmFsKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBzZXR1cEZ1bGxNdXN0YWNoZVBhcmFtczogZnVuY3Rpb24gc2V0dXBGdWxsTXVzdGFjaGVQYXJhbXMoc2V4cHIsIHByb2dyYW0sIGludmVyc2UsIG9taXRFbXB0eSkge1xyXG5cdCAgICB2YXIgcGFyYW1zID0gc2V4cHIucGFyYW1zO1xyXG5cdCAgICB0aGlzLnB1c2hQYXJhbXMocGFyYW1zKTtcclxuXHJcblx0ICAgIHRoaXMub3Bjb2RlKCdwdXNoUHJvZ3JhbScsIHByb2dyYW0pO1xyXG5cdCAgICB0aGlzLm9wY29kZSgncHVzaFByb2dyYW0nLCBpbnZlcnNlKTtcclxuXHJcblx0ICAgIGlmIChzZXhwci5oYXNoKSB7XHJcblx0ICAgICAgdGhpcy5hY2NlcHQoc2V4cHIuaGFzaCk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5vcGNvZGUoJ2VtcHR5SGFzaCcsIG9taXRFbXB0eSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiBwYXJhbXM7XHJcblx0ICB9LFxyXG5cclxuXHQgIGJsb2NrUGFyYW1JbmRleDogZnVuY3Rpb24gYmxvY2tQYXJhbUluZGV4KG5hbWUpIHtcclxuXHQgICAgZm9yICh2YXIgZGVwdGggPSAwLCBsZW4gPSB0aGlzLm9wdGlvbnMuYmxvY2tQYXJhbXMubGVuZ3RoOyBkZXB0aCA8IGxlbjsgZGVwdGgrKykge1xyXG5cdCAgICAgIHZhciBibG9ja1BhcmFtcyA9IHRoaXMub3B0aW9ucy5ibG9ja1BhcmFtc1tkZXB0aF0sXHJcblx0ICAgICAgICAgIHBhcmFtID0gYmxvY2tQYXJhbXMgJiYgX3V0aWxzLmluZGV4T2YoYmxvY2tQYXJhbXMsIG5hbWUpO1xyXG5cdCAgICAgIGlmIChibG9ja1BhcmFtcyAmJiBwYXJhbSA+PSAwKSB7XHJcblx0ICAgICAgICByZXR1cm4gW2RlcHRoLCBwYXJhbV07XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcHJlY29tcGlsZShpbnB1dCwgb3B0aW9ucywgZW52KSB7XHJcblx0ICBpZiAoaW5wdXQgPT0gbnVsbCB8fCB0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnICYmIGlucHV0LnR5cGUgIT09ICdQcm9ncmFtJykge1xyXG5cdCAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgnWW91IG11c3QgcGFzcyBhIHN0cmluZyBvciBIYW5kbGViYXJzIEFTVCB0byBIYW5kbGViYXJzLnByZWNvbXBpbGUuIFlvdSBwYXNzZWQgJyArIGlucHV0KTtcclxuXHQgIH1cclxuXHJcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQgIGlmICghKCdkYXRhJyBpbiBvcHRpb25zKSkge1xyXG5cdCAgICBvcHRpb25zLmRhdGEgPSB0cnVlO1xyXG5cdCAgfVxyXG5cdCAgaWYgKG9wdGlvbnMuY29tcGF0KSB7XHJcblx0ICAgIG9wdGlvbnMudXNlRGVwdGhzID0gdHJ1ZTtcclxuXHQgIH1cclxuXHJcblx0ICB2YXIgYXN0ID0gZW52LnBhcnNlKGlucHV0LCBvcHRpb25zKSxcclxuXHQgICAgICBlbnZpcm9ubWVudCA9IG5ldyBlbnYuQ29tcGlsZXIoKS5jb21waWxlKGFzdCwgb3B0aW9ucyk7XHJcblx0ICByZXR1cm4gbmV3IGVudi5KYXZhU2NyaXB0Q29tcGlsZXIoKS5jb21waWxlKGVudmlyb25tZW50LCBvcHRpb25zKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNvbXBpbGUoaW5wdXQsIG9wdGlvbnMsIGVudikge1xyXG5cdCAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9O1xyXG5cclxuXHQgIGlmIChpbnB1dCA9PSBudWxsIHx8IHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycgJiYgaW5wdXQudHlwZSAhPT0gJ1Byb2dyYW0nKSB7XHJcblx0ICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdZb3UgbXVzdCBwYXNzIGEgc3RyaW5nIG9yIEhhbmRsZWJhcnMgQVNUIHRvIEhhbmRsZWJhcnMuY29tcGlsZS4gWW91IHBhc3NlZCAnICsgaW5wdXQpO1xyXG5cdCAgfVxyXG5cclxuXHQgIG9wdGlvbnMgPSBfdXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zKTtcclxuXHQgIGlmICghKCdkYXRhJyBpbiBvcHRpb25zKSkge1xyXG5cdCAgICBvcHRpb25zLmRhdGEgPSB0cnVlO1xyXG5cdCAgfVxyXG5cdCAgaWYgKG9wdGlvbnMuY29tcGF0KSB7XHJcblx0ICAgIG9wdGlvbnMudXNlRGVwdGhzID0gdHJ1ZTtcclxuXHQgIH1cclxuXHJcblx0ICB2YXIgY29tcGlsZWQgPSB1bmRlZmluZWQ7XHJcblxyXG5cdCAgZnVuY3Rpb24gY29tcGlsZUlucHV0KCkge1xyXG5cdCAgICB2YXIgYXN0ID0gZW52LnBhcnNlKGlucHV0LCBvcHRpb25zKSxcclxuXHQgICAgICAgIGVudmlyb25tZW50ID0gbmV3IGVudi5Db21waWxlcigpLmNvbXBpbGUoYXN0LCBvcHRpb25zKSxcclxuXHQgICAgICAgIHRlbXBsYXRlU3BlYyA9IG5ldyBlbnYuSmF2YVNjcmlwdENvbXBpbGVyKCkuY29tcGlsZShlbnZpcm9ubWVudCwgb3B0aW9ucywgdW5kZWZpbmVkLCB0cnVlKTtcclxuXHQgICAgcmV0dXJuIGVudi50ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMpO1xyXG5cdCAgfVxyXG5cclxuXHQgIC8vIFRlbXBsYXRlIGlzIG9ubHkgY29tcGlsZWQgb24gZmlyc3QgdXNlIGFuZCBjYWNoZWQgYWZ0ZXIgdGhhdCBwb2ludC5cclxuXHQgIGZ1bmN0aW9uIHJldChjb250ZXh0LCBleGVjT3B0aW9ucykge1xyXG5cdCAgICBpZiAoIWNvbXBpbGVkKSB7XHJcblx0ICAgICAgY29tcGlsZWQgPSBjb21waWxlSW5wdXQoKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gY29tcGlsZWQuY2FsbCh0aGlzLCBjb250ZXh0LCBleGVjT3B0aW9ucyk7XHJcblx0ICB9XHJcblx0ICByZXQuX3NldHVwID0gZnVuY3Rpb24gKHNldHVwT3B0aW9ucykge1xyXG5cdCAgICBpZiAoIWNvbXBpbGVkKSB7XHJcblx0ICAgICAgY29tcGlsZWQgPSBjb21waWxlSW5wdXQoKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gY29tcGlsZWQuX3NldHVwKHNldHVwT3B0aW9ucyk7XHJcblx0ICB9O1xyXG5cdCAgcmV0Ll9jaGlsZCA9IGZ1bmN0aW9uIChpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XHJcblx0ICAgIGlmICghY29tcGlsZWQpIHtcclxuXHQgICAgICBjb21waWxlZCA9IGNvbXBpbGVJbnB1dCgpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBjb21waWxlZC5fY2hpbGQoaSwgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XHJcblx0ICB9O1xyXG5cdCAgcmV0dXJuIHJldDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFyZ0VxdWFscyhhLCBiKSB7XHJcblx0ICBpZiAoYSA9PT0gYikge1xyXG5cdCAgICByZXR1cm4gdHJ1ZTtcclxuXHQgIH1cclxuXHJcblx0ICBpZiAoX3V0aWxzLmlzQXJyYXkoYSkgJiYgX3V0aWxzLmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoKSB7XHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG5cdCAgICAgIGlmICghYXJnRXF1YWxzKGFbaV0sIGJbaV0pKSB7XHJcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiB0cnVlO1xyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdHJhbnNmb3JtTGl0ZXJhbFRvUGF0aChzZXhwcikge1xyXG5cdCAgaWYgKCFzZXhwci5wYXRoLnBhcnRzKSB7XHJcblx0ICAgIHZhciBsaXRlcmFsID0gc2V4cHIucGF0aDtcclxuXHQgICAgLy8gQ2FzdGluZyB0byBzdHJpbmcgaGVyZSB0byBtYWtlIGZhbHNlIGFuZCAwIGxpdGVyYWwgdmFsdWVzIHBsYXkgbmljZWx5IHdpdGggdGhlIHJlc3RcclxuXHQgICAgLy8gb2YgdGhlIHN5c3RlbS5cclxuXHQgICAgc2V4cHIucGF0aCA9IHtcclxuXHQgICAgICB0eXBlOiAnUGF0aEV4cHJlc3Npb24nLFxyXG5cdCAgICAgIGRhdGE6IGZhbHNlLFxyXG5cdCAgICAgIGRlcHRoOiAwLFxyXG5cdCAgICAgIHBhcnRzOiBbbGl0ZXJhbC5vcmlnaW5hbCArICcnXSxcclxuXHQgICAgICBvcmlnaW5hbDogbGl0ZXJhbC5vcmlnaW5hbCArICcnLFxyXG5cdCAgICAgIGxvYzogbGl0ZXJhbC5sb2NcclxuXHQgICAgfTtcclxuXHQgIH1cclxuXHR9XHJcblxyXG4vKioqLyB9KSxcclxuLyogNDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdHZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKVsnZGVmYXVsdCddO1xyXG5cclxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG5cclxuXHR2YXIgX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxuXHR2YXIgX2V4Y2VwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cdHZhciBfZXhjZXB0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4Y2VwdGlvbik7XHJcblxyXG5cdHZhciBfdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHR2YXIgX2NvZGVHZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcclxuXHJcblx0dmFyIF9jb2RlR2VuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvZGVHZW4pO1xyXG5cclxuXHRmdW5jdGlvbiBMaXRlcmFsKHZhbHVlKSB7XHJcblx0ICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBKYXZhU2NyaXB0Q29tcGlsZXIoKSB7fVxyXG5cclxuXHRKYXZhU2NyaXB0Q29tcGlsZXIucHJvdG90eXBlID0ge1xyXG5cdCAgLy8gUFVCTElDIEFQSTogWW91IGNhbiBvdmVycmlkZSB0aGVzZSBtZXRob2RzIGluIGEgc3ViY2xhc3MgdG8gcHJvdmlkZVxyXG5cdCAgLy8gYWx0ZXJuYXRpdmUgY29tcGlsZWQgZm9ybXMgZm9yIG5hbWUgbG9va3VwIGFuZCBidWZmZXJpbmcgc2VtYW50aWNzXHJcblx0ICBuYW1lTG9va3VwOiBmdW5jdGlvbiBuYW1lTG9va3VwKHBhcmVudCwgbmFtZSAvKiAsIHR5cGUqLykge1xyXG5cdCAgICBpZiAoSmF2YVNjcmlwdENvbXBpbGVyLmlzVmFsaWRKYXZhU2NyaXB0VmFyaWFibGVOYW1lKG5hbWUpKSB7XHJcblx0ICAgICAgcmV0dXJuIFtwYXJlbnQsICcuJywgbmFtZV07XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuIFtwYXJlbnQsICdbJywgSlNPTi5zdHJpbmdpZnkobmFtZSksICddJ107XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblx0ICBkZXB0aGVkTG9va3VwOiBmdW5jdGlvbiBkZXB0aGVkTG9va3VwKG5hbWUpIHtcclxuXHQgICAgcmV0dXJuIFt0aGlzLmFsaWFzYWJsZSgnY29udGFpbmVyLmxvb2t1cCcpLCAnKGRlcHRocywgXCInLCBuYW1lLCAnXCIpJ107XHJcblx0ICB9LFxyXG5cclxuXHQgIGNvbXBpbGVySW5mbzogZnVuY3Rpb24gY29tcGlsZXJJbmZvKCkge1xyXG5cdCAgICB2YXIgcmV2aXNpb24gPSBfYmFzZS5DT01QSUxFUl9SRVZJU0lPTixcclxuXHQgICAgICAgIHZlcnNpb25zID0gX2Jhc2UuUkVWSVNJT05fQ0hBTkdFU1tyZXZpc2lvbl07XHJcblx0ICAgIHJldHVybiBbcmV2aXNpb24sIHZlcnNpb25zXTtcclxuXHQgIH0sXHJcblxyXG5cdCAgYXBwZW5kVG9CdWZmZXI6IGZ1bmN0aW9uIGFwcGVuZFRvQnVmZmVyKHNvdXJjZSwgbG9jYXRpb24sIGV4cGxpY2l0KSB7XHJcblx0ICAgIC8vIEZvcmNlIGEgc291cmNlIGFzIHRoaXMgc2ltcGxpZmllcyB0aGUgbWVyZ2UgbG9naWMuXHJcblx0ICAgIGlmICghX3V0aWxzLmlzQXJyYXkoc291cmNlKSkge1xyXG5cdCAgICAgIHNvdXJjZSA9IFtzb3VyY2VdO1xyXG5cdCAgICB9XHJcblx0ICAgIHNvdXJjZSA9IHRoaXMuc291cmNlLndyYXAoc291cmNlLCBsb2NhdGlvbik7XHJcblxyXG5cdCAgICBpZiAodGhpcy5lbnZpcm9ubWVudC5pc1NpbXBsZSkge1xyXG5cdCAgICAgIHJldHVybiBbJ3JldHVybiAnLCBzb3VyY2UsICc7J107XHJcblx0ICAgIH0gZWxzZSBpZiAoZXhwbGljaXQpIHtcclxuXHQgICAgICAvLyBUaGlzIGlzIGEgY2FzZSB3aGVyZSB0aGUgYnVmZmVyIG9wZXJhdGlvbiBvY2N1cnMgYXMgYSBjaGlsZCBvZiBhbm90aGVyXHJcblx0ICAgICAgLy8gY29uc3RydWN0LCBnZW5lcmFsbHkgYnJhY2VzLiBXZSBoYXZlIHRvIGV4cGxpY2l0bHkgb3V0cHV0IHRoZXNlIGJ1ZmZlclxyXG5cdCAgICAgIC8vIG9wZXJhdGlvbnMgdG8gZW5zdXJlIHRoYXQgdGhlIGVtaXR0ZWQgY29kZSBnb2VzIGluIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxyXG5cdCAgICAgIHJldHVybiBbJ2J1ZmZlciArPSAnLCBzb3VyY2UsICc7J107XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgc291cmNlLmFwcGVuZFRvQnVmZmVyID0gdHJ1ZTtcclxuXHQgICAgICByZXR1cm4gc291cmNlO1xyXG5cdCAgICB9XHJcblx0ICB9LFxyXG5cclxuXHQgIGluaXRpYWxpemVCdWZmZXI6IGZ1bmN0aW9uIGluaXRpYWxpemVCdWZmZXIoKSB7XHJcblx0ICAgIHJldHVybiB0aGlzLnF1b3RlZFN0cmluZygnJyk7XHJcblx0ICB9LFxyXG5cdCAgLy8gRU5EIFBVQkxJQyBBUElcclxuXHJcblx0ICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKGVudmlyb25tZW50LCBvcHRpb25zLCBjb250ZXh0LCBhc09iamVjdCkge1xyXG5cdCAgICB0aGlzLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XHJcblx0ICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0ICAgIHRoaXMuc3RyaW5nUGFyYW1zID0gdGhpcy5vcHRpb25zLnN0cmluZ1BhcmFtcztcclxuXHQgICAgdGhpcy50cmFja0lkcyA9IHRoaXMub3B0aW9ucy50cmFja0lkcztcclxuXHQgICAgdGhpcy5wcmVjb21waWxlID0gIWFzT2JqZWN0O1xyXG5cclxuXHQgICAgdGhpcy5uYW1lID0gdGhpcy5lbnZpcm9ubWVudC5uYW1lO1xyXG5cdCAgICB0aGlzLmlzQ2hpbGQgPSAhIWNvbnRleHQ7XHJcblx0ICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwge1xyXG5cdCAgICAgIGRlY29yYXRvcnM6IFtdLFxyXG5cdCAgICAgIHByb2dyYW1zOiBbXSxcclxuXHQgICAgICBlbnZpcm9ubWVudHM6IFtdXHJcblx0ICAgIH07XHJcblxyXG5cdCAgICB0aGlzLnByZWFtYmxlKCk7XHJcblxyXG5cdCAgICB0aGlzLnN0YWNrU2xvdCA9IDA7XHJcblx0ICAgIHRoaXMuc3RhY2tWYXJzID0gW107XHJcblx0ICAgIHRoaXMuYWxpYXNlcyA9IHt9O1xyXG5cdCAgICB0aGlzLnJlZ2lzdGVycyA9IHsgbGlzdDogW10gfTtcclxuXHQgICAgdGhpcy5oYXNoZXMgPSBbXTtcclxuXHQgICAgdGhpcy5jb21waWxlU3RhY2sgPSBbXTtcclxuXHQgICAgdGhpcy5pbmxpbmVTdGFjayA9IFtdO1xyXG5cdCAgICB0aGlzLmJsb2NrUGFyYW1zID0gW107XHJcblxyXG5cdCAgICB0aGlzLmNvbXBpbGVDaGlsZHJlbihlbnZpcm9ubWVudCwgb3B0aW9ucyk7XHJcblxyXG5cdCAgICB0aGlzLnVzZURlcHRocyA9IHRoaXMudXNlRGVwdGhzIHx8IGVudmlyb25tZW50LnVzZURlcHRocyB8fCBlbnZpcm9ubWVudC51c2VEZWNvcmF0b3JzIHx8IHRoaXMub3B0aW9ucy5jb21wYXQ7XHJcblx0ICAgIHRoaXMudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IGVudmlyb25tZW50LnVzZUJsb2NrUGFyYW1zO1xyXG5cclxuXHQgICAgdmFyIG9wY29kZXMgPSBlbnZpcm9ubWVudC5vcGNvZGVzLFxyXG5cdCAgICAgICAgb3Bjb2RlID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgZmlyc3RMb2MgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBpID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgbCA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICAgIGZvciAoaSA9IDAsIGwgPSBvcGNvZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgIG9wY29kZSA9IG9wY29kZXNbaV07XHJcblxyXG5cdCAgICAgIHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbiA9IG9wY29kZS5sb2M7XHJcblx0ICAgICAgZmlyc3RMb2MgPSBmaXJzdExvYyB8fCBvcGNvZGUubG9jO1xyXG5cdCAgICAgIHRoaXNbb3Bjb2RlLm9wY29kZV0uYXBwbHkodGhpcywgb3Bjb2RlLmFyZ3MpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBGbHVzaCBhbnkgdHJhaWxpbmcgY29udGVudCB0aGF0IG1pZ2h0IGJlIHBlbmRpbmcuXHJcblx0ICAgIHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbiA9IGZpcnN0TG9jO1xyXG5cdCAgICB0aGlzLnB1c2hTb3VyY2UoJycpO1xyXG5cclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgaWYgKHRoaXMuc3RhY2tTbG90IHx8IHRoaXMuaW5saW5lU3RhY2subGVuZ3RoIHx8IHRoaXMuY29tcGlsZVN0YWNrLmxlbmd0aCkge1xyXG5cdCAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdDb21waWxlIGNvbXBsZXRlZCB3aXRoIGNvbnRlbnQgbGVmdCBvbiBzdGFjaycpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAoIXRoaXMuZGVjb3JhdG9ycy5pc0VtcHR5KCkpIHtcclxuXHQgICAgICB0aGlzLnVzZURlY29yYXRvcnMgPSB0cnVlO1xyXG5cclxuXHQgICAgICB0aGlzLmRlY29yYXRvcnMucHJlcGVuZCgndmFyIGRlY29yYXRvcnMgPSBjb250YWluZXIuZGVjb3JhdG9ycztcXG4nKTtcclxuXHQgICAgICB0aGlzLmRlY29yYXRvcnMucHVzaCgncmV0dXJuIGZuOycpO1xyXG5cclxuXHQgICAgICBpZiAoYXNPYmplY3QpIHtcclxuXHQgICAgICAgIHRoaXMuZGVjb3JhdG9ycyA9IEZ1bmN0aW9uLmFwcGx5KHRoaXMsIFsnZm4nLCAncHJvcHMnLCAnY29udGFpbmVyJywgJ2RlcHRoMCcsICdkYXRhJywgJ2Jsb2NrUGFyYW1zJywgJ2RlcHRocycsIHRoaXMuZGVjb3JhdG9ycy5tZXJnZSgpXSk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMuZGVjb3JhdG9ycy5wcmVwZW5kKCdmdW5jdGlvbihmbiwgcHJvcHMsIGNvbnRhaW5lciwgZGVwdGgwLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XFxuJyk7XHJcblx0ICAgICAgICB0aGlzLmRlY29yYXRvcnMucHVzaCgnfVxcbicpO1xyXG5cdCAgICAgICAgdGhpcy5kZWNvcmF0b3JzID0gdGhpcy5kZWNvcmF0b3JzLm1lcmdlKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMuZGVjb3JhdG9ycyA9IHVuZGVmaW5lZDtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGZuID0gdGhpcy5jcmVhdGVGdW5jdGlvbkNvbnRleHQoYXNPYmplY3QpO1xyXG5cdCAgICBpZiAoIXRoaXMuaXNDaGlsZCkge1xyXG5cdCAgICAgIHZhciByZXQgPSB7XHJcblx0ICAgICAgICBjb21waWxlcjogdGhpcy5jb21waWxlckluZm8oKSxcclxuXHQgICAgICAgIG1haW46IGZuXHJcblx0ICAgICAgfTtcclxuXHJcblx0ICAgICAgaWYgKHRoaXMuZGVjb3JhdG9ycykge1xyXG5cdCAgICAgICAgcmV0Lm1haW5fZCA9IHRoaXMuZGVjb3JhdG9yczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuXHQgICAgICAgIHJldC51c2VEZWNvcmF0b3JzID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIHZhciBfY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuXHQgICAgICB2YXIgcHJvZ3JhbXMgPSBfY29udGV4dC5wcm9ncmFtcztcclxuXHQgICAgICB2YXIgZGVjb3JhdG9ycyA9IF9jb250ZXh0LmRlY29yYXRvcnM7XHJcblxyXG5cdCAgICAgIGZvciAoaSA9IDAsIGwgPSBwcm9ncmFtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHQgICAgICAgIGlmIChwcm9ncmFtc1tpXSkge1xyXG5cdCAgICAgICAgICByZXRbaV0gPSBwcm9ncmFtc1tpXTtcclxuXHQgICAgICAgICAgaWYgKGRlY29yYXRvcnNbaV0pIHtcclxuXHQgICAgICAgICAgICByZXRbaSArICdfZCddID0gZGVjb3JhdG9yc1tpXTtcclxuXHQgICAgICAgICAgICByZXQudXNlRGVjb3JhdG9ycyA9IHRydWU7XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblxyXG5cdCAgICAgIGlmICh0aGlzLmVudmlyb25tZW50LnVzZVBhcnRpYWwpIHtcclxuXHQgICAgICAgIHJldC51c2VQYXJ0aWFsID0gdHJ1ZTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgaWYgKHRoaXMub3B0aW9ucy5kYXRhKSB7XHJcblx0ICAgICAgICByZXQudXNlRGF0YSA9IHRydWU7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0aGlzLnVzZURlcHRocykge1xyXG5cdCAgICAgICAgcmV0LnVzZURlcHRocyA9IHRydWU7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0aGlzLnVzZUJsb2NrUGFyYW1zKSB7XHJcblx0ICAgICAgICByZXQudXNlQmxvY2tQYXJhbXMgPSB0cnVlO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdCkge1xyXG5cdCAgICAgICAgcmV0LmNvbXBhdCA9IHRydWU7XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICBpZiAoIWFzT2JqZWN0KSB7XHJcblx0ICAgICAgICByZXQuY29tcGlsZXIgPSBKU09OLnN0cmluZ2lmeShyZXQuY29tcGlsZXIpO1xyXG5cclxuXHQgICAgICAgIHRoaXMuc291cmNlLmN1cnJlbnRMb2NhdGlvbiA9IHsgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAwIH0gfTtcclxuXHQgICAgICAgIHJldCA9IHRoaXMub2JqZWN0TGl0ZXJhbChyZXQpO1xyXG5cclxuXHQgICAgICAgIGlmIChvcHRpb25zLnNyY05hbWUpIHtcclxuXHQgICAgICAgICAgcmV0ID0gcmV0LnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7IGZpbGU6IG9wdGlvbnMuZGVzdE5hbWUgfSk7XHJcblx0ICAgICAgICAgIHJldC5tYXAgPSByZXQubWFwICYmIHJldC5tYXAudG9TdHJpbmcoKTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIHJldCA9IHJldC50b1N0cmluZygpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICByZXQuY29tcGlsZXJPcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdCAgICAgIH1cclxuXHJcblx0ICAgICAgcmV0dXJuIHJldDtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gZm47XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgcHJlYW1ibGU6IGZ1bmN0aW9uIHByZWFtYmxlKCkge1xyXG5cdCAgICAvLyB0cmFjayB0aGUgbGFzdCBjb250ZXh0IHB1c2hlZCBpbnRvIHBsYWNlIHRvIGFsbG93IHNraXBwaW5nIHRoZVxyXG5cdCAgICAvLyBnZXRDb250ZXh0IG9wY29kZSB3aGVuIGl0IHdvdWxkIGJlIGEgbm9vcFxyXG5cdCAgICB0aGlzLmxhc3RDb250ZXh0ID0gMDtcclxuXHQgICAgdGhpcy5zb3VyY2UgPSBuZXcgX2NvZGVHZW4yWydkZWZhdWx0J10odGhpcy5vcHRpb25zLnNyY05hbWUpO1xyXG5cdCAgICB0aGlzLmRlY29yYXRvcnMgPSBuZXcgX2NvZGVHZW4yWydkZWZhdWx0J10odGhpcy5vcHRpb25zLnNyY05hbWUpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBjcmVhdGVGdW5jdGlvbkNvbnRleHQ6IGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29udGV4dChhc09iamVjdCkge1xyXG5cdCAgICB2YXIgdmFyRGVjbGFyYXRpb25zID0gJyc7XHJcblxyXG5cdCAgICB2YXIgbG9jYWxzID0gdGhpcy5zdGFja1ZhcnMuY29uY2F0KHRoaXMucmVnaXN0ZXJzLmxpc3QpO1xyXG5cdCAgICBpZiAobG9jYWxzLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICB2YXJEZWNsYXJhdGlvbnMgKz0gJywgJyArIGxvY2Fscy5qb2luKCcsICcpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBHZW5lcmF0ZSBtaW5pbWl6ZXIgYWxpYXMgbWFwcGluZ3NcclxuXHQgICAgLy9cclxuXHQgICAgLy8gV2hlbiB1c2luZyB0cnVlIFNvdXJjZU5vZGVzLCB0aGlzIHdpbGwgdXBkYXRlIGFsbCByZWZlcmVuY2VzIHRvIHRoZSBnaXZlbiBhbGlhc1xyXG5cdCAgICAvLyBhcyB0aGUgc291cmNlIG5vZGVzIGFyZSByZXVzZWQgaW4gc2l0dS4gRm9yIHRoZSBub24tc291cmNlIG5vZGUgY29tcGlsYXRpb24gbW9kZSxcclxuXHQgICAgLy8gYWxpYXNlcyB3aWxsIG5vdCBiZSB1c2VkLCBidXQgdGhpcyBjYXNlIGlzIGFscmVhZHkgYmVpbmcgcnVuIG9uIHRoZSBjbGllbnQgYW5kXHJcblx0ICAgIC8vIHdlIGFyZW4ndCBjb25jZXJuIGFib3V0IG1pbmltaXppbmcgdGhlIHRlbXBsYXRlIHNpemUuXHJcblx0ICAgIHZhciBhbGlhc0NvdW50ID0gMDtcclxuXHQgICAgZm9yICh2YXIgYWxpYXMgaW4gdGhpcy5hbGlhc2VzKSB7XHJcblx0ICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cclxuXHQgICAgICB2YXIgbm9kZSA9IHRoaXMuYWxpYXNlc1thbGlhc107XHJcblxyXG5cdCAgICAgIGlmICh0aGlzLmFsaWFzZXMuaGFzT3duUHJvcGVydHkoYWxpYXMpICYmIG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5yZWZlcmVuY2VDb3VudCA+IDEpIHtcclxuXHQgICAgICAgIHZhckRlY2xhcmF0aW9ucyArPSAnLCBhbGlhcycgKyArK2FsaWFzQ291bnQgKyAnPScgKyBhbGlhcztcclxuXHQgICAgICAgIG5vZGUuY2hpbGRyZW5bMF0gPSAnYWxpYXMnICsgYWxpYXNDb3VudDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBwYXJhbXMgPSBbJ2NvbnRhaW5lcicsICdkZXB0aDAnLCAnaGVscGVycycsICdwYXJ0aWFscycsICdkYXRhJ107XHJcblxyXG5cdCAgICBpZiAodGhpcy51c2VCbG9ja1BhcmFtcyB8fCB0aGlzLnVzZURlcHRocykge1xyXG5cdCAgICAgIHBhcmFtcy5wdXNoKCdibG9ja1BhcmFtcycpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0aGlzLnVzZURlcHRocykge1xyXG5cdCAgICAgIHBhcmFtcy5wdXNoKCdkZXB0aHMnKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgLy8gUGVyZm9ybSBhIHNlY29uZCBwYXNzIG92ZXIgdGhlIG91dHB1dCB0byBtZXJnZSBjb250ZW50IHdoZW4gcG9zc2libGVcclxuXHQgICAgdmFyIHNvdXJjZSA9IHRoaXMubWVyZ2VTb3VyY2UodmFyRGVjbGFyYXRpb25zKTtcclxuXHJcblx0ICAgIGlmIChhc09iamVjdCkge1xyXG5cdCAgICAgIHBhcmFtcy5wdXNoKHNvdXJjZSk7XHJcblxyXG5cdCAgICAgIHJldHVybiBGdW5jdGlvbi5hcHBseSh0aGlzLCBwYXJhbXMpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLnNvdXJjZS53cmFwKFsnZnVuY3Rpb24oJywgcGFyYW1zLmpvaW4oJywnKSwgJykge1xcbiAgJywgc291cmNlLCAnfSddKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIG1lcmdlU291cmNlOiBmdW5jdGlvbiBtZXJnZVNvdXJjZSh2YXJEZWNsYXJhdGlvbnMpIHtcclxuXHQgICAgdmFyIGlzU2ltcGxlID0gdGhpcy5lbnZpcm9ubWVudC5pc1NpbXBsZSxcclxuXHQgICAgICAgIGFwcGVuZE9ubHkgPSAhdGhpcy5mb3JjZUJ1ZmZlcixcclxuXHQgICAgICAgIGFwcGVuZEZpcnN0ID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgc291cmNlU2VlbiA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGJ1ZmZlclN0YXJ0ID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgYnVmZmVyRW5kID0gdW5kZWZpbmVkO1xyXG5cdCAgICB0aGlzLnNvdXJjZS5lYWNoKGZ1bmN0aW9uIChsaW5lKSB7XHJcblx0ICAgICAgaWYgKGxpbmUuYXBwZW5kVG9CdWZmZXIpIHtcclxuXHQgICAgICAgIGlmIChidWZmZXJTdGFydCkge1xyXG5cdCAgICAgICAgICBsaW5lLnByZXBlbmQoJyAgKyAnKTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIGJ1ZmZlclN0YXJ0ID0gbGluZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGJ1ZmZlckVuZCA9IGxpbmU7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIGlmIChidWZmZXJTdGFydCkge1xyXG5cdCAgICAgICAgICBpZiAoIXNvdXJjZVNlZW4pIHtcclxuXHQgICAgICAgICAgICBhcHBlbmRGaXJzdCA9IHRydWU7XHJcblx0ICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgYnVmZmVyU3RhcnQucHJlcGVuZCgnYnVmZmVyICs9ICcpO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgICAgIGJ1ZmZlckVuZC5hZGQoJzsnKTtcclxuXHQgICAgICAgICAgYnVmZmVyU3RhcnQgPSBidWZmZXJFbmQgPSB1bmRlZmluZWQ7XHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgc291cmNlU2VlbiA9IHRydWU7XHJcblx0ICAgICAgICBpZiAoIWlzU2ltcGxlKSB7XHJcblx0ICAgICAgICAgIGFwcGVuZE9ubHkgPSBmYWxzZTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgaWYgKGFwcGVuZE9ubHkpIHtcclxuXHQgICAgICBpZiAoYnVmZmVyU3RhcnQpIHtcclxuXHQgICAgICAgIGJ1ZmZlclN0YXJ0LnByZXBlbmQoJ3JldHVybiAnKTtcclxuXHQgICAgICAgIGJ1ZmZlckVuZC5hZGQoJzsnKTtcclxuXHQgICAgICB9IGVsc2UgaWYgKCFzb3VyY2VTZWVuKSB7XHJcblx0ICAgICAgICB0aGlzLnNvdXJjZS5wdXNoKCdyZXR1cm4gXCJcIjsnKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdmFyRGVjbGFyYXRpb25zICs9ICcsIGJ1ZmZlciA9ICcgKyAoYXBwZW5kRmlyc3QgPyAnJyA6IHRoaXMuaW5pdGlhbGl6ZUJ1ZmZlcigpKTtcclxuXHJcblx0ICAgICAgaWYgKGJ1ZmZlclN0YXJ0KSB7XHJcblx0ICAgICAgICBidWZmZXJTdGFydC5wcmVwZW5kKCdyZXR1cm4gYnVmZmVyICsgJyk7XHJcblx0ICAgICAgICBidWZmZXJFbmQuYWRkKCc7Jyk7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMuc291cmNlLnB1c2goJ3JldHVybiBidWZmZXI7Jyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAodmFyRGVjbGFyYXRpb25zKSB7XHJcblx0ICAgICAgdGhpcy5zb3VyY2UucHJlcGVuZCgndmFyICcgKyB2YXJEZWNsYXJhdGlvbnMuc3Vic3RyaW5nKDIpICsgKGFwcGVuZEZpcnN0ID8gJycgOiAnO1xcbicpKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuIHRoaXMuc291cmNlLm1lcmdlKCk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtibG9ja1ZhbHVlXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHZhbHVlXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJldHVybiB2YWx1ZSBvZiBibG9ja0hlbHBlck1pc3NpbmdcclxuXHQgIC8vXHJcblx0ICAvLyBUaGUgcHVycG9zZSBvZiB0aGlzIG9wY29kZSBpcyB0byB0YWtlIGEgYmxvY2sgb2YgdGhlIGZvcm1cclxuXHQgIC8vIGB7eyN0aGlzLmZvb319Li4ue3svdGhpcy5mb299fWAsIHJlc29sdmUgdGhlIHZhbHVlIG9mIGBmb29gLCBhbmRcclxuXHQgIC8vIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIHdpdGggdGhlIHJlc3VsdCBvZiBwcm9wZXJseVxyXG5cdCAgLy8gaW52b2tpbmcgYmxvY2tIZWxwZXJNaXNzaW5nLlxyXG5cdCAgYmxvY2tWYWx1ZTogZnVuY3Rpb24gYmxvY2tWYWx1ZShuYW1lKSB7XHJcblx0ICAgIHZhciBibG9ja0hlbHBlck1pc3NpbmcgPSB0aGlzLmFsaWFzYWJsZSgnaGVscGVycy5ibG9ja0hlbHBlck1pc3NpbmcnKSxcclxuXHQgICAgICAgIHBhcmFtcyA9IFt0aGlzLmNvbnRleHROYW1lKDApXTtcclxuXHQgICAgdGhpcy5zZXR1cEhlbHBlckFyZ3MobmFtZSwgMCwgcGFyYW1zKTtcclxuXHJcblx0ICAgIHZhciBibG9ja05hbWUgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgIHBhcmFtcy5zcGxpY2UoMSwgMCwgYmxvY2tOYW1lKTtcclxuXHJcblx0ICAgIHRoaXMucHVzaCh0aGlzLnNvdXJjZS5mdW5jdGlvbkNhbGwoYmxvY2tIZWxwZXJNaXNzaW5nLCAnY2FsbCcsIHBhcmFtcykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbYW1iaWd1b3VzQmxvY2tWYWx1ZV1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiBoYXNoLCBpbnZlcnNlLCBwcm9ncmFtLCB2YWx1ZVxyXG5cdCAgLy8gQ29tcGlsZXIgdmFsdWUsIGJlZm9yZTogbGFzdEhlbHBlcj12YWx1ZSBvZiBsYXN0IGZvdW5kIGhlbHBlciwgaWYgYW55XHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXIsIGlmIG5vIGxhc3RIZWxwZXI6IHNhbWUgYXMgW2Jsb2NrVmFsdWVdXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXIsIGlmIGxhc3RIZWxwZXI6IHZhbHVlXHJcblx0ICBhbWJpZ3VvdXNCbG9ja1ZhbHVlOiBmdW5jdGlvbiBhbWJpZ3VvdXNCbG9ja1ZhbHVlKCkge1xyXG5cdCAgICAvLyBXZSdyZSBiZWluZyBhIGJpdCBjaGVla3kgYW5kIHJldXNpbmcgdGhlIG9wdGlvbnMgdmFsdWUgZnJvbSB0aGUgcHJpb3IgZXhlY1xyXG5cdCAgICB2YXIgYmxvY2tIZWxwZXJNaXNzaW5nID0gdGhpcy5hbGlhc2FibGUoJ2hlbHBlcnMuYmxvY2tIZWxwZXJNaXNzaW5nJyksXHJcblx0ICAgICAgICBwYXJhbXMgPSBbdGhpcy5jb250ZXh0TmFtZSgwKV07XHJcblx0ICAgIHRoaXMuc2V0dXBIZWxwZXJBcmdzKCcnLCAwLCBwYXJhbXMsIHRydWUpO1xyXG5cclxuXHQgICAgdGhpcy5mbHVzaElubGluZSgpO1xyXG5cclxuXHQgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnRvcFN0YWNrKCk7XHJcblx0ICAgIHBhcmFtcy5zcGxpY2UoMSwgMCwgY3VycmVudCk7XHJcblxyXG5cdCAgICB0aGlzLnB1c2hTb3VyY2UoWydpZiAoIScsIHRoaXMubGFzdEhlbHBlciwgJykgeyAnLCBjdXJyZW50LCAnID0gJywgdGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGJsb2NrSGVscGVyTWlzc2luZywgJ2NhbGwnLCBwYXJhbXMpLCAnfSddKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2FwcGVuZENvbnRlbnRdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIEFwcGVuZHMgdGhlIHN0cmluZyB2YWx1ZSBvZiBgY29udGVudGAgdG8gdGhlIGN1cnJlbnQgYnVmZmVyXHJcblx0ICBhcHBlbmRDb250ZW50OiBmdW5jdGlvbiBhcHBlbmRDb250ZW50KGNvbnRlbnQpIHtcclxuXHQgICAgaWYgKHRoaXMucGVuZGluZ0NvbnRlbnQpIHtcclxuXHQgICAgICBjb250ZW50ID0gdGhpcy5wZW5kaW5nQ29udGVudCArIGNvbnRlbnQ7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5wZW5kaW5nTG9jYXRpb24gPSB0aGlzLnNvdXJjZS5jdXJyZW50TG9jYXRpb247XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMucGVuZGluZ0NvbnRlbnQgPSBjb250ZW50O1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbYXBwZW5kXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gQ29lcmNlcyBgdmFsdWVgIHRvIGEgU3RyaW5nIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBjdXJyZW50IGJ1ZmZlci5cclxuXHQgIC8vXHJcblx0ICAvLyBJZiBgdmFsdWVgIGlzIHRydXRoeSwgb3IgMCwgaXQgaXMgY29lcmNlZCBpbnRvIGEgc3RyaW5nIGFuZCBhcHBlbmRlZFxyXG5cdCAgLy8gT3RoZXJ3aXNlLCB0aGUgZW1wdHkgc3RyaW5nIGlzIGFwcGVuZGVkXHJcblx0ICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZCgpIHtcclxuXHQgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xyXG5cdCAgICAgIHRoaXMucmVwbGFjZVN0YWNrKGZ1bmN0aW9uIChjdXJyZW50KSB7XHJcblx0ICAgICAgICByZXR1cm4gWycgIT0gbnVsbCA/ICcsIGN1cnJlbnQsICcgOiBcIlwiJ107XHJcblx0ICAgICAgfSk7XHJcblxyXG5cdCAgICAgIHRoaXMucHVzaFNvdXJjZSh0aGlzLmFwcGVuZFRvQnVmZmVyKHRoaXMucG9wU3RhY2soKSkpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHZhciBsb2NhbCA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgICB0aGlzLnB1c2hTb3VyY2UoWydpZiAoJywgbG9jYWwsICcgIT0gbnVsbCkgeyAnLCB0aGlzLmFwcGVuZFRvQnVmZmVyKGxvY2FsLCB1bmRlZmluZWQsIHRydWUpLCAnIH0nXSk7XHJcblx0ICAgICAgaWYgKHRoaXMuZW52aXJvbm1lbnQuaXNTaW1wbGUpIHtcclxuXHQgICAgICAgIHRoaXMucHVzaFNvdXJjZShbJ2Vsc2UgeyAnLCB0aGlzLmFwcGVuZFRvQnVmZmVyKFwiJydcIiwgdW5kZWZpbmVkLCB0cnVlKSwgJyB9J10pO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbYXBwZW5kRXNjYXBlZF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiB2YWx1ZSwgLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIEVzY2FwZSBgdmFsdWVgIGFuZCBhcHBlbmQgaXQgdG8gdGhlIGJ1ZmZlclxyXG5cdCAgYXBwZW5kRXNjYXBlZDogZnVuY3Rpb24gYXBwZW5kRXNjYXBlZCgpIHtcclxuXHQgICAgdGhpcy5wdXNoU291cmNlKHRoaXMuYXBwZW5kVG9CdWZmZXIoW3RoaXMuYWxpYXNhYmxlKCdjb250YWluZXIuZXNjYXBlRXhwcmVzc2lvbicpLCAnKCcsIHRoaXMucG9wU3RhY2soKSwgJyknXSkpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbZ2V0Q29udGV4dF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXHJcblx0ICAvLyBDb21waWxlciB2YWx1ZSwgYWZ0ZXI6IGxhc3RDb250ZXh0PWRlcHRoXHJcblx0ICAvL1xyXG5cdCAgLy8gU2V0IHRoZSB2YWx1ZSBvZiB0aGUgYGxhc3RDb250ZXh0YCBjb21waWxlciB2YWx1ZSB0byB0aGUgZGVwdGhcclxuXHQgIGdldENvbnRleHQ6IGZ1bmN0aW9uIGdldENvbnRleHQoZGVwdGgpIHtcclxuXHQgICAgdGhpcy5sYXN0Q29udGV4dCA9IGRlcHRoO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbcHVzaENvbnRleHRdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IGN1cnJlbnRDb250ZXh0LCAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBQdXNoZXMgdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGNvbnRleHQgb250byB0aGUgc3RhY2suXHJcblx0ICBwdXNoQ29udGV4dDogZnVuY3Rpb24gcHVzaENvbnRleHQoKSB7XHJcblx0ICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh0aGlzLmNvbnRleHROYW1lKHRoaXMubGFzdENvbnRleHQpKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2xvb2t1cE9uQ29udGV4dF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogY3VycmVudENvbnRleHRbbmFtZV0sIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIExvb2tzIHVwIHRoZSB2YWx1ZSBvZiBgbmFtZWAgb24gdGhlIGN1cnJlbnQgY29udGV4dCBhbmQgcHVzaGVzXHJcblx0ICAvLyBpdCBvbnRvIHRoZSBzdGFjay5cclxuXHQgIGxvb2t1cE9uQ29udGV4dDogZnVuY3Rpb24gbG9va3VwT25Db250ZXh0KHBhcnRzLCBmYWxzeSwgc3RyaWN0LCBzY29wZWQpIHtcclxuXHQgICAgdmFyIGkgPSAwO1xyXG5cclxuXHQgICAgaWYgKCFzY29wZWQgJiYgdGhpcy5vcHRpb25zLmNvbXBhdCAmJiAhdGhpcy5sYXN0Q29udGV4dCkge1xyXG5cdCAgICAgIC8vIFRoZSBkZXB0aGVkIHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhbmRsZSB0aGUgdW5kZWZpbmVkIGxvZ2ljIGZvciB0aGUgcm9vdCBsZXZlbCB0aGF0XHJcblx0ICAgICAgLy8gaXMgaW1wbGVtZW50ZWQgYmVsb3csIHNvIHdlIGV2YWx1YXRlIHRoYXQgZGlyZWN0bHkgaW4gY29tcGF0IG1vZGVcclxuXHQgICAgICB0aGlzLnB1c2godGhpcy5kZXB0aGVkTG9va3VwKHBhcnRzW2krK10pKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLnB1c2hDb250ZXh0KCk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMucmVzb2x2ZVBhdGgoJ2NvbnRleHQnLCBwYXJ0cywgaSwgZmFsc3ksIHN0cmljdCk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtsb29rdXBCbG9ja1BhcmFtXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiBibG9ja1BhcmFtW25hbWVdLCAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBMb29rcyB1cCB0aGUgdmFsdWUgb2YgYHBhcnRzYCBvbiB0aGUgZ2l2ZW4gYmxvY2sgcGFyYW0gYW5kIHB1c2hlc1xyXG5cdCAgLy8gaXQgb250byB0aGUgc3RhY2suXHJcblx0ICBsb29rdXBCbG9ja1BhcmFtOiBmdW5jdGlvbiBsb29rdXBCbG9ja1BhcmFtKGJsb2NrUGFyYW1JZCwgcGFydHMpIHtcclxuXHQgICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRydWU7XHJcblxyXG5cdCAgICB0aGlzLnB1c2goWydibG9ja1BhcmFtc1snLCBibG9ja1BhcmFtSWRbMF0sICddWycsIGJsb2NrUGFyYW1JZFsxXSwgJ10nXSk7XHJcblx0ICAgIHRoaXMucmVzb2x2ZVBhdGgoJ2NvbnRleHQnLCBwYXJ0cywgMSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtsb29rdXBEYXRhXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiBkYXRhLCAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBQdXNoIHRoZSBkYXRhIGxvb2t1cCBvcGVyYXRvclxyXG5cdCAgbG9va3VwRGF0YTogZnVuY3Rpb24gbG9va3VwRGF0YShkZXB0aCwgcGFydHMsIHN0cmljdCkge1xyXG5cdCAgICBpZiAoIWRlcHRoKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdkYXRhJyk7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdjb250YWluZXIuZGF0YShkYXRhLCAnICsgZGVwdGggKyAnKScpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB0aGlzLnJlc29sdmVQYXRoKCdkYXRhJywgcGFydHMsIDAsIHRydWUsIHN0cmljdCk7XHJcblx0ICB9LFxyXG5cclxuXHQgIHJlc29sdmVQYXRoOiBmdW5jdGlvbiByZXNvbHZlUGF0aCh0eXBlLCBwYXJ0cywgaSwgZmFsc3ksIHN0cmljdCkge1xyXG5cdCAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxyXG5cclxuXHQgICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaWN0IHx8IHRoaXMub3B0aW9ucy5hc3N1bWVPYmplY3RzKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoKHN0cmljdExvb2t1cCh0aGlzLm9wdGlvbnMuc3RyaWN0ICYmIHN0cmljdCwgdGhpcywgcGFydHMsIHR5cGUpKTtcclxuXHQgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBsZW4gPSBwYXJ0cy5sZW5ndGg7XHJcblx0ICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cclxuXHQgICAgICB0aGlzLnJlcGxhY2VTdGFjayhmdW5jdGlvbiAoY3VycmVudCkge1xyXG5cdCAgICAgICAgdmFyIGxvb2t1cCA9IF90aGlzLm5hbWVMb29rdXAoY3VycmVudCwgcGFydHNbaV0sIHR5cGUpO1xyXG5cdCAgICAgICAgLy8gV2Ugd2FudCB0byBlbnN1cmUgdGhhdCB6ZXJvIGFuZCBmYWxzZSBhcmUgaGFuZGxlZCBwcm9wZXJseSBpZiB0aGUgY29udGV4dCAoZmFsc3kgZmxhZylcclxuXHQgICAgICAgIC8vIG5lZWRzIHRvIGhhdmUgdGhlIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoZXNlIHZhbHVlcy5cclxuXHQgICAgICAgIGlmICghZmFsc3kpIHtcclxuXHQgICAgICAgICAgcmV0dXJuIFsnICE9IG51bGwgPyAnLCBsb29rdXAsICcgOiAnLCBjdXJyZW50XTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW4gdXNlIGdlbmVyaWMgZmFsc3kgaGFuZGxpbmdcclxuXHQgICAgICAgICAgcmV0dXJuIFsnICYmICcsIGxvb2t1cF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgfSk7XHJcblx0ICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbcmVzb2x2ZVBvc3NpYmxlTGFtYmRhXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IHZhbHVlLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzb2x2ZWQgdmFsdWUsIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIElmIHRoZSBgdmFsdWVgIGlzIGEgbGFtYmRhLCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBieVxyXG5cdCAgLy8gdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgbGFtYmRhXHJcblx0ICByZXNvbHZlUG9zc2libGVMYW1iZGE6IGZ1bmN0aW9uIHJlc29sdmVQb3NzaWJsZUxhbWJkYSgpIHtcclxuXHQgICAgdGhpcy5wdXNoKFt0aGlzLmFsaWFzYWJsZSgnY29udGFpbmVyLmxhbWJkYScpLCAnKCcsIHRoaXMucG9wU3RhY2soKSwgJywgJywgdGhpcy5jb250ZXh0TmFtZSgwKSwgJyknXSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtwdXNoU3RyaW5nUGFyYW1dXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHN0cmluZywgY3VycmVudENvbnRleHQsIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFRoaXMgb3Bjb2RlIGlzIGRlc2lnbmVkIGZvciB1c2UgaW4gc3RyaW5nIG1vZGUsIHdoaWNoXHJcblx0ICAvLyBwcm92aWRlcyB0aGUgc3RyaW5nIHZhbHVlIG9mIGEgcGFyYW1ldGVyIGFsb25nIHdpdGggaXRzXHJcblx0ICAvLyBkZXB0aCByYXRoZXIgdGhhbiByZXNvbHZpbmcgaXQgaW1tZWRpYXRlbHkuXHJcblx0ICBwdXNoU3RyaW5nUGFyYW06IGZ1bmN0aW9uIHB1c2hTdHJpbmdQYXJhbShzdHJpbmcsIHR5cGUpIHtcclxuXHQgICAgdGhpcy5wdXNoQ29udGV4dCgpO1xyXG5cdCAgICB0aGlzLnB1c2hTdHJpbmcodHlwZSk7XHJcblxyXG5cdCAgICAvLyBJZiBpdCdzIGEgc3ViZXhwcmVzc2lvbiwgdGhlIHN0cmluZyByZXN1bHRcclxuXHQgICAgLy8gd2lsbCBiZSBwdXNoZWQgYWZ0ZXIgdGhpcyBvcGNvZGUuXHJcblx0ICAgIGlmICh0eXBlICE9PSAnU3ViRXhwcmVzc2lvbicpIHtcclxuXHQgICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgIHRoaXMucHVzaFN0cmluZyhzdHJpbmcpO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoc3RyaW5nKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgZW1wdHlIYXNoOiBmdW5jdGlvbiBlbXB0eUhhc2gob21pdEVtcHR5KSB7XHJcblx0ICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoKCd7fScpOyAvLyBoYXNoSWRzXHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoKCd7fScpOyAvLyBoYXNoQ29udGV4dHNcclxuXHQgICAgICB0aGlzLnB1c2goJ3t9Jyk7IC8vIGhhc2hUeXBlc1xyXG5cdCAgICB9XHJcblx0ICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChvbWl0RW1wdHkgPyAndW5kZWZpbmVkJyA6ICd7fScpO1xyXG5cdCAgfSxcclxuXHQgIHB1c2hIYXNoOiBmdW5jdGlvbiBwdXNoSGFzaCgpIHtcclxuXHQgICAgaWYgKHRoaXMuaGFzaCkge1xyXG5cdCAgICAgIHRoaXMuaGFzaGVzLnB1c2godGhpcy5oYXNoKTtcclxuXHQgICAgfVxyXG5cdCAgICB0aGlzLmhhc2ggPSB7IHZhbHVlczogW10sIHR5cGVzOiBbXSwgY29udGV4dHM6IFtdLCBpZHM6IFtdIH07XHJcblx0ICB9LFxyXG5cdCAgcG9wSGFzaDogZnVuY3Rpb24gcG9wSGFzaCgpIHtcclxuXHQgICAgdmFyIGhhc2ggPSB0aGlzLmhhc2g7XHJcblx0ICAgIHRoaXMuaGFzaCA9IHRoaXMuaGFzaGVzLnBvcCgpO1xyXG5cclxuXHQgICAgaWYgKHRoaXMudHJhY2tJZHMpIHtcclxuXHQgICAgICB0aGlzLnB1c2godGhpcy5vYmplY3RMaXRlcmFsKGhhc2guaWRzKSk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoKHRoaXMub2JqZWN0TGl0ZXJhbChoYXNoLmNvbnRleHRzKSk7XHJcblx0ICAgICAgdGhpcy5wdXNoKHRoaXMub2JqZWN0TGl0ZXJhbChoYXNoLnR5cGVzKSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMucHVzaCh0aGlzLm9iamVjdExpdGVyYWwoaGFzaC52YWx1ZXMpKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW3B1c2hTdHJpbmddXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHF1b3RlZFN0cmluZyhzdHJpbmcpLCAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBQdXNoIGEgcXVvdGVkIHZlcnNpb24gb2YgYHN0cmluZ2Agb250byB0aGUgc3RhY2tcclxuXHQgIHB1c2hTdHJpbmc6IGZ1bmN0aW9uIHB1c2hTdHJpbmcoc3RyaW5nKSB7XHJcblx0ICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbCh0aGlzLnF1b3RlZFN0cmluZyhzdHJpbmcpKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW3B1c2hMaXRlcmFsXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IC4uLlxyXG5cdCAgLy8gT24gc3RhY2ssIGFmdGVyOiB2YWx1ZSwgLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gUHVzaGVzIGEgdmFsdWUgb250byB0aGUgc3RhY2suIFRoaXMgb3BlcmF0aW9uIHByZXZlbnRzXHJcblx0ICAvLyB0aGUgY29tcGlsZXIgZnJvbSBjcmVhdGluZyBhIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBob2xkXHJcblx0ICAvLyBpdC5cclxuXHQgIHB1c2hMaXRlcmFsOiBmdW5jdGlvbiBwdXNoTGl0ZXJhbCh2YWx1ZSkge1xyXG5cdCAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwodmFsdWUpO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbcHVzaFByb2dyYW1dXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHByb2dyYW0oZ3VpZCksIC4uLlxyXG5cdCAgLy9cclxuXHQgIC8vIFB1c2ggYSBwcm9ncmFtIGV4cHJlc3Npb24gb250byB0aGUgc3RhY2suIFRoaXMgdGFrZXNcclxuXHQgIC8vIGEgY29tcGlsZS10aW1lIGd1aWQgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBydW50aW1lLWFjY2Vzc2libGVcclxuXHQgIC8vIGV4cHJlc3Npb24uXHJcblx0ICBwdXNoUHJvZ3JhbTogZnVuY3Rpb24gcHVzaFByb2dyYW0oZ3VpZCkge1xyXG5cdCAgICBpZiAoZ3VpZCAhPSBudWxsKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKHRoaXMucHJvZ3JhbUV4cHJlc3Npb24oZ3VpZCkpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHRoaXMucHVzaFN0YWNrTGl0ZXJhbChudWxsKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbcmVnaXN0ZXJEZWNvcmF0b3JdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uXHJcblx0ICAvL1xyXG5cdCAgLy8gUG9wcyBvZmYgdGhlIGRlY29yYXRvcidzIHBhcmFtZXRlcnMsIGludm9rZXMgdGhlIGRlY29yYXRvcixcclxuXHQgIC8vIGFuZCBpbnNlcnRzIHRoZSBkZWNvcmF0b3IgaW50byB0aGUgZGVjb3JhdG9ycyBsaXN0LlxyXG5cdCAgcmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVjb3JhdG9yKHBhcmFtU2l6ZSwgbmFtZSkge1xyXG5cdCAgICB2YXIgZm91bmREZWNvcmF0b3IgPSB0aGlzLm5hbWVMb29rdXAoJ2RlY29yYXRvcnMnLCBuYW1lLCAnZGVjb3JhdG9yJyksXHJcblx0ICAgICAgICBvcHRpb25zID0gdGhpcy5zZXR1cEhlbHBlckFyZ3MobmFtZSwgcGFyYW1TaXplKTtcclxuXHJcblx0ICAgIHRoaXMuZGVjb3JhdG9ycy5wdXNoKFsnZm4gPSAnLCB0aGlzLmRlY29yYXRvcnMuZnVuY3Rpb25DYWxsKGZvdW5kRGVjb3JhdG9yLCAnJywgWydmbicsICdwcm9wcycsICdjb250YWluZXInLCBvcHRpb25zXSksICcgfHwgZm47J10pO1xyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBbaW52b2tlSGVscGVyXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHBhcmFtcy4uLiwgLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJlc3VsdCBvZiBoZWxwZXIgaW52b2NhdGlvblxyXG5cdCAgLy9cclxuXHQgIC8vIFBvcHMgb2ZmIHRoZSBoZWxwZXIncyBwYXJhbWV0ZXJzLCBpbnZva2VzIHRoZSBoZWxwZXIsXHJcblx0ICAvLyBhbmQgcHVzaGVzIHRoZSBoZWxwZXIncyByZXR1cm4gdmFsdWUgb250byB0aGUgc3RhY2suXHJcblx0ICAvL1xyXG5cdCAgLy8gSWYgdGhlIGhlbHBlciBpcyBub3QgZm91bmQsIGBoZWxwZXJNaXNzaW5nYCBpcyBjYWxsZWQuXHJcblx0ICBpbnZva2VIZWxwZXI6IGZ1bmN0aW9uIGludm9rZUhlbHBlcihwYXJhbVNpemUsIG5hbWUsIGlzU2ltcGxlKSB7XHJcblx0ICAgIHZhciBub25IZWxwZXIgPSB0aGlzLnBvcFN0YWNrKCksXHJcblx0ICAgICAgICBoZWxwZXIgPSB0aGlzLnNldHVwSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSksXHJcblx0ICAgICAgICBzaW1wbGUgPSBpc1NpbXBsZSA/IFtoZWxwZXIubmFtZSwgJyB8fCAnXSA6ICcnO1xyXG5cclxuXHQgICAgdmFyIGxvb2t1cCA9IFsnKCddLmNvbmNhdChzaW1wbGUsIG5vbkhlbHBlcik7XHJcblx0ICAgIGlmICghdGhpcy5vcHRpb25zLnN0cmljdCkge1xyXG5cdCAgICAgIGxvb2t1cC5wdXNoKCcgfHwgJywgdGhpcy5hbGlhc2FibGUoJ2hlbHBlcnMuaGVscGVyTWlzc2luZycpKTtcclxuXHQgICAgfVxyXG5cdCAgICBsb29rdXAucHVzaCgnKScpO1xyXG5cclxuXHQgICAgdGhpcy5wdXNoKHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbChsb29rdXAsICdjYWxsJywgaGVscGVyLmNhbGxQYXJhbXMpKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2ludm9rZUtub3duSGVscGVyXVxyXG5cdCAgLy9cclxuXHQgIC8vIE9uIHN0YWNrLCBiZWZvcmU6IGhhc2gsIGludmVyc2UsIHByb2dyYW0sIHBhcmFtcy4uLiwgLi4uXHJcblx0ICAvLyBPbiBzdGFjaywgYWZ0ZXI6IHJlc3VsdCBvZiBoZWxwZXIgaW52b2NhdGlvblxyXG5cdCAgLy9cclxuXHQgIC8vIFRoaXMgb3BlcmF0aW9uIGlzIHVzZWQgd2hlbiB0aGUgaGVscGVyIGlzIGtub3duIHRvIGV4aXN0LFxyXG5cdCAgLy8gc28gYSBgaGVscGVyTWlzc2luZ2AgZmFsbGJhY2sgaXMgbm90IHJlcXVpcmVkLlxyXG5cdCAgaW52b2tlS25vd25IZWxwZXI6IGZ1bmN0aW9uIGludm9rZUtub3duSGVscGVyKHBhcmFtU2l6ZSwgbmFtZSkge1xyXG5cdCAgICB2YXIgaGVscGVyID0gdGhpcy5zZXR1cEhlbHBlcihwYXJhbVNpemUsIG5hbWUpO1xyXG5cdCAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKGhlbHBlci5uYW1lLCAnY2FsbCcsIGhlbHBlci5jYWxsUGFyYW1zKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIC8vIFtpbnZva2VBbWJpZ3VvdXNdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogaGFzaCwgaW52ZXJzZSwgcHJvZ3JhbSwgcGFyYW1zLi4uLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogcmVzdWx0IG9mIGRpc2FtYmlndWF0aW9uXHJcblx0ICAvL1xyXG5cdCAgLy8gVGhpcyBvcGVyYXRpb24gaXMgdXNlZCB3aGVuIGFuIGV4cHJlc3Npb24gbGlrZSBge3tmb299fWBcclxuXHQgIC8vIGlzIHByb3ZpZGVkLCBidXQgd2UgZG9uJ3Qga25vdyBhdCBjb21waWxlLXRpbWUgd2hldGhlciBpdFxyXG5cdCAgLy8gaXMgYSBoZWxwZXIgb3IgYSBwYXRoLlxyXG5cdCAgLy9cclxuXHQgIC8vIFRoaXMgb3BlcmF0aW9uIGVtaXRzIG1vcmUgY29kZSB0aGFuIHRoZSBvdGhlciBvcHRpb25zLFxyXG5cdCAgLy8gYW5kIGNhbiBiZSBhdm9pZGVkIGJ5IHBhc3NpbmcgdGhlIGBrbm93bkhlbHBlcnNgIGFuZFxyXG5cdCAgLy8gYGtub3duSGVscGVyc09ubHlgIGZsYWdzIGF0IGNvbXBpbGUtdGltZS5cclxuXHQgIGludm9rZUFtYmlndW91czogZnVuY3Rpb24gaW52b2tlQW1iaWd1b3VzKG5hbWUsIGhlbHBlckNhbGwpIHtcclxuXHQgICAgdGhpcy51c2VSZWdpc3RlcignaGVscGVyJyk7XHJcblxyXG5cdCAgICB2YXIgbm9uSGVscGVyID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cclxuXHQgICAgdGhpcy5lbXB0eUhhc2goKTtcclxuXHQgICAgdmFyIGhlbHBlciA9IHRoaXMuc2V0dXBIZWxwZXIoMCwgbmFtZSwgaGVscGVyQ2FsbCk7XHJcblxyXG5cdCAgICB2YXIgaGVscGVyTmFtZSA9IHRoaXMubGFzdEhlbHBlciA9IHRoaXMubmFtZUxvb2t1cCgnaGVscGVycycsIG5hbWUsICdoZWxwZXInKTtcclxuXHJcblx0ICAgIHZhciBsb29rdXAgPSBbJygnLCAnKGhlbHBlciA9ICcsIGhlbHBlck5hbWUsICcgfHwgJywgbm9uSGVscGVyLCAnKSddO1xyXG5cdCAgICBpZiAoIXRoaXMub3B0aW9ucy5zdHJpY3QpIHtcclxuXHQgICAgICBsb29rdXBbMF0gPSAnKGhlbHBlciA9ICc7XHJcblx0ICAgICAgbG9va3VwLnB1c2goJyAhPSBudWxsID8gaGVscGVyIDogJywgdGhpcy5hbGlhc2FibGUoJ2hlbHBlcnMuaGVscGVyTWlzc2luZycpKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdGhpcy5wdXNoKFsnKCcsIGxvb2t1cCwgaGVscGVyLnBhcmFtc0luaXQgPyBbJyksKCcsIGhlbHBlci5wYXJhbXNJbml0XSA6IFtdLCAnKSwnLCAnKHR5cGVvZiBoZWxwZXIgPT09ICcsIHRoaXMuYWxpYXNhYmxlKCdcImZ1bmN0aW9uXCInKSwgJyA/ICcsIHRoaXMuc291cmNlLmZ1bmN0aW9uQ2FsbCgnaGVscGVyJywgJ2NhbGwnLCBoZWxwZXIuY2FsbFBhcmFtcyksICcgOiBoZWxwZXIpKSddKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2ludm9rZVBhcnRpYWxdXHJcblx0ICAvL1xyXG5cdCAgLy8gT24gc3RhY2ssIGJlZm9yZTogY29udGV4dCwgLi4uXHJcblx0ICAvLyBPbiBzdGFjayBhZnRlcjogcmVzdWx0IG9mIHBhcnRpYWwgaW52b2NhdGlvblxyXG5cdCAgLy9cclxuXHQgIC8vIFRoaXMgb3BlcmF0aW9uIHBvcHMgb2ZmIGEgY29udGV4dCwgaW52b2tlcyBhIHBhcnRpYWwgd2l0aCB0aGF0IGNvbnRleHQsXHJcblx0ICAvLyBhbmQgcHVzaGVzIHRoZSByZXN1bHQgb2YgdGhlIGludm9jYXRpb24gYmFjay5cclxuXHQgIGludm9rZVBhcnRpYWw6IGZ1bmN0aW9uIGludm9rZVBhcnRpYWwoaXNEeW5hbWljLCBuYW1lLCBpbmRlbnQpIHtcclxuXHQgICAgdmFyIHBhcmFtcyA9IFtdLFxyXG5cdCAgICAgICAgb3B0aW9ucyA9IHRoaXMuc2V0dXBQYXJhbXMobmFtZSwgMSwgcGFyYW1zKTtcclxuXHJcblx0ICAgIGlmIChpc0R5bmFtaWMpIHtcclxuXHQgICAgICBuYW1lID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIGRlbGV0ZSBvcHRpb25zLm5hbWU7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmIChpbmRlbnQpIHtcclxuXHQgICAgICBvcHRpb25zLmluZGVudCA9IEpTT04uc3RyaW5naWZ5KGluZGVudCk7XHJcblx0ICAgIH1cclxuXHQgICAgb3B0aW9ucy5oZWxwZXJzID0gJ2hlbHBlcnMnO1xyXG5cdCAgICBvcHRpb25zLnBhcnRpYWxzID0gJ3BhcnRpYWxzJztcclxuXHQgICAgb3B0aW9ucy5kZWNvcmF0b3JzID0gJ2NvbnRhaW5lci5kZWNvcmF0b3JzJztcclxuXHJcblx0ICAgIGlmICghaXNEeW5hbWljKSB7XHJcblx0ICAgICAgcGFyYW1zLnVuc2hpZnQodGhpcy5uYW1lTG9va3VwKCdwYXJ0aWFscycsIG5hbWUsICdwYXJ0aWFsJykpO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHBhcmFtcy51bnNoaWZ0KG5hbWUpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdCkge1xyXG5cdCAgICAgIG9wdGlvbnMuZGVwdGhzID0gJ2RlcHRocyc7XHJcblx0ICAgIH1cclxuXHQgICAgb3B0aW9ucyA9IHRoaXMub2JqZWN0TGl0ZXJhbChvcHRpb25zKTtcclxuXHQgICAgcGFyYW1zLnB1c2gob3B0aW9ucyk7XHJcblxyXG5cdCAgICB0aGlzLnB1c2godGhpcy5zb3VyY2UuZnVuY3Rpb25DYWxsKCdjb250YWluZXIuaW52b2tlUGFydGlhbCcsICcnLCBwYXJhbXMpKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgLy8gW2Fzc2lnblRvSGFzaF1cclxuXHQgIC8vXHJcblx0ICAvLyBPbiBzdGFjaywgYmVmb3JlOiB2YWx1ZSwgLi4uLCBoYXNoLCAuLi5cclxuXHQgIC8vIE9uIHN0YWNrLCBhZnRlcjogLi4uLCBoYXNoLCAuLi5cclxuXHQgIC8vXHJcblx0ICAvLyBQb3BzIGEgdmFsdWUgb2ZmIHRoZSBzdGFjayBhbmQgYXNzaWducyBpdCB0byB0aGUgY3VycmVudCBoYXNoXHJcblx0ICBhc3NpZ25Ub0hhc2g6IGZ1bmN0aW9uIGFzc2lnblRvSGFzaChrZXkpIHtcclxuXHQgICAgdmFyIHZhbHVlID0gdGhpcy5wb3BTdGFjaygpLFxyXG5cdCAgICAgICAgY29udGV4dCA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIHR5cGUgPSB1bmRlZmluZWQsXHJcblx0ICAgICAgICBpZCA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XHJcblx0ICAgICAgaWQgPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMuc3RyaW5nUGFyYW1zKSB7XHJcblx0ICAgICAgdHlwZSA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgICBjb250ZXh0ID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaDtcclxuXHQgICAgaWYgKGNvbnRleHQpIHtcclxuXHQgICAgICBoYXNoLmNvbnRleHRzW2tleV0gPSBjb250ZXh0O1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0eXBlKSB7XHJcblx0ICAgICAgaGFzaC50eXBlc1trZXldID0gdHlwZTtcclxuXHQgICAgfVxyXG5cdCAgICBpZiAoaWQpIHtcclxuXHQgICAgICBoYXNoLmlkc1trZXldID0gaWQ7XHJcblx0ICAgIH1cclxuXHQgICAgaGFzaC52YWx1ZXNba2V5XSA9IHZhbHVlO1xyXG5cdCAgfSxcclxuXHJcblx0ICBwdXNoSWQ6IGZ1bmN0aW9uIHB1c2hJZCh0eXBlLCBuYW1lLCBjaGlsZCkge1xyXG5cdCAgICBpZiAodHlwZSA9PT0gJ0Jsb2NrUGFyYW0nKSB7XHJcblx0ICAgICAgdGhpcy5wdXNoU3RhY2tMaXRlcmFsKCdibG9ja1BhcmFtc1snICsgbmFtZVswXSArICddLnBhdGhbJyArIG5hbWVbMV0gKyAnXScgKyAoY2hpbGQgPyAnICsgJyArIEpTT04uc3RyaW5naWZ5KCcuJyArIGNoaWxkKSA6ICcnKSk7XHJcblx0ICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1BhdGhFeHByZXNzaW9uJykge1xyXG5cdCAgICAgIHRoaXMucHVzaFN0cmluZyhuYW1lKTtcclxuXHQgICAgfSBlbHNlIGlmICh0eXBlID09PSAnU3ViRXhwcmVzc2lvbicpIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ3RydWUnKTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICB0aGlzLnB1c2hTdGFja0xpdGVyYWwoJ251bGwnKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICAvLyBIRUxQRVJTXHJcblxyXG5cdCAgY29tcGlsZXI6IEphdmFTY3JpcHRDb21waWxlcixcclxuXHJcblx0ICBjb21waWxlQ2hpbGRyZW46IGZ1bmN0aW9uIGNvbXBpbGVDaGlsZHJlbihlbnZpcm9ubWVudCwgb3B0aW9ucykge1xyXG5cdCAgICB2YXIgY2hpbGRyZW4gPSBlbnZpcm9ubWVudC5jaGlsZHJlbixcclxuXHQgICAgICAgIGNoaWxkID0gdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgY29tcGlsZXIgPSB1bmRlZmluZWQ7XHJcblxyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XHJcblx0ICAgICAgY29tcGlsZXIgPSBuZXcgdGhpcy5jb21waWxlcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcclxuXHJcblx0ICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5tYXRjaEV4aXN0aW5nUHJvZ3JhbShjaGlsZCk7XHJcblxyXG5cdCAgICAgIGlmIChleGlzdGluZyA9PSBudWxsKSB7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQucHJvZ3JhbXMucHVzaCgnJyk7IC8vIFBsYWNlaG9sZGVyIHRvIHByZXZlbnQgbmFtZSBjb25mbGljdHMgZm9yIG5lc3RlZCBjaGlsZHJlblxyXG5cdCAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0LnByb2dyYW1zLmxlbmd0aDtcclxuXHQgICAgICAgIGNoaWxkLmluZGV4ID0gaW5kZXg7XHJcblx0ICAgICAgICBjaGlsZC5uYW1lID0gJ3Byb2dyYW0nICsgaW5kZXg7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQucHJvZ3JhbXNbaW5kZXhdID0gY29tcGlsZXIuY29tcGlsZShjaGlsZCwgb3B0aW9ucywgdGhpcy5jb250ZXh0LCAhdGhpcy5wcmVjb21waWxlKTtcclxuXHQgICAgICAgIHRoaXMuY29udGV4dC5kZWNvcmF0b3JzW2luZGV4XSA9IGNvbXBpbGVyLmRlY29yYXRvcnM7XHJcblx0ICAgICAgICB0aGlzLmNvbnRleHQuZW52aXJvbm1lbnRzW2luZGV4XSA9IGNoaWxkO1xyXG5cclxuXHQgICAgICAgIHRoaXMudXNlRGVwdGhzID0gdGhpcy51c2VEZXB0aHMgfHwgY29tcGlsZXIudXNlRGVwdGhzO1xyXG5cdCAgICAgICAgdGhpcy51c2VCbG9ja1BhcmFtcyA9IHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgY29tcGlsZXIudXNlQmxvY2tQYXJhbXM7XHJcblx0ICAgICAgICBjaGlsZC51c2VEZXB0aHMgPSB0aGlzLnVzZURlcHRocztcclxuXHQgICAgICAgIGNoaWxkLnVzZUJsb2NrUGFyYW1zID0gdGhpcy51c2VCbG9ja1BhcmFtcztcclxuXHQgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgY2hpbGQuaW5kZXggPSBleGlzdGluZy5pbmRleDtcclxuXHQgICAgICAgIGNoaWxkLm5hbWUgPSAncHJvZ3JhbScgKyBleGlzdGluZy5pbmRleDtcclxuXHJcblx0ICAgICAgICB0aGlzLnVzZURlcHRocyA9IHRoaXMudXNlRGVwdGhzIHx8IGV4aXN0aW5nLnVzZURlcHRocztcclxuXHQgICAgICAgIHRoaXMudXNlQmxvY2tQYXJhbXMgPSB0aGlzLnVzZUJsb2NrUGFyYW1zIHx8IGV4aXN0aW5nLnVzZUJsb2NrUGFyYW1zO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIG1hdGNoRXhpc3RpbmdQcm9ncmFtOiBmdW5jdGlvbiBtYXRjaEV4aXN0aW5nUHJvZ3JhbShjaGlsZCkge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jb250ZXh0LmVudmlyb25tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIHZhciBlbnZpcm9ubWVudCA9IHRoaXMuY29udGV4dC5lbnZpcm9ubWVudHNbaV07XHJcblx0ICAgICAgaWYgKGVudmlyb25tZW50ICYmIGVudmlyb25tZW50LmVxdWFscyhjaGlsZCkpIHtcclxuXHQgICAgICAgIHJldHVybiBlbnZpcm9ubWVudDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgcHJvZ3JhbUV4cHJlc3Npb246IGZ1bmN0aW9uIHByb2dyYW1FeHByZXNzaW9uKGd1aWQpIHtcclxuXHQgICAgdmFyIGNoaWxkID0gdGhpcy5lbnZpcm9ubWVudC5jaGlsZHJlbltndWlkXSxcclxuXHQgICAgICAgIHByb2dyYW1QYXJhbXMgPSBbY2hpbGQuaW5kZXgsICdkYXRhJywgY2hpbGQuYmxvY2tQYXJhbXNdO1xyXG5cclxuXHQgICAgaWYgKHRoaXMudXNlQmxvY2tQYXJhbXMgfHwgdGhpcy51c2VEZXB0aHMpIHtcclxuXHQgICAgICBwcm9ncmFtUGFyYW1zLnB1c2goJ2Jsb2NrUGFyYW1zJyk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKHRoaXMudXNlRGVwdGhzKSB7XHJcblx0ICAgICAgcHJvZ3JhbVBhcmFtcy5wdXNoKCdkZXB0aHMnKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0dXJuICdjb250YWluZXIucHJvZ3JhbSgnICsgcHJvZ3JhbVBhcmFtcy5qb2luKCcsICcpICsgJyknO1xyXG5cdCAgfSxcclxuXHJcblx0ICB1c2VSZWdpc3RlcjogZnVuY3Rpb24gdXNlUmVnaXN0ZXIobmFtZSkge1xyXG5cdCAgICBpZiAoIXRoaXMucmVnaXN0ZXJzW25hbWVdKSB7XHJcblx0ICAgICAgdGhpcy5yZWdpc3RlcnNbbmFtZV0gPSB0cnVlO1xyXG5cdCAgICAgIHRoaXMucmVnaXN0ZXJzLmxpc3QucHVzaChuYW1lKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICBwdXNoOiBmdW5jdGlvbiBwdXNoKGV4cHIpIHtcclxuXHQgICAgaWYgKCEoZXhwciBpbnN0YW5jZW9mIExpdGVyYWwpKSB7XHJcblx0ICAgICAgZXhwciA9IHRoaXMuc291cmNlLndyYXAoZXhwcik7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHRoaXMuaW5saW5lU3RhY2sucHVzaChleHByKTtcclxuXHQgICAgcmV0dXJuIGV4cHI7XHJcblx0ICB9LFxyXG5cclxuXHQgIHB1c2hTdGFja0xpdGVyYWw6IGZ1bmN0aW9uIHB1c2hTdGFja0xpdGVyYWwoaXRlbSkge1xyXG5cdCAgICB0aGlzLnB1c2gobmV3IExpdGVyYWwoaXRlbSkpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBwdXNoU291cmNlOiBmdW5jdGlvbiBwdXNoU291cmNlKHNvdXJjZSkge1xyXG5cdCAgICBpZiAodGhpcy5wZW5kaW5nQ29udGVudCkge1xyXG5cdCAgICAgIHRoaXMuc291cmNlLnB1c2godGhpcy5hcHBlbmRUb0J1ZmZlcih0aGlzLnNvdXJjZS5xdW90ZWRTdHJpbmcodGhpcy5wZW5kaW5nQ29udGVudCksIHRoaXMucGVuZGluZ0xvY2F0aW9uKSk7XHJcblx0ICAgICAgdGhpcy5wZW5kaW5nQ29udGVudCA9IHVuZGVmaW5lZDtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgaWYgKHNvdXJjZSkge1xyXG5cdCAgICAgIHRoaXMuc291cmNlLnB1c2goc291cmNlKTtcclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHJcblx0ICByZXBsYWNlU3RhY2s6IGZ1bmN0aW9uIHJlcGxhY2VTdGFjayhjYWxsYmFjaykge1xyXG5cdCAgICB2YXIgcHJlZml4ID0gWycoJ10sXHJcblx0ICAgICAgICBzdGFjayA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIGNyZWF0ZWRTdGFjayA9IHVuZGVmaW5lZCxcclxuXHQgICAgICAgIHVzZWRMaXRlcmFsID0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgICAgaWYgKCF0aGlzLmlzSW5saW5lKCkpIHtcclxuXHQgICAgICB0aHJvdyBuZXcgX2V4Y2VwdGlvbjJbJ2RlZmF1bHQnXSgncmVwbGFjZVN0YWNrIG9uIG5vbi1pbmxpbmUnKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgLy8gV2Ugd2FudCB0byBtZXJnZSB0aGUgaW5saW5lIHN0YXRlbWVudCBpbnRvIHRoZSByZXBsYWNlbWVudCBzdGF0ZW1lbnQgdmlhICcsJ1xyXG5cdCAgICB2YXIgdG9wID0gdGhpcy5wb3BTdGFjayh0cnVlKTtcclxuXHJcblx0ICAgIGlmICh0b3AgaW5zdGFuY2VvZiBMaXRlcmFsKSB7XHJcblx0ICAgICAgLy8gTGl0ZXJhbHMgZG8gbm90IG5lZWQgdG8gYmUgaW5saW5lZFxyXG5cdCAgICAgIHN0YWNrID0gW3RvcC52YWx1ZV07XHJcblx0ICAgICAgcHJlZml4ID0gWycoJywgc3RhY2tdO1xyXG5cdCAgICAgIHVzZWRMaXRlcmFsID0gdHJ1ZTtcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBjdXJyZW50IHN0YWNrIG5hbWUgZm9yIHVzZSBieSB0aGUgaW5saW5lXHJcblx0ICAgICAgY3JlYXRlZFN0YWNrID0gdHJ1ZTtcclxuXHQgICAgICB2YXIgX25hbWUgPSB0aGlzLmluY3JTdGFjaygpO1xyXG5cclxuXHQgICAgICBwcmVmaXggPSBbJygoJywgdGhpcy5wdXNoKF9uYW1lKSwgJyA9ICcsIHRvcCwgJyknXTtcclxuXHQgICAgICBzdGFjayA9IHRoaXMudG9wU3RhY2soKTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIGl0ZW0gPSBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YWNrKTtcclxuXHJcblx0ICAgIGlmICghdXNlZExpdGVyYWwpIHtcclxuXHQgICAgICB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGNyZWF0ZWRTdGFjaykge1xyXG5cdCAgICAgIHRoaXMuc3RhY2tTbG90LS07XHJcblx0ICAgIH1cclxuXHQgICAgdGhpcy5wdXNoKHByZWZpeC5jb25jYXQoaXRlbSwgJyknKSk7XHJcblx0ICB9LFxyXG5cclxuXHQgIGluY3JTdGFjazogZnVuY3Rpb24gaW5jclN0YWNrKCkge1xyXG5cdCAgICB0aGlzLnN0YWNrU2xvdCsrO1xyXG5cdCAgICBpZiAodGhpcy5zdGFja1Nsb3QgPiB0aGlzLnN0YWNrVmFycy5sZW5ndGgpIHtcclxuXHQgICAgICB0aGlzLnN0YWNrVmFycy5wdXNoKCdzdGFjaycgKyB0aGlzLnN0YWNrU2xvdCk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHRoaXMudG9wU3RhY2tOYW1lKCk7XHJcblx0ICB9LFxyXG5cdCAgdG9wU3RhY2tOYW1lOiBmdW5jdGlvbiB0b3BTdGFja05hbWUoKSB7XHJcblx0ICAgIHJldHVybiAnc3RhY2snICsgdGhpcy5zdGFja1Nsb3Q7XHJcblx0ICB9LFxyXG5cdCAgZmx1c2hJbmxpbmU6IGZ1bmN0aW9uIGZsdXNoSW5saW5lKCkge1xyXG5cdCAgICB2YXIgaW5saW5lU3RhY2sgPSB0aGlzLmlubGluZVN0YWNrO1xyXG5cdCAgICB0aGlzLmlubGluZVN0YWNrID0gW107XHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbmxpbmVTdGFjay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIHZhciBlbnRyeSA9IGlubGluZVN0YWNrW2ldO1xyXG5cdCAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG5cdCAgICAgIGlmIChlbnRyeSBpbnN0YW5jZW9mIExpdGVyYWwpIHtcclxuXHQgICAgICAgIHRoaXMuY29tcGlsZVN0YWNrLnB1c2goZW50cnkpO1xyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmluY3JTdGFjaygpO1xyXG5cdCAgICAgICAgdGhpcy5wdXNoU291cmNlKFtzdGFjaywgJyA9ICcsIGVudHJ5LCAnOyddKTtcclxuXHQgICAgICAgIHRoaXMuY29tcGlsZVN0YWNrLnB1c2goc3RhY2spO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgfSxcclxuXHQgIGlzSW5saW5lOiBmdW5jdGlvbiBpc0lubGluZSgpIHtcclxuXHQgICAgcmV0dXJuIHRoaXMuaW5saW5lU3RhY2subGVuZ3RoO1xyXG5cdCAgfSxcclxuXHJcblx0ICBwb3BTdGFjazogZnVuY3Rpb24gcG9wU3RhY2sod3JhcHBlZCkge1xyXG5cdCAgICB2YXIgaW5saW5lID0gdGhpcy5pc0lubGluZSgpLFxyXG5cdCAgICAgICAgaXRlbSA9IChpbmxpbmUgPyB0aGlzLmlubGluZVN0YWNrIDogdGhpcy5jb21waWxlU3RhY2spLnBvcCgpO1xyXG5cclxuXHQgICAgaWYgKCF3cmFwcGVkICYmIGl0ZW0gaW5zdGFuY2VvZiBMaXRlcmFsKSB7XHJcblx0ICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgaWYgKCFpbmxpbmUpIHtcclxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0ICAgICAgICBpZiAoIXRoaXMuc3RhY2tTbG90KSB7XHJcblx0ICAgICAgICAgIHRocm93IG5ldyBfZXhjZXB0aW9uMlsnZGVmYXVsdCddKCdJbnZhbGlkIHN0YWNrIHBvcCcpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgdGhpcy5zdGFja1Nsb3QtLTtcclxuXHQgICAgICB9XHJcblx0ICAgICAgcmV0dXJuIGl0ZW07XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgdG9wU3RhY2s6IGZ1bmN0aW9uIHRvcFN0YWNrKCkge1xyXG5cdCAgICB2YXIgc3RhY2sgPSB0aGlzLmlzSW5saW5lKCkgPyB0aGlzLmlubGluZVN0YWNrIDogdGhpcy5jb21waWxlU3RhY2ssXHJcblx0ICAgICAgICBpdGVtID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcblxyXG5cdCAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuXHQgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBMaXRlcmFsKSB7XHJcblx0ICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgcmV0dXJuIGl0ZW07XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgY29udGV4dE5hbWU6IGZ1bmN0aW9uIGNvbnRleHROYW1lKGNvbnRleHQpIHtcclxuXHQgICAgaWYgKHRoaXMudXNlRGVwdGhzICYmIGNvbnRleHQpIHtcclxuXHQgICAgICByZXR1cm4gJ2RlcHRoc1snICsgY29udGV4dCArICddJztcclxuXHQgICAgfSBlbHNlIHtcclxuXHQgICAgICByZXR1cm4gJ2RlcHRoJyArIGNvbnRleHQ7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgcXVvdGVkU3RyaW5nOiBmdW5jdGlvbiBxdW90ZWRTdHJpbmcoc3RyKSB7XHJcblx0ICAgIHJldHVybiB0aGlzLnNvdXJjZS5xdW90ZWRTdHJpbmcoc3RyKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgb2JqZWN0TGl0ZXJhbDogZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbChvYmopIHtcclxuXHQgICAgcmV0dXJuIHRoaXMuc291cmNlLm9iamVjdExpdGVyYWwob2JqKTtcclxuXHQgIH0sXHJcblxyXG5cdCAgYWxpYXNhYmxlOiBmdW5jdGlvbiBhbGlhc2FibGUobmFtZSkge1xyXG5cdCAgICB2YXIgcmV0ID0gdGhpcy5hbGlhc2VzW25hbWVdO1xyXG5cdCAgICBpZiAocmV0KSB7XHJcblx0ICAgICAgcmV0LnJlZmVyZW5jZUNvdW50Kys7XHJcblx0ICAgICAgcmV0dXJuIHJldDtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgcmV0ID0gdGhpcy5hbGlhc2VzW25hbWVdID0gdGhpcy5zb3VyY2Uud3JhcChuYW1lKTtcclxuXHQgICAgcmV0LmFsaWFzYWJsZSA9IHRydWU7XHJcblx0ICAgIHJldC5yZWZlcmVuY2VDb3VudCA9IDE7XHJcblxyXG5cdCAgICByZXR1cm4gcmV0O1xyXG5cdCAgfSxcclxuXHJcblx0ICBzZXR1cEhlbHBlcjogZnVuY3Rpb24gc2V0dXBIZWxwZXIocGFyYW1TaXplLCBuYW1lLCBibG9ja0hlbHBlcikge1xyXG5cdCAgICB2YXIgcGFyYW1zID0gW10sXHJcblx0ICAgICAgICBwYXJhbXNJbml0ID0gdGhpcy5zZXR1cEhlbHBlckFyZ3MobmFtZSwgcGFyYW1TaXplLCBwYXJhbXMsIGJsb2NrSGVscGVyKTtcclxuXHQgICAgdmFyIGZvdW5kSGVscGVyID0gdGhpcy5uYW1lTG9va3VwKCdoZWxwZXJzJywgbmFtZSwgJ2hlbHBlcicpLFxyXG5cdCAgICAgICAgY2FsbENvbnRleHQgPSB0aGlzLmFsaWFzYWJsZSh0aGlzLmNvbnRleHROYW1lKDApICsgJyAhPSBudWxsID8gJyArIHRoaXMuY29udGV4dE5hbWUoMCkgKyAnIDogKGNvbnRhaW5lci5udWxsQ29udGV4dCB8fCB7fSknKTtcclxuXHJcblx0ICAgIHJldHVybiB7XHJcblx0ICAgICAgcGFyYW1zOiBwYXJhbXMsXHJcblx0ICAgICAgcGFyYW1zSW5pdDogcGFyYW1zSW5pdCxcclxuXHQgICAgICBuYW1lOiBmb3VuZEhlbHBlcixcclxuXHQgICAgICBjYWxsUGFyYW1zOiBbY2FsbENvbnRleHRdLmNvbmNhdChwYXJhbXMpXHJcblx0ICAgIH07XHJcblx0ICB9LFxyXG5cclxuXHQgIHNldHVwUGFyYW1zOiBmdW5jdGlvbiBzZXR1cFBhcmFtcyhoZWxwZXIsIHBhcmFtU2l6ZSwgcGFyYW1zKSB7XHJcblx0ICAgIHZhciBvcHRpb25zID0ge30sXHJcblx0ICAgICAgICBjb250ZXh0cyA9IFtdLFxyXG5cdCAgICAgICAgdHlwZXMgPSBbXSxcclxuXHQgICAgICAgIGlkcyA9IFtdLFxyXG5cdCAgICAgICAgb2JqZWN0QXJncyA9ICFwYXJhbXMsXHJcblx0ICAgICAgICBwYXJhbSA9IHVuZGVmaW5lZDtcclxuXHJcblx0ICAgIGlmIChvYmplY3RBcmdzKSB7XHJcblx0ICAgICAgcGFyYW1zID0gW107XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIG9wdGlvbnMubmFtZSA9IHRoaXMucXVvdGVkU3RyaW5nKGhlbHBlcik7XHJcblx0ICAgIG9wdGlvbnMuaGFzaCA9IHRoaXMucG9wU3RhY2soKTtcclxuXHJcblx0ICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XHJcblx0ICAgICAgb3B0aW9ucy5oYXNoSWRzID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xyXG5cdCAgICAgIG9wdGlvbnMuaGFzaFR5cGVzID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICAgIG9wdGlvbnMuaGFzaENvbnRleHRzID0gdGhpcy5wb3BTdGFjaygpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgaW52ZXJzZSA9IHRoaXMucG9wU3RhY2soKSxcclxuXHQgICAgICAgIHByb2dyYW0gPSB0aGlzLnBvcFN0YWNrKCk7XHJcblxyXG5cdCAgICAvLyBBdm9pZCBzZXR0aW5nIGZuIGFuZCBpbnZlcnNlIGlmIG5laXRoZXIgYXJlIHNldC4gVGhpcyBhbGxvd3NcclxuXHQgICAgLy8gaGVscGVycyB0byBkbyBhIGNoZWNrIGZvciBgaWYgKG9wdGlvbnMuZm4pYFxyXG5cdCAgICBpZiAocHJvZ3JhbSB8fCBpbnZlcnNlKSB7XHJcblx0ICAgICAgb3B0aW9ucy5mbiA9IHByb2dyYW0gfHwgJ2NvbnRhaW5lci5ub29wJztcclxuXHQgICAgICBvcHRpb25zLmludmVyc2UgPSBpbnZlcnNlIHx8ICdjb250YWluZXIubm9vcCc7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIFRoZSBwYXJhbWV0ZXJzIGdvIG9uIHRvIHRoZSBzdGFjayBpbiBvcmRlciAobWFraW5nIHN1cmUgdGhhdCB0aGV5IGFyZSBldmFsdWF0ZWQgaW4gb3JkZXIpXHJcblx0ICAgIC8vIHNvIHdlIG5lZWQgdG8gcG9wIHRoZW0gb2ZmIHRoZSBzdGFjayBpbiByZXZlcnNlIG9yZGVyXHJcblx0ICAgIHZhciBpID0gcGFyYW1TaXplO1xyXG5cdCAgICB3aGlsZSAoaS0tKSB7XHJcblx0ICAgICAgcGFyYW0gPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgICAgcGFyYW1zW2ldID0gcGFyYW07XHJcblxyXG5cdCAgICAgIGlmICh0aGlzLnRyYWNrSWRzKSB7XHJcblx0ICAgICAgICBpZHNbaV0gPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xyXG5cdCAgICAgICAgdHlwZXNbaV0gPSB0aGlzLnBvcFN0YWNrKCk7XHJcblx0ICAgICAgICBjb250ZXh0c1tpXSA9IHRoaXMucG9wU3RhY2soKTtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmIChvYmplY3RBcmdzKSB7XHJcblx0ICAgICAgb3B0aW9ucy5hcmdzID0gdGhpcy5zb3VyY2UuZ2VuZXJhdGVBcnJheShwYXJhbXMpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBpZiAodGhpcy50cmFja0lkcykge1xyXG5cdCAgICAgIG9wdGlvbnMuaWRzID0gdGhpcy5zb3VyY2UuZ2VuZXJhdGVBcnJheShpZHMpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmICh0aGlzLnN0cmluZ1BhcmFtcykge1xyXG5cdCAgICAgIG9wdGlvbnMudHlwZXMgPSB0aGlzLnNvdXJjZS5nZW5lcmF0ZUFycmF5KHR5cGVzKTtcclxuXHQgICAgICBvcHRpb25zLmNvbnRleHRzID0gdGhpcy5zb3VyY2UuZ2VuZXJhdGVBcnJheShjb250ZXh0cyk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGlmICh0aGlzLm9wdGlvbnMuZGF0YSkge1xyXG5cdCAgICAgIG9wdGlvbnMuZGF0YSA9ICdkYXRhJztcclxuXHQgICAgfVxyXG5cdCAgICBpZiAodGhpcy51c2VCbG9ja1BhcmFtcykge1xyXG5cdCAgICAgIG9wdGlvbnMuYmxvY2tQYXJhbXMgPSAnYmxvY2tQYXJhbXMnO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBvcHRpb25zO1xyXG5cdCAgfSxcclxuXHJcblx0ICBzZXR1cEhlbHBlckFyZ3M6IGZ1bmN0aW9uIHNldHVwSGVscGVyQXJncyhoZWxwZXIsIHBhcmFtU2l6ZSwgcGFyYW1zLCB1c2VSZWdpc3Rlcikge1xyXG5cdCAgICB2YXIgb3B0aW9ucyA9IHRoaXMuc2V0dXBQYXJhbXMoaGVscGVyLCBwYXJhbVNpemUsIHBhcmFtcyk7XHJcblx0ICAgIG9wdGlvbnMgPSB0aGlzLm9iamVjdExpdGVyYWwob3B0aW9ucyk7XHJcblx0ICAgIGlmICh1c2VSZWdpc3Rlcikge1xyXG5cdCAgICAgIHRoaXMudXNlUmVnaXN0ZXIoJ29wdGlvbnMnKTtcclxuXHQgICAgICBwYXJhbXMucHVzaCgnb3B0aW9ucycpO1xyXG5cdCAgICAgIHJldHVybiBbJ29wdGlvbnM9Jywgb3B0aW9uc107XHJcblx0ICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XHJcblx0ICAgICAgcGFyYW1zLnB1c2gob3B0aW9ucyk7XHJcblx0ICAgICAgcmV0dXJuICcnO1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgIHJldHVybiBvcHRpb25zO1xyXG5cdCAgICB9XHJcblx0ICB9XHJcblx0fTtcclxuXHJcblx0KGZ1bmN0aW9uICgpIHtcclxuXHQgIHZhciByZXNlcnZlZFdvcmRzID0gKCdicmVhayBlbHNlIG5ldyB2YXInICsgJyBjYXNlIGZpbmFsbHkgcmV0dXJuIHZvaWQnICsgJyBjYXRjaCBmb3Igc3dpdGNoIHdoaWxlJyArICcgY29udGludWUgZnVuY3Rpb24gdGhpcyB3aXRoJyArICcgZGVmYXVsdCBpZiB0aHJvdycgKyAnIGRlbGV0ZSBpbiB0cnknICsgJyBkbyBpbnN0YW5jZW9mIHR5cGVvZicgKyAnIGFic3RyYWN0IGVudW0gaW50IHNob3J0JyArICcgYm9vbGVhbiBleHBvcnQgaW50ZXJmYWNlIHN0YXRpYycgKyAnIGJ5dGUgZXh0ZW5kcyBsb25nIHN1cGVyJyArICcgY2hhciBmaW5hbCBuYXRpdmUgc3luY2hyb25pemVkJyArICcgY2xhc3MgZmxvYXQgcGFja2FnZSB0aHJvd3MnICsgJyBjb25zdCBnb3RvIHByaXZhdGUgdHJhbnNpZW50JyArICcgZGVidWdnZXIgaW1wbGVtZW50cyBwcm90ZWN0ZWQgdm9sYXRpbGUnICsgJyBkb3VibGUgaW1wb3J0IHB1YmxpYyBsZXQgeWllbGQgYXdhaXQnICsgJyBudWxsIHRydWUgZmFsc2UnKS5zcGxpdCgnICcpO1xyXG5cclxuXHQgIHZhciBjb21waWxlcldvcmRzID0gSmF2YVNjcmlwdENvbXBpbGVyLlJFU0VSVkVEX1dPUkRTID0ge307XHJcblxyXG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSByZXNlcnZlZFdvcmRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdCAgICBjb21waWxlcldvcmRzW3Jlc2VydmVkV29yZHNbaV1dID0gdHJ1ZTtcclxuXHQgIH1cclxuXHR9KSgpO1xyXG5cclxuXHRKYXZhU2NyaXB0Q29tcGlsZXIuaXNWYWxpZEphdmFTY3JpcHRWYXJpYWJsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG5cdCAgcmV0dXJuICFKYXZhU2NyaXB0Q29tcGlsZXIuUkVTRVJWRURfV09SRFNbbmFtZV0gJiYgL15bYS16QS1aXyRdWzAtOWEtekEtWl8kXSokLy50ZXN0KG5hbWUpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHN0cmljdExvb2t1cChyZXF1aXJlVGVybWluYWwsIGNvbXBpbGVyLCBwYXJ0cywgdHlwZSkge1xyXG5cdCAgdmFyIHN0YWNrID0gY29tcGlsZXIucG9wU3RhY2soKSxcclxuXHQgICAgICBpID0gMCxcclxuXHQgICAgICBsZW4gPSBwYXJ0cy5sZW5ndGg7XHJcblx0ICBpZiAocmVxdWlyZVRlcm1pbmFsKSB7XHJcblx0ICAgIGxlbi0tO1xyXG5cdCAgfVxyXG5cclxuXHQgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgc3RhY2sgPSBjb21waWxlci5uYW1lTG9va3VwKHN0YWNrLCBwYXJ0c1tpXSwgdHlwZSk7XHJcblx0ICB9XHJcblxyXG5cdCAgaWYgKHJlcXVpcmVUZXJtaW5hbCkge1xyXG5cdCAgICByZXR1cm4gW2NvbXBpbGVyLmFsaWFzYWJsZSgnY29udGFpbmVyLnN0cmljdCcpLCAnKCcsIHN0YWNrLCAnLCAnLCBjb21waWxlci5xdW90ZWRTdHJpbmcocGFydHNbaV0pLCAnKSddO1xyXG5cdCAgfSBlbHNlIHtcclxuXHQgICAgcmV0dXJuIHN0YWNrO1xyXG5cdCAgfVxyXG5cdH1cclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gSmF2YVNjcmlwdENvbXBpbGVyO1xyXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblx0LyogZ2xvYmFsIGRlZmluZSAqL1xyXG5cdCd1c2Ugc3RyaWN0JztcclxuXHJcblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuXHJcblx0dmFyIF91dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cdHZhciBTb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xyXG5cclxuXHR0cnkge1xyXG5cdCAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHQgIGlmIChmYWxzZSkge1xyXG5cdCAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHRoaXMgaW4gQU1EIGVudmlyb25tZW50cy4gRm9yIHRoZXNlIGVudmlyb25tZW50cywgd2UgYXN1c21lIHRoYXRcclxuXHQgICAgLy8gdGhleSBhcmUgcnVubmluZyBvbiB0aGUgYnJvd3NlciBhbmQgdGh1cyBoYXZlIG5vIG5lZWQgZm9yIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkuXHJcblx0ICAgIHZhciBTb3VyY2VNYXAgPSByZXF1aXJlKCdzb3VyY2UtbWFwJyk7XHJcblx0ICAgIFNvdXJjZU5vZGUgPSBTb3VyY2VNYXAuU291cmNlTm9kZTtcclxuXHQgIH1cclxuXHR9IGNhdGNoIChlcnIpIHt9XHJcblx0LyogTk9QICovXHJcblxyXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBpZjogdGVzdGVkIGJ1dCBub3QgY292ZXJlZCBpbiBpc3RhbmJ1bCBkdWUgdG8gZGlzdCBidWlsZCAgKi9cclxuXHRpZiAoIVNvdXJjZU5vZGUpIHtcclxuXHQgIFNvdXJjZU5vZGUgPSBmdW5jdGlvbiAobGluZSwgY29sdW1uLCBzcmNGaWxlLCBjaHVua3MpIHtcclxuXHQgICAgdGhpcy5zcmMgPSAnJztcclxuXHQgICAgaWYgKGNodW5rcykge1xyXG5cdCAgICAgIHRoaXMuYWRkKGNodW5rcyk7XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblx0ICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCAgU291cmNlTm9kZS5wcm90b3R5cGUgPSB7XHJcblx0ICAgIGFkZDogZnVuY3Rpb24gYWRkKGNodW5rcykge1xyXG5cdCAgICAgIGlmIChfdXRpbHMuaXNBcnJheShjaHVua3MpKSB7XHJcblx0ICAgICAgICBjaHVua3MgPSBjaHVua3Muam9pbignJyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHRoaXMuc3JjICs9IGNodW5rcztcclxuXHQgICAgfSxcclxuXHQgICAgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZChjaHVua3MpIHtcclxuXHQgICAgICBpZiAoX3V0aWxzLmlzQXJyYXkoY2h1bmtzKSkge1xyXG5cdCAgICAgICAgY2h1bmtzID0gY2h1bmtzLmpvaW4oJycpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICB0aGlzLnNyYyA9IGNodW5rcyArIHRoaXMuc3JjO1xyXG5cdCAgICB9LFxyXG5cdCAgICB0b1N0cmluZ1dpdGhTb3VyY2VNYXA6IGZ1bmN0aW9uIHRvU3RyaW5nV2l0aFNvdXJjZU1hcCgpIHtcclxuXHQgICAgICByZXR1cm4geyBjb2RlOiB0aGlzLnRvU3RyaW5nKCkgfTtcclxuXHQgICAgfSxcclxuXHQgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdCAgICAgIHJldHVybiB0aGlzLnNyYztcclxuXHQgICAgfVxyXG5cdCAgfTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNhc3RDaHVuayhjaHVuaywgY29kZUdlbiwgbG9jKSB7XHJcblx0ICBpZiAoX3V0aWxzLmlzQXJyYXkoY2h1bmspKSB7XHJcblx0ICAgIHZhciByZXQgPSBbXTtcclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaHVuay5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIHJldC5wdXNoKGNvZGVHZW4ud3JhcChjaHVua1tpXSwgbG9jKSk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIHJldDtcclxuXHQgIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIGNodW5rID09PSAnbnVtYmVyJykge1xyXG5cdCAgICAvLyBIYW5kbGUgcHJpbWl0aXZlcyB0aGF0IHRoZSBTb3VyY2VOb2RlIHdpbGwgdGhyb3cgdXAgb25cclxuXHQgICAgcmV0dXJuIGNodW5rICsgJyc7XHJcblx0ICB9XHJcblx0ICByZXR1cm4gY2h1bms7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBDb2RlR2VuKHNyY0ZpbGUpIHtcclxuXHQgIHRoaXMuc3JjRmlsZSA9IHNyY0ZpbGU7XHJcblx0ICB0aGlzLnNvdXJjZSA9IFtdO1xyXG5cdH1cclxuXHJcblx0Q29kZUdlbi5wcm90b3R5cGUgPSB7XHJcblx0ICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xyXG5cdCAgICByZXR1cm4gIXRoaXMuc291cmNlLmxlbmd0aDtcclxuXHQgIH0sXHJcblx0ICBwcmVwZW5kOiBmdW5jdGlvbiBwcmVwZW5kKHNvdXJjZSwgbG9jKSB7XHJcblx0ICAgIHRoaXMuc291cmNlLnVuc2hpZnQodGhpcy53cmFwKHNvdXJjZSwgbG9jKSk7XHJcblx0ICB9LFxyXG5cdCAgcHVzaDogZnVuY3Rpb24gcHVzaChzb3VyY2UsIGxvYykge1xyXG5cdCAgICB0aGlzLnNvdXJjZS5wdXNoKHRoaXMud3JhcChzb3VyY2UsIGxvYykpO1xyXG5cdCAgfSxcclxuXHJcblx0ICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoKSB7XHJcblx0ICAgIHZhciBzb3VyY2UgPSB0aGlzLmVtcHR5KCk7XHJcblx0ICAgIHRoaXMuZWFjaChmdW5jdGlvbiAobGluZSkge1xyXG5cdCAgICAgIHNvdXJjZS5hZGQoWycgICcsIGxpbmUsICdcXG4nXSk7XHJcblx0ICAgIH0pO1xyXG5cdCAgICByZXR1cm4gc291cmNlO1xyXG5cdCAgfSxcclxuXHJcblx0ICBlYWNoOiBmdW5jdGlvbiBlYWNoKGl0ZXIpIHtcclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0ICAgICAgaXRlcih0aGlzLnNvdXJjZVtpXSk7XHJcblx0ICAgIH1cclxuXHQgIH0sXHJcblxyXG5cdCAgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xyXG5cdCAgICB2YXIgbG9jID0gdGhpcy5jdXJyZW50TG9jYXRpb24gfHwgeyBzdGFydDoge30gfTtcclxuXHQgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKGxvYy5zdGFydC5saW5lLCBsb2Muc3RhcnQuY29sdW1uLCB0aGlzLnNyY0ZpbGUpO1xyXG5cdCAgfSxcclxuXHQgIHdyYXA6IGZ1bmN0aW9uIHdyYXAoY2h1bmspIHtcclxuXHQgICAgdmFyIGxvYyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRoaXMuY3VycmVudExvY2F0aW9uIHx8IHsgc3RhcnQ6IHt9IH0gOiBhcmd1bWVudHNbMV07XHJcblxyXG5cdCAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBTb3VyY2VOb2RlKSB7XHJcblx0ICAgICAgcmV0dXJuIGNodW5rO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBjaHVuayA9IGNhc3RDaHVuayhjaHVuaywgdGhpcywgbG9jKTtcclxuXHJcblx0ICAgIHJldHVybiBuZXcgU291cmNlTm9kZShsb2Muc3RhcnQubGluZSwgbG9jLnN0YXJ0LmNvbHVtbiwgdGhpcy5zcmNGaWxlLCBjaHVuayk7XHJcblx0ICB9LFxyXG5cclxuXHQgIGZ1bmN0aW9uQ2FsbDogZnVuY3Rpb24gZnVuY3Rpb25DYWxsKGZuLCB0eXBlLCBwYXJhbXMpIHtcclxuXHQgICAgcGFyYW1zID0gdGhpcy5nZW5lcmF0ZUxpc3QocGFyYW1zKTtcclxuXHQgICAgcmV0dXJuIHRoaXMud3JhcChbZm4sIHR5cGUgPyAnLicgKyB0eXBlICsgJygnIDogJygnLCBwYXJhbXMsICcpJ10pO1xyXG5cdCAgfSxcclxuXHJcblx0ICBxdW90ZWRTdHJpbmc6IGZ1bmN0aW9uIHF1b3RlZFN0cmluZyhzdHIpIHtcclxuXHQgICAgcmV0dXJuICdcIicgKyAoc3RyICsgJycpLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JykgLy8gUGVyIEVjbWEtMjYyIDcuMyArIDcuOC40XHJcblx0ICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKSArICdcIic7XHJcblx0ICB9LFxyXG5cclxuXHQgIG9iamVjdExpdGVyYWw6IGZ1bmN0aW9uIG9iamVjdExpdGVyYWwob2JqKSB7XHJcblx0ICAgIHZhciBwYWlycyA9IFtdO1xyXG5cclxuXHQgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG5cdCAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdCAgICAgICAgdmFyIHZhbHVlID0gY2FzdENodW5rKG9ialtrZXldLCB0aGlzKTtcclxuXHQgICAgICAgIGlmICh2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHQgICAgICAgICAgcGFpcnMucHVzaChbdGhpcy5xdW90ZWRTdHJpbmcoa2V5KSwgJzonLCB2YWx1ZV0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cclxuXHQgICAgdmFyIHJldCA9IHRoaXMuZ2VuZXJhdGVMaXN0KHBhaXJzKTtcclxuXHQgICAgcmV0LnByZXBlbmQoJ3snKTtcclxuXHQgICAgcmV0LmFkZCgnfScpO1xyXG5cdCAgICByZXR1cm4gcmV0O1xyXG5cdCAgfSxcclxuXHJcblx0ICBnZW5lcmF0ZUxpc3Q6IGZ1bmN0aW9uIGdlbmVyYXRlTGlzdChlbnRyaWVzKSB7XHJcblx0ICAgIHZhciByZXQgPSB0aGlzLmVtcHR5KCk7XHJcblxyXG5cdCAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdCAgICAgIGlmIChpKSB7XHJcblx0ICAgICAgICByZXQuYWRkKCcsJyk7XHJcblx0ICAgICAgfVxyXG5cclxuXHQgICAgICByZXQuYWRkKGNhc3RDaHVuayhlbnRyaWVzW2ldLCB0aGlzKSk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9LFxyXG5cclxuXHQgIGdlbmVyYXRlQXJyYXk6IGZ1bmN0aW9uIGdlbmVyYXRlQXJyYXkoZW50cmllcykge1xyXG5cdCAgICB2YXIgcmV0ID0gdGhpcy5nZW5lcmF0ZUxpc3QoZW50cmllcyk7XHJcblx0ICAgIHJldC5wcmVwZW5kKCdbJyk7XHJcblx0ICAgIHJldC5hZGQoJ10nKTtcclxuXHJcblx0ICAgIHJldHVybiByZXQ7XHJcblx0ICB9XHJcblx0fTtcclxuXHJcblx0ZXhwb3J0c1snZGVmYXVsdCddID0gQ29kZUdlbjtcclxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcclxuXHJcbi8qKiovIH0pXHJcbi8qKioqKiovIF0pXHJcbn0pO1xyXG47IiwiLypcbiAgICBKYXZhU2NyaXB0IGF1dG9Db21wbGV0ZSB2MS4wLjRcbiAgICBDb3B5cmlnaHQgKGMpIDIwMTQgU2ltb24gU3RlaW5iZXJnZXIgLyBQaXhhYmF5XG4gICAgR2l0SHViOiBodHRwczovL2dpdGh1Yi5jb20vUGl4YWJheS9KYXZhU2NyaXB0LWF1dG9Db21wbGV0ZVxuICAgIExpY2Vuc2U6IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4qL1xuXG52YXIgYXV0b0NvbXBsZXRlID0gKGZ1bmN0aW9uKCl7XG4gICAgLy8gXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gYXV0b0NvbXBsZXRlKG9wdGlvbnMpe1xuICAgICAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IpIHJldHVybjtcblxuICAgICAgICAvLyBoZWxwZXJzXG4gICAgICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBjbGFzc05hbWUpeyByZXR1cm4gZWwuY2xhc3NMaXN0ID8gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkgOiBuZXcgUmVnRXhwKCdcXFxcYicrIGNsYXNzTmFtZSsnXFxcXGInKS50ZXN0KGVsLmNsYXNzTmFtZSk7IH1cblxuICAgICAgICBmdW5jdGlvbiBhZGRFdmVudChlbCwgdHlwZSwgaGFuZGxlcil7XG4gICAgICAgICAgICBpZiAoZWwuYXR0YWNoRXZlbnQpIGVsLmF0dGFjaEV2ZW50KCdvbicrdHlwZSwgaGFuZGxlcik7IGVsc2UgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZW1vdmVFdmVudChlbCwgdHlwZSwgaGFuZGxlcil7XG4gICAgICAgICAgICAvLyBpZiAoZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcikgbm90IHdvcmtpbmcgaW4gSUUxMVxuICAgICAgICAgICAgaWYgKGVsLmRldGFjaEV2ZW50KSBlbC5kZXRhY2hFdmVudCgnb24nK3R5cGUsIGhhbmRsZXIpOyBlbHNlIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGl2ZShlbENsYXNzLCBldmVudCwgY2IsIGNvbnRleHQpe1xuICAgICAgICAgICAgYWRkRXZlbnQoY29udGV4dCB8fCBkb2N1bWVudCwgZXZlbnQsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZCwgZWwgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsICYmICEoZm91bmQgPSBoYXNDbGFzcyhlbCwgZWxDbGFzcykpKSBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSBjYi5jYWxsKGVsLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG8gPSB7XG4gICAgICAgICAgICBzZWxlY3RvcjogMCxcbiAgICAgICAgICAgIHNvdXJjZTogMCxcbiAgICAgICAgICAgIG1pbkNoYXJzOiAzLFxuICAgICAgICAgICAgZGVsYXk6IDE1MCxcbiAgICAgICAgICAgIG9mZnNldExlZnQ6IDAsXG4gICAgICAgICAgICBvZmZzZXRUb3A6IDEsXG4gICAgICAgICAgICBjYWNoZTogMSxcbiAgICAgICAgICAgIG1lbnVDbGFzczogJycsXG4gICAgICAgICAgICByZW5kZXJJdGVtOiBmdW5jdGlvbiAoaXRlbSwgc2VhcmNoKXtcbiAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgICAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCIoXCIgKyBzZWFyY2guc3BsaXQoJyAnKS5qb2luKCd8JykgKyBcIilcIiwgXCJnaVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtc3VnZ2VzdGlvblwiIGRhdGEtdmFsPVwiJyArIGl0ZW0gKyAnXCI+JyArIGl0ZW0ucmVwbGFjZShyZSwgXCI8Yj4kMTwvYj5cIikgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24oZSwgdGVybSwgaXRlbSl7fVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBrIGluIG9wdGlvbnMpIHsgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoaykpIG9ba10gPSBvcHRpb25zW2tdOyB9XG5cbiAgICAgICAgLy8gaW5pdFxuICAgICAgICB2YXIgZWxlbXMgPSB0eXBlb2Ygby5zZWxlY3RvciA9PSAnb2JqZWN0JyA/IFtvLnNlbGVjdG9yXSA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoby5zZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSBlbGVtc1tpXTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHN1Z2dlc3Rpb25zIGNvbnRhaW5lciBcInNjXCJcbiAgICAgICAgICAgIHRoYXQuc2MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoYXQuc2MuY2xhc3NOYW1lID0gJ2F1dG9jb21wbGV0ZS1zdWdnZXN0aW9ucyAnK28ubWVudUNsYXNzO1xuXG4gICAgICAgICAgICB0aGF0LmF1dG9jb21wbGV0ZUF0dHIgPSB0aGF0LmdldEF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJyk7XG4gICAgICAgICAgICB0aGF0LnNldEF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJywgJ29mZicpO1xuICAgICAgICAgICAgdGhhdC5jYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhhdC5sYXN0X3ZhbCA9ICcnO1xuXG4gICAgICAgICAgICB0aGF0LnVwZGF0ZVNDID0gZnVuY3Rpb24ocmVzaXplLCBuZXh0KXtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IHRoYXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhhdC5zYy5zdHlsZS5sZWZ0ID0gTWF0aC5yb3VuZChyZWN0LmxlZnQgKyAod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KSArIG8ub2Zmc2V0TGVmdCkgKyAncHgnO1xuICAgICAgICAgICAgICAgIHRoYXQuc2Muc3R5bGUudG9wID0gTWF0aC5yb3VuZChyZWN0LmJvdHRvbSArICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkgKyBvLm9mZnNldFRvcCkgKyAncHgnO1xuICAgICAgICAgICAgICAgIHRoYXQuc2Muc3R5bGUud2lkdGggPSBNYXRoLnJvdW5kKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpICsgJ3B4JzsgLy8gb3V0ZXJXaWR0aFxuICAgICAgICAgICAgICAgIGlmICghcmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2Muc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC5zYy5tYXhIZWlnaHQpIHsgdGhhdC5zYy5tYXhIZWlnaHQgPSBwYXJzZUludCgod2luZG93LmdldENvbXB1dGVkU3R5bGUgPyBnZXRDb21wdXRlZFN0eWxlKHRoYXQuc2MsIG51bGwpIDogdGhhdC5zYy5jdXJyZW50U3R5bGUpLm1heEhlaWdodCk7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0LnNjLnN1Z2dlc3Rpb25IZWlnaHQpIHRoYXQuc2Muc3VnZ2VzdGlvbkhlaWdodCA9IHRoYXQuc2MucXVlcnlTZWxlY3RvcignLmF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uJykub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5zYy5zdWdnZXN0aW9uSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0KSB0aGF0LnNjLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NyVG9wID0gdGhhdC5zYy5zY3JvbGxUb3AsIHNlbFRvcCA9IG5leHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhhdC5zYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbFRvcCArIHRoYXQuc2Muc3VnZ2VzdGlvbkhlaWdodCAtIHRoYXQuc2MubWF4SGVpZ2h0ID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zYy5zY3JvbGxUb3AgPSBzZWxUb3AgKyB0aGF0LnNjLnN1Z2dlc3Rpb25IZWlnaHQgKyBzY3JUb3AgLSB0aGF0LnNjLm1heEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxUb3AgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNjLnNjcm9sbFRvcCA9IHNlbFRvcCArIHNjclRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRFdmVudCh3aW5kb3csICdyZXNpemUnLCB0aGF0LnVwZGF0ZVNDKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhhdC5zYyk7XG5cbiAgICAgICAgICAgIGxpdmUoJ2F1dG9jb21wbGV0ZS1zdWdnZXN0aW9uJywgJ21vdXNlbGVhdmUnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsID0gdGhhdC5zYy5xdWVyeVNlbGVjdG9yKCcuYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb24uc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsKSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IHNlbC5jbGFzc05hbWUgPSBzZWwuY2xhc3NOYW1lLnJlcGxhY2UoJ3NlbGVjdGVkJywgJycpOyB9LCAyMCk7XG4gICAgICAgICAgICB9LCB0aGF0LnNjKTtcblxuICAgICAgICAgICAgbGl2ZSgnYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb24nLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbCA9IHRoYXQuc2MucXVlcnlTZWxlY3RvcignLmF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uLnNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCkgc2VsLmNsYXNzTmFtZSA9IHNlbC5jbGFzc05hbWUucmVwbGFjZSgnc2VsZWN0ZWQnLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgKz0gJyBzZWxlY3RlZCc7XG4gICAgICAgICAgICB9LCB0aGF0LnNjKTtcblxuICAgICAgICAgICAgbGl2ZSgnYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb24nLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHRoaXMsICdhdXRvY29tcGxldGUtc3VnZ2VzdGlvbicpKSB7IC8vIGVsc2Ugb3V0c2lkZSBjbGlja1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICAgICAgby5vblNlbGVjdChlLCB2LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zYy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoYXQuc2MpO1xuXG4gICAgICAgICAgICB0aGF0LmJsdXJIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB0cnkgeyB2YXIgb3Zlcl9zYiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hdXRvY29tcGxldGUtc3VnZ2VzdGlvbnM6aG92ZXInKTsgfSBjYXRjaChlKXsgdmFyIG92ZXJfc2IgPSAwOyB9XG4gICAgICAgICAgICAgICAgaWYgKCFvdmVyX3NiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQubGFzdF92YWwgPSB0aGF0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNjLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdGhhdC5zYy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9LCAzNTApOyAvLyBoaWRlIHN1Z2dlc3Rpb25zIG9uIGZhc3QgaW5wdXRcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdGhhdC5mb2N1cygpOyB9LCAyMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkRXZlbnQodGhhdCwgJ2JsdXInLCB0aGF0LmJsdXJIYW5kbGVyKTtcblxuICAgICAgICAgICAgdmFyIHN1Z2dlc3QgPSBmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhhdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGF0LmNhY2hlW3ZhbF0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAmJiB2YWwubGVuZ3RoID49IG8ubWluQ2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wO2k8ZGF0YS5sZW5ndGg7aSsrKSBzICs9IG8ucmVuZGVySXRlbShkYXRhW2ldLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNjLmlubmVySFRNTCA9IHM7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQudXBkYXRlU0MoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zYy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LmtleWRvd25IYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHdpbmRvdy5ldmVudCA/IGUua2V5Q29kZSA6IGUud2hpY2g7XG4gICAgICAgICAgICAgICAgLy8gZG93biAoNDApLCB1cCAoMzgpXG4gICAgICAgICAgICAgICAgaWYgKChrZXkgPT0gNDAgfHwga2V5ID09IDM4KSAmJiB0aGF0LnNjLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCwgc2VsID0gdGhhdC5zYy5xdWVyeVNlbGVjdG9yKCcuYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb24uc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSAoa2V5ID09IDQwKSA/IHRoYXQuc2MucXVlcnlTZWxlY3RvcignLmF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uJykgOiB0aGF0LnNjLmNoaWxkTm9kZXNbdGhhdC5zYy5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdOyAvLyBmaXJzdCA6IGxhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuY2xhc3NOYW1lICs9ICcgc2VsZWN0ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC52YWx1ZSA9IG5leHQuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IChrZXkgPT0gNDApID8gc2VsLm5leHRTaWJsaW5nIDogc2VsLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmNsYXNzTmFtZSA9IHNlbC5jbGFzc05hbWUucmVwbGFjZSgnc2VsZWN0ZWQnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5jbGFzc05hbWUgKz0gJyBzZWxlY3RlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC52YWx1ZSA9IG5leHQuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IHNlbC5jbGFzc05hbWUgPSBzZWwuY2xhc3NOYW1lLnJlcGxhY2UoJ3NlbGVjdGVkJywgJycpOyB0aGF0LnZhbHVlID0gdGhhdC5sYXN0X3ZhbDsgbmV4dCA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZVNDKDAsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzY1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PSAyNykgeyB0aGF0LnZhbHVlID0gdGhhdC5sYXN0X3ZhbDsgdGhhdC5zYy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9XG4gICAgICAgICAgICAgICAgLy8gZW50ZXJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT0gMTMgfHwga2V5ID09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbCA9IHRoYXQuc2MucXVlcnlTZWxlY3RvcignLmF1dG9jb21wbGV0ZS1zdWdnZXN0aW9uLnNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwgJiYgdGhhdC5zYy5zdHlsZS5kaXNwbGF5ICE9ICdub25lJykgeyBvLm9uU2VsZWN0KGUsIHNlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdmFsJyksIHNlbCk7IHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgdGhhdC5zYy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9LCAyMCk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWRkRXZlbnQodGhhdCwgJ2tleWRvd24nLCB0aGF0LmtleWRvd25IYW5kbGVyKTtcblxuICAgICAgICAgICAgdGhhdC5rZXl1cEhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gd2luZG93LmV2ZW50ID8gZS5rZXlDb2RlIDogZS53aGljaDtcbiAgICAgICAgICAgICAgICBpZiAoIWtleSB8fCAoa2V5IDwgMzUgfHwga2V5ID4gNDApICYmIGtleSAhPSAxMyAmJiBrZXkgIT0gMjcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHRoYXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoID49IG8ubWluQ2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT0gdGhhdC5sYXN0X3ZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubGFzdF92YWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoYXQudGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgaW4gdGhhdC5jYWNoZSkgeyBzdWdnZXN0KHRoYXQuY2FjaGVbdmFsXSk7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyByZXF1ZXN0cyBpZiBwcmV2aW91cyBzdWdnZXN0aW9ucyB3ZXJlIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MTsgaTx2YWwubGVuZ3RoLW8ubWluQ2hhcnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSB2YWwuc2xpY2UoMCwgdmFsLmxlbmd0aC1pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0IGluIHRoYXQuY2FjaGUgJiYgIXRoYXQuY2FjaGVbcGFydF0ubGVuZ3RoKSB7IHN1Z2dlc3QoW10pOyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpeyBvLnNvdXJjZSh2YWwsIHN1Z2dlc3QpIH0sIG8uZGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5sYXN0X3ZhbCA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2Muc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhZGRFdmVudCh0aGF0LCAna2V5dXAnLCB0aGF0LmtleXVwSGFuZGxlcik7XG5cbiAgICAgICAgICAgIHRoYXQuZm9jdXNIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgdGhhdC5sYXN0X3ZhbCA9ICdcXG4nO1xuICAgICAgICAgICAgICAgIHRoYXQua2V5dXBIYW5kbGVyKGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFvLm1pbkNoYXJzKSBhZGRFdmVudCh0aGF0LCAnZm9jdXMnLCB0aGF0LmZvY3VzSGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwdWJsaWMgZGVzdHJveSBtZXRob2RcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gZWxlbXNbaV07XG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQod2luZG93LCAncmVzaXplJywgdGhhdC51cGRhdGVTQyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGhhdCwgJ2JsdXInLCB0aGF0LmJsdXJIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudCh0aGF0LCAnZm9jdXMnLCB0aGF0LmZvY3VzSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGhhdCwgJ2tleWRvd24nLCB0aGF0LmtleWRvd25IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudCh0aGF0LCAna2V5dXAnLCB0aGF0LmtleXVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuYXV0b2NvbXBsZXRlQXR0cilcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRBdHRyaWJ1dGUoJ2F1dG9jb21wbGV0ZScsIHRoYXQuYXV0b2NvbXBsZXRlQXR0cik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGF0LnJlbW92ZUF0dHJpYnV0ZSgnYXV0b2NvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGF0LnNjKTtcbiAgICAgICAgICAgICAgICB0aGF0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGF1dG9Db21wbGV0ZTtcbn0pKCk7XG5cbihmdW5jdGlvbigpe1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG4gICAgICAgIGRlZmluZSgnYXV0b0NvbXBsZXRlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gYXV0b0NvbXBsZXRlOyB9KTtcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhdXRvQ29tcGxldGU7XG4gICAgZWxzZVxuICAgICAgICB3aW5kb3cuYXV0b0NvbXBsZXRlID0gYXV0b0NvbXBsZXRlO1xufSkoKTtcbiIsIi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG5cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGR0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHR2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0ICAgXHJcblx0JChmdW5jdGlvbiAoKSB7XHJcblxyXG5cdCAgICBsZXQgaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgXHJcblx0ICAgICAgICBkdC5pbml0KCk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGluaXQoKTsgICAgICBcclxuXHQgICBcclxuXHQgICAgXHJcblx0fSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRsZXQgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0bGV0IF9kdCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblx0bGV0IF9kdEV2ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuXHRsZXQgX2hoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KVxyXG5cdGxldCBfaGhfaGVscGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblx0bGV0IF9zZXJ2aWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblx0bGV0IHNlcnZpY2VjYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcblx0bGV0IGFwcHNldHRpbmdzb2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHRsZXQgYXBwc2V0dGluZ3MgPSBhcHBzZXR0aW5nc29iamVjdC5jb25maWc7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLmNhY2hlRG9tKCk7XHJcblx0ICAgICAgICB0aGlzLmJpbmRFdmVudCgpO1xyXG5cdCAgICAgICAgdGhpcy5FdmVudEhhbmRsZXIoKTtcclxuXHQgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcblx0ICAgIH0sXHJcblx0ICAgIGNhY2hlRG9tOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICB0aGlzLiRib2R5ID0gJCgnYm9keScpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfbGlzdGF0b0FwcHJvdmUgPSAkKFwiI2JiX2FqX2xpc3RhdG9BcHByb3ZlXCIpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfbGlzdGFBbGxhID0gJChcIiNiYl9hal9saXN0YUFsbGFcIik7XHJcblx0ICAgICAgICB0aGlzLiRiYl9hal9ib2t0aXBzQWRtaW5MaXN0ID0gJChcIiNiYl9hal9ib2t0aXBzQWRtaW5MaXN0XCIpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdCA9ICQoXCIjYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdFwiKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmluZEV2ZW50OiBmdW5jdGlvbiAodXNlcmlkKSB7XHJcblx0ICAgICAgICBsZXQgdGhhdCA9IHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnI2JiX2FqX2xpc3RhQWxsYScsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcyhcIm5vdC1hY3RpdmVcIik7XHJcblx0ICAgICAgICAgICAgdGhhdC4kYmJfYWpfbGlzdGF0b0FwcHJvdmUucmVtb3ZlQ2xhc3MoXCJub3QtYWN0aXZlXCIpO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LiRiYl9hal9ib2t0aXBzQWRtaW5MaXN0LmhpZGUoKTtcclxuXHQgICAgICAgICAgICBsZXQgZGF0YXRhYmxlcyA9IHRoYXQuJGJiX2FqX2Jva3RpcHNBZG1pbkxpc3QuRGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgZGF0YXRhYmxlcy5kZXN0cm95KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgdGhhdC5zZXJ2aWNlSGFuZGxlcihcIiNiYl9hal9ib2t0aXBzQWRtaW5BTExMaXN0XCIsIGFwcHNldHRpbmdzLmFwaS5ib2t0aXBzbGlzdG9yLmdldGJva3RpcHNsaXN0QWxsKCksIGZ1bmN0aW9uKCl7XHJcblx0ICAgICAgICAgICAgICAgIHRoYXQuJGJiX2FqX2Jva3RpcHNBZG1pbkFMTExpc3Quc2hvdygpO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnI2JiX2FqX2xpc3RhdG9BcHByb3ZlJywgZnVuY3Rpb24gKGUpIHsgICAgICAgIFxyXG5cdCAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJub3QtYWN0aXZlXCIpO1xyXG5cdCAgICAgICAgICAgIHRoYXQuJGJiX2FqX2xpc3RhQWxsYS5yZW1vdmVDbGFzcyhcIm5vdC1hY3RpdmVcIik7XHJcblx0ICAgICAgICAgICAgdGhhdC4kYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdC5oaWRlKCk7XHJcblxyXG5cdCAgICAgICAgICAgIGxldCBkYXRhdGFibGVzID0gdGhhdC4kYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdC5EYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICBkYXRhdGFibGVzLmRlc3Ryb3koKTsgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB0aGF0LnNlcnZpY2VIYW5kbGVyKFwiI2JiX2FqX2Jva3RpcHNBZG1pbkxpc3RcIiwgYXBwc2V0dGluZ3MuYXBpLmJva3RpcHNsaXN0b3IuZ2V0Ym9rdGlwc2xpc3RUb0FwcHJvdmUoKSwgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LiRiYl9hal9ib2t0aXBzQWRtaW5MaXN0LnNob3coKTtcclxuXHQgICAgICAgICAgICB9KTsgICAgICAgICAgIFxyXG5cdCAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJyNiYl9hal9EZWxldGVib2t0aXBzJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgaWQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtdGlwaWQnKTtcclxuXHJcblx0ICAgICAgICAgICAgc2VydmljZWNhbGwuZGVsZXRldGlwKGlkLCBmdW5jdGlvbiAoaXNvaykge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZXRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICQoXCIjYmJfYWpfbW9kYWxDb250YWluZXJcIikuaGlkZSgpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJyNiYl9hal9TYXZlYm9rdGlwcycsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgbGV0IGlkID0gJCh0aGlzKS5hdHRyKCdkYXRhLXRpcGlkJyk7XHJcblx0ICAgICAgICAgICAgbGV0IHJ1YiA9ICQoXCIjYmJfYWpfc2F2ZUJva3RpcFJ1YnJpa1wiKS5odG1sKCk7XHJcblx0ICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0aW55TUNFLmFjdGl2ZUVkaXRvci5nZXRDb250ZW50KCk7XHJcblxyXG5cdCAgICAgICAgICAgIHNlcnZpY2VjYWxsLnNhdmV0aXAoaWQsIHJ1YiwgY29udGVudCwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgICAgIHRoYXQudXBkYXRldGFibGUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAkKFwiI2JiX2FqX21vZGFsQ29udGFpbmVyXCIpLmhpZGUoKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfSxcclxuXHQgICAgRXZlbnRIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBfZHRFdmVudC5pbml0KCk7XHJcblx0ICAgICAgICBfaGhfaGVscGVyLmluaXQoKTtcclxuXHQgICAgfSxcclxuXHQgICAgdXBkYXRldGFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0ICAgICAgICBsZXQgdmFsZGxpc3QsIHVybGVuLCBjc3NkaXY7XHJcblx0ICAgICAgICBpZiAodGhpcy4kYmJfYWpfYm9rdGlwc0FkbWluTGlzdC5pcygnOnZpc2libGUnKSkge1xyXG5cdCAgICAgICAgICAgIHZhbGRsaXN0ID0gdGhpcy4kYmJfYWpfYm9rdGlwc0FkbWluTGlzdDtcclxuXHQgICAgICAgICAgICB1cmxlbiA9IGFwcHNldHRpbmdzLmFwaS5ib2t0aXBzbGlzdG9yLmdldGJva3RpcHNsaXN0VG9BcHByb3ZlKCk7XHJcblx0ICAgICAgICAgICAgY3NzZGl2ID0gXCIjYmJfYWpfYm9rdGlwc0FkbWluTGlzdFwiXHJcblx0ICAgICAgICAgICAgXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICBpZiAodGhpcy4kYmJfYWpfYm9rdGlwc0FkbWluQUxMTGlzdC5pcygnOnZpc2libGUnKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YWxkbGlzdCA9IHRoaXMuJGJiX2FqX2Jva3RpcHNBZG1pbkFMTExpc3RcclxuXHQgICAgICAgICAgICAgICAgdXJsZW4gPSBhcHBzZXR0aW5ncy5hcGkuYm9rdGlwc2xpc3Rvci5nZXRib2t0aXBzbGlzdEFsbCgpO1xyXG5cdCAgICAgICAgICAgICAgICBjc3NkaXYgPSBcIiNiYl9hal9ib2t0aXBzQWRtaW5BTExMaXN0XCIgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH07ICAgICAgXHJcblx0ICAgICAgIFxyXG5cdCAgICAgICAgbGV0IGRhdGF0YWJsZXMgPSB2YWxkbGlzdC5EYXRhVGFibGUoKTtcclxuXHQgICAgICAgIGRhdGF0YWJsZXMuZGVzdHJveSgpO1xyXG5cdCAgICAgICAgdmFsZGxpc3QuaGlkZSgpO1xyXG5cdCAgICAgICAgdGhpcy5zZXJ2aWNlSGFuZGxlcihjc3NkaXYsIHVybGVuLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgdmFsZGxpc3Quc2hvdygpO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgIH0sXHJcblx0ICAgIHNlcnZpY2VIYW5kbGVyOiBmdW5jdGlvbiAoY3NzU2VsZWN0b3IsdXJsLCBjYWxsYmFjaykge1xyXG5cdCAgICAgICAgLy9sZXQganNvbmRhdGFwcm9taXNlID0gX3NlcnZpY2UuZ2V0anNvbmRhdGEoJ2h0dHBzOi8vd3d3Mi5iYXJuZW5zYmlibGlvdGVrLnNlL0FwaV92My4xL2Jva3RpcHMvdHlwL0J5VXNlcklkL3ZhbC83MDE3L3R4dHZhbC8wL2RldmtleS9hbGYvP3R5cGU9anNvbicpO1xyXG5cdCAgICAgICAgbGV0IGpzb25kYXRhcHJvbWlzZSA9IF9zZXJ2aWNlLmdldGpzb25kYXRhKHVybCk7XHJcblxyXG5cdCAgICAgICAganNvbmRhdGFwcm9taXNlLnRoZW4oanNvbmRhdGEgPT4ge1xyXG5cclxuXHQgICAgICAgICAgICBhcHBzZXR0aW5ncy5kYXRhc2V0LmN1cnJlbnRkYXRhbGlzdCA9IGpzb25kYXRhO1xyXG5cclxuXHQgICAgICAgICAgICBfaGguaW5qZWN0aHRtbHRlbXBsYXRlKGNzc1NlbGVjdG9yLCBhcHBzZXR0aW5ncy5oYW5kbGViYXJ0ZW1wbGF0ZS5oYl9ib29rdGlwTGlzdF90bXAsIGpzb25kYXRhLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZnVua2FyMTpcIiArIGFwcHNldHRpbmdzLmRhdGFzZXQuY3VycmVudGRhdGFsaXN0KTtcclxuXHQgICAgICAgICAgICAgICAgX2R0LlJ1bkRhdGFUYWJsZShjc3NTZWxlY3Rvcik7XHJcblx0ICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZnVua2FyMjpcIiArIGFwcHNldHRpbmdzLmRhdGFzZXQuY3VycmVudGRhdGFsaXN0KTtcclxuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH0pOyAgICBcclxuXHQgICAgfSxcclxuXHQgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIHRoaXMuc2VydmljZUhhbmRsZXIoXCIjYmJfYWpfYm9rdGlwc0FkbWluTGlzdFwiLCBhcHBzZXR0aW5ncy5hcGkuYm9rdGlwc2xpc3Rvci5nZXRib2t0aXBzbGlzdFRvQXBwcm92ZSgpLCBmdW5jdGlvbiAoKSB7IH0pO1xyXG5cdCAgICAgICAgLy90aGlzLnNlcnZpY2VIYW5kbGVyKFwiI2JiX2FqX2Jva3RpcHNBZG1pbkFMTExpc3RcIiwgYXBwc2V0dGluZ3MuYXBpLmJva3RpcHNsaXN0b3IuZ2V0Ym9rdGlwc2xpc3RBbGwoKSk7XHJcblx0ICAgIH1cclxuXHR9XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiFcblx0ICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My4zLjFcblx0ICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuXHQgKlxuXHQgKiBJbmNsdWRlcyBTaXp6bGUuanNcblx0ICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG5cdCAqXG5cdCAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcblx0ICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG5cdCAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG5cdCAqXG5cdCAqIERhdGU6IDIwMTgtMDEtMjBUMTc6MjRaXG5cdCAqL1xuXHQoIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0XHRcInVzZSBzdHJpY3RcIjtcblxuXHRcdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgYHdpbmRvd2Bcblx0XHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdFx0Ly8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHMuXG5cdFx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdFx0Ly8gU2VlIHRpY2tldCAjMTQ1NDkgZm9yIG1vcmUgaW5mby5cblx0XHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0XHRmdW5jdGlvbiggdyApIHtcblx0XHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0XHR9XG5cblx0Ly8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcblx0fSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cblx0Ly8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG5cdC8vIHRocm93IGV4Y2VwdGlvbnMgd2hlbiBub24tc3RyaWN0IGNvZGUgKGUuZy4sIEFTUC5ORVQgNC41KSBhY2Nlc3NlcyBzdHJpY3QgbW9kZVxuXHQvLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuXHQvLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGFyciA9IFtdO1xuXG5cdHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXHR2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cblx0dmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG5cdHZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG5cdHZhciBwdXNoID0gYXJyLnB1c2g7XG5cblx0dmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxuXHR2YXIgY2xhc3MydHlwZSA9IHt9O1xuXG5cdHZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cblx0dmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0dmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cblx0dmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxuXHR2YXIgc3VwcG9ydCA9IHt9O1xuXG5cdHZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG5cdCAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcblx0ICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG5cdCAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG5cdCAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cblx0ICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuXHQgIH07XG5cblxuXHR2YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0XHR9O1xuXG5cblxuXG5cdFx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0XHR0eXBlOiB0cnVlLFxuXHRcdFx0c3JjOiB0cnVlLFxuXHRcdFx0bm9Nb2R1bGU6IHRydWVcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jLCBub2RlICkge1xuXHRcdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdFx0aWYgKCBub2RlICkge1xuXHRcdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdFx0aWYgKCBub2RlWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHRbIGkgXSA9IG5vZGVbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0XHR9XG5cblxuXHRmdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0XHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0XHR0eXBlb2Ygb2JqO1xuXHR9XG5cdC8qIGdsb2JhbCBTeW1ib2wgKi9cblx0Ly8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcblx0Ly8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cblx0dmFyXG5cdFx0dmVyc2lvbiA9IFwiMy4zLjFcIixcblxuXHRcdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdFx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0XHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0XHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuXHRqUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdFx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRcdGpxdWVyeTogdmVyc2lvbixcblxuXHRcdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0XHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0XHRsZW5ndGg6IDAsXG5cblx0XHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fSxcblxuXHRcdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0XHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRcdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdFx0fSxcblxuXHRcdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0XHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0XHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXHRcdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdFx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHRcdH0sXG5cblx0XHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0XHR9ICkgKTtcblx0XHR9LFxuXG5cdFx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0XHR9LFxuXG5cdFx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0XHR9LFxuXG5cdFx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0XHR9LFxuXG5cdFx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHRcdH0sXG5cblx0XHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdFx0fSxcblxuXHRcdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0XHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0XHRwdXNoOiBwdXNoLFxuXHRcdHNvcnQ6IGFyci5zb3J0LFxuXHRcdHNwbGljZTogYXJyLnNwbGljZVxuXHR9O1xuXG5cdGpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0XHRpID0gMSxcblx0XHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRkZWVwID0gZmFsc2U7XG5cblx0XHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdFx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRcdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0XHR0YXJnZXQgPSB7fTtcblx0XHR9XG5cblx0XHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0XHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0XHRpLS07XG5cdFx0fVxuXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KCBzcmMgKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHRqUXVlcnkuZXh0ZW5kKCB7XG5cblx0XHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0XHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdFx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0XHRpc1JlYWR5OiB0cnVlLFxuXG5cdFx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHRcdH0sXG5cblx0XHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdFx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdFx0fSxcblxuXHRcdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHRcdHZhciBuYW1lO1xuXG5cdFx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdFx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0XHRET01FdmFsKCBjb2RlICk7XG5cdFx0fSxcblxuXHRcdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdFx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHRcdH0sXG5cblx0XHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdFx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSxcblxuXHRcdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRcdGogPSAwLFxuXHRcdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0XHR9XG5cblx0XHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRcdHJldHVybiBmaXJzdDtcblx0XHR9LFxuXG5cdFx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlcztcblx0XHR9LFxuXG5cdFx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdFx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdHJldCA9IFtdO1xuXG5cdFx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdFx0fSxcblxuXHRcdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRcdGd1aWQ6IDEsXG5cblx0XHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0XHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRcdHN1cHBvcnQ6IHN1cHBvcnRcblx0fSApO1xuXG5cdGlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xuXHR9XG5cblx0Ly8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5cdGpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHR9ICk7XG5cblx0ZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0XHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdFx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdFx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHRcdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcblx0fVxuXHR2YXIgU2l6emxlID1cblx0LyohXG5cdCAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuXHQgKiBodHRwczovL3NpenpsZWpzLmNvbS9cblx0ICpcblx0ICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcblx0ICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG5cdCAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2Vcblx0ICpcblx0ICogRGF0ZTogMjAxNi0wOC0wOFxuXHQgKi9cblx0KGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cblx0dmFyIGksXG5cdFx0c3VwcG9ydCxcblx0XHRFeHByLFxuXHRcdGdldFRleHQsXG5cdFx0aXNYTUwsXG5cdFx0dG9rZW5pemUsXG5cdFx0Y29tcGlsZSxcblx0XHRzZWxlY3QsXG5cdFx0b3V0ZXJtb3N0Q29udGV4dCxcblx0XHRzb3J0SW5wdXQsXG5cdFx0aGFzRHVwbGljYXRlLFxuXG5cdFx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRcdHNldERvY3VtZW50LFxuXHRcdGRvY3VtZW50LFxuXHRcdGRvY0VsZW0sXG5cdFx0ZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmJ1Z2d5UVNBLFxuXHRcdHJidWdneU1hdGNoZXMsXG5cdFx0bWF0Y2hlcyxcblx0XHRjb250YWlucyxcblxuXHRcdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0XHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRcdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0XHRkaXJydW5zID0gMCxcblx0XHRkb25lID0gMCxcblx0XHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0XHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0XHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0XHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwO1xuXHRcdH0sXG5cblx0XHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdFx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0XHRhcnIgPSBbXSxcblx0XHRwb3AgPSBhcnIucG9wLFxuXHRcdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdFx0cHVzaCA9IGFyci5wdXNoLFxuXHRcdHNsaWNlID0gYXJyLnNsaWNlLFxuXHRcdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHRcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0XHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH0sXG5cblx0XHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHRcdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdFx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRcdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0XHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0XHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqXFxcXF1cIixcblxuXHRcdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcdFwiLipcIiArXG5cdFx0XHRcIilcXFxcKXwpXCIsXG5cblx0XHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdFx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdFx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdFx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdFx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0XHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdFx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0XHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0XHRtYXRjaEV4cHIgPSB7XG5cdFx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFx0XCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHRcdC8vIEZvciB1c2UgaW4gbGlicmFyaWVzIGltcGxlbWVudGluZyAuaXMoKVxuXHRcdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdFx0fSxcblxuXHRcdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRcdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0XHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHRcdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRcdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRcdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdFx0Ly8gQ1NTIGVzY2FwZXNcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdFx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0XHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZWQgLSAweDEwMDAwO1xuXHRcdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHRcdC8vIFdvcmthcm91bmQgZXJyb25lb3VzIG51bWVyaWMgaW50ZXJwcmV0YXRpb24gb2YgK1wiMHhcIlxuXHRcdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0XHRlc2NhcGVkIDpcblx0XHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0XHQvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcblx0XHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0XHR9LFxuXG5cdFx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0XHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdFx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHRcdH0sXG5cblx0XHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdFx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0XHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0XHQvLyBlcnJvciBpbiBJRVxuXHRcdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHNldERvY3VtZW50KCk7XG5cdFx0fSxcblxuXHRcdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIChcImZvcm1cIiBpbiBlbGVtIHx8IFwibGFiZWxcIiBpbiBlbGVtKTtcblx0XHRcdH0sXG5cdFx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHRcdCk7XG5cblx0Ly8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcblx0dHJ5IHtcblx0XHRwdXNoLmFwcGx5KFxuXHRcdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0XHQpO1xuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRcdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0XHR9IDpcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0XHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0XHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH1cblxuXHRcdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0XHRpZiAoICFzZWVkICkge1xuXG5cdFx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHRcdC8vIHFTQSBsb29rcyBvdXRzaWRlIEVsZW1lbnQgY29udGV4dCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudFxuXHRcdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFsbCBvdGhlcnNcblx0XHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcblx0ICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuXHQgKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcblx0ICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHRcdHZhciBrZXlzID0gW107XG5cblx0XHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cdFx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRcdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRcdHJldHVybiBmbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG5cdCAqL1xuXHRmdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRcdGVsID0gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0XHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdFx0aSA9IGFyci5sZW5ndGg7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gYVxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGJcblx0ICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG5cdCAqL1xuXHRmdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdFx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdFx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdFx0aWYgKCBkaWZmICkge1xuXHRcdFx0cmV0dXJuIGRpZmY7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0XHRpZiAoIGN1ciApIHtcblx0XHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XG5cdFx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBhID8gMSA6IC0xO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzYWJsZWQgdHJ1ZSBmb3IgOmRpc2FibGVkOyBmYWxzZSBmb3IgOmVuYWJsZWRcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHRcdC8vIEtub3duIDpkaXNhYmxlZCBmYWxzZSBwb3NpdGl2ZXM6IGZpZWxkc2V0W2Rpc2FibGVkXSA+IGxlZ2VuZDpudGgtb2YtdHlwZShuKzIpIDpjYW4tZGlzYWJsZVxuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWVuYWJsZWRcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGluaGVyaXRlZCBkaXNhYmxlZG5lc3Mgb24gcmVsZXZhbnQgbm9uLWRpc2FibGVkIGVsZW1lbnRzOlxuXHRcdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LWZlLWRpc2FibGVkXG5cdFx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHRcdC8vIEFsbCBzdWNoIGVsZW1lbnRzIGhhdmUgYSBcImZvcm1cIiBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uaXNEaXNhYmxlZCA9PT0gZGlzYWJsZWQgfHxcblxuXHRcdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdFx0ZWxlbS5pc0Rpc2FibGVkICE9PSAhZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0dmFyIGosXG5cdFx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcblx0ICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcblx0ICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG5cdCAqL1xuXHRmdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0XHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xuXHR9XG5cblx0Ly8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2Vcblx0c3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cblx0LyoqXG5cdCAqIERldGVjdHMgWE1MIG5vZGVzXG5cdCAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcblx0ICovXG5cdGlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHRcdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHRcdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRcdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuXHQgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG5cdCAqL1xuXHRzZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHRcdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0XHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRcdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0XHRkb2N1bWVudCA9IGRvYztcblx0XHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRcdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHRcdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0XHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyogQXR0cmlidXRlc1xuXHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0XHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0XHR9KTtcblxuXHRcdC8qIGdldEVsZW1lbnQocylCeSpcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0XHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdFx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHRcdH0pO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8MTBcblx0XHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0XHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0XHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0XHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0XHR9KTtcblxuXHRcdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRcdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFRhZ1xuXHRcdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IDpcblxuXHRcdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0fTtcblxuXHRcdC8vIENsYXNzXG5cdFx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0XHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0XHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRcdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHRcdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdFx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdFx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHRcdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdFx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRcdHJidWdneVFTQSA9IFtdO1xuXG5cdFx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0XHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdFx0LyogQ29udGFpbnNcblx0XHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdFx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdFx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdFx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdFx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0XHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdFx0KSk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXG5cdFx0LyogU29ydGluZ1xuXHRcdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHRcdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0XHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHRcdDE7XG5cblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHRcdDA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdXIsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0XHRjdXIgPSBhO1xuXHRcdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHRcdH1cblx0XHRcdGN1ciA9IGI7XG5cdFx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRcdGkrKztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGkgP1xuXHRcdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdFx0MDtcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9O1xuXG5cdFNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRcdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG5cdH07XG5cblx0U2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRcdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXG5cdFx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdFx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdFx0IWNvbXBpbGVyQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcblx0fTtcblxuXHRTaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0XHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0XHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcblx0fTtcblxuXHRTaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRcdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0fVxuXG5cdFx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cblx0XHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0dmFsIDpcblx0XHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0XHRudWxsO1xuXHR9O1xuXG5cdFNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRcdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHR9O1xuXG5cdFNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcblx0ICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcblx0ICovXG5cdFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRcdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdFx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdFx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRcdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRcdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fTtcblxuXHQvKipcblx0ICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcblx0ICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG5cdCAqL1xuXHRnZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbm9kZSxcblx0XHRcdHJldCA9IFwiXCIsXG5cdFx0XHRpID0gMCxcblx0XHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdGlmICggIW5vZGVUeXBlICkge1xuXHRcdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdFx0fVxuXHRcdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdFx0cmV0dXJuIHJldDtcblx0fTtcblxuXHRFeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHRcdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRcdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRcdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdFx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRcdGF0dHJIYW5kbGU6IHt9LFxuXG5cdFx0ZmluZDoge30sXG5cblx0XHRyZWxhdGl2ZToge1xuXHRcdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdFx0fSxcblxuXHRcdHByZUZpbHRlcjoge1xuXHRcdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHRcdH0sXG5cblx0XHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQqL1xuXHRcdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9LFxuXG5cdFx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRmaWx0ZXI6IHtcblxuXHRcdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9LFxuXG5cdFx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cblx0XHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblxuXHRcdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0fSA6XG5cblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZuO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRwc2V1ZG9zOiB7XG5cdFx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9KSxcblxuXHRcdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdFx0fTtcblx0XHRcdH0pLFxuXG5cdFx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHRcdH07XG5cdFx0XHR9KSxcblxuXHRcdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSksXG5cblx0XHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdFx0fSxcblxuXHRcdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHRcdH0sXG5cblx0XHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdFx0fSxcblxuXHRcdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDb250ZW50c1xuXHRcdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0XHR9LFxuXG5cdFx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0XHR9LFxuXG5cdFx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0XHR9LFxuXG5cdFx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBhdHRyO1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdFx0fSksXG5cblx0XHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdFx0fSksXG5cblx0XHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0XHR9KSxcblxuXHRcdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHRcdH0pLFxuXG5cdFx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0XHR9KSxcblxuXHRcdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdFx0fSksXG5cblx0XHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0XHR9KVxuXHRcdH1cblx0fTtcblxuXHRFeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuXHQvLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuXHRmb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0XHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG5cdH1cblx0Zm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0XHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xuXHR9XG5cblx0Ly8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5cdGZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuXHRzZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcblx0RXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxuXHR0b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHRcdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRcdGlmICggY2FjaGVkICkge1xuXHRcdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0XHR9XG5cblx0XHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRcdGdyb3VwcyA9IFtdO1xuXHRcdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHRcdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHRcdH1cblxuXHRcdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpbHRlcnNcblx0XHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdFx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdFx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdFx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdFx0c29GYXIgP1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gc2VsZWN0b3I7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHRcdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRcdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSA6XG5cblx0XHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0XHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0gOlxuXHRcdFx0bWF0Y2hlcnNbMF07XG5cdH1cblxuXHRmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHRmdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBuZXdVbm1hdGNoZWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdFx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHRcdH1cblx0XHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0XHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH0gXTtcblxuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG5cdH1cblxuXHRmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdFx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdFx0fTtcblxuXHRcdHJldHVybiBieVNldCA/XG5cdFx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRcdHN1cGVyTWF0Y2hlcjtcblx0fVxuXG5cdGNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0XHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXHRcdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlZDtcblx0fTtcblxuXHQvKipcblx0ICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuXHQgKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG5cdCAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuXHQgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cblx0ICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3Rcblx0ICovXG5cdHNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdFx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0XHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdFx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRcdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHRcdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0XHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0XHRzZWVkLFxuXHRcdFx0Y29udGV4dCxcblx0XHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRcdHJlc3VsdHMsXG5cdFx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0KTtcblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fTtcblxuXHQvLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG5cdC8vIFNvcnQgc3RhYmlsaXR5XG5cdHN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuXHQvLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG5cdC8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cblx0c3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cblx0Ly8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5cdHNldERvY3VtZW50KCk7XG5cblx0Ly8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcblx0Ly8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5cdHN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0XHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuXHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuXHRpZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRcdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcblx0fSkgKSB7XG5cdFx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdC8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcblx0aWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0XHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdFx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcblx0fSkgKSB7XG5cdFx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdC8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcblx0aWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcblx0fSkgKSB7XG5cdFx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0dmFyIHZhbDtcblx0XHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlO1xuXG5cdH0pKCB3aW5kb3cgKTtcblxuXG5cblx0alF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5cdGpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuXHQvLyBEZXByZWNhdGVkXG5cdGpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcblx0alF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5cdGpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5cdGpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcblx0alF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xuXHRqUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG5cdHZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVkO1xuXHR9O1xuXG5cblx0dmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRcdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZWQ7XG5cdH07XG5cblxuXHR2YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cblx0ZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cblx0ICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHR9O1xuXHR2YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cblx0Ly8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3Rcblx0ZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0XHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRcdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdH1cblxuXHRqUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdFx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdFx0aWYgKCBub3QgKSB7XG5cdFx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHRcdH1cblxuXHRcdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdFx0fSApICk7XG5cdH07XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHZhciBpLCByZXQsXG5cdFx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdFx0fSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHRcdH0sXG5cdFx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHRcdH0sXG5cdFx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdFx0dGhpcyxcblxuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdFx0ZmFsc2Vcblx0XHRcdCkubGVuZ3RoO1xuXHRcdH1cblx0fSApO1xuXG5cblx0Ly8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG5cdC8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxuXHR2YXIgcm9vdGpRdWVyeSxcblxuXHRcdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdFx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHRcdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRcdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0XHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0XHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHRcdH07XG5cblx0Ly8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuXHRpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuXHQvLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5cdHJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxuXHR2YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0XHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRcdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdFx0bmV4dDogdHJ1ZSxcblx0XHRcdHByZXY6IHRydWVcblx0XHR9O1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgY3VyLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdFx0fSxcblxuXHRcdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRcdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHRcdCk7XG5cdFx0fVxuXHR9ICk7XG5cblx0ZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRcdHJldHVybiBjdXI7XG5cdH1cblxuXHRqUXVlcnkuZWFjaCgge1xuXHRcdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0XHR9LFxuXHRcdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0XHR9LFxuXHRcdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdFx0fSxcblx0XHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0XHR9LFxuXHRcdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0XHR9LFxuXHRcdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdFx0fSxcblx0XHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0XHR9LFxuXHRcdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHRcdH0sXG5cdFx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHRcdH0sXG5cdFx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdFx0fSxcblx0XHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdCAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJpZnJhbWVcIiApICkge1xuXHQgICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdCAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdCAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0ICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0ICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0XHR9XG5cdH0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0XHR9O1xuXHR9ICk7XG5cdHZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cblx0Ly8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcblx0ZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdFx0fSApO1xuXHRcdHJldHVybiBvYmplY3Q7XG5cdH1cblxuXHQvKlxuXHQgKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcblx0ICpcblx0ICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcblx0ICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG5cdCAqXG5cdCAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG5cdCAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cblx0ICpcblx0ICogUG9zc2libGUgb3B0aW9uczpcblx0ICpcblx0ICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuXHQgKlxuXHQgKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcblx0ICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuXHQgKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcblx0ICpcblx0ICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcblx0ICpcblx0ICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG5cdCAqXG5cdCAqL1xuXHRqUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdFx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRcdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHRcdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0XHRmaXJpbmcsXG5cblx0XHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0XHRtZW1vcnksXG5cblx0XHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0XHRmaXJlZCxcblxuXHRcdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdFx0bG9ja2VkLFxuXG5cdFx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdFx0bGlzdCA9IFtdLFxuXG5cdFx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdFx0cXVldWUgPSBbXSxcblxuXHRcdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRcdHNlbGYgPSB7XG5cblx0XHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdHJldHVybiBzZWxmO1xuXHR9O1xuXG5cblx0ZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdFx0cmV0dXJuIHY7XG5cdH1cblx0ZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdFx0dGhyb3cgZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHRcdHZhciBtZXRob2Q7XG5cblx0XHR0cnkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0XHR9XG5cblx0XHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0XHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdFx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0XHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkuZXh0ZW5kKCB7XG5cblx0XHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XHRdLFxuXHRcdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbGwgZG9uZSFcblx0XHRcdHJldHVybiBkZWZlcnJlZDtcblx0XHR9LFxuXG5cdFx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdFx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdFx0dmFyXG5cblx0XHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHRcdH1cblx0fSApO1xuXG5cblx0Ly8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG5cdC8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxuXHR2YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxuXHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdFx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0XHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHRcdH1cblx0fTtcblxuXG5cblxuXHRqUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fSApO1xuXHR9O1xuXG5cblxuXG5cdC8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxuXHR2YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cblx0alF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdFx0cmVhZHlMaXN0XG5cdFx0XHQudGhlbiggZm4gKVxuXG5cdFx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdFx0fSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0alF1ZXJ5LmV4dGVuZCgge1xuXG5cdFx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0XHRpc1JlYWR5OiBmYWxzZSxcblxuXHRcdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0XHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRcdHJlYWR5V2FpdDogMSxcblxuXHRcdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0XHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cblx0Ly8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2Rcblx0ZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRcdGpRdWVyeS5yZWFkeSgpO1xuXHR9XG5cblx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcblx0Ly8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcblx0Ly8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5cdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdFx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0XHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0XHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdH1cblxuXG5cblxuXHQvLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cblx0Ly8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG5cdHZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdFx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRcdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0XHR9XG5cblx0XHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0XHRyYXcgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGZuKFxuXHRcdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbXM7XG5cdFx0fVxuXG5cdFx0Ly8gR2V0c1xuXHRcdGlmICggYnVsayApIHtcblx0XHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcblx0fTtcblxuXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xuXHR2YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0XHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cblx0Ly8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5cdGZ1bmN0aW9uIGZjYW1lbENhc2UoIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fVxuXG5cdC8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHQvLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5cdGZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9XG5cdHZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQWNjZXB0cyBvbmx5OlxuXHRcdC8vICAtIE5vZGVcblx0XHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdFx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0XHQvLyAgLSBPYmplY3Rcblx0XHQvLyAgICAtIEFueVxuXHRcdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcblx0fTtcblxuXG5cblxuXHRmdW5jdGlvbiBEYXRhKCkge1xuXHRcdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcblx0fVxuXG5cdERhdGEudWlkID0gMTtcblxuXHREYXRhLnByb3RvdHlwZSA9IHtcblxuXHRcdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcHJvcCxcblx0XHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjYWNoZTtcblx0XHR9LFxuXHRcdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0XHR9LFxuXHRcdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0XHQvL1xuXHRcdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0XHQvL1xuXHRcdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdFx0Ly9cblx0XHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHRcdC8vXG5cdFx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdFx0Ly9cblx0XHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0XHR9LFxuXHRcdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdFx0fVxuXHR9O1xuXHR2YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG5cdHZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG5cdC8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG5cdC8vXG5cdC8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG5cdC8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcblx0Ly9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuXHQvL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cblx0Ly9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcblx0Ly9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuXHQvL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cblx0dmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0XHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cblx0ZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0XHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0XHRyZXR1cm4gK2RhdGE7XG5cdFx0fVxuXG5cdFx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdFx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0fVxuXG5cdGpRdWVyeS5leHRlbmQoIHtcblx0XHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0XHR9LFxuXG5cdFx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0XHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0XHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdFx0fSxcblxuXHRcdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0gKTtcblxuXG5cdGpRdWVyeS5leHRlbmQoIHtcblx0XHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0XHR2YXIgcXVldWU7XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0XHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHRcdH0gKVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRcdHNldHRlci0tO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cdFx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH0gKTtcblx0XHR9LFxuXHRcdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH0sXG5cblx0XHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdFx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdFx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHRcdHZhciB0bXAsXG5cdFx0XHRcdGNvdW50ID0gMSxcblx0XHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdFx0fVxuXHR9ICk7XG5cdHZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxuXHR2YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxuXHR2YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cblx0dmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdFx0fTtcblxuXHR2YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0XHR2YXIgcmV0LCBuYW1lLFxuXHRcdFx0b2xkID0ge307XG5cblx0XHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdFx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fTtcblxuXG5cblxuXHRmdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHRcdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRcdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGFkanVzdGVkO1xuXHR9XG5cblxuXHR2YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuXHRmdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0XHR2YXIgdGVtcCxcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRcdGlmICggZGlzcGxheSApIHtcblx0XHRcdHJldHVybiBkaXNwbGF5O1xuXHRcdH1cblxuXHRcdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHRcdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdFx0fVxuXHRcdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHRcdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdFx0dmFsdWVzID0gW10sXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0XHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtZW50cztcblx0fVxuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHRcdH0sXG5cdFx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0XHR9LFxuXHRcdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9ICk7XG5cdHZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxuXHR2YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG5cdHZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuXHQvLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxuXHR2YXIgd3JhcE1hcCA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0XHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHRcdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0XHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdFx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRcdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdFx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHRcdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRcdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxuXHR9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxuXHR3cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xuXHR3cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5cdGZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0XHR2YXIgcmV0O1xuXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ID0gW107XG5cdFx0fVxuXG5cdFx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXG5cdC8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuXHRmdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGRhdGFQcml2LnNldChcblx0XHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblxuXHR2YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cblx0ZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0XHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRcdG5vZGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdFx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmcmFnbWVudDtcblx0fVxuXG5cblx0KCBmdW5jdGlvbigpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHRcdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdFx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHRcdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHRcdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRcdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRcdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuXHR9ICkoKTtcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyXG5cdFx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRcdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRcdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuXHRmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gU2VlICMxMzM5MyBmb3IgbW9yZSBpbmZvXG5cdGZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0XHR9IGNhdGNoICggZXJyICkgeyB9XG5cdH1cblxuXHRmdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHRcdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0XHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBlbGVtO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRcdGZuID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbTtcblx0XHR9XG5cblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRcdG9yaWdGbiA9IGZuO1xuXHRcdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8qXG5cdCAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cblx0ICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cblx0ICovXG5cdGpRdWVyeS5ldmVudCA9IHtcblxuXHRcdGdsb2JhbDoge30sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHRcdH1cblx0XHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0XHR9XG5cblx0XHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0XHRpID0gMDtcblx0XHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdFx0fSxcblxuXHRcdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0XHRjdXIgPSB0aGlzO1xuXHRcdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0XHR9LFxuXG5cdFx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IDpcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdFx0fSxcblxuXHRcdHNwZWNpYWw6IHtcblx0XHRcdGxvYWQ6IHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0Zm9jdXM6IHtcblxuXHRcdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjoge1xuXHRcdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdFx0fSxcblx0XHRcdGNsaWNrOiB7XG5cblx0XHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMuY2xpY2soKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVOYW1lKCBldmVudC50YXJnZXQsIFwiYVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0XHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0XHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdFx0fVxuXHR9O1xuXG5cdGpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdFx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHRcdH1cblxuXHRcdC8vIEV2ZW50IG9iamVjdFxuXHRcdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdFx0Ly8gRXZlbnQgdHlwZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdFx0fVxuXG5cdFx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0XHRpZiAoIHByb3BzICkge1xuXHRcdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHRcdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHRcdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0XHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcblx0fTtcblxuXHQvLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcblx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuXHRqUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRcdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdFx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0XHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdFx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRcdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRcdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xuXHRqUXVlcnkuZWFjaCgge1xuXHRcdGFsdEtleTogdHJ1ZSxcblx0XHRidWJibGVzOiB0cnVlLFxuXHRcdGNhbmNlbGFibGU6IHRydWUsXG5cdFx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdFx0Y3RybEtleTogdHJ1ZSxcblx0XHRkZXRhaWw6IHRydWUsXG5cdFx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0XHRtZXRhS2V5OiB0cnVlLFxuXHRcdHBhZ2VYOiB0cnVlLFxuXHRcdHBhZ2VZOiB0cnVlLFxuXHRcdHNoaWZ0S2V5OiB0cnVlLFxuXHRcdHZpZXc6IHRydWUsXG5cdFx0XCJjaGFyXCI6IHRydWUsXG5cdFx0Y2hhckNvZGU6IHRydWUsXG5cdFx0a2V5OiB0cnVlLFxuXHRcdGtleUNvZGU6IHRydWUsXG5cdFx0YnV0dG9uOiB0cnVlLFxuXHRcdGJ1dHRvbnM6IHRydWUsXG5cdFx0Y2xpZW50WDogdHJ1ZSxcblx0XHRjbGllbnRZOiB0cnVlLFxuXHRcdG9mZnNldFg6IHRydWUsXG5cdFx0b2Zmc2V0WTogdHJ1ZSxcblx0XHRwb2ludGVySWQ6IHRydWUsXG5cdFx0cG9pbnRlclR5cGU6IHRydWUsXG5cdFx0c2NyZWVuWDogdHJ1ZSxcblx0XHRzY3JlZW5ZOiB0cnVlLFxuXHRcdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdFx0dG9FbGVtZW50OiB0cnVlLFxuXHRcdHRvdWNoZXM6IHRydWUsXG5cblx0XHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudC53aGljaDtcblx0XHR9XG5cdH0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cblx0Ly8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG5cdC8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG5cdC8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG5cdC8vXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcblx0Ly8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG5cdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuXHQvLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxuXHRqUXVlcnkuZWFjaCgge1xuXHRcdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdFx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRcdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRcdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcblx0fSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHJldCxcblx0XHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0XHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0XHR9LFxuXHRcdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0XHR9LFxuXHRcdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0XHQpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fSApO1xuXG5cblx0dmFyXG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0XHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHRcdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0XHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHRcdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdFx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0XHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0XHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdFx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG5cdC8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuXHRmdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdFx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdC8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cblx0ZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0XHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXHRmdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRcdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdFx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0XHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0XHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRcdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5cdGZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdFx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdFx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHRcdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdFx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdFx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIGwgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYywgbm9kZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbGxlY3Rpb247XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0XHR2YXIgbm9kZSxcblx0XHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCgge1xuXHRcdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdFx0cmV0dXJuIGNsb25lO1xuXHRcdH0sXG5cblx0XHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdFx0fSxcblxuXHRcdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0XHR9LFxuXG5cdFx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHRcdH0sXG5cblx0XHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHRcdH0sIGlnbm9yZWQgKTtcblx0XHR9XG5cdH0gKTtcblxuXHRqUXVlcnkuZWFjaCgge1xuXHRcdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRcdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdFx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRcdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdFx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG5cdH0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHZhciBlbGVtcyxcblx0XHRcdFx0cmV0ID0gW10sXG5cdFx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0XHR9O1xuXHR9ICk7XG5cdHZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxuXHR2YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0XHR9O1xuXG5cdHZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cblx0KCBmdW5jdGlvbigpIHtcblxuXHRcdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHRcdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdFx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRcdGlmICggIWRpdiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IGRpdi5vZmZzZXRXaWR0aCA9PT0gMzYgfHwgXCJhYnNvbHV0ZVwiO1xuXG5cdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0XHRkaXYgPSBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0XHR9XG5cblx0XHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdFx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0XHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdFx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0XHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdFx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0XHR9LFxuXHRcdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0XHR9LFxuXHRcdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdFx0fSxcblx0XHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0XHR9LFxuXHRcdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSApKCk7XG5cblxuXHRmdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHRcdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHRcdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0XHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0XHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdFx0cmV0ICsgXCJcIiA6XG5cdFx0XHRyZXQ7XG5cdH1cblxuXG5cdGZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHRcdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXG5cdHZhclxuXG5cdFx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHRcdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHRcdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRcdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0XHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRcdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRcdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHRcdH0sXG5cblx0XHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdFx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuXHQvLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5cdGZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0XHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRcdHJldHVybiBuYW1lO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiBhIHByb3BlcnR5IG1hcHBlZCBhbG9uZyB3aGF0IGpRdWVyeS5jc3NQcm9wcyBzdWdnZXN0cyBvciB0b1xuXHQvLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cblx0ZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0XHR2YXIgcmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF07XG5cdFx0aWYgKCAhcmV0ICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdFx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHRcdC8vIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludFxuXHRcdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRcdHJldHVybiBtYXRjaGVzID9cblxuXHRcdFx0Ly8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3Ncblx0XHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdFx0dmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0XHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0XHRleHRyYSA9IDAsXG5cdFx0XHRkZWx0YSA9IDA7XG5cblx0XHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdFx0aWYgKCBib3ggPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSApIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiApIHtcblxuXHRcdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgYm94ICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0XHRpZiAoICFpc0JvcmRlckJveCApIHtcblxuXHRcdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0XHQvLyBGb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiLCBhZGQgYm9yZGVyXG5cdFx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHRcdC8vIEJ1dCBzdGlsbCBrZWVwIHRyYWNrIG9mIGl0IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRcdGRlbHRhIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdFx0aWYgKCBib3ggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggJiYgY29tcHV0ZWRWYWwgPj0gMCApIHtcblxuXHRcdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdFx0ZGVsdGEgKz0gTWF0aC5tYXgoIDAsIE1hdGguY2VpbChcblx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0XHRkZWx0YSAtXG5cdFx0XHRcdGV4dHJhIC1cblx0XHRcdFx0MC41XG5cdFx0XHQpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlbHRhO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHRcdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0XHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3g7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0XHRpZiAoIHJudW1ub25weC50ZXN0KCB2YWwgKSApIHtcblx0XHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fVxuXHRcdFx0dmFsID0gXCJhdXRvXCI7XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIHN0eWxlIGluIGNhc2UgYSBicm93c2VyIHdoaWNoIHJldHVybnMgdW5yZWxpYWJsZSB2YWx1ZXNcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHZhbHVlSXNCb3JkZXJCb3ggJiZcblx0XHRcdCggc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gKTtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHRcdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIC0gNC4zIG9ubHlcblx0XHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRcdGlmICggdmFsID09PSBcImF1dG9cIiB8fFxuXHRcdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSB7XG5cblx0XHRcdHZhbCA9IGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXTtcblxuXHRcdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHByb3ZpZGUgYm9yZGVyLWJveCB2YWx1ZXNcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdFx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHRcdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0XHRyZXR1cm4gKCB2YWwgK1xuXHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdFx0c3R5bGVzLFxuXG5cdFx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHRcdHZhbFxuXHRcdFx0KVxuXHRcdCkgKyBcInB4XCI7XG5cdH1cblxuXHRqUXVlcnkuZXh0ZW5kKCB7XG5cblx0XHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0XHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0XHRjc3NIb29rczoge1xuXHRcdFx0b3BhY2l0eToge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0XHRjc3NOdW1iZXI6IHtcblx0XHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcdFwiem9vbVwiOiB0cnVlXG5cdFx0fSxcblxuXHRcdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0XHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdFx0Y3NzUHJvcHM6IHt9LFxuXG5cdFx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0XHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHRcdC8vIENoZWNrIGlmIHdlJ3JlIHNldHRpbmcgYSB2YWx1ZVxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHRcdC8vIENvbnZlcnQgXCIrPVwiIG9yIFwiLT1cIiB0byByZWxhdGl2ZSBudW1iZXJzICgjNzM0NSlcblx0XHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdFx0Ly8gRml4ZXMgYnVnICM5MjM3XG5cdFx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQgKCM3MTE2KVxuXHRcdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgPT09IHN0eWxlcy5wb3NpdGlvbiApIHtcblx0XHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdFx0MC41XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG5cblx0alF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xuXG5cdC8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcblx0alF1ZXJ5LmVhY2goIHtcblx0XHRtYXJnaW46IFwiXCIsXG5cdFx0cGFkZGluZzogXCJcIixcblx0XHRib3JkZXI6IFwiV2lkdGhcIlxuXHR9LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHRcdH1cblx0fSApO1xuXG5cblx0ZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRcdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG5cdH1cblx0alF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblx0VHdlZW4ucHJvdG90eXBlID0ge1xuXHRcdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0XHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHR9LFxuXHRcdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdFx0fSxcblx0XHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdFx0dmFyIGVhc2VkLFxuXHRcdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fTtcblxuXHRUd2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblx0VHdlZW4ucHJvcEhvb2tzID0ge1xuXHRcdF9kZWZhdWx0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGpRdWVyeS5lYXNpbmcgPSB7XG5cdFx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRcdHJldHVybiBwO1xuXHRcdH0sXG5cdFx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0XHR9LFxuXHRcdF9kZWZhdWx0OiBcInN3aW5nXCJcblx0fTtcblxuXHRqUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuXHQvLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxuXHRqUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG5cdHZhclxuXHRcdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRcdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRcdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5cdGZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRcdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHRcdH1cblxuXHRcdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0XHR9XG5cdH1cblxuXHQvLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5cdGZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcblx0fVxuXG5cdC8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5cdGZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0dmFyIHdoaWNoLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0XHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdFx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0XHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0XHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHRcdH1cblxuXHRcdHJldHVybiBhdHRycztcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHRcdHZhciB0d2Vlbixcblx0XHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0XHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdFx0YW5pbSA9IHRoaXMsXG5cdFx0XHRvcmlnID0ge30sXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHRcdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRcdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRcdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0XHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0XHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdH1cblx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0XHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdFx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdFx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0XHR2YXIgcmVzdWx0LFxuXHRcdFx0c3RvcHBlZCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHRcdH0gKSxcblx0XHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICksXG5cdFx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRcdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHRcdH1cblxuXHRcdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdFx0YW5pbWF0aW9uXG5cdFx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRcdGpRdWVyeS5meC50aW1lcihcblx0XHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHRcdH0gKVxuXHRcdCk7XG5cblx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXHR9XG5cblx0alF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdFx0dHdlZW5lcnM6IHtcblx0XHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0gXVxuXHRcdH0sXG5cblx0XHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHByb3AsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdFx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0XHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0XHR9O1xuXG5cdFx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdFx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdFx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdFx0fVxuXG5cdFx0Ly8gUXVldWVpbmdcblx0XHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdFx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJldHVybiBvcHQ7XG5cdH07XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9LFxuXHRcdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHRcdH0sXG5cdFx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cdFx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0alF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRcdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9O1xuXHR9ICk7XG5cblx0Ly8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xuXHRqUXVlcnkuZWFjaCgge1xuXHRcdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdFx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdFx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdFx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdFx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRcdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG5cdH0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHRcdH07XG5cdH0gKTtcblxuXHRqUXVlcnkudGltZXJzID0gW107XG5cdGpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRpbWVyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdFx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdFx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHRcdH1cblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fTtcblxuXHRqUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdFx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9O1xuXG5cdGpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xuXHRqUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdFx0c2NoZWR1bGUoKTtcblx0fTtcblxuXHRqUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdGluUHJvZ3Jlc3MgPSBudWxsO1xuXHR9O1xuXG5cdGpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdFx0c2xvdzogNjAwLFxuXHRcdGZhc3Q6IDIwMCxcblxuXHRcdC8vIERlZmF1bHQgc3BlZWRcblx0XHRfZGVmYXVsdDogNDAwXG5cdH07XG5cblxuXHQvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG5cdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5cdGpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHRcdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdFx0fTtcblx0XHR9ICk7XG5cdH07XG5cblxuXHQoIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRcdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0XHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0XHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdFx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRcdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdFx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xuXHR9ICkoKTtcblxuXG5cdHZhciBib29sSG9vayxcblx0XHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHtcblx0XHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdFx0fSxcblxuXHRcdGF0dHJIb29rczoge1xuXHRcdFx0dHlwZToge1xuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0dmFyIG5hbWUsXG5cdFx0XHRcdGkgPSAwLFxuXG5cdFx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHQvLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5cdGJvb2xIb29rID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fTtcblxuXHRqUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdFx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9O1xuXHR9ICk7XG5cblxuXG5cblx0dmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRcdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0XHR9LFxuXG5cdFx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5leHRlbmQoIHtcblx0XHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHRcdH0sXG5cblx0XHRwcm9wSG9va3M6IHtcblx0XHRcdHRhYkluZGV4OiB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cHJvcEZpeDoge1xuXHRcdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG5cdC8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcblx0Ly8gb24gdGhlIG9wdGlvblxuXHQvLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuXHQvLyB3aGVuIGluIGFuIG9wdGdyb3VwXG5cdC8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuXHQvLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3Bcblx0aWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0XHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRqUXVlcnkuZWFjaCggW1xuXHRcdFwidGFiSW5kZXhcIixcblx0XHRcInJlYWRPbmx5XCIsXG5cdFx0XCJtYXhMZW5ndGhcIixcblx0XHRcImNlbGxTcGFjaW5nXCIsXG5cdFx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcdFwicm93U3BhblwiLFxuXHRcdFwiY29sU3BhblwiLFxuXHRcdFwidXNlTWFwXCIsXG5cdFx0XCJmcmFtZUJvcmRlclwiLFxuXHRcdFwiY29udGVudEVkaXRhYmxlXCJcblx0XSwgZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcblx0fSApO1xuXG5cblxuXG5cdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHRcdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRcdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdFx0fVxuXG5cblx0ZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0XHR9XG5cblx0XHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9ICk7XG5cblxuXG5cblx0dmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cblx0alF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRcdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdH0gKTtcblxuXHRqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0dmFsSG9va3M6IHtcblx0XHRcdG9wdGlvbjoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZWxlY3Q6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHQvLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxuXHRqUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gKTtcblxuXG5cblxuXHQvLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuXHRzdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG5cdHZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0XHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9O1xuXG5cdGpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdFx0fVxuXHRcdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0XHRldmVudCA6XG5cdFx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRcdG51bGw7XG5cblx0XHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFx0WyBldmVudCBdIDpcblx0XHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0XHRpID0gMDtcblx0XHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHRcdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdFx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0XHRldmVudCxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0XHR9XG5cblx0fSApO1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0XHR9ICk7XG5cdFx0fSxcblx0XHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcblx0Ly8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuXHQvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuXHQvL1xuXHQvLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcblx0Ly8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG5cdC8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuXHQvLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuXHRpZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdFx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSApO1xuXHR9XG5cdHZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxuXHR2YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG5cdHZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG5cdC8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcblx0alF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0dmFyIHhtbDtcblx0XHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0XHR0cnkge1xuXHRcdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHRcdH1cblx0XHRyZXR1cm4geG1sO1xuXHR9O1xuXG5cblx0dmFyXG5cdFx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdFx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRcdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0XHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cblx0ZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0XHRhZGRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuXHQvLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcblx0alF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHRcdHZhciBwcmVmaXgsXG5cdFx0XHRzID0gW10sXG5cdFx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRcdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0XHR9ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdFx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcblx0fTtcblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHRcdH0sXG5cdFx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0XHR9IClcblx0XHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0XHR9IClcblx0XHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdH0gKS5nZXQoKTtcblx0XHR9XG5cdH0gKTtcblxuXG5cdHZhclxuXHRcdHIyMCA9IC8lMjAvZyxcblx0XHRyaGFzaCA9IC8jLiokLyxcblx0XHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRcdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHRcdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRcdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdFx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdFx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdFx0LyogUHJlZmlsdGVyc1xuXHRcdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdFx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0XHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdFx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHRcdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0XHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdFx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0XHQgKi9cblx0XHRwcmVmaWx0ZXJzID0ge30sXG5cblx0XHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdFx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHRcdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0XHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0XHQgKi9cblx0XHR0cmFuc3BvcnRzID0ge30sXG5cblx0XHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0XHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0XHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0XHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRcdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuXHQvLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5cdGZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdFx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRcdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5cdGZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0XHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRcdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdFx0dmFyIHNlbGVjdGVkO1xuXHRcdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBzZWxlY3RlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcblx0fVxuXG5cdC8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuXHQvLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuXHQvLyBGaXhlcyAjOTg4N1xuXHRmdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0XHR2YXIga2V5LCBkZWVwLFxuXHRcdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdFx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGRlZXAgKSB7XG5cdFx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9XG5cblx0LyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuXHQgKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuXHQgKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0XHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHRcdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdFx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdFx0aWYgKCBjdCApIHtcblx0XHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRcdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHRcdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdFx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRcdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdFx0fVxuXHR9XG5cblx0LyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuXHQgKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2Vcblx0ICovXG5cdGZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0XHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHRcdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRcdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHRcdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHRcdH1cblxuXHRcdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcblx0fVxuXG5cdGpRdWVyeS5leHRlbmQoIHtcblxuXHRcdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRcdGFjdGl2ZTogMCxcblxuXHRcdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0XHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRcdGV0YWc6IHt9LFxuXG5cdFx0YWpheFNldHRpbmdzOiB7XG5cdFx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdFx0YXN5bmM6IHRydWUsXG5cdFx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdFx0Lypcblx0XHRcdHRpbWVvdXQ6IDAsXG5cdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdFx0Y2FjaGU6IG51bGwsXG5cdFx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdFx0aGVhZGVyczoge30sXG5cdFx0XHQqL1xuXG5cdFx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHRcdH0sXG5cblx0XHRcdGNvbnRlbnRzOiB7XG5cdFx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0XHR9LFxuXG5cdFx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0XHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdFx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0XHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0XHR9LFxuXG5cdFx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdFx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0XHQvLyBNYWluIG1ldGhvZFxuXHRcdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0XHRpLFxuXG5cdFx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHRcdCk7XG5cblx0XHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH0sXG5cblx0XHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHRcdH0sXG5cblx0XHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHRcdH1cblx0fSApO1xuXG5cdGpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBpLCBtZXRob2QgKSB7XG5cdFx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHVybDogdXJsLFxuXHRcdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdFx0fTtcblx0fSApO1xuXG5cblx0alF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRcdGNhY2hlOiB0cnVlLFxuXHRcdFx0YXN5bmM6IGZhbHNlLFxuXHRcdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcdFwidGhyb3dzXCI6IHRydWVcblx0XHR9ICk7XG5cdH07XG5cblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdFx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0XHR2YXIgd3JhcDtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9ICk7XG5cblxuXHRqUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG5cdH07XG5cdGpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG5cdH07XG5cblxuXG5cblx0alF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0XHR9IGNhdGNoICggZSApIHt9XG5cdH07XG5cblx0dmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0XHQwOiAyMDAsXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHRcdDEyMjM6IDIwNFxuXHRcdH0sXG5cdFx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuXHRzdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5cdHN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5cdGpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0XHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdFx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHR9ICk7XG5cblxuXG5cblx0Ly8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcblx0alF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcblx0alF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRcdGFjY2VwdHM6IHtcblx0XHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHRcdH0sXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdFx0fSxcblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0XHRyZXR1cm4gdGV4dDtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHQvLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5cdGpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0XHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdFx0cy50eXBlID0gXCJHRVRcIjtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcblx0alF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdFx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRcdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdH0gKTtcblxuXG5cblxuXHR2YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdFx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuXHQvLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5cdGpRdWVyeS5hamF4U2V0dXAoIHtcblx0XHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRcdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRcdHJldHVybiBjYWxsYmFjaztcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcblx0alF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0XHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XHRcInVybFwiIDpcblx0XHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHRcdCk7XG5cblx0XHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdFx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHRcdH07XG5cblx0XHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHRcdH07XG5cblx0XHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0XHR9ICk7XG5cblx0XHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdFx0fVxuXHR9ICk7XG5cblxuXG5cblx0Ly8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuXHQvLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG5cdC8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuXHQvLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG5cdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcblx0c3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0XHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0XHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcblx0fSApKCk7XG5cblxuXHQvLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcblx0Ly8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuXHQvLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHQvLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5cdGpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdFx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRcdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHRcdC8vIFNpbmdsZSB0YWdcblx0XHRpZiAoIHBhcnNlZCApIHtcblx0XHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHRcdH1cblxuXHRcdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0XHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG5cdCAqL1xuXHRqUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0XHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHRcdH1cblxuXHRcdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRcdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHRcdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0XHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRcdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cblxuXG5cdC8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5cdGpRdWVyeS5lYWNoKCBbXG5cdFx0XCJhamF4U3RhcnRcIixcblx0XHRcImFqYXhTdG9wXCIsXG5cdFx0XCJhamF4Q29tcGxldGVcIixcblx0XHRcImFqYXhFcnJvclwiLFxuXHRcdFwiYWpheFN1Y2Nlc3NcIixcblx0XHRcImFqYXhTZW5kXCJcblx0XSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdFx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0XHR9O1xuXHR9ICk7XG5cblxuXG5cblx0alF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdFx0fSApLmxlbmd0aDtcblx0fTtcblxuXG5cblxuXHRqUXVlcnkub2Zmc2V0ID0ge1xuXHRcdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRcdHByb3BzID0ge307XG5cblx0XHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0XHR9XG5cblx0XHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRcdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRcdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0XHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0XHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0XHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdFx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdFx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHRcdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0XHQvL1xuXHRcdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHRcdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHRcdC8vXG5cdFx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0XHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xuXHRqUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdFx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRcdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0XHR2YXIgd2luO1xuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdFx0fTtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcblx0Ly8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cblx0Ly8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG5cdC8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG5cdC8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG5cdC8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5cdGpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9ICk7XG5cblxuXHQvLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcblx0alF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRcdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0XHR9O1xuXHRcdH0gKTtcblx0fSApO1xuXG5cblx0alF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0XHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fSApO1xuXG5cdGpRdWVyeS5mbi5leHRlbmQoIHtcblx0XHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0XHR9XG5cdH0gKTtcblxuXG5cblxuXHRqUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0XHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHRcdH0sXG5cdFx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0XHR9LFxuXHRcdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcblx0Ly8gYXJndW1lbnRzLlxuXHQvLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG5cdC8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxuXHRqUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBTaW11bGF0ZWQgYmluZFxuXHRcdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdFx0fTtcblxuXHRcdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRcdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdFx0cmV0dXJuIHByb3h5O1xuXHR9O1xuXG5cdGpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0XHRpZiAoIGhvbGQgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHRcdH1cblx0fTtcblx0alF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXHRqUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcblx0alF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cdGpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblx0alF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5cdGpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5cdGpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5cdGpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxuXHRqUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdFx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHRcdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdFx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcblx0fTtcblxuXG5cblxuXHQvLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcblx0Ly8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuXHQvLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcblx0Ly8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuXHQvLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcblx0Ly8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG5cdC8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuXHQvLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuXHQvLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG5cdC8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuXHRpZiAoIHRydWUgKSB7XG5cdFx0IShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5O1xuXHRcdH0uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0fVxuXG5cblxuXG5cdHZhclxuXG5cdFx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdFx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0XHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRcdF8kID0gd2luZG93LiQ7XG5cblx0alF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0XHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0XHR3aW5kb3cuJCA9IF8kO1xuXHRcdH1cblxuXHRcdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9O1xuXG5cdC8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG5cdC8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcblx0Ly8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuXHRpZiAoICFub0dsb2JhbCApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG5cdH1cblxuXG5cblxuXHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187LyohIERhdGFUYWJsZXMgMS4xMC43XHJcblx0ICogwqkyMDA4LTIwMTQgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcclxuXHQgKi9cclxuXHR2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblx0LyoqXHJcblx0ICogQHN1bW1hcnkgICAgIERhdGFUYWJsZXNcclxuXHQgKiBAZGVzY3JpcHRpb24gUGFnaW5hdGUsIHNlYXJjaCBhbmQgb3JkZXIgSFRNTCB0YWJsZXNcclxuXHQgKiBAdmVyc2lvbiAgICAgMS4xMC43XHJcblx0ICogQGZpbGUgICAgICAgIGpxdWVyeS5kYXRhVGFibGVzLmpzXHJcblx0ICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGQgKHd3dy5zcHJ5bWVkaWEuY28udWspXHJcblx0ICogQGNvbnRhY3QgICAgIHd3dy5zcHJ5bWVkaWEuY28udWsvY29udGFjdFxyXG5cdCAqIEBjb3B5cmlnaHQgICBDb3B5cmlnaHQgMjAwOC0yMDE0IFNwcnlNZWRpYSBMdGQuXHJcblx0ICpcclxuXHQgKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIGF2YWlsYWJsZSB1bmRlciB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XHJcblx0ICogICBNSVQgbGljZW5zZSAtIGh0dHA6Ly9kYXRhdGFibGVzLm5ldC9saWNlbnNlXHJcblx0ICpcclxuXHQgKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dFxyXG5cdCAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXHJcblx0ICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgbGljZW5zZSBmaWxlcyBmb3IgZGV0YWlscy5cclxuXHQgKlxyXG5cdCAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldFxyXG5cdCAqL1xyXG5cclxuXHQvKmpzbGludCBldmlsOiB0cnVlLCB1bmRlZjogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSAqL1xyXG5cdC8qZ2xvYmFscyAkLHJlcXVpcmUsalF1ZXJ5LGRlZmluZSxfc2VsZWN0b3JfcnVuLF9zZWxlY3Rvcl9vcHRzLF9zZWxlY3Rvcl9maXJzdCxfc2VsZWN0b3Jfcm93X2luZGV4ZXMsX2V4dCxfQXBpLF9hcGlfcmVnaXN0ZXIsX2FwaV9yZWdpc3RlclBsdXJhbCxfcmVfbmV3X2xpbmVzLF9yZV9odG1sLF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyxfcmVfZXNjYXBlX3JlZ2V4LF9lbXB0eSxfaW50VmFsLF9udW1Ub0RlY2ltYWwsX2lzTnVtYmVyLF9pc0h0bWwsX2h0bWxOdW1lcmljLF9wbHVjayxfcGx1Y2tfb3JkZXIsX3JhbmdlLF9zdHJpcEh0bWwsX3VuaXF1ZSxfZm5CdWlsZEFqYXgsX2ZuQWpheFVwZGF0ZSxfZm5BamF4UGFyYW1ldGVycyxfZm5BamF4VXBkYXRlRHJhdyxfZm5BamF4RGF0YVNyYyxfZm5BZGRDb2x1bW4sX2ZuQ29sdW1uT3B0aW9ucyxfZm5BZGp1c3RDb2x1bW5TaXppbmcsX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgsX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUsX2ZuVmlzYmxlQ29sdW1ucyxfZm5HZXRDb2x1bW5zLF9mbkNvbHVtblR5cGVzLF9mbkFwcGx5Q29sdW1uRGVmcyxfZm5IdW5nYXJpYW5NYXAsX2ZuQ2FtZWxUb0h1bmdhcmlhbixfZm5MYW5ndWFnZUNvbXBhdCxfZm5Ccm93c2VyRGV0ZWN0LF9mbkFkZERhdGEsX2ZuQWRkVHIsX2ZuTm9kZVRvRGF0YUluZGV4LF9mbk5vZGVUb0NvbHVtbkluZGV4LF9mbkdldENlbGxEYXRhLF9mblNldENlbGxEYXRhLF9mblNwbGl0T2JqTm90YXRpb24sX2ZuR2V0T2JqZWN0RGF0YUZuLF9mblNldE9iamVjdERhdGFGbixfZm5HZXREYXRhTWFzdGVyLF9mbkNsZWFyVGFibGUsX2ZuRGVsZXRlSW5kZXgsX2ZuSW52YWxpZGF0ZSxfZm5HZXRSb3dFbGVtZW50cyxfZm5DcmVhdGVUcixfZm5CdWlsZEhlYWQsX2ZuRHJhd0hlYWQsX2ZuRHJhdyxfZm5SZURyYXcsX2ZuQWRkT3B0aW9uc0h0bWwsX2ZuRGV0ZWN0SGVhZGVyLF9mbkdldFVuaXF1ZVRocyxfZm5GZWF0dXJlSHRtbEZpbHRlcixfZm5GaWx0ZXJDb21wbGV0ZSxfZm5GaWx0ZXJDdXN0b20sX2ZuRmlsdGVyQ29sdW1uLF9mbkZpbHRlcixfZm5GaWx0ZXJDcmVhdGVTZWFyY2gsX2ZuRXNjYXBlUmVnZXgsX2ZuRmlsdGVyRGF0YSxfZm5GZWF0dXJlSHRtbEluZm8sX2ZuVXBkYXRlSW5mbyxfZm5JbmZvTWFjcm9zLF9mbkluaXRpYWxpc2UsX2ZuSW5pdENvbXBsZXRlLF9mbkxlbmd0aENoYW5nZSxfZm5GZWF0dXJlSHRtbExlbmd0aCxfZm5GZWF0dXJlSHRtbFBhZ2luYXRlLF9mblBhZ2VDaGFuZ2UsX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nLF9mblByb2Nlc3NpbmdEaXNwbGF5LF9mbkZlYXR1cmVIdG1sVGFibGUsX2ZuU2Nyb2xsRHJhdyxfZm5BcHBseVRvQ2hpbGRyZW4sX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzLF9mblRocm90dGxlLF9mbkNvbnZlcnRUb1dpZHRoLF9mblNjcm9sbGluZ1dpZHRoQWRqdXN0LF9mbkdldFdpZGVzdE5vZGUsX2ZuR2V0TWF4TGVuU3RyaW5nLF9mblN0cmluZ1RvQ3NzLF9mblNjcm9sbEJhcldpZHRoLF9mblNvcnRGbGF0dGVuLF9mblNvcnQsX2ZuU29ydEFyaWEsX2ZuU29ydExpc3RlbmVyLF9mblNvcnRBdHRhY2hMaXN0ZW5lcixfZm5Tb3J0aW5nQ2xhc3NlcyxfZm5Tb3J0RGF0YSxfZm5TYXZlU3RhdGUsX2ZuTG9hZFN0YXRlLF9mblNldHRpbmdzRnJvbU5vZGUsX2ZuTG9nLF9mbk1hcCxfZm5CaW5kQWN0aW9uLF9mbkNhbGxiYWNrUmVnLF9mbkNhbGxiYWNrRmlyZSxfZm5MZW5ndGhPdmVyZmxvdyxfZm5SZW5kZXJlcixfZm5EYXRhU291cmNlLF9mblJvd0F0dHJpYnV0ZXMqL1xyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBqcXVlcnlUYWJsZUluaXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICgvKiogQGxlbmRzIDxnbG9iYWw+ICovZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG5cclxuXHQgICAgICAgICAgICAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuXHQgICAgICAgICAgICAgICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRGVmaW5lIGFzIGFuIEFNRCBtb2R1bGUgaWYgcG9zc2libGVcclxuXHQgICAgICAgICAgICAgICAgICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDIpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBOb2RlL0NvbW1vbkpTXHJcblx0ICAgICAgICAgICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnanF1ZXJ5JykpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpRdWVyeSAmJiAhalF1ZXJ5LmZuLmRhdGFUYWJsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRGVmaW5lIHVzaW5nIGJyb3dzZXIgZ2xvYmFscyBvdGhlcndpc2VcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgaW5zdGFudGlhdGlvbnMgaWYgdGhlIHNjcmlwdCBpcyBsb2FkZWQgdHdpY2VcclxuXHQgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkoalF1ZXJ5KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAoLyoqIEBsZW5kcyA8Z2xvYmFsPiAqL2Z1bmN0aW9uICgkKSB7XHJcblx0ICAgICAgICAgICAgICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgaXMgYSBwbHVnLWluIGZvciB0aGUgalF1ZXJ5IEphdmFzY3JpcHQgbGlicmFyeS4gSXQgaXMgYSBoaWdobHlcclxuXHQgICAgICAgICAgICAgICAgICogZmxleGlibGUgdG9vbCwgYmFzZWQgdXBvbiB0aGUgZm91bmRhdGlvbnMgb2YgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQsXHJcblx0ICAgICAgICAgICAgICAgICAqIHdoaWNoIHdpbGwgYWRkIGFkdmFuY2VkIGludGVyYWN0aW9uIGNvbnRyb2xzIHRvIGFueSBIVE1MIHRhYmxlLiBGb3IgYVxyXG5cdCAgICAgICAgICAgICAgICAgKiBmdWxsIGxpc3Qgb2YgZmVhdHVyZXMgcGxlYXNlIHJlZmVyIHRvXHJcblx0ICAgICAgICAgICAgICAgICAqIFtEYXRhVGFibGVzLm5ldF0oaHJlZj1cImh0dHA6Ly9kYXRhdGFibGVzLm5ldCkuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZWAgb2JqZWN0IGlzIG5vdCBhIGdsb2JhbCB2YXJpYWJsZSBidXQgaXMgYWxpYXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiB0byBgalF1ZXJ5LmZuLkRhdGFUYWJsZWAgYW5kIGBqUXVlcnkuZm4uZGF0YVRhYmxlYCB0aHJvdWdoIHdoaWNoIGl0IG1heVxyXG5cdCAgICAgICAgICAgICAgICAgKiBiZSAgYWNjZXNzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAY2xhc3NcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBbaW5pdD17fV0gQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMuIE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICogICAgYXJlIGRlZmluZWQgYnkge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c31cclxuXHQgICAgICAgICAgICAgICAgICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAgLy8gQmFzaWMgaW5pdGlhbGlzYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAvLyBJbml0aWFsaXNhdGlvbiB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAtIGluIHRoaXMgY2FzZSwgZGlzYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAvLyBwYWdpbmF0aW9uIGFuZCBzb3J0aW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24ge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzb3J0XCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgRGF0YVRhYmxlO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAqIEl0IGlzIHVzZWZ1bCB0byBoYXZlIHZhcmlhYmxlcyB3aGljaCBhcmUgc2NvcGVkIGxvY2FsbHkgc28gb25seSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBmdW5jdGlvbnMgY2FuIGFjY2VzcyB0aGVtIGFuZCB0aGV5IGRvbid0IGxlYWsgaW50byBnbG9iYWwgc3BhY2UuXHJcblx0ICAgICAgICAgICAgICAgICAqIEF0IHRoZSBzYW1lIHRpbWUgdGhlc2UgZnVuY3Rpb25zIGFyZSBvZnRlbiB1c2VmdWwgb3ZlciBtdWx0aXBsZSBmaWxlcyBpbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogY29yZSBhbmQgQVBJLCBzbyB3ZSBsaXN0LCBvciBhdCBsZWFzdCBkb2N1bWVudCwgYWxsIHZhcmlhYmxlcyB3aGljaCBhcmUgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBieSBEYXRhVGFibGVzIGFzIHByaXZhdGUgdmFyaWFibGVzIGhlcmUuIFRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm9cclxuXHQgICAgICAgICAgICAgICAgICogY2xhc2hpbmcgb2YgdmFyaWFibGUgbmFtZXMgYW5kIHRoYXQgdGhleSBjYW4gZWFzaWx5IHJlZmVyZW5jZWQgZm9yIHJldXNlLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBEZWZpbmVkIGVsc2Ugd2hlcmVcclxuXHQgICAgICAgICAgICAgICAgLy8gIF9zZWxlY3Rvcl9ydW5cclxuXHQgICAgICAgICAgICAgICAgLy8gIF9zZWxlY3Rvcl9vcHRzXHJcblx0ICAgICAgICAgICAgICAgIC8vICBfc2VsZWN0b3JfZmlyc3RcclxuXHQgICAgICAgICAgICAgICAgLy8gIF9zZWxlY3Rvcl9yb3dfaW5kZXhlc1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9leHQ7IC8vIERhdGFUYWJsZS5leHRcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9BcGk7IC8vIERhdGFUYWJsZS5BcGlcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9hcGlfcmVnaXN0ZXI7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9hcGlfcmVnaXN0ZXJQbHVyYWw7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWxcclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfcmVfZGljID0ge307XHJcblx0ICAgICAgICAgICAgICAgIHZhciBfcmVfbmV3X2xpbmVzID0gL1tcXHJcXG5dL2c7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBfcmVfaHRtbCA9IC88Lio/Pi9nO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3JlX2RhdGVfc3RhcnQgPSAvXltcXHdcXCtcXC1dLztcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9yZV9kYXRlX2VuZCA9IC9bXFx3XFwrXFwtXSQvO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gRXNjYXBlIHJlZ3VsYXIgZXhwcmVzc2lvbiBzcGVjaWFsIGNoYXJhY3RlcnNcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9yZV9lc2NhcGVfcmVnZXggPSBuZXcgUmVnRXhwKCcoXFxcXCcgKyBbJy8nLCAnLicsICcqJywgJysnLCAnPycsICd8JywgJygnLCAnKScsICdbJywgJ10nLCAneycsICd9JywgJ1xcXFwnLCAnJCcsICdeJywgJy0nXS5qb2luKCd8XFxcXCcpICsgJyknLCAnZycpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3JlaWduX2V4Y2hhbmdlX21hcmtldFxyXG5cdCAgICAgICAgICAgICAgICAvLyAtIFxcdTIwQkQgLSBSdXNzaWFuIHJ1YmxlLlxyXG5cdCAgICAgICAgICAgICAgICAvLyAtIFxcdTIwYTkgLSBTb3V0aCBLb3JlYW4gV29uXHJcblx0ICAgICAgICAgICAgICAgIC8vIC0gXFx1MjBCQSAtIFR1cmtpc2ggTGlyYVxyXG5cdCAgICAgICAgICAgICAgICAvLyAtIFxcdTIwQjkgLSBJbmRpYW4gUnVwZWVcclxuXHQgICAgICAgICAgICAgICAgLy8gLSBSIC0gQnJhemlsIChSJCkgYW5kIFNvdXRoIEFmcmljYVxyXG5cdCAgICAgICAgICAgICAgICAvLyAtIGZyIC0gU3dpc3MgRnJhbmNcclxuXHQgICAgICAgICAgICAgICAgLy8gLSBrciAtIFN3ZWRpc2gga3JvbmEsIE5vcndlZ2lhbiBrcm9uZSBhbmQgRGFuaXNoIGtyb25lXHJcblx0ICAgICAgICAgICAgICAgIC8vIC0gXFx1MjAwOSBpcyB0aGluIHNwYWNlIGFuZCBcXHUyMDJGIGlzIG5hcnJvdyBuby1icmVhayBzcGFjZSwgYm90aCB1c2VkIGluIG1hbnlcclxuXHQgICAgICAgICAgICAgICAgLy8gICBzdGFuZGFyZHMgYXMgdGhvdXNhbmRzIHNlcGFyYXRvcnMuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfcmVfZm9ybWF0dGVkX251bWVyaWMgPSAvWycsJMKj4oKswqUlXFx1MjAwOVxcdTIwMkZcXHUyMEJEXFx1MjBhOVxcdTIwQkFyZmtdL2dpO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfZW1wdHkgPSBmdW5jdGlvbiAoZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkIHx8IGQgPT09IHRydWUgfHwgZCA9PT0gJy0nID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfaW50VmFsID0gZnVuY3Rpb24gKHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnRlZ2VyID0gcGFyc2VJbnQocywgMTApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gQ29udmVydCBmcm9tIGEgZm9ybWF0dGVkIG51bWJlciB3aXRoIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiBgLmAgYXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcGxhY2UsIHRvIGEgSmF2YXNjcmlwdCBudW1iZXJcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9udW1Ub0RlY2ltYWwgPSBmdW5jdGlvbiAobnVtLCBkZWNpbWFsUG9pbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGNyZWF0ZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3BlZWQgYXMgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb2Z0ZW5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghX3JlX2RpY1tkZWNpbWFsUG9pbnRdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3JlX2RpY1tkZWNpbWFsUG9pbnRdID0gbmV3IFJlZ0V4cChfZm5Fc2NhcGVSZWdleChkZWNpbWFsUG9pbnQpLCAnZycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdzdHJpbmcnICYmIGRlY2ltYWxQb2ludCAhPT0gJy4nID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW0ucmVwbGFjZSgvXFwuL2csICcnKS5yZXBsYWNlKF9yZV9kaWNbZGVjaW1hbFBvaW50XSwgJy4nKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiAoZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdHJUeXBlID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIGVtcHR5IHJldHVybiBpbW1lZGlhdGVseSBzbyB0aGVyZSBtdXN0IGJlIGEgbnVtYmVyIGlmIGl0IGlzIGFcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdHRlZCBzdHJpbmcgKHRoaXMgc3RvcHMgdGhlIHN0cmluZyBcImtcIiwgb3IgXCJrclwiLCBldGMgYmVpbmcgZGV0ZWN0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGFzIGEgZm9ybWF0dGVkIG51bWJlciBmb3IgY3VycmVuY3lcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfZW1wdHkoZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbFBvaW50ICYmIHN0clR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkID0gX251bVRvRGVjaW1hbChkLCBkZWNpbWFsUG9pbnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWQgJiYgc3RyVHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoX3JlX2Zvcm1hdHRlZF9udW1lcmljLCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KGQpKSAmJiBpc0Zpbml0ZShkKTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBBIHN0cmluZyB3aXRob3V0IEhUTUwgaW4gaXQgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgSFRNTCBzdGlsbFxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX2lzSHRtbCA9IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VtcHR5KGQpIHx8IHR5cGVvZiBkID09PSAnc3RyaW5nJztcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX2h0bWxOdW1lcmljID0gZnVuY3Rpb24gKGQsIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX2VtcHR5KGQpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBfaXNIdG1sKGQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFodG1sID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfaXNOdW1iZXIoX3N0cmlwSHRtbChkKSwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQpID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9wbHVjayA9IGZ1bmN0aW9uIChhLCBwcm9wLCBwcm9wMikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBpZW4gPSBhLmxlbmd0aDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaXMgZXNzZW50aWFsIGhlcmVcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wMiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbaV0gJiYgYVtpXVtwcm9wXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goYVtpXVtwcm9wXVtwcm9wMl0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbaV0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGFbaV1bcHJvcF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gQmFzaWNhbGx5IHRoZSBzYW1lIGFzIF9wbHVjaywgYnV0IHJhdGhlciB0aGFuIGxvb3Bpbmcgb3ZlciBgYWAgd2UgdXNlIGBvcmRlcmBcclxuXHQgICAgICAgICAgICAgICAgLy8gYXMgdGhlIGluZGV4ZXMgdG8gcGljayBmcm9tIGBhYFxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3BsdWNrX29yZGVyID0gZnVuY3Rpb24gKGEsIG9yZGVyLCBwcm9wLCBwcm9wMikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLCBpZW4gPSBvcmRlci5sZW5ndGg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ291bGQgaGF2ZSB0aGUgdGVzdCBpbiB0aGUgbG9vcCBmb3Igc2xpZ2h0bHkgc21hbGxlciBjb2RlLCBidXQgc3BlZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGlzIGVzc2VudGlhbCBoZXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcDIgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW29yZGVyW2ldXVtwcm9wXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goYVtvcmRlcltpXV1bcHJvcF1bcHJvcDJdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGFbb3JkZXJbaV1dW3Byb3BdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3JhbmdlID0gZnVuY3Rpb24gKGxlbiwgc3RhcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbmQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gbGVuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBsZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0IDsgaSA8IGVuZCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uIChhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGEubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW2ldKSB7IC8vIGNhcmVmdWwgLSB3aWxsIHJlbW92ZSBhbGwgZmFsc3kgdmFsdWVzIVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChhW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3N0cmlwSHRtbCA9IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5yZXBsYWNlKF9yZV9odG1sLCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEZpbmQgdGhlIHVuaXF1ZSBlbGVtZW50cyBpbiBhIHNvdXJjZSBhcnJheS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtICB7YXJyYXl9IHNyYyBTb3VyY2UgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIHVuaXF1ZSBpdGVtc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBAaWdub3JlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3VuaXF1ZSA9IGZ1bmN0aW9uIChzcmMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEEgZmFzdGVyIHVuaXF1ZSBtZXRob2QgaXMgdG8gdXNlIG9iamVjdCBrZXlzIHRvIGlkZW50aWZ5IHVzZWQgdmFsdWVzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgZG9lc24ndCB3b3JrIHdpdGggYXJyYXlzIG9yIG9iamVjdHMsIHdoaWNoIHdlIG11c3QgYWxzb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gY29uc2lkZXIuIFNlZSBqc3BlcmYuY29tL2NvbXBhcmUtYXJyYXktdW5pcXVlLXZlcnNpb25zLzQgZm9yIG1vcmVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGluZm9ybWF0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGksIGllbiA9IHNyYy5sZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaiwgayA9IDA7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYWdhaW46IGZvciAoaSA9IDAgOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gc3JjW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwIDsgaiA8IGsgOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dFtqXSA9PT0gdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBhZ2FpbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2godmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrKys7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENyZWF0ZSBhIG1hcHBpbmcgb2JqZWN0IHRoYXQgYWxsb3dzIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBiZSBsb29rZWQgdXBcclxuXHQgICAgICAgICAgICAgICAgICogZm9yIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHMuIFRoZSBtYXBwaW5nIGlzIHN0b3JlZCBpbiBhIHByaXZhdGVcclxuXHQgICAgICAgICAgICAgICAgICogcGFyYW1ldGVyIGNhbGxlZCBgX2h1bmdhcmlhbk1hcGAgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkIG9uIHRoZSBzb3VyY2Ugb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuSHVuZ2FyaWFuTWFwKG8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGh1bmdhcmlhbiA9ICdhIGFhIGFpIGFvIGFzIGIgZm4gaSBtIG8gcyAnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ld0tleSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXAgPSB7fTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAkLmVhY2gobywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBrZXkubWF0Y2goL14oW15BLVpdKz8pKFtBLVpdKS8pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgaHVuZ2FyaWFuLmluZGV4T2YobWF0Y2hbMV0gKyAnICcpICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdLZXkgPSBrZXkucmVwbGFjZShtYXRjaFswXSwgbWF0Y2hbMl0udG9Mb3dlckNhc2UoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcFtuZXdLZXldID0ga2V5O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09PSAnbycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkh1bmdhcmlhbk1hcChvW2tleV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgby5faHVuZ2FyaWFuTWFwID0gbWFwO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gSHVuZ2FyaWFuLCBiYXNlZCBvbiBhIEh1bmdhcmlhbiBtYXBcclxuXHQgICAgICAgICAgICAgICAgICogY3JlYXRlZCBieSBfZm5IdW5nYXJpYW5NYXAuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcclxuXHQgICAgICAgICAgICAgICAgICogICAgbWFwcGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHVzZXIgVGhlIG9iamVjdCB0byBjb252ZXJ0IGZyb20gY2FtZWwgY2FzZSB0byBIdW5nYXJpYW4uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcclxuXHQgICAgICAgICAgICAgICAgICogICAgd29uJ3QgYmUuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNhbWVsVG9IdW5nYXJpYW4oc3JjLCB1c2VyLCBmb3JjZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzcmMuX2h1bmdhcmlhbk1hcCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkh1bmdhcmlhbk1hcChzcmMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBodW5nYXJpYW5LZXk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHVzZXIsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGh1bmdhcmlhbktleSA9IHNyYy5faHVuZ2FyaWFuTWFwW2tleV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodW5nYXJpYW5LZXkgIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgdXNlcltodW5nYXJpYW5LZXldID09PSB1bmRlZmluZWQpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBvYmplY3RzLCB3ZSBuZWVkIHRvIGJ1enogZG93biBpbnRvIHRoZSBvYmplY3QgdG8gY29weSBwYXJhbWV0ZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChodW5nYXJpYW5LZXkuY2hhckF0KDApID09PSAnbycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGNhbWVsQ2FzZSBvcHRpb25zIG92ZXIgdG8gdGhlIGh1bmdhcmlhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyW2h1bmdhcmlhbktleV0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyW2h1bmdhcmlhbktleV0gPSB7fTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIHVzZXJbaHVuZ2FyaWFuS2V5XSwgdXNlcltrZXldKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuKHNyY1todW5nYXJpYW5LZXldLCB1c2VyW2h1bmdhcmlhbktleV0sIGZvcmNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJbaHVuZ2FyaWFuS2V5XSA9IHVzZXJba2V5XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIExhbmd1YWdlIGNvbXBhdGliaWxpdHkgLSB3aGVuIGNlcnRhaW4gb3B0aW9ucyBhcmUgZ2l2ZW4sIGFuZCBvdGhlcnMgYXJlbid0LCB3ZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBuZWVkIHRvIGR1cGxpY2F0ZSB0aGUgdmFsdWVzIG92ZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuXHQgICAgICAgICAgICAgICAgICogd2l0aCBvbGRlciBsYW5ndWFnZSBmaWxlcy5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuTGFuZ3VhZ2VDb21wYXQobGFuZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLm9MYW5ndWFnZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB6ZXJvUmVjb3JkcyA9IGxhbmcuc1plcm9SZWNvcmRzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IC0gaWYgdGhlcmUgaXMgbm8gc0VtcHR5VGFibGUgZ2l2ZW4sIHRoZW4gdXNlIHRoZSBzYW1lIGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzWmVyb1JlY29yZHMgLSBhc3N1bWluZyB0aGF0IGlzIGdpdmVuLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWxhbmcuc0VtcHR5VGFibGUgJiYgemVyb1JlY29yZHMgJiZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0cy5zRW1wdHlUYWJsZSA9PT0gXCJObyBkYXRhIGF2YWlsYWJsZSBpbiB0YWJsZVwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0VtcHR5VGFibGUnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBMaWtld2lzZSB3aXRoIGxvYWRpbmcgcmVjb3JkcyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFsYW5nLnNMb2FkaW5nUmVjb3JkcyAmJiB6ZXJvUmVjb3JkcyAmJlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzLnNMb2FkaW5nUmVjb3JkcyA9PT0gXCJMb2FkaW5nLi4uXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAobGFuZywgbGFuZywgJ3NaZXJvUmVjb3JkcycsICdzTG9hZGluZ1JlY29yZHMnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBPbGQgcGFyYW1ldGVyIG5hbWUgb2YgdGhlIHRob3VzYW5kcyBzZXBhcmF0b3IgbWFwcGVkIG9udG8gdGhlIG5ld1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmcuc0luZm9UaG91c2FuZHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5nLnNUaG91c2FuZHMgPSBsYW5nLnNJbmZvVGhvdXNhbmRzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gbGFuZy5zRGVjaW1hbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2FkZE51bWVyaWNTb3J0KGRlY2ltYWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIE1hcCBvbmUgcGFyYW1ldGVyIG9udG8gYW5vdGhlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gT2JqZWN0IHRvIG1hcFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSBrbmV3IFRoZSBuZXcgcGFyYW1ldGVyIG5hbWVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Kn0gb2xkIFRoZSBvbGQgcGFyYW1ldGVyIG5hbWVcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfZm5Db21wYXRNYXAgPSBmdW5jdGlvbiAobywga25ldywgb2xkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob1trbmV3XSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1tvbGRdID0gb1trbmV3XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIG1haW4gRFQgb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXdcclxuXHQgICAgICAgICAgICAgICAgICogb3B0aW9ucyBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBjaGFuZ2Ugb25seS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNvbXBhdE9wdHMoaW5pdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlcmluZycsICdiU29ydCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlck11bHRpJywgJ2JTb3J0TXVsdGknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJDbGFzc2VzJywgJ2JTb3J0Q2xhc3NlcycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlckNlbGxzVG9wJywgJ2JTb3J0Q2VsbHNUb3AnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXInLCAnYWFTb3J0aW5nJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyRml4ZWQnLCAnYWFTb3J0aW5nRml4ZWQnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAncGFnaW5nJywgJ2JQYWdpbmF0ZScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdwYWdpbmdUeXBlJywgJ3NQYWdpbmF0aW9uVHlwZScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdwYWdlTGVuZ3RoJywgJ2lEaXNwbGF5TGVuZ3RoJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ3NlYXJjaGluZycsICdiRmlsdGVyJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ29sdW1uIHNlYXJjaCBvYmplY3RzIGFyZSBpbiBhbiBhcnJheSwgc28gaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGJ5IGVsZW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hDb2xzID0gaW5pdC5hb1NlYXJjaENvbHM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaENvbHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gc2VhcmNoQ29scy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hDb2xzW2ldKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuKERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCwgc2VhcmNoQ29sc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgY29sdW1uIG9wdGlvbnMuIE5vdGUgdGhhdCB0aGUgbmV3IG9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICogYXJlIG1hcHBlZCBvbnRvIHRoZSBvbGQgcGFyYW1ldGVycywgc28gdGhpcyBpcyBhbiBleHRlcm5hbCBpbnRlcmZhY2UgY2hhbmdlXHJcblx0ICAgICAgICAgICAgICAgICAqIG9ubHkuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gaW5pdCBPYmplY3QgdG8gbWFwXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Db21wYXRDb2xzKGluaXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJhYmxlJywgJ2JTb3J0YWJsZScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlckRhdGEnLCAnYURhdGFTb3J0Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyU2VxdWVuY2UnLCAnYXNTb3J0aW5nJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyRGF0YVR5cGUnLCAnc29ydERhdGFUeXBlJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gb3JkZXJEYXRhIGNhbiBiZSBnaXZlbiBhcyBhbiBpbnRlZ2VyXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVNvcnQgPSBpbml0LmFEYXRhU29ydDtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhU29ydCAmJiAhJC5pc0FycmF5KGRhdGFTb3J0KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluaXQuYURhdGFTb3J0ID0gW2RhdGFTb3J0XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBCcm93c2VyIGZlYXR1cmUgZGV0ZWN0aW9uIGZvciBjYXBhYmlsaXRpZXMsIHF1aXJrc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkJyb3dzZXJEZXRlY3Qoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBicm93c2VyID0gc2V0dGluZ3Mub0Jyb3dzZXI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2Nyb2xsaW5nIGZlYXR1cmUgLyBxdWlya3MgZGV0ZWN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICQoJzxkaXYvPicpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGRpdi8+JylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAxLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdzY3JvbGwnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8ZGl2IGNsYXNzPVwidGVzdFwiLz4nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbygnYm9keScpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0gbi5maW5kKCcudGVzdCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElFNi83IHdpbGwgb3ZlcnNpemUgYSB3aWR0aCAxMDAlIGVsZW1lbnQgaW5zaWRlIGEgc2Nyb2xsaW5nIGVsZW1lbnQsIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyLCB3aGlsZSBvdGhlciBicm93c2VycyBlbnN1cmUgdGhlIGlubmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRob3V0IGZvcmNpbmcgc2Nyb2xsaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICBicm93c2VyLmJTY3JvbGxPdmVyc2l6ZSA9IHRlc3RbMF0ub2Zmc2V0V2lkdGggPT09IDEwMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJbiBydGwgdGV4dCBsYXlvdXQsIHNvbWUgYnJvd3NlcnMgKG1vc3QsIGJ1dCBub3QgYWxsKSB3aWxsIHBsYWNlIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0LCByYXRoZXIgdGhhbiB0aGUgcmlnaHQuXHJcblx0ICAgICAgICAgICAgICAgICAgICBicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID0gTWF0aC5yb3VuZCh0ZXN0Lm9mZnNldCgpLmxlZnQpICE9PSAxO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIG4ucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQXJyYXkucHJvdG90eXBlIHJlZHVjZVtSaWdodF0gbWV0aG9kLCB1c2VkIGZvciBicm93c2VycyB3aGljaCBkb24ndCBzdXBwb3J0XHJcblx0ICAgICAgICAgICAgICAgICAqIEpTIDEuNi4gRG9uZSB0aGlzIHdheSB0byByZWR1Y2UgY29kZSBzaXplLCBzaW5jZSB3ZSBpdGVyYXRlIGVpdGhlciB3YXlcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5SZWR1Y2UodGhhdCwgZm4sIGluaXQsIHN0YXJ0LCBlbmQsIGluYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlzU2V0ID0gZmFsc2U7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpc1NldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgIT09IGVuZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXNTZXQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbih2YWx1ZSwgdGhhdFtpXSwgaSwgdGhhdCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0W2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpc1NldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBpbmM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWRkIGEgY29sdW1uIHRvIHRoZSBsaXN0IHVzZWQgZm9yIHRoZSB0YWJsZSB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5UaCBUaGUgdGggZWxlbWVudCBmb3IgdGhpcyBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQWRkQ29sdW1uKG9TZXR0aW5ncywgblRoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY29sdW1uIHRvIGFvQ29sdW1ucyBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9EZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaUNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9Db2wgPSAkLmV4dGVuZCh7fSwgRGF0YVRhYmxlLm1vZGVscy5vQ29sdW1uLCBvRGVmYXVsdHMsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIm5UaFwiOiBuVGggPyBuVGggOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1RpdGxlXCI6IG9EZWZhdWx0cy5zVGl0bGUgPyBvRGVmYXVsdHMuc1RpdGxlIDogblRoID8gblRoLmlubmVySFRNTCA6ICcnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYURhdGFTb3J0XCI6IG9EZWZhdWx0cy5hRGF0YVNvcnQgPyBvRGVmYXVsdHMuYURhdGFTb3J0IDogW2lDb2xdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwibURhdGFcIjogb0RlZmF1bHRzLm1EYXRhID8gb0RlZmF1bHRzLm1EYXRhIDogaUNvbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZHg6IGlDb2xcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmFvQ29sdW1ucy5wdXNoKG9Db2wpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzZWFyY2ggb2JqZWN0IGZvciBjb2x1bW4gc3BlY2lmaWMgc2VhcmNoLiBOb3RlIHRoYXQgdGhlIGBzZWFyY2hDb2xzWyBpQ29sIF1gXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBwYXNzZWQgaW50byBleHRlbmQgY2FuIGJlIHVuZGVmaW5lZC4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZ2l2ZSBhIGRlZmF1bHRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggb25seSBzb21lIG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQsIGFuZCBhbHNvIG5vdCBnaXZlIGEgZGVmYXVsdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlYXJjaENvbHMgPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2VhcmNoQ29sc1tpQ29sXSA9ICQuZXh0ZW5kKHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbaUNvbF0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVmYXVsdCBjb2x1bW4gb3B0aW9ucyBmdW5jdGlvbiB0byBpbml0aWFsaXNlIGNsYXNzZXMgZXRjXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5PcHRpb25zKG9TZXR0aW5ncywgaUNvbCwgJChuVGgpLmRhdGEoKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQXBwbHkgb3B0aW9ucyBmb3IgYSBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBpQ29sIGNvbHVtbiBpbmRleCB0byBjb25zaWRlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9PcHRpb25zIG9iamVjdCB3aXRoIHNUeXBlLCBiVmlzaWJsZSBhbmQgYlNlYXJjaGFibGUgZXRjXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNvbHVtbk9wdGlvbnMob1NldHRpbmdzLCBpQ29sLCBvT3B0aW9ucykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2lDb2xdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoID0gJChvQ29sLm5UaCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGdldCB3aWR0aCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBET00uIFdlIGNhbid0IGdldCBpdCBmcm9tIENTU1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYXMgd2UnZCBuZWVkIHRvIHBhcnNlIHRoZSBDU1Mgc3R5bGVzaGVldC4gYHdpZHRoYCBvcHRpb24gY2FuIG92ZXJyaWRlXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW9Db2wuc1dpZHRoT3JpZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpZHRoIGF0dHJpYnV0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuc1dpZHRoT3JpZyA9IHRoLmF0dHIoJ3dpZHRoJykgfHwgbnVsbDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3R5bGUgYXR0cmlidXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAodGguYXR0cignc3R5bGUnKSB8fCAnJykubWF0Y2goL3dpZHRoOlxccyooXFxkK1tweGVtJV0rKS8pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuc1dpZHRoT3JpZyA9IHRbMV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFVzZXIgc3BlY2lmaWVkIGNvbHVtbiBvcHRpb25zICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0Q29scyhvT3B0aW9ucyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcCBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gdGhlaXIgSHVuZ2FyaWFuIGNvdW50ZXJwYXJ0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbiwgb09wdGlvbnMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgbURhdGFQcm9wICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9PcHRpb25zLm1EYXRhUHJvcCAhPT0gdW5kZWZpbmVkICYmICFvT3B0aW9ucy5tRGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvT3B0aW9ucy5tRGF0YSA9IG9PcHRpb25zLm1EYXRhUHJvcDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvT3B0aW9ucy5zVHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvQ29sLl9zTWFudWFsVHlwZSA9IG9PcHRpb25zLnNUeXBlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGNsYXNzYCBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSmF2YXNjcmlwdCwgc28gd2UgbmVlZCB0byBwcm92aWRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFiaWxpdHkgdG8gdXNlIGEgdmFsaWQgbmFtZSBmb3IgdGhlIGNhbWVsIGNhc2UgaW5wdXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob09wdGlvbnMuY2xhc3NOYW1lICYmICFvT3B0aW9ucy5zQ2xhc3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb09wdGlvbnMuc0NsYXNzID0gb09wdGlvbnMuY2xhc3NOYW1lO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQob0NvbCwgb09wdGlvbnMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbk1hcChvQ29sLCBvT3B0aW9ucywgXCJzV2lkdGhcIiwgXCJzV2lkdGhPcmlnXCIpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBpRGF0YVNvcnQgdG8gYmUgYXBwbGllZCAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpLCBidXQgYURhdGFTb3J0IHdpbGwgdGFrZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHByaW9yaXR5IGlmIGRlZmluZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob09wdGlvbnMuaURhdGFTb3J0ICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5hRGF0YVNvcnQgPSBbb09wdGlvbnMuaURhdGFTb3J0XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKG9Db2wsIG9PcHRpb25zLCBcImFEYXRhU29ydFwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBDYWNoZSB0aGUgZGF0YSBnZXQgYW5kIHNldCBmdW5jdGlvbnMgZm9yIHNwZWVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbURhdGFTcmMgPSBvQ29sLm1EYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1EYXRhID0gX2ZuR2V0T2JqZWN0RGF0YUZuKG1EYXRhU3JjKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtUmVuZGVyID0gb0NvbC5tUmVuZGVyID8gX2ZuR2V0T2JqZWN0RGF0YUZuKG9Db2wubVJlbmRlcikgOiBudWxsO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyVGVzdCA9IGZ1bmN0aW9uIChzcmMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLmluZGV4T2YoJ0AnKSAhPT0gLTE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb0NvbC5fYkF0dHJTcmMgPSAkLmlzUGxhaW5PYmplY3QobURhdGFTcmMpICYmIChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhdHRyVGVzdChtRGF0YVNyYy5zb3J0KSB8fCBhdHRyVGVzdChtRGF0YVNyYy50eXBlKSB8fCBhdHRyVGVzdChtRGF0YVNyYy5maWx0ZXIpXHJcblx0ICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIG9Db2wuZm5HZXREYXRhID0gZnVuY3Rpb24gKHJvd0RhdGEsIHR5cGUsIG1ldGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5uZXJEYXRhID0gbURhdGEocm93RGF0YSwgdHlwZSwgdW5kZWZpbmVkLCBtZXRhKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1SZW5kZXIgJiYgdHlwZSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1SZW5kZXIoaW5uZXJEYXRhLCB0eXBlLCByb3dEYXRhLCBtZXRhKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyRGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICBvQ29sLmZuU2V0RGF0YSA9IGZ1bmN0aW9uIChyb3dEYXRhLCB2YWwsIG1ldGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKG1EYXRhU3JjKShyb3dEYXRhLCB2YWwsIG1ldGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZSBpZiBEYXRhVGFibGVzIHNob3VsZCByZWFkIERPTSBkYXRhIGFzIGFuIG9iamVjdCBvciBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVXNlZCBpbiBfZm5HZXRSb3dFbGVtZW50c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtRGF0YVNyYyAhPT0gJ251bWJlcicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX3Jvd1JlYWRPYmplY3QgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEZlYXR1cmUgc29ydGluZyBvdmVycmlkZXMgY29sdW1uIHNwZWNpZmljIHdoZW4gb2ZmICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW9TZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvQ29sLmJTb3J0YWJsZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoLmFkZENsYXNzKG9DbGFzc2VzLnNTb3J0YWJsZU5vbmUpOyAvLyBIYXZlIHRvIGFkZCBjbGFzcyBoZXJlIGFzIG9yZGVyIGV2ZW50IGlzbid0IGNhbGxlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIENoZWNrIHRoYXQgdGhlIGNsYXNzIGFzc2lnbm1lbnQgaXMgY29ycmVjdCBmb3Igc29ydGluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGJBc2MgPSAkLmluQXJyYXkoJ2FzYycsIG9Db2wuYXNTb3J0aW5nKSAhPT0gLTE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYkRlc2MgPSAkLmluQXJyYXkoJ2Rlc2MnLCBvQ29sLmFzU29ydGluZykgIT09IC0xO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFvQ29sLmJTb3J0YWJsZSB8fCAoIWJBc2MgJiYgIWJEZXNjKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZU5vbmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzSlVJID0gXCJcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJBc2MgJiYgIWJEZXNjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlQXNjO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFiQXNjICYmIGJEZXNjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlRGVzYztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzID0gb0NsYXNzZXMuc1NvcnRhYmxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IG9DbGFzc2VzLnNTb3J0SlVJO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFkanVzdCB0aGUgdGFibGUgY29sdW1uIHdpZHRocyBmb3IgbmV3IGRhdGEuIE5vdGU6IHlvdSB3b3VsZCBwcm9iYWJseSB3YW50IHRvXHJcblx0ICAgICAgICAgICAgICAgICAqIGRvIGEgcmVkcmF3IGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiFcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BZGp1c3RDb2x1bW5TaXppbmcoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIE5vdCBpbnRlcmVzdGVkIGluIGRvaW5nIGNvbHVtbiB3aWR0aCBjYWxjdWxhdGlvbiBpZiBhdXRvLXdpZHRoIGlzIGRpc2FibGVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Mub0ZlYXR1cmVzLmJBdXRvV2lkdGggIT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBjb2x1bW5zLmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnNbaV0ublRoLnN0eWxlLndpZHRoID0gY29sdW1uc1tpXS5zV2lkdGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbC5zWSAhPT0gJycgfHwgc2Nyb2xsLnNYICE9PSAnJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mblNjcm9sbERyYXcoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi1zaXppbmcnLCBbc2V0dGluZ3NdKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb3ZlcnQgdGhlIGluZGV4IG9mIGEgdmlzaWJsZSBjb2x1bW4gdG8gdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5ICh0YWtlIGFjY291bnRcclxuXHQgICAgICAgICAgICAgICAgICogb2YgaGlkZGVuIGNvbHVtbnMpXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaU1hdGNoIFZpc2libGUgY29sdW1uIGluZGV4IHRvIGxvb2t1cFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2ludH0gaSB0aGUgZGF0YSBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChvU2V0dGluZ3MsIGlNYXRjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFpVmlzID0gX2ZuR2V0Q29sdW1ucyhvU2V0dGluZ3MsICdiVmlzaWJsZScpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYWlWaXNbaU1hdGNoXSA9PT0gJ251bWJlcicgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFpVmlzW2lNYXRjaF0gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ292ZXJ0IHRoZSBpbmRleCBvZiBhbiBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSBhbmQgY29udmVydCBpdCB0byB0aGUgdmlzaWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIGNvbHVtbiBpbmRleCAodGFrZSBhY2NvdW50IG9mIGhpZGRlbiBjb2x1bW5zKVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBDb2x1bW4gaW5kZXggdG8gbG9va3VwXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKG9TZXR0aW5ncywgaU1hdGNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgJ2JWaXNpYmxlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaVBvcyA9ICQuaW5BcnJheShpTWF0Y2gsIGFpVmlzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVBvcyAhPT0gLTEgPyBpUG9zIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuVmlzYmxlQ29sdW1ucyhvU2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgJ2JWaXNpYmxlJykubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdldCBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyB0aGF0IG1hdGNoIGEgZ2l2ZW4gcHJvcGVydHlcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzUGFyYW0gUGFyYW1ldGVyIGluIGFvQ29sdW1ucyB0byBsb29rIGZvciAtIHR5cGljYWxseVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBiVmlzaWJsZSBvciBiU2VhcmNoYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBpbmRleGVzIHdpdGggbWF0Y2hlZCBwcm9wZXJ0aWVzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkdldENvbHVtbnMob1NldHRpbmdzLCBzUGFyYW0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgJC5tYXAob1NldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24gKHZhbCwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxbc1BhcmFtXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goaSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlIHRoZSAndHlwZScgb2YgYSBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Db2x1bW5UeXBlcyhzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlcyA9IERhdGFUYWJsZS5leHQudHlwZS5kZXRlY3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaWVuLCBqLCBqZW4sIGssIGtlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2wsIGNlbGwsIGRldGVjdGVkVHlwZSwgY2FjaGU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggY29sdW1uLCBzcGluIG92ZXIgdGhlIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY29sdW1ucy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sID0gY29sdW1uc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZSA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbC5zVHlwZSAmJiBjb2wuX3NNYW51YWxUeXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5zVHlwZSA9IGNvbC5fc01hbnVhbFR5cGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjb2wuc1R5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamVuID0gdHlwZXMubGVuZ3RoIDsgaiA8IGplbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCwga2VuID0gZGF0YS5sZW5ndGggOyBrIDwga2VuIDsgaysrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgY2FjaGUgYXJyYXkgc28gd2Ugb25seSBuZWVkIHRvIGdldCB0aGUgdHlwZSBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgZm9ybWF0dGVyIG9uY2UgKHdoZW4gdXNpbmcgbXVsdGlwbGUgZGV0ZWN0b3JzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVtrXSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlW2tdID0gX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIGssIGksICd0eXBlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZFR5cGUgPSB0eXBlc1tqXShjYWNoZVtrXSwgc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBudWxsLCB0aGVuIHRoaXMgdHlwZSBjYW4ndCBhcHBseSB0byB0aGlzIGNvbHVtbiwgc29cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByYXRoZXIgdGhhbiB0ZXN0aW5nIGFsbCBjZWxscywgYnJlYWsgb3V0LiBUaGVyZSBpcyBhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VwdGlvbiBmb3IgdGhlIGxhc3QgdHlwZSB3aGljaCBpcyBgaHRtbGAuIFdlIG5lZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2FuIGFsbCByb3dzIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIG1peCBzdHJpbmcgYW5kIEhUTUxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGV0ZWN0ZWRUeXBlICYmIGogIT09IHR5cGVzLmxlbmd0aCAtIDEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGEgc2luZ2xlIG1hdGNoIGlzIG5lZWRlZCBmb3IgaHRtbCB0eXBlIHNpbmNlIGl0IGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm90dG9tIG9mIHRoZSBwaWxlIGFuZCB2ZXJ5IHNpbWlsYXIgdG8gc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldGVjdGVkVHlwZSA9PT0gJ2h0bWwnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIGlzIHZhbGlkIGZvciBhbGwgZGF0YSBwb2ludHMgaW4gdGhlIGNvbHVtbiAtIHVzZSB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRUeXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sLnNUeXBlID0gZGV0ZWN0ZWRUeXBlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgLSBpZiBubyB0eXBlIHdhcyBkZXRlY3RlZCwgYWx3YXlzIHVzZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2wuc1R5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5zVHlwZSA9ICdzdHJpbmcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFRha2UgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyBhbmQgc3RhdGljIGNvbHVtbnMgYXJyYXlzIGFuZCBjYWxjdWxhdGUgaG93XHJcblx0ICAgICAgICAgICAgICAgICAqIHRoZXkgcmVsYXRlIHRvIGNvbHVtbiBpbmRleGVzLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2lsbCB0aGVuIGFwcGx5IHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBkZWZpbml0aW9uIGZvdW5kIGZvciBhIGNvbHVtbiB0byBhIHN1aXRhYmxlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xEZWZzIFRoZSBhb0NvbHVtbkRlZnMgYXJyYXkgdGhhdCBpcyB0byBiZSBhcHBsaWVkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhb0NvbHMgVGhlIGFvQ29sdW1ucyBhcnJheSB0aGF0IGRlZmluZXMgY29sdW1ucyBpbmRpdmlkdWFsbHlcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIC0gdGFrZXMgdHdvIHBhcmFtZXRlcnMsIHRoZSBjYWxjdWxhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGNvbHVtbiBpbmRleCBhbmQgdGhlIGRlZmluaXRpb24gZm9yIHRoYXQgY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BcHBseUNvbHVtbkRlZnMob1NldHRpbmdzLCBhb0NvbERlZnMsIGFvQ29scywgZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpTGVuLCBqLCBqTGVuLCBrLCBrTGVuLCBkZWY7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ29sdW1uIGRlZmluaXRpb25zIHdpdGggYVRhcmdldHNcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhb0NvbERlZnMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBMb29wIG92ZXIgdGhlIGRlZmluaXRpb25zIGFycmF5IC0gbG9vcCBpbiByZXZlcnNlIHNvIGZpcnN0IGluc3RhbmNlIGhhcyBwcmlvcml0eSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGFvQ29sRGVmcy5sZW5ndGggLSAxIDsgaSA+PSAwIDsgaS0tKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZiA9IGFvQ29sRGVmc1tpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEVhY2ggZGVmaW5pdGlvbiBjYW4gdGFyZ2V0IG11bHRpcGxlIGNvbHVtbnMsIGFzIGl0IGlzIGFuIGFycmF5ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhVGFyZ2V0cyA9IGRlZi50YXJnZXRzICE9PSB1bmRlZmluZWQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnRhcmdldHMgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLmFUYXJnZXRzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmlzQXJyYXkoYVRhcmdldHMpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhVGFyZ2V0cyA9IFthVGFyZ2V0c107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGpMZW4gPSBhVGFyZ2V0cy5sZW5ndGggOyBqIDwgakxlbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhVGFyZ2V0c1tqXSA9PT0gJ251bWJlcicgJiYgYVRhcmdldHNbal0gPj0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFkZCBjb2x1bW5zIHRoYXQgd2UgZG9uJ3QgeWV0IGtub3cgYWJvdXQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29sdW1ucy5sZW5ndGggPD0gYVRhcmdldHNbal0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkQ29sdW1uKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJbnRlZ2VyLCBiYXNpYyBpbmRleCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGFUYXJnZXRzW2pdLCBkZWYpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBOZWdhdGl2ZSBpbnRlZ2VyLCByaWdodCB0byBsZWZ0IGNvbHVtbiBjb3VudGluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGNvbHVtbnMubGVuZ3RoICsgYVRhcmdldHNbal0sIGRlZik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYVRhcmdldHNbal0gPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2xhc3MgbmFtZSBtYXRjaGluZyBvbiBUSCBlbGVtZW50ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCwga0xlbiA9IGNvbHVtbnMubGVuZ3RoIDsgayA8IGtMZW4gOyBrKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFUYXJnZXRzW2pdID09IFwiX2FsbFwiIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChjb2x1bW5zW2tdLm5UaCkuaGFzQ2xhc3MoYVRhcmdldHNbal0pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbihrLCBkZWYpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFN0YXRpY2FsbHkgZGVmaW5lZCBjb2x1bW5zIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYW9Db2xzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGFvQ29scy5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbihpLCBhb0NvbHNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFkZCBhIGRhdGEgYXJyYXkgdG8gdGhlIHRhYmxlLCBjcmVhdGluZyBET00gbm9kZSBldGMuIFRoaXMgaXMgdGhlIHBhcmFsbGVsIHRvXHJcblx0ICAgICAgICAgICAgICAgICAqIF9mbkdhdGhlckRhdGEsIGJ1dCBmb3IgYWRkaW5nIHJvd3MgZnJvbSBhIEphdmFzY3JpcHQgc291cmNlLCByYXRoZXIgdGhhbiBhXHJcblx0ICAgICAgICAgICAgICAgICAqIERPTSBzb3VyY2UuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhRGF0YSBkYXRhIGFycmF5IHRvIGJlIGFkZGVkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IFtuVHJdIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cclxuXHQgICAgICAgICAgICAgICAgICogICAgaWYgblRyIGlzLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2ludH0gPj0wIGlmIHN1Y2Nlc3NmdWwgKGluZGV4IG9mIG5ldyBhb0RhdGEgZW50cnkpLCAtMSBpZiBmYWlsZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQWRkRGF0YShvU2V0dGluZ3MsIGFEYXRhSW4sIG5UciwgYW5UZHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgb2JqZWN0IGZvciBzdG9yaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbmV3IHJvdyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlSb3cgPSBvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvRGF0YSA9ICQuZXh0ZW5kKHRydWUsIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Sb3csIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzcmM6IG5UciA/ICdkb20nIDogJ2RhdGEnXHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBvRGF0YS5fYURhdGEgPSBhRGF0YUluO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmFvRGF0YS5wdXNoKG9EYXRhKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBDcmVhdGUgdGhlIGNlbGxzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgblRkLCBzVGhpc1R5cGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNvbHVtbnMubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdvcmtpbmcgd2l0aCBhIHJvdywgdGhlIGRhdGEgc291cmNlIG9iamVjdCBtdXN0IGJlIHBvcHVsYXRlZC4gSW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgY2FzZXMsIHRoZSBkYXRhIHNvdXJjZSBvYmplY3QgaXMgYWxyZWFkeSBwb3B1bGF0ZWQsIHNvIHdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3Qgb3ZlcndyaXRlIGl0LCB3aGljaCBtaWdodCBicmVhayBiaW5kaW5ncyBldGNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoblRyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblNldENlbGxEYXRhKG9TZXR0aW5ncywgaVJvdywgaSwgX2ZuR2V0Q2VsbERhdGEob1NldHRpbmdzLCBpUm93LCBpKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnNbaV0uc1R5cGUgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEFkZCB0byB0aGUgZGlzcGxheSBhcnJheSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5wdXNoKGlSb3cpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgRE9NIGluZm9ybWF0aW9uLCBvciByZWdpc3RlciBpdCBpZiBhbHJlYWR5IHByZXNlbnQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChuVHIgfHwgIW9TZXR0aW5ncy5vRmVhdHVyZXMuYkRlZmVyUmVuZGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ3JlYXRlVHIob1NldHRpbmdzLCBpUm93LCBuVHIsIGFuVGRzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVJvdztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBZGQgb25lIG9yIG1vcmUgVFIgZWxlbWVudHMgdG8gdGhlIHRhYmxlLiBHZW5lcmFsbHkgd2UnZCBleHBlY3QgdG9cclxuXHQgICAgICAgICAgICAgICAgICogdXNlIHRoaXMgZm9yIHJlYWRpbmcgZGF0YSBmcm9tIGEgRE9NIHNvdXJjZWQgdGFibGUsIGJ1dCBpdCBjb3VsZCBiZVxyXG5cdCAgICAgICAgICAgICAgICAgKiB1c2VkIGZvciBhbiBUUiBlbGVtZW50LiBOb3RlIHRoYXQgaWYgYSBUUiBpcyBnaXZlbiwgaXQgaXMgdXNlZCAoaS5lLlxyXG5cdCAgICAgICAgICAgICAgICAgKiBpdCBpcyBub3QgY2xvbmVkKS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxub2RlfGpRdWVyeX0gdHJzIFRoZSBUUiBlbGVtZW50KHMpIHRvIGFkZCB0byB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyBmb3IgdGhlIGFkZGVkIHJvd3NcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQWRkVHIoc2V0dGluZ3MsIHRycykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvdztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbiBpbmRpdmlkdWFsIG5vZGUgdG8gYmUgcGFzc2VkIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0cnMgaW5zdGFuY2VvZiAkKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRycyA9ICQodHJzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJzLm1hcChmdW5jdGlvbiAoaSwgZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBfZm5HZXRSb3dFbGVtZW50cyhzZXR0aW5ncywgZWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5BZGREYXRhKHNldHRpbmdzLCByb3cuZGF0YSwgZWwsIHJvdy5jZWxscyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUYWtlIGEgVFIgZWxlbWVudCBhbmQgY29udmVydCBpdCB0byBhbiBpbmRleCBpbiBhb0RhdGFcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbiB0aGUgVFIgZWxlbWVudCB0byBmaW5kXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgbnVsbCBpZiBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuTm9kZVRvRGF0YUluZGV4KG9TZXR0aW5ncywgbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChuLl9EVF9Sb3dJbmRleCAhPT0gdW5kZWZpbmVkKSA/IG4uX0RUX1Jvd0luZGV4IDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUYWtlIGEgVEQgZWxlbWVudCBhbmQgY29udmVydCBpdCBpbnRvIGEgY29sdW1uIGRhdGEgaW5kZXggKG5vdCB0aGUgdmlzaWJsZSBpbmRleClcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgbnVtYmVyIHRoZSBURC9USCBjYW4gYmUgZm91bmQgaW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbiBUaGUgVEQvVEggZWxlbWVudCB0byBmaW5kXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgLTEgaWYgbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbk5vZGVUb0NvbHVtbkluZGV4KG9TZXR0aW5ncywgaVJvdywgbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuaW5BcnJheShuLCBvU2V0dGluZ3MuYW9EYXRhW2lSb3ddLmFuQ2VsbHMpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdldCB0aGUgZGF0YSBmb3IgYSBnaXZlbiBjZWxsIGZyb20gdGhlIGludGVybmFsIGNhY2hlLCB0YWtpbmcgaW50byBhY2NvdW50IGRhdGEgbWFwcGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gcm93SWR4IGFvRGF0YSByb3cgaWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gdHlwZSBkYXRhIGdldCB0eXBlICgnZGlzcGxheScsICd0eXBlJyAnZmlsdGVyJyAnc29ydCcpXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7Kn0gQ2VsbCBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXcgPSBzZXR0aW5ncy5pRHJhdztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRDb250ZW50ID0gY29sLnNEZWZhdWx0Q29udGVudDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjZWxsRGF0YSA9IGNvbC5mbkdldERhdGEocm93RGF0YSwgdHlwZSwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvd0lkeCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbElkeFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaURyYXdFcnJvciAhPSBkcmF3ICYmIGRlZmF1bHRDb250ZW50ID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxvZyhzZXR0aW5ncywgMCwgXCJSZXF1ZXN0ZWQgdW5rbm93biBwYXJhbWV0ZXIgXCIgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBjb2wubURhdGEgPT0gJ2Z1bmN0aW9uJyA/ICd7ZnVuY3Rpb259JyA6IFwiJ1wiICsgY29sLm1EYXRhICsgXCInXCIpICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGZvciByb3cgXCIgKyByb3dJZHgsIDQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5pRHJhd0Vycm9yID0gZHJhdztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb250ZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGwsIHdlIGNhbiB1c2UgZGVmYXVsdCBjb2x1bW4gZGF0YSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKChjZWxsRGF0YSA9PT0gcm93RGF0YSB8fCBjZWxsRGF0YSA9PT0gbnVsbCkgJiYgZGVmYXVsdENvbnRlbnQgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IGRlZmF1bHRDb250ZW50O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNlbGxEYXRhID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRhdGEgc291cmNlIGlzIGEgZnVuY3Rpb24sIHRoZW4gd2UgcnVuIGl0IGFuZCB1c2UgdGhlIHJldHVybixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRpbmcgaW4gdGhlIHNjb3BlIG9mIHRoZSBkYXRhIG9iamVjdCAoZm9yIGluc3RhbmNlcylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbERhdGEuY2FsbChyb3dEYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbERhdGEgPT09IG51bGwgJiYgdHlwZSA9PSAnZGlzcGxheScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VsbERhdGE7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogU2V0IHRoZSB2YWx1ZSBmb3IgYSBzcGVjaWZpYyBjZWxsLCBpbnRvIHRoZSBpbnRlcm5hbCBkYXRhIGNhY2hlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSByb3dJZHggYW9EYXRhIHJvdyBpZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBDb2x1bW4gaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5TZXRDZWxsRGF0YShzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHZhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0RhdGEgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XS5fYURhdGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sLmZuU2V0RGF0YShyb3dEYXRhLCB2YWwsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nczogc2V0dGluZ3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93OiByb3dJZHgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBjb2xJZHhcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gUHJpdmF0ZSB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgdG8gbWF0Y2ggYWN0aW9uIHN5bnRheCBpbiB0aGUgZGF0YSBwcm9wZXJ0eSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fcmVBcnJheSA9IC9cXFsuKj9cXF0kLztcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fcmVGbiA9IC9cXChcXCkkLztcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBTcGxpdCBzdHJpbmcgb24gcGVyaW9kcywgdGFraW5nIGludG8gYWNjb3VudCBlc2NhcGVkIHBlcmlvZHNcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0XHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2FycmF5fSBTcGxpdCBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNwbGl0T2JqTm90YXRpb24oc3RyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5tYXAoc3RyLm1hdGNoKC8oXFxcXC58W15cXC5dKSsvZyksIGZ1bmN0aW9uIChzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvXFxcXC4vZywgJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgZ2V0IGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkdldE9iamVjdERhdGFGbihtU291cmNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KG1Tb3VyY2UpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQnVpbGQgYW4gb2JqZWN0IG9mIGdldCBmdW5jdGlvbnMsIGFuZCB3cmFwIHRoZW0gaW4gYSBzaW5nbGUgY2FsbCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0ge307XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKG1Tb3VyY2UsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvW2tleV0gPSBfZm5HZXRPYmplY3REYXRhRm4odmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG9bdHlwZV0gfHwgby5fO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAhPT0gdW5kZWZpbmVkID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtU291cmNlID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogR2l2ZSBhbiBlbXB0eSBzdHJpbmcgZm9yIHJlbmRlcmluZyAvIHNvcnRpbmcgZXRjICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IC8vIHR5cGUsIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtU291cmNlKGRhdGEsIHR5cGUsIHJvdywgbWV0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbVNvdXJjZS5pbmRleE9mKCdbJykgIT09IC0xIHx8IG1Tb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGVyZSBpcyBhIC4gaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlbiB0aGUgZGF0YSBzb3VyY2UgaXMgaW4gYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIG5lc3RlZCBvYmplY3Qgc28gd2UgbG9vcCBvdmVyIHRoZSBkYXRhIGZvciBlYWNoIGxldmVsIHRvIGdldCB0aGUgbmV4dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGxldmVsIGRvd24uIE9uIGVhY2ggbG9vcCB3ZSB0ZXN0IGZvciB1bmRlZmluZWQsIGFuZCBpZiBmb3VuZCBpbW1lZGlhdGVseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHJldHVybi4gVGhpcyBhbGxvd3MgZW50aXJlIG9iamVjdHMgdG8gYmUgbWlzc2luZyBhbmQgc0RlZmF1bHRDb250ZW50IHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYmUgdXNlZCBpZiBkZWZpbmVkLCByYXRoZXIgdGhhbiB0aHJvd2luZyBhbiBlcnJvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZXRjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgc3JjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG91dCwgaW5uZXJTcmM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3JjICE9PSBcIlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oc3JjKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGEubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIHNwZWNpYWwgbm90YXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUZuKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycmF5Tm90YXRpb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgbm90YXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbmRpdGlvbiBhbGxvd3Mgc2ltcGx5IFtdIHRvIGJlIHBhc3NlZCBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtpXSAhPT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbYVtpXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBnZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5zcGxpY2UoMCwgaSArIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclNyYyA9IGEuam9pbignLicpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhdmVyc2UgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgZ2V0dGluZyB0aGUgcHJvcGVydGllcyByZXF1ZXN0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpMZW4gPSBkYXRhLmxlbmd0aCA7IGogPCBqTGVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChmZXRjaERhdGEoZGF0YVtqXSwgdHlwZSwgaW5uZXJTcmMpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzdHJpbmcgaXMgZ2l2ZW4gaW4gYmV0d2VlbiB0aGUgYXJyYXkgbm90YXRpb24gaW5kaWNhdG9ycywgdGhhdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB1c2VkIHRvIGpvaW4gdGhlIHN0cmluZ3MgdG9nZXRoZXIsIG90aGVyd2lzZSBhbiBhcnJheSBpcyByZXR1cm5lZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgam9pbiA9IGFycmF5Tm90YXRpb25bMF0uc3Vic3RyaW5nKDEsIGFycmF5Tm90YXRpb25bMF0ubGVuZ3RoIC0gMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAoam9pbiA9PT0gXCJcIikgPyBvdXQgOiBvdXQuam9pbihqb2luKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbm5lciBjYWxsIHRvIGZldGNoRGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2UgcmVxdWVzdGVkLCBzbyB3ZSBleGl0IGZyb20gdGhlIGxvb3BcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZ1bmNOb3RhdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjYWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2FbaV1dKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwgfHwgZGF0YVthW2ldXSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2FbaV1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHsgLy8gcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGF0YShkYXRhLCB0eXBlLCBtU291cmNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVttU291cmNlXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiBpbnRvIGFjY291bnQgdGhlIGFiaWxpdHkgdG8gdXNlIG5lc3RlZCBvYmplY3RzIGFzIGEgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgc2V0IGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNldE9iamVjdERhdGFGbihtU291cmNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KG1Tb3VyY2UpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogVW5saWtlIGdldCwgb25seSB0aGUgdW5kZXJzY29yZSAoZ2xvYmFsKSBvcHRpb24gaXMgdXNlZCBmb3IgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0dGluZyBkYXRhIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIHR5cGUgaGVyZS4gVGhpcyBpcyB3aHkgYW4gb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogb3B0aW9uIGlzIG5vdCBkb2N1bWVudGVkIGZvciBgbURhdGFgICh3aGljaCBpcyByZWFkL3dyaXRlKSwgYnV0IGl0IGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZm9yIGBtUmVuZGVyYCB3aGljaCBpcyByZWFkIG9ubHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mblNldE9iamVjdERhdGFGbihtU291cmNlLl8pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobVNvdXJjZSA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIE5vdGhpbmcgdG8gZG8gd2hlbiB0aGUgZGF0YSBzb3VyY2UgaXMgbnVsbCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsLCBtZXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1Tb3VyY2UoZGF0YSwgJ3NldCcsIHZhbCwgbWV0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbVNvdXJjZS5pbmRleE9mKCdbJykgIT09IC0xIHx8IG1Tb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBMaWtlIHRoZSBnZXQsIHdlIG5lZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIG5lc3RlZCBvYmplY3QgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhLCB2YWwsIHNyYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IF9mblNwbGl0T2JqTm90YXRpb24oc3JjKSwgYjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFMYXN0ID0gYVthLmxlbmd0aCAtIDFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvLCBpbm5lclNyYztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gYS5sZW5ndGggLSAxIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gYXJyYXkgbm90YXRpb24gcmVxdWVzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUFycmF5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUZuKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyYXlOb3RhdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVthW2ldXSA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBzZXQgc28gd2UgY2FuIHJlY3Vyc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gYS5zbGljZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuc3BsaWNlKDAsIGkgKyAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclNyYyA9IGIuam9pbignLicpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBlYWNoIGVudHJ5IGluIHRoZSBhcnJheSBzZXR0aW5nIHRoZSBwcm9wZXJ0aWVzIHJlcXVlc3RlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gdmFsLmxlbmd0aCA7IGogPCBqTGVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB7fTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RGF0YShvLCB2YWxbal0sIGlubmVyU3JjKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVthW2ldXS5wdXNoKG8pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlubmVyIGNhbGwgdG8gc2V0RGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBhbmQgaGFzIHNldCB0aGUgZGF0YSwgdGh1cyB3ZSBjYW4gZXhpdCBoZXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZnVuY05vdGF0aW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gY2FsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbYVtpXV0odmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmVzdGVkIG9iamVjdCBkb2Vzbid0IGN1cnJlbnRseSBleGlzdCAtIHNpbmNlIHdlIGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5aW5nIHRvIHNldCB0aGUgdmFsdWUgLSBjcmVhdGUgaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2FbaV1dID09PSBudWxsIHx8IGRhdGFbYVtpXV0gPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbYVtpXV0gPSB7fTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2FbaV1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXN0IGl0ZW0gaW4gdGhlIGlucHV0IC0gaS5lLCB0aGUgYWN0dWFsIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYUxhc3QubWF0Y2goX19yZUZuKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gY2FsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbYUxhc3QucmVwbGFjZShfX3JlRm4sICcnKV0odmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFycmF5IG5vdGF0aW9uIGlzIHVzZWQsIHdlIGp1c3Qgd2FudCB0byBzdHJpcCBpdCBhbmQgdXNlIHRoZSBwcm9wZXJ0eSBuYW1lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYXNzaWduIHRoZSB2YWx1ZS4gSWYgaXQgaXNuJ3QgdXNlZCwgdGhlbiB3ZSBnZXQgdGhlIHJlc3VsdCB3ZSB3YW50IGFueXdheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVthTGFzdC5yZXBsYWNlKF9fcmVBcnJheSwgJycpXSA9IHZhbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsKSB7IC8vIG1ldGEgaXMgYWxzbyBwYXNzZWQgaW4sIGJ1dCBub3QgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0RGF0YShkYXRhLCB2YWwsIG1Tb3VyY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBBcnJheSBvciBmbGF0IG9iamVjdCBtYXBwaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbbVNvdXJjZV0gPSB2YWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgZnVsbCB0YWJsZSBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyBhcnJheSB7YXJyYXl9IGFEYXRhIE1hc3RlciBkYXRhIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkdldERhdGFNYXN0ZXIoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcGx1Y2soc2V0dGluZ3MuYW9EYXRhLCAnX2FEYXRhJyk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogTnVrZSB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ2xlYXJUYWJsZShzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggPSAwO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICogVGFrZSBhbiBhcnJheSBvZiBpbnRlZ2VycyAoaW5kZXggYXJyYXkpIGFuZCByZW1vdmUgYSB0YXJnZXQgaW50ZWdlciAodmFsdWUgLSBub3RcclxuXHQgICAgICAgICAgICAgICAgKiB0aGUga2V5ISlcclxuXHQgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gYSBJbmRleCBhcnJheSB0byB0YXJnZXRcclxuXHQgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlUYXJnZXQgdmFsdWUgdG8gZmluZFxyXG5cdCAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRGVsZXRlSW5kZXgoYSwgaVRhcmdldCwgc3BsaWNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaVRhcmdldEluZGV4ID0gLTE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBhLmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbaV0gPT0gaVRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpVGFyZ2V0SW5kZXggPSBpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhW2ldID4gaVRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ldLS07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpVGFyZ2V0SW5kZXggIT0gLTEgJiYgc3BsaWNlID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhLnNwbGljZShpVGFyZ2V0SW5kZXgsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIE1hcmsgY2FjaGVkIGRhdGEgYXMgaW52YWxpZCBzdWNoIHRoYXQgYSByZS1yZWFkIG9mIHRoZSBkYXRhIHdpbGwgb2NjdXIgd2hlblxyXG5cdCAgICAgICAgICAgICAgICAgKiB0aGUgY2FjaGVkIGRhdGEgaXMgbmV4dCByZXF1ZXN0ZWQuIEFsc28gdXBkYXRlIGZyb20gdGhlIGRhdGEgc291cmNlIG9iamVjdC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7aW50fSAgICByb3dJZHggICBSb3cgaW5kZXggdG8gaW52YWxpZGF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gICAgU291cmNlIHRvIGludmFsaWRhdGUgZnJvbTogdW5kZWZpbmVkLCAnYXV0bycsICdkb20nXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICBvciAnZGF0YSdcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtpbnR9ICAgIFtjb2xJZHhdIENvbHVtbiBpbmRleCB0byBpbnZhbGlkYXRlLiBJZiB1bmRlZmluZWQgdGhlIHdob2xlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICByb3cgd2lsbCBiZSBpbnZhbGlkYXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHRvZG8gRm9yIHRoZSBtb2R1bGFyaXNhdGlvbiBvZiB2MS4xMSB0aGlzIHdpbGwgbmVlZCB0byBiZWNvbWUgYSBjYWxsYmFjaywgc29cclxuXHQgICAgICAgICAgICAgICAgICogICB0aGUgc29ydCBhbmQgZmlsdGVyIG1ldGhvZHMgY2FuIHN1YnNjcmliZSB0byBpdC4gVGhhdCB3aWxsIHJlcXVpcmVkXHJcblx0ICAgICAgICAgICAgICAgICAqICAgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBmb3Igc29ydGluZywgd2hpY2ggaXMgd2h5IGl0IGlzIG5vdCBhbHJlYWR5IGJha2VkIGluXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5JbnZhbGlkYXRlKHNldHRpbmdzLCByb3dJZHgsIHNyYywgY29sSWR4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaWVuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxXcml0ZSA9IGZ1bmN0aW9uIChjZWxsLCBjb2wpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHZlcnkgZnJ1c3RyYXRpbmcsIGJ1dCBpbiBJRSBpZiB5b3UganVzdCB3cml0ZSBkaXJlY3RseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGlubmVySFRNTCwgYW5kIGVsZW1lbnRzIHRoYXQgYXJlIG92ZXJ3cml0dGVuIGFyZSBHQydlZCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBldmVuIGlmIHRoZXJlIGlzIGEgcmVmZXJlbmNlIHRvIHRoZW0gZWxzZXdoZXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNlbGwuY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5yZW1vdmVDaGlsZChjZWxsLmZpcnN0Q2hpbGQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93SWR4LCBjb2wsICdkaXNwbGF5Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFyZSB3ZSByZWFkaW5nIGxhc3QgZGF0YSBmcm9tIERPTSBvciB0aGUgZGF0YSBvYmplY3Q/XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3JjID09PSAnZG9tJyB8fCAoKCFzcmMgfHwgc3JjID09PSAnYXV0bycpICYmIHJvdy5zcmMgPT09ICdkb20nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgRE9NXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MsIHJvdywgY29sSWR4LCBjb2xJZHggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJvdy5fYURhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWRpbmcgZnJvbSBkYXRhIG9iamVjdCwgdXBkYXRlIHRoZSBET01cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbHMgPSByb3cuYW5DZWxscztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xJZHggIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdyaXRlKGNlbGxzW2NvbElkeF0sIGNvbElkeCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBjZWxscy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdyaXRlKGNlbGxzW2ldLCBpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYm90aCByb3cgYW5kIGNlbGwgaW52YWxpZGF0aW9uLCB0aGUgY2FjaGVkIGRhdGEgZm9yIHNvcnRpbmcgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXJpbmcgaXMgbnVsbGVkIG91dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcm93Ll9hU29ydERhdGEgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcm93Ll9hRmlsdGVyRGF0YSA9IG51bGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgdHlwZSBmb3IgYSBzcGVjaWZpYyBjb2x1bW4gKGlmIGdpdmVuKSBvciBhbGwgY29sdW1ucyBzaW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29scyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb2xJZHggIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHNbY29sSWR4XS5zVHlwZSA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBjb2xzLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sc1tpXS5zVHlwZSA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgRGF0YVRhYmxlcyBzcGVjaWFsIGBEVF8qYCBhdHRyaWJ1dGVzIGZvciB0aGUgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUm93QXR0cmlidXRlcyhyb3cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEJ1aWxkIGEgZGF0YSBzb3VyY2Ugb2JqZWN0IGZyb20gYW4gSFRNTCByb3csIHJlYWRpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBjZWxscyB0aGF0IGFyZSBpbiB0aGUgcm93LlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtub2RlfG9iamVjdH0gVFIgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHJlYWQgZGF0YSBvciBleGlzdGluZyByb3dcclxuXHQgICAgICAgICAgICAgICAgICogICBvYmplY3QgZnJvbSB3aGljaCB0byByZS1yZWFkIHRoZSBkYXRhIGZyb20gdGhlIGNlbGxzXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7aW50fSBbY29sSWR4XSBPcHRpb25hbCBjb2x1bW4gaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHthcnJheXxvYmplY3R9IFtkXSBEYXRhIHNvdXJjZSBvYmplY3QuIElmIGBjb2xJZHhgIGlzIGdpdmVuIHRoZW4gdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHBhcmFtZXRlciBzaG91bGQgYWxzbyBiZSBnaXZlbiBhbmQgd2lsbCBiZSB1c2VkIHRvIHdyaXRlIHRoZSBkYXRhIGludG8uXHJcblx0ICAgICAgICAgICAgICAgICAqICAgT25seSB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIHdpbGwgYmUgd3JpdHRlblxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0d28gcGFyYW1ldGVyczogYGRhdGFgIHRoZSBkYXRhIHJlYWQsIGluXHJcblx0ICAgICAgICAgICAgICAgICAqICAgZG9jdW1lbnQgb3JkZXIsIGFuZCBgY2VsbHNgIGFuZCBhcnJheSBvZiBub2RlcyAodGhleSBjYW4gYmUgdXNlZnVsIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIGNhbGxlciwgc28gcmF0aGVyIHRoYW4gbmVlZGluZyBhIHNlY29uZCB0cmF2ZXJzYWwgdG8gZ2V0IHRoZW0sIGp1c3QgcmV0dXJuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgdGhlbSBmcm9tIGhlcmUpLlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkdldFJvd0VsZW1lbnRzKHNldHRpbmdzLCByb3csIGNvbElkeCwgZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGRzID0gW10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGQgPSByb3cuZmlyc3RDaGlsZCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBjb2wsIG8sIGkgPSAwLCBjb250ZW50cyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFJlYWQgPSBzZXR0aW5ncy5fcm93UmVhZE9iamVjdDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgZGF0YSBvYmplY3QgdG8gYmUgcGFzc2VkIGluLCBvciBjb25zdHJ1Y3RcclxuXHQgICAgICAgICAgICAgICAgICAgIGQgPSBkIHx8IG9iamVjdFJlYWQgPyB7fSA6IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gZnVuY3Rpb24gKHN0ciwgdGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IHN0ci5pbmRleE9mKCdAJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBzdHIuc3Vic3RyaW5nKGlkeCArIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRlciA9IF9mblNldE9iamVjdERhdGFGbihzdHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKGQsIHRkLmdldEF0dHJpYnV0ZShhdHRyKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgZGF0YSBmcm9tIGEgY2VsbCBhbmQgc3RvcmUgaW50byB0aGUgZGF0YSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjZWxsUHJvY2VzcyA9IGZ1bmN0aW9uIChjZWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbElkeCA9PT0gdW5kZWZpbmVkIHx8IGNvbElkeCA9PT0gaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBjb2x1bW5zW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9ICQudHJpbShjZWxsLmlubmVySFRNTCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sICYmIGNvbC5fYkF0dHJTcmMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oY29sLm1EYXRhLl8pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyKGQsIGNvbnRlbnRzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyKGNvbC5tRGF0YS5zb3J0LCBjZWxsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIoY29sLm1EYXRhLnR5cGUsIGNlbGwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cihjb2wubURhdGEuZmlsdGVyLCBjZWxsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgYGRhdGFgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbnMgdGhlIGRhdGEgY2FuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSByZWFkIHRvIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0UmVhZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29sLl9zZXR0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHNldHRlciBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wuX3NldHRlciA9IF9mblNldE9iamVjdERhdGFGbihjb2wubURhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wuX3NldHRlcihkLCBjb250ZW50cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkW2ldID0gY29udGVudHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHRyYCBlbGVtZW50IHdhcyBwYXNzZWQgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodGQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcIlREXCIgfHwgbmFtZSA9PSBcIlRIXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxQcm9jZXNzKHRkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkcy5wdXNoKHRkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGQgPSB0ZC5uZXh0U2libGluZztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeGlzdGluZyByb3cgb2JqZWN0IHBhc3NlZCBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRkcyA9IHJvdy5hbkNlbGxzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamVuID0gdGRzLmxlbmd0aCA7IGogPCBqZW4gOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFByb2Nlc3ModGRzW2pdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzOiB0ZHNcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENyZWF0ZSBhIG5ldyBUUiBlbGVtZW50IChhbmQgaXQncyBURCBjaGlsZHJlbikgZm9yIGEgcm93XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gaVJvdyBSb3cgdG8gY29uc2lkZXJcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gW25UckluXSBUUiBlbGVtZW50IHRvIGFkZCB0byB0aGUgdGFibGUgLSBvcHRpb25hbC4gSWYgbm90IGdpdmVuLFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGlmIG5UciBpcy5cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ3JlYXRlVHIob1NldHRpbmdzLCBpUm93LCBuVHJJbiwgYW5UZHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IG9TZXR0aW5ncy5hb0RhdGFbaVJvd10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93RGF0YSA9IHJvdy5fYURhdGEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHMgPSBbXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuVHIsIG5UZCwgb0NvbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpLCBpTGVuO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyb3cublRyID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgblRyID0gblRySW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93Lm5UciA9IG5UcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3cuYW5DZWxscyA9IGNlbGxzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBVc2UgYSBwcml2YXRlIHByb3BlcnR5IG9uIHRoZSBub2RlIHRvIGFsbG93IHJlc2VydmUgbWFwcGluZyBmcm9tIHRoZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdG8gdGhlIGFvRGF0YSBhcnJheSBmb3IgZmFzdCBsb29rIHVwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgblRyLl9EVF9Sb3dJbmRleCA9IGlSb3c7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNwZWNpYWwgcGFyYW1ldGVycyBjYW4gYmUgZ2l2ZW4gYnkgdGhlIGRhdGEgc291cmNlIHRvIGJlIHVzZWQgb24gdGhlIHJvdyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mblJvd0F0dHJpYnV0ZXMocm93KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogUHJvY2VzcyBlYWNoIGNvbHVtbiAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgblRkID0gblRySW4gPyBhblRkc1tpXSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQob0NvbC5zQ2VsbFR5cGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKG5UZCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGNyZWF0ZSB0aGUgSFRNTCBpZiBuZXcsIG9yIGlmIGEgcmVuZGVyaW5nIGZ1bmN0aW9uIGlzIGRlZmluZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuVHJJbiB8fCBvQ29sLm1SZW5kZXIgfHwgb0NvbC5tRGF0YSAhPT0gaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgblRkLmlubmVySFRNTCA9IF9mbkdldENlbGxEYXRhKG9TZXR0aW5ncywgaVJvdywgaSwgJ2Rpc3BsYXknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQWRkIHVzZXIgZGVmaW5lZCBjbGFzcyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob0NvbC5zQ2xhc3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5UZC5jbGFzc05hbWUgKz0gJyAnICsgb0NvbC5zQ2xhc3M7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZpc2liaWxpdHkgLSBhZGQgb3IgcmVtb3ZlIGFzIHJlcXVpcmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvQ29sLmJWaXNpYmxlICYmICFuVHJJbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgblRyLmFwcGVuZENoaWxkKG5UZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW9Db2wuYlZpc2libGUgJiYgblRySW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5UZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5UZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvQ29sLmZuQ3JlYXRlZENlbGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9Db2wuZm5DcmVhdGVkQ2VsbC5jYWxsKG9TZXR0aW5ncy5vSW5zdGFuY2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgblRkLCBfZm5HZXRDZWxsRGF0YShvU2V0dGluZ3MsIGlSb3csIGkpLCByb3dEYXRhLCBpUm93LCBpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBudWxsLCBbblRyLCByb3dEYXRhLCBpUm93XSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9uY2Ugd2Via2l0IGJ1ZyAxMzE4MTkgYW5kIENocm9taXVtIGJ1ZyAzNjU2MTkgaGF2ZSBiZWVuIHJlc29sdmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBhbmQgZGVwbG95ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIHJvdy5uVHIuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3JvdycpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFkZCBhdHRyaWJ1dGVzIHRvIGEgcm93IGJhc2VkIG9uIHRoZSBzcGVjaWFsIGBEVF8qYCBwYXJhbWV0ZXJzIGluIGEgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgKiBzb3VyY2Ugb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IERhdGFUYWJsZXMgcm93IG9iamVjdCBmb3IgdGhlIHJvdyB0byBiZSBtb2RpZmllZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Sb3dBdHRyaWJ1dGVzKHJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRyID0gcm93Lm5UcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcm93Ll9hRGF0YTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5EVF9Sb3dJZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5pZCA9IGRhdGEuRFRfUm93SWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5EVF9Sb3dDbGFzcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IGNsYXNzZXMgYWRkZWQgYnkgRFRfUm93Q2xhc3MgYmVmb3JlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gZGF0YS5EVF9Sb3dDbGFzcy5zcGxpdCgnICcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuX19yb3djID0gcm93Ll9fcm93YyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdW5pcXVlKHJvdy5fX3Jvd2MuY29uY2F0KGEpKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0cilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhyb3cuX19yb3djLmpvaW4oJyAnKSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhkYXRhLkRUX1Jvd0NsYXNzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLkRUX1Jvd0F0dHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCh0cikuYXR0cihkYXRhLkRUX1Jvd0F0dHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuRFRfUm93RGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRyKS5kYXRhKGRhdGEuRFRfUm93RGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENyZWF0ZSB0aGUgSFRNTCBoZWFkZXIgZm9yIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5CdWlsZEhlYWQob1NldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaWVuLCBjZWxsLCByb3csIGNvbHVtbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGVhZCA9IG9TZXR0aW5ncy5uVEhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGZvb3QgPSBvU2V0dGluZ3MublRGb290O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUhlYWRlciA9ICQoJ3RoLCB0ZCcsIHRoZWFkKS5sZW5ndGggPT09IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IG9TZXR0aW5ncy5vQ2xhc3NlcztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRlSGVhZGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gJCgnPHRyLz4nKS5hcHBlbmRUbyh0aGVhZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY29sdW1ucy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjZWxsID0gJChjb2x1bW4ublRoKS5hZGRDbGFzcyhjb2x1bW4uc0NsYXNzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUhlYWRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZFRvKHJvdyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLjExIG1vdmUgaW50byBzb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5hZGRDbGFzcyhjb2x1bW4uc1NvcnRpbmdDbGFzcyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmJTb3J0YWJsZSAhPT0gZmFsc2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGFiaW5kZXgnLCBvU2V0dGluZ3MuaVRhYkluZGV4KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgb1NldHRpbmdzLnNUYWJsZUlkKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIob1NldHRpbmdzLCBjb2x1bW4ublRoLCBpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5zVGl0bGUgIT0gY2VsbC5odG1sKCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5odG1sKGNvbHVtbi5zVGl0bGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUmVuZGVyZXIob1NldHRpbmdzLCAnaGVhZGVyJykoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRlSGVhZGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRGV0ZWN0SGVhZGVyKG9TZXR0aW5ncy5hb0hlYWRlciwgdGhlYWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEFSSUEgcm9sZSBmb3IgdGhlIHJvd3MgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICQodGhlYWQpLmZpbmQoJz50cicpLmF0dHIoJ3JvbGUnLCAncm93Jyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogRGVhbCB3aXRoIHRoZSBmb290ZXIgLSBhZGQgY2xhc3NlcyBpZiByZXF1aXJlZCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgJCh0aGVhZCkuZmluZCgnPnRyPnRoLCA+dHI+dGQnKS5hZGRDbGFzcyhjbGFzc2VzLnNIZWFkZXJUSCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAkKHRmb290KS5maW5kKCc+dHI+dGgsID50cj50ZCcpLmFkZENsYXNzKGNsYXNzZXMuc0Zvb3RlclRIKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgZm9vdGVyIGNlbGxzLiBOb3RlIHRoYXQgd2Ugb25seSB0YWtlIHRoZSBjZWxscyBmcm9tIHRoZSBmaXJzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gcm93IGluIHRoZSBmb290ZXIuIElmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcm93IHRoZSB1c2VyIHdhbnRzIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcmFjdCB3aXRoLCB0aGV5IG5lZWQgdG8gdXNlIHRoZSB0YWJsZSgpLmZvb3QoKSBtZXRob2QuIE5vdGUgYWxzbyB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd3MgY2VsbHMgdG8gYmUgdXNlZCBmb3IgbXVsdGlwbGUgY29sdW1ucyB1c2luZyBjb2xzcGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGZvb3QgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbHMgPSBvU2V0dGluZ3MuYW9Gb290ZXJbMF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNlbGxzLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLm5UZiA9IGNlbGxzW2ldLmNlbGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNDbGFzcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChjb2x1bW4ublRmKS5hZGRDbGFzcyhjb2x1bW4uc0NsYXNzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEcmF3IHRoZSBoZWFkZXIgKG9yIGZvb3RlcikgZWxlbWVudCBiYXNlZCBvbiB0aGUgY29sdW1uIHZpc2liaWxpdHkgc3RhdGVzLiBUaGVcclxuXHQgICAgICAgICAgICAgICAgICogbWV0aG9kb2xvZ3kgaGVyZSBpcyB0byB1c2UgdGhlIGxheW91dCBhcnJheSBmcm9tIF9mbkRldGVjdEhlYWRlciwgbW9kaWZpZWQgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAqIHRoZSBpbnN0YW50YW5lb3VzIGNvbHVtbiB2aXNpYmlsaXR5LCB0byBjb25zdHJ1Y3QgdGhlIG5ldyBsYXlvdXQuIFRoZSBncmlkIGlzXHJcblx0ICAgICAgICAgICAgICAgICAqIHRyYXZlcnNlZCBvdmVyIGNlbGwgYXQgYSB0aW1lIGluIGEgcm93cyB4IGNvbHVtbnMgZ3JpZCBmYXNoaW9uLCBhbHRob3VnaCBlYWNoXHJcblx0ICAgICAgICAgICAgICAgICAqIGNlbGwgaW5zZXJ0IGNhbiBjb3ZlciBtdWx0aXBsZSBlbGVtZW50cyBpbiB0aGUgZ3JpZCAtIHdoaWNoIGlzIHRyYWNrcyB1c2luZyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogYUFwcGxpZWQgYXJyYXkuIENlbGwgaW5zZXJ0cyBpbiB0aGUgZ3JpZCB3aWxsIG9ubHkgb2NjdXIgd2hlcmUgdGhlcmUgaXNuJ3RcclxuXHQgICAgICAgICAgICAgICAgICogYWxyZWFkeSBhIGNlbGwgaW4gdGhhdCBwb3NpdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSBhcnJheSB7b2JqZWN0c30gYW9Tb3VyY2UgTGF5b3V0IGFycmF5IGZyb20gX2ZuRGV0ZWN0SGVhZGVyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IFtiSW5jbHVkZUhpZGRlbj1mYWxzZV0gSWYgdHJ1ZSB0aGVuIGluY2x1ZGUgdGhlIGhpZGRlbiBjb2x1bW5zIGluIHRoZSBjYWxjLFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5EcmF3SGVhZChvU2V0dGluZ3MsIGFvU291cmNlLCBiSW5jbHVkZUhpZGRlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGksIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sIG4sIG5Mb2NhbFRyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFvTG9jYWwgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhQXBwbGllZCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlDb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaVJvd3NwYW4sIGlDb2xzcGFuO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghYW9Tb3VyY2UpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGJJbmNsdWRlSGlkZGVuID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBiSW5jbHVkZUhpZGRlbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgbGF5b3V0IGFycmF5LCBidXQgd2l0aG91dCB0aGUgdmlzaWJsZSBjb2x1bW5zIGluIGl0ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gYW9Tb3VyY2UubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhb0xvY2FsW2ldID0gYW9Tb3VyY2VbaV0uc2xpY2UoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhb0xvY2FsW2ldLm5UciA9IGFvU291cmNlW2ldLm5UcjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVtb3ZlIGFueSBjb2x1bW5zIHdoaWNoIGFyZSBjdXJyZW50bHkgaGlkZGVuICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gaUNvbHVtbnMgLSAxIDsgaiA+PSAwIDsgai0tKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb1NldHRpbmdzLmFvQ29sdW1uc1tqXS5iVmlzaWJsZSAmJiAhYkluY2x1ZGVIaWRkZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFvTG9jYWxbaV0uc3BsaWNlKGosIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBQcmVwIHRoZSBhcHBsaWVkIGFycmF5IC0gaXQgbmVlZHMgYW4gZWxlbWVudCBmb3IgZWFjaCByb3cgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhQXBwbGllZC5wdXNoKFtdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gYW9Mb2NhbC5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5Mb2NhbFRyID0gYW9Mb2NhbFtpXS5uVHI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFsbCBjZWxscyBhcmUgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHNvIGVtcHR5IG91dCB0aGUgcm93ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5Mb2NhbFRyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgobiA9IG5Mb2NhbFRyLmZpcnN0Q2hpbGQpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTG9jYWxUci5yZW1vdmVDaGlsZChuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgakxlbiA9IGFvTG9jYWxbaV0ubGVuZ3RoIDsgaiA8IGpMZW4gOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVJvd3NwYW4gPSAxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpQ29sc3BhbiA9IDE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBDaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIGNlbGwgKHJvdy9jb2xzcGFuKSBjb3ZlcmluZyBvdXIgdGFyZ2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluc2VydCBwb2ludC4gSWYgdGhlcmUgaXMsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkby5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhQXBwbGllZFtpXVtqXSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTG9jYWxUci5hcHBlbmRDaGlsZChhb0xvY2FsW2ldW2pdLmNlbGwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUFwcGxpZWRbaV1bal0gPSAxO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEV4cGFuZCB0aGUgY2VsbCB0byBjb3ZlciBhcyBtYW55IHJvd3MgYXMgbmVlZGVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW9Mb2NhbFtpICsgaVJvd3NwYW5dICE9PSB1bmRlZmluZWQgJiZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW9Mb2NhbFtpXVtqXS5jZWxsID09IGFvTG9jYWxbaSArIGlSb3dzcGFuXVtqXS5jZWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUFwcGxpZWRbaSArIGlSb3dzcGFuXVtqXSA9IDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVJvd3NwYW4rKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBFeHBhbmQgdGhlIGNlbGwgdG8gY292ZXIgYXMgbWFueSBjb2x1bW5zIGFzIG5lZWRlZCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFvTG9jYWxbaV1baiArIGlDb2xzcGFuXSAhPT0gdW5kZWZpbmVkICYmXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2ldW2ogKyBpQ29sc3Bhbl0uY2VsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE11c3QgdXBkYXRlIHRoZSBhcHBsaWVkIGFycmF5IG92ZXIgdGhlIHJvd3MgZm9yIHRoZSBjb2x1bW5zICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCA7IGsgPCBpUm93c3BhbiA7IGsrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQXBwbGllZFtpICsga11baiArIGlDb2xzcGFuXSA9IDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDb2xzcGFuKys7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogRG8gdGhlIGFjdHVhbCBleHBhbnNpb24gaW4gdGhlIERPTSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChhb0xvY2FsW2ldW2pdLmNlbGwpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3Jvd3NwYW4nLCBpUm93c3BhbilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY29sc3BhbicsIGlDb2xzcGFuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBJbnNlcnQgdGhlIHJlcXVpcmVkIFRSIG5vZGVzIGludG8gdGhlIHRhYmxlIGZvciBkaXNwbGF5XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkRyYXcob1NldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBQcm92aWRlIGEgcHJlLWNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgZHJhdyBpcyBmYWxzZSBpcyByZXR1cm5lZCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFQcmVEcmF3ID0gX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgJ2FvUHJlRHJhd0NhbGxiYWNrJywgJ3ByZURyYXcnLCBbb1NldHRpbmdzXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KGZhbHNlLCBhUHJlRHJhdykgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkob1NldHRpbmdzLCBmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpTGVuLCBuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFuUm93cyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlSb3dDb3VudCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXNTdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpU3RyaXBlcyA9IGFzU3RyaXBlQ2xhc3Nlcy5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaU9wZW5Sb3dzID0gb1NldHRpbmdzLmFvT3BlblJvd3MubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9MYW5nID0gb1NldHRpbmdzLm9MYW5ndWFnZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpSW5pdERpc3BsYXlTdGFydCA9IG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBiU2VydmVyU2lkZSA9IF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PSAnc3NwJztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhaURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5iRHJhd2luZyA9IHRydWU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgYW5kIHNlZSBpZiB3ZSBoYXZlIGFuIGluaXRpYWwgZHJhdyBwb3NpdGlvbiBmcm9tIHN0YXRlIHNhdmluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlJbml0RGlzcGxheVN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgaUluaXREaXNwbGF5U3RhcnQgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gYlNlcnZlclNpZGUgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpSW5pdERpc3BsYXlTdGFydCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlJbml0RGlzcGxheVN0YXJ0ID49IG9TZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpSW5pdERpc3BsYXlTdGFydDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gLTE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlEaXNwbGF5U3RhcnQgPSBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaURpc3BsYXlFbmQgPSBvU2V0dGluZ3MuZm5EaXNwbGF5RW5kKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBkcmF3IGludGVyY2VwdCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmJEZWZlckxvYWRpbmcgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuaURyYXcrKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShvU2V0dGluZ3MsIGZhbHNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFiU2VydmVyU2lkZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5pRHJhdysrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW9TZXR0aW5ncy5iRGVzdHJveWluZyAmJiAhX2ZuQWpheFVwZGF0ZShvU2V0dGluZ3MpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhaURpc3BsYXkubGVuZ3RoICE9PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlTdGFydCA9IGJTZXJ2ZXJTaWRlID8gMCA6IGlEaXNwbGF5U3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlFbmQgPSBiU2VydmVyU2lkZSA/IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDogaURpc3BsYXlFbmQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpU3RhcnQgOyBqIDwgaUVuZCA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaURhdGFJbmRleCA9IGFpRGlzcGxheVtqXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGFbaURhdGFJbmRleF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhb0RhdGEublRyID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DcmVhdGVUcihvU2V0dGluZ3MsIGlEYXRhSW5kZXgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgblJvdyA9IGFvRGF0YS5uVHI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBSZW1vdmUgdGhlIG9sZCBzdHJpcGluZyBjbGFzc2VzIGFuZCB0aGVuIGFkZCB0aGUgbmV3IG9uZSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaVN0cmlwZXMgIT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzU3RyaXBlID0gYXNTdHJpcGVDbGFzc2VzW2lSb3dDb3VudCAlIGlTdHJpcGVzXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhb0RhdGEuX3NSb3dTdHJpcGUgIT0gc1N0cmlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoblJvdykucmVtb3ZlQ2xhc3MoYW9EYXRhLl9zUm93U3RyaXBlKS5hZGRDbGFzcyhzU3RyaXBlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb0RhdGEuX3NSb3dTdHJpcGUgPSBzU3RyaXBlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3cgY2FsbGJhY2sgZnVuY3Rpb25zIC0gbWlnaHQgd2FudCB0byBtYW5pcHVsYXRlIHRoZSByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaVJvd0NvdW50IGFuZCBqIGFyZSBub3QgY3VycmVudGx5IGRvY3VtZW50ZWQuIEFyZSB0aGV5IGF0IGFsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2VmdWw/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuUm93LCBhb0RhdGEuX2FEYXRhLCBpUm93Q291bnQsIGpdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuUm93cy5wdXNoKG5Sb3cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUm93Q291bnQrKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBUYWJsZSBpcyBlbXB0eSAtIGNyZWF0ZSBhIHJvdyB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UgaW4gaXQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc1plcm8gPSBvTGFuZy5zWmVyb1JlY29yZHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5pRHJhdyA9PSAxICYmIF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PSAnYWpheCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc1plcm8gPSBvTGFuZy5zTG9hZGluZ1JlY29yZHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9MYW5nLnNFbXB0eVRhYmxlICYmIG9TZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNaZXJvID0gb0xhbmcuc0VtcHR5VGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhblJvd3NbMF0gPSAkKCc8dHIvPicsIHsgJ2NsYXNzJzogaVN0cmlwZXMgPyBhc1N0cmlwZUNsYXNzZXNbMF0gOiAnJyB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzx0ZCAvPicsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd2YWxpZ24nOiAndG9wJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2xTcGFuJzogX2ZuVmlzYmxlQ29sdW1ucyhvU2V0dGluZ3MpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogb1NldHRpbmdzLm9DbGFzc2VzLnNSb3dFbXB0eVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5odG1sKHNaZXJvKSlbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogSGVhZGVyIGFuZCBmb290ZXIgY2FsbGJhY2tzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsICdoZWFkZXInLCBbJChvU2V0dGluZ3MublRIZWFkKS5jaGlsZHJlbigndHInKVswXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5HZXREYXRhTWFzdGVyKG9TZXR0aW5ncyksIGlEaXNwbGF5U3RhcnQsIGlEaXNwbGF5RW5kLCBhaURpc3BsYXldKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCAnYW9Gb290ZXJDYWxsYmFjaycsICdmb290ZXInLCBbJChvU2V0dGluZ3MublRGb290KS5jaGlsZHJlbigndHInKVswXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5HZXREYXRhTWFzdGVyKG9TZXR0aW5ncyksIGlEaXNwbGF5U3RhcnQsIGlEaXNwbGF5RW5kLCBhaURpc3BsYXldKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9ICQob1NldHRpbmdzLm5UQm9keSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYm9keS5jaGlsZHJlbigpLmRldGFjaCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJChhblJvd3MpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBDYWxsIGFsbCByZXF1aXJlZCBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHRoZSBlbmQgb2YgYSBkcmF3ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCAnZHJhdycsIFtvU2V0dGluZ3NdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBEcmF3IGlzIGNvbXBsZXRlLCBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgbXVzdCBiZSBhcyB3ZWxsICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYlNvcnRlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmJGaWx0ZXJlZCA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmJEcmF3aW5nID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUmVkcmF3IHRoZSB0YWJsZSAtIHRha2luZyBhY2NvdW50IG9mIHRoZSB2YXJpb3VzIGZlYXR1cmVzIHdoaWNoIGFyZSBlbmFibGVkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IFtob2xkUG9zaXRpb25dIEtlZXAgdGhlIGN1cnJlbnQgcGFnaW5nIHBvc2l0aW9uLiBCeSBkZWZhdWx0XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIHRoZSBwYWdpbmcgaXMgcmVzZXQgdG8gdGhlIGZpcnN0IHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuUmVEcmF3KHNldHRpbmdzLCBob2xkUG9zaXRpb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQgPSBmZWF0dXJlcy5iU29ydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBmZWF0dXJlcy5iRmlsdGVyO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydChzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckNvbXBsZXRlKHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gZmlsdGVyaW5nLCBzbyB3ZSB3YW50IHRvIGp1c3QgdXNlIHRoZSBkaXNwbGF5IG1hc3RlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChob2xkUG9zaXRpb24gIT09IHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTGV0IGFueSBtb2R1bGVzIGtub3cgYWJvdXQgdGhlIGRyYXcgaG9sZCBwb3NpdGlvbiBzdGF0ZSAodXNlZCBieVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsaW5nIGludGVybmFsbHkpXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5fZHJhd0hvbGQgPSBob2xkUG9zaXRpb247XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRHJhdyhzZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2RyYXdIb2xkID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWRkIHRoZSBvcHRpb25zIHRvIHRoZSBwYWdlIEhUTUwgZm9yIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BZGRPcHRpb25zSHRtbChvU2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gJChvU2V0dGluZ3MublRhYmxlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBob2xkaW5nID0gJCgnPGRpdi8+JykuaW5zZXJ0QmVmb3JlKHRhYmxlKTsgLy8gSG9sZGluZyBlbGVtZW50IGZvciBzcGVlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBbGwgRGF0YVRhYmxlcyBhcmUgd3JhcHBlZCBpbiBhIGRpdlxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydCA9ICQoJzxkaXYvPicsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZDogb1NldHRpbmdzLnNUYWJsZUlkICsgJ193cmFwcGVyJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBjbGFzc2VzLnNXcmFwcGVyICsgKG9TZXR0aW5ncy5uVEZvb3QgPyAnJyA6ICcgJyArIGNsYXNzZXMuc05vRm9vdGVyKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm5Ib2xkaW5nID0gaG9sZGluZ1swXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5uVGFibGVXcmFwcGVyID0gaW5zZXJ0WzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm5UYWJsZVJlaW5zZXJ0QmVmb3JlID0gb1NldHRpbmdzLm5UYWJsZS5uZXh0U2libGluZztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBMb29wIG92ZXIgdGhlIHVzZXIgc2V0IHBvc2l0aW9uaW5nIGFuZCBwbGFjZSB0aGUgZWxlbWVudHMgYXMgbmVlZGVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYURvbSA9IG9TZXR0aW5ncy5zRG9tLnNwbGl0KCcnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlTm9kZSwgY09wdGlvbiwgbk5ld05vZGUsIGNOZXh0LCBzQXR0ciwgajtcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGFEb20ubGVuZ3RoIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU5vZGUgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNPcHRpb24gPSBhRG9tW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY09wdGlvbiA9PSAnPCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogTmV3IGNvbnRhaW5lciBkaXYgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk5ld05vZGUgPSAkKCc8ZGl2Lz4nKVswXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgYXBwZW5kIGFuIGlkIGFuZC9vciBhIGNsYXNzIG5hbWUgdG8gdGhlIGNvbnRhaW5lciAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjTmV4dCA9IGFEb21baSArIDFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY05leHQgPT0gXCInXCIgfHwgY05leHQgPT0gJ1wiJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0F0dHIgPSBcIlwiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYURvbVtpICsgal0gIT0gY05leHQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzQXR0ciArPSBhRG9tW2kgKyBqXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVwbGFjZSBqUXVlcnkgVUkgY29uc3RhbnRzIEB0b2RvIGRlcHJlY2lhdGVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc0F0dHIgPT0gXCJIXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzQXR0ciA9IGNsYXNzZXMuc0pVSUhlYWRlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNBdHRyID09IFwiRlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0F0dHIgPSBjbGFzc2VzLnNKVUlGb290ZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIGF0dHJpYnV0ZSBjYW4gYmUgaW4gdGhlIGZvcm1hdCBvZiBcIiNpZC5jbGFzc1wiLCBcIiNpZFwiIG9yIFwiY2xhc3NcIiBUaGlzIGxvZ2ljXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBicmVha3MgdGhlIHN0cmluZyBpbnRvIHBhcnRzIGFuZCBhcHBsaWVzIHRoZW0gYXMgbmVlZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzQXR0ci5pbmRleE9mKCcuJykgIT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYVNwbGl0ID0gc0F0dHIuc3BsaXQoJy4nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTmV3Tm9kZS5pZCA9IGFTcGxpdFswXS5zdWJzdHIoMSwgYVNwbGl0WzBdLmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5OZXdOb2RlLmNsYXNzTmFtZSA9IGFTcGxpdFsxXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNBdHRyLmNoYXJBdCgwKSA9PSBcIiNcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5OZXdOb2RlLmlkID0gc0F0dHIuc3Vic3RyKDEsIHNBdHRyLmxlbmd0aCAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk5ld05vZGUuY2xhc3NOYW1lID0gc0F0dHI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBqOyAvKiBNb3ZlIGFsb25nIHRoZSBwb3NpdGlvbiBhcnJheSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQuYXBwZW5kKG5OZXdOb2RlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gJChuTmV3Tm9kZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJz4nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEVuZCBjb250YWluZXIgZGl2ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCA9IGluc2VydC5wYXJlbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIE1vdmUgb3B0aW9ucyBpbnRvIHRoZWlyIG93biBwbHVnaW5zP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJ2wnICYmIGZlYXR1cmVzLmJQYWdpbmF0ZSAmJiBmZWF0dXJlcy5iTGVuZ3RoQ2hhbmdlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIExlbmd0aCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sTGVuZ3RoKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJ2YnICYmIGZlYXR1cmVzLmJGaWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogRmlsdGVyICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAncicgJiYgZmVhdHVyZXMuYlByb2Nlc3NpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogcFJvY2Vzc2luZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyhvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICd0Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUYWJsZSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sVGFibGUob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAnaScgJiYgZmVhdHVyZXMuYkluZm8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogSW5mbyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sSW5mbyhvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICdwJyAmJiBmZWF0dXJlcy5iUGFnaW5hdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogUGFnaW5hdGlvbiAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoRGF0YVRhYmxlLmV4dC5mZWF0dXJlLmxlbmd0aCAhPT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBQbHVnLWluIGZlYXR1cmVzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhb0ZlYXR1cmVzID0gRGF0YVRhYmxlLmV4dC5mZWF0dXJlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga0xlbiA9IGFvRmVhdHVyZXMubGVuZ3RoIDsgayA8IGtMZW4gOyBrKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjT3B0aW9uID09IGFvRmVhdHVyZXNba10uY0ZlYXR1cmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IGFvRmVhdHVyZXNba10uZm5Jbml0KG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFkZCB0byB0aGUgMkQgZmVhdHVyZXMgYXJyYXkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZU5vZGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFhbkZlYXR1cmVzID0gb1NldHRpbmdzLmFhbkZlYXR1cmVzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhYW5GZWF0dXJlc1tjT3B0aW9uXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWFuRmVhdHVyZXNbY09wdGlvbl0gPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWFuRmVhdHVyZXNbY09wdGlvbl0ucHVzaChmZWF0dXJlTm9kZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydC5hcHBlbmQoZmVhdHVyZU5vZGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBCdWlsdCBvdXIgRE9NIHN0cnVjdHVyZSAtIHJlcGxhY2UgdGhlIGhvbGRpbmcgZGl2IHdpdGggd2hhdCB3ZSB3YW50ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBob2xkaW5nLnJlcGxhY2VXaXRoKGluc2VydCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogVXNlIHRoZSBET00gc291cmNlIHRvIGNyZWF0ZSB1cCBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbHMuIFRoZSBpZGVhIGhlcmUgaXMgdG9cclxuXHQgICAgICAgICAgICAgICAgICogY3JlYXRlIGEgbGF5b3V0IGdyaWQgKGFycmF5KSBvZiByb3dzIHggY29sdW1ucywgd2hpY2ggY29udGFpbnMgYSByZWZlcmVuY2VcclxuXHQgICAgICAgICAgICAgICAgICogdG8gdGhlIGNlbGwgdGhhdCB0aGF0IHBvaW50IGluIHRoZSBncmlkIChyZWdhcmRsZXNzIG9mIGNvbC9yb3dzcGFuKSwgc3VjaCB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAqIGFueSBjb2x1bW4gLyByb3cgY291bGQgYmUgcmVtb3ZlZCBhbmQgdGhlIG5ldyBncmlkIGNvbnN0cnVjdGVkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0gYXJyYXkge29iamVjdH0gYUxheW91dCBBcnJheSB0byBzdG9yZSB0aGUgY2FsY3VsYXRlZCBsYXlvdXQgaW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gblRoZWFkIFRoZSBoZWFkZXIvZm9vdGVyIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5EZXRlY3RIZWFkZXIoYUxheW91dCwgblRoZWFkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgblRycyA9ICQoblRoZWFkKS5jaGlsZHJlbigndHInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuVHIsIG5DZWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGksIGssIGwsIGlMZW4sIGpMZW4sIGlDb2xTaGlmdGVkLCBpQ29sdW1uLCBpQ29sc3BhbiwgaVJvd3NwYW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYlVuaXF1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmblNoaWZ0Q29sID0gZnVuY3Rpb24gKGEsIGksIGopIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGFbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGtbal0pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gajtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYUxheW91dC5zcGxpY2UoMCwgYUxheW91dC5sZW5ndGgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFdlIGtub3cgaG93IG1hbnkgcm93cyB0aGVyZSBhcmUgaW4gdGhlIGxheW91dCAtIHNvIHByZXAgaXQgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBuVHJzLmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYUxheW91dC5wdXNoKFtdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBDYWxjdWxhdGUgYSBsYXlvdXQgYXJyYXkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBuVHJzLmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgblRyID0gblRyc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpQ29sdW1uID0gMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogRm9yIGV2ZXJ5IGNlbGwgaW4gdGhlIHJvdy4uLiAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5DZWxsID0gblRyLmZpcnN0Q2hpbGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5DZWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuQ2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09IFwiVERcIiB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJUSFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBHZXQgdGhlIGNvbCBhbmQgcm93c3BhbiBhdHRyaWJ1dGVzIGZyb20gdGhlIERPTSBhbmQgc2FuaXRpc2UgdGhlbSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaUNvbHNwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSAqIDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUm93c3BhbiA9IG5DZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpICogMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDb2xzcGFuID0gKCFpQ29sc3BhbiB8fCBpQ29sc3BhbiA9PT0gMCB8fCBpQ29sc3BhbiA9PT0gMSkgPyAxIDogaUNvbHNwYW47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpUm93c3BhbiA9ICghaVJvd3NwYW4gfHwgaVJvd3NwYW4gPT09IDAgfHwgaVJvd3NwYW4gPT09IDEpID8gMSA6IGlSb3dzcGFuO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZXJlIG1pZ2h0IGJlIGNvbHNwYW4gY2VsbHMgYWxyZWFkeSBpbiB0aGlzIHJvdywgc28gc2hpZnQgb3VyIHRhcmdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYWNjb3JkaW5nbHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaUNvbFNoaWZ0ZWQgPSBmblNoaWZ0Q29sKGFMYXlvdXQsIGksIGlDb2x1bW4pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIENhY2hlIGNhbGN1bGF0aW9uIGZvciB1bmlxdWUgY29sdW1ucyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYlVuaXF1ZSA9IGlDb2xzcGFuID09PSAxID8gdHJ1ZSA6IGZhbHNlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZXJlIGlzIGNvbCAvIHJvd3NwYW4sIGNvcHkgdGhlIGluZm9ybWF0aW9uIGludG8gdGhlIGxheW91dCBncmlkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSAwIDsgbCA8IGlDb2xzcGFuIDsgbCsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCA7IGsgPCBpUm93c3BhbiA7IGsrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTGF5b3V0W2kgKyBrXVtpQ29sU2hpZnRlZCArIGxdID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjZWxsXCI6IG5DZWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1bmlxdWVcIjogYlVuaXF1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTGF5b3V0W2kgKyBrXS5uVHIgPSBuVHI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5DZWxsID0gbkNlbGwubmV4dFNpYmxpbmc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdldCBhbiBhcnJheSBvZiB1bmlxdWUgdGggZWxlbWVudHMsIG9uZSBmb3IgZWFjaCBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbkhlYWRlciBhdXRvbWF0aWNhbGx5IGRldGVjdCB0aGUgbGF5b3V0IGZyb20gdGhpcyBub2RlIC0gb3B0aW9uYWxcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGFMYXlvdXQgdGhlYWQvdGZvb3QgbGF5b3V0IGZyb20gX2ZuRGV0ZWN0SGVhZGVyIC0gb3B0aW9uYWxcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIGFycmF5IHtub2RlfSBhUmV0dXJuIGxpc3Qgb2YgdW5pcXVlIHRoJ3NcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuR2V0VW5pcXVlVGhzKG9TZXR0aW5ncywgbkhlYWRlciwgYUxheW91dCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFSZXR1cm4gPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghYUxheW91dCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFMYXlvdXQgPSBvU2V0dGluZ3MuYW9IZWFkZXI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5IZWFkZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUxheW91dCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5EZXRlY3RIZWFkZXIoYUxheW91dCwgbkhlYWRlcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gYUxheW91dC5sZW5ndGggOyBpIDwgaUxlbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gYUxheW91dFtpXS5sZW5ndGggOyBqIDwgakxlbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYUxheW91dFtpXVtqXS51bmlxdWUgJiZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWFSZXR1cm5bal0gfHwgIW9TZXR0aW5ncy5iU29ydENlbGxzVG9wKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVJldHVybltqXSA9IGFMYXlvdXRbaV1bal0uY2VsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gYVJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENyZWF0ZSBhbiBBamF4IGNhbGwgYmFzZWQgb24gdGhlIHRhYmxlJ3Mgc2V0dGluZ3MsIHRha2luZyBpbnRvIGFjY291bnQgdGhhdFxyXG5cdCAgICAgICAgICAgICAgICAgKiBwYXJhbWV0ZXJzIGNhbiBoYXZlIG11bHRpcGxlIGZvcm1zLCBhbmQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHthcnJheX0gZGF0YSBEYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlciwgcmVxdWlyZWQgYnlcclxuXHQgICAgICAgICAgICAgICAgICogICAgIERhdGFUYWJsZXMgLSBtYXkgYmUgYXVnbWVudGVkIGJ5IGRldmVsb3BlciBjYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIHdoZW4gZGF0YSBpcyBvYnRhaW5lZFxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQnVpbGRBamF4KG9TZXR0aW5ncywgZGF0YSwgZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLCBhbGxvdyBmblNlcnZlckRhdGEgYW5kIGV2ZW50IHRvIG1hbmlwdWxhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICdzZXJ2ZXJQYXJhbXMnLCBbZGF0YV0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gb2JqZWN0IGJhc2VkIGZvciAxLjEwKyBpZiB1c2luZyB0aGUgb2xkIGFycmF5IHNjaGVtZSB3aGljaCBjYW5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGNvbWUgZnJvbSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG9yIHNlcnZlclBhcmFtc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgJC5pc0FycmF5KGRhdGEpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYnJhY2tldCA9IC8oLio/KVxcW1xcXSQvO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHZhbC5uYW1lLm1hdGNoKHJicmFja2V0KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydCBmb3IgYXJyYXlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG1hdGNoWzBdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdG1wW25hbWVdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wW25hbWVdID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBbbmFtZV0ucHVzaCh2YWwudmFsdWUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wW3ZhbC5uYW1lXSA9IHZhbC52YWx1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0bXA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFqYXhEYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFqYXggPSBvU2V0dGluZ3MuYWpheDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG9TZXR0aW5ncy5vSW5zdGFuY2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoanNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBqc29uLCBvU2V0dGluZ3MuanFYSFJdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmbihqc29uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChhamF4KSAmJiBhamF4LmRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhamF4RGF0YSA9IGFqYXguZGF0YTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSAkLmlzRnVuY3Rpb24oYWpheERhdGEpID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheERhdGEoZGF0YSwgb1NldHRpbmdzKSA6ICAvLyBmbiBjYW4gbWFuaXB1bGF0ZSBkYXRhIG9yIHJldHVyblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhamF4RGF0YTsgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gb2JqZWN0IG9iamVjdCBvciBhcnJheSB0byBtZXJnZVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgc29tZXRoaW5nLCB1c2UgdGhhdCBhbG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSAkLmlzRnVuY3Rpb24oYWpheERhdGEpICYmIG5ld0RhdGEgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgZGF0YSwgbmV3RGF0YSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZGF0YSBwcm9wZXJ0eSBhcyB3ZSd2ZSByZXNvbHZlZCBpdCBhbHJlYWR5IGFuZCBkb24ndCB3YW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8galF1ZXJ5IHRvIGRvIGl0IGFnYWluIChpdCBpcyByZXN0b3JlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWpheC5kYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBiYXNlQWpheCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGFcIjogZGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0ganNvbi5lcnJvciB8fCBqc29uLnNFcnJvcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2cob1NldHRpbmdzLCAwLCBlcnJvcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5qc29uID0ganNvbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soanNvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FjaGVcIjogZmFsc2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IG9TZXR0aW5ncy5zU2VydmVyTWV0aG9kLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiZXJyb3JcIjogZnVuY3Rpb24gKHhociwgZXJyb3IsIHRocm93bikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIG51bGwsIG9TZXR0aW5ncy5qcVhIUl0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheSh0cnVlLCByZXQpID09PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yID09IFwicGFyc2VyZXJyb3JcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxvZyhvU2V0dGluZ3MsIDAsICdJbnZhbGlkIEpTT04gcmVzcG9uc2UnLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKG9TZXR0aW5ncywgMCwgJ0FqYXggZXJyb3InLCA3KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkob1NldHRpbmdzLCBmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgZGF0YSBzdWJtaXR0ZWQgZm9yIHRoZSBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5vQWpheERhdGEgPSBkYXRhO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHBsdWctaW5zIGFuZCBleHRlcm5hbCBwcm9jZXNzZXMgdG8gbW9kaWZ5IHRoZSBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCBudWxsLCAncHJlWGhyJywgW29TZXR0aW5ncywgZGF0YV0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGliaWxpdHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhLmNhbGwoaW5zdGFuY2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5zQWpheFNvdXJjZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5tYXAoZGF0YSwgZnVuY3Rpb24gKHZhbCwga2V5KSB7IC8vIE5lZWQgdG8gY29udmVydCBiYWNrIHRvIDEuOSB0cmFkIGZvcm1hdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZToga2V5LCB2YWx1ZTogdmFsIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9TZXR0aW5ncy5zQWpheFNvdXJjZSB8fCB0eXBlb2YgYWpheCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCgkLmV4dGVuZChiYXNlQWpheCwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFqYXggfHwgb1NldHRpbmdzLnNBamF4U291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKGFqYXgpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXMgYSBmdW5jdGlvbiAtIGxldCB0aGUgY2FsbGVyIGRlZmluZSB3aGF0IG5lZWRzIHRvIGJlIGRvbmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuanFYSFIgPSBhamF4LmNhbGwoaW5zdGFuY2UsIGRhdGEsIGNhbGxiYWNrLCBvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2JqZWN0IHRvIGV4dGVuZCB0aGUgYmFzZSBzZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCgkLmV4dGVuZChiYXNlQWpheCwgYWpheCkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGZvciBuZXh0IHRpbWUgYXJvdW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWpheC5kYXRhID0gYWpheERhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogVXBkYXRlIHRoZSB0YWJsZSB1c2luZyBhbiBBamF4IGNhbGxcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IEJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BamF4VXBkYXRlKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYkFqYXhEYXRhR2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaURyYXcrKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkJ1aWxkQWpheChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFqYXhQYXJhbWV0ZXJzKHNldHRpbmdzKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFqYXhVcGRhdGVEcmF3KHNldHRpbmdzLCBqc29uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEJ1aWxkIHVwIHRoZSBwYXJhbWV0ZXJzIGluIGFuIG9iamVjdCBuZWVkZWQgZm9yIGEgc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiByZXF1ZXN0LiBOb3RlIHRoYXQgdGhpcyBpcyBiYXNpY2FsbHkgZG9uZSB0d2ljZSwgaXMgZGlmZmVyZW50IHdheXMgLSBhIG1vZGVyblxyXG5cdCAgICAgICAgICAgICAgICAgKiBtZXRob2Qgd2hpY2ggaXMgdXNlZCBieSBkZWZhdWx0IGluIERhdGFUYWJsZXMgMS4xMCB3aGljaCB1c2VzIG9iamVjdHMgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAqIGFycmF5cywgb3IgdGhlIDEuOS0gbWV0aG9kIHdpdGggaXMgbmFtZSAvIHZhbHVlIHBhaXJzLiAxLjkgbWV0aG9kIGlzIHVzZWQgaWZcclxuXHQgICAgICAgICAgICAgICAgICogdGhlIHNBamF4U291cmNlIG9wdGlvbiBpcyB1c2VkIGluIHRoZSBpbml0aWFsaXNhdGlvbiwgb3IgdGhlIGxlZ2FjeUFqYXhcclxuXHQgICAgICAgICAgICAgICAgICogb3B0aW9uIGlzIHNldC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtib29sfSBibG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQWpheFBhcmFtZXRlcnMoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmVTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJlQ29sU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGksIGRhdGEgPSBbXSwgZGF0YVByb3AsIGNvbHVtbiwgY29sdW1uU2VhcmNoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQgPSBfZm5Tb3J0RmxhdHRlbihzZXR0aW5ncyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheUxlbmd0aCA9IGZlYXR1cmVzLmJQYWdpbmF0ZSAhPT0gZmFsc2UgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goeyAnbmFtZSc6IG5hbWUsICd2YWx1ZSc6IHZhbHVlIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJsZSBtZXRob2RcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtKCdzRWNobycsIHNldHRpbmdzLmlEcmF3KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtKCdpQ29sdW1ucycsIGNvbHVtbkNvdW50KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtKCdzQ29sdW1ucycsIF9wbHVjayhjb2x1bW5zLCAnc05hbWUnKS5qb2luKCcsJykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2lEaXNwbGF5U3RhcnQnLCBkaXNwbGF5U3RhcnQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2lEaXNwbGF5TGVuZ3RoJywgZGlzcGxheUxlbmd0aCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRGF0YVRhYmxlcyAxLjEwKyBtZXRob2RcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRyYXc6IHNldHRpbmdzLmlEcmF3LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOiBbXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZGlzcGxheVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aDogZGlzcGxheUxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZVNlYXJjaC5zU2VhcmNoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleDogcHJlU2VhcmNoLmJSZWdleFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCA7IGkgPCBjb2x1bW5Db3VudCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2VhcmNoID0gcHJlQ29sU2VhcmNoW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQcm9wID0gdHlwZW9mIGNvbHVtbi5tRGF0YSA9PSBcImZ1bmN0aW9uXCIgPyAnZnVuY3Rpb24nIDogY29sdW1uLm1EYXRhO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkLmNvbHVtbnMucHVzaCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFQcm9wLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb2x1bW4uc05hbWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaGFibGU6IGNvbHVtbi5iU2VhcmNoYWJsZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJhYmxlOiBjb2x1bW4uYlNvcnRhYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2x1bW5TZWFyY2guc1NlYXJjaCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBjb2x1bW5TZWFyY2guYlJlZ2V4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oXCJtRGF0YVByb3BfXCIgKyBpLCBkYXRhUHJvcCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iRmlsdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtKCdzU2VhcmNoXycgKyBpLCBjb2x1bW5TZWFyY2guc1NlYXJjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtKCdiUmVnZXhfJyArIGksIGNvbHVtblNlYXJjaC5iUmVnZXgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSgnYlNlYXJjaGFibGVfJyArIGksIGNvbHVtbi5iU2VhcmNoYWJsZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMuYlNvcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2JTb3J0YWJsZV8nICsgaSwgY29sdW1uLmJTb3J0YWJsZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iRmlsdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ3NTZWFyY2gnLCBwcmVTZWFyY2guc1NlYXJjaCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2JSZWdleCcsIHByZVNlYXJjaC5iUmVnZXgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iU29ydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChzb3J0LCBmdW5jdGlvbiAoaSwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQub3JkZXIucHVzaCh7IGNvbHVtbjogdmFsLmNvbCwgZGlyOiB2YWwuZGlyIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2lTb3J0Q29sXycgKyBpLCB2YWwuY29sKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ3NTb3J0RGlyXycgKyBpLCB2YWwuZGlyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2lTb3J0aW5nQ29scycsIHNvcnQubGVuZ3RoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGVnYWN5LmFqYXggcGFyYW1ldGVyIGlzIG51bGwsIHRoZW4gd2UgYXV0b21hdGljYWxseSBkZWNpZGUgd2hpY2hcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGZvcm0gdG8gdXNlLCBiYXNlZCBvbiBzQWpheFNvdXJjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2FjeSA9IERhdGFUYWJsZS5leHQubGVnYWN5LmFqYXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGVnYWN5ID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnNBamF4U291cmNlID8gZGF0YSA6IGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBsZWdhY3kgaGFzIGJlZW4gc3BlY2lmaWVkIHRoZW4gd2UgdXNlIHRoYXQgdG8gZGVjaWRlIG9uIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9ybVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxlZ2FjeSA/IGRhdGEgOiBkO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERhdGEgdGhlIGRhdGEgZnJvbSB0aGUgc2VydmVyIChudWtpbmcgdGhlIG9sZCkgYW5kIHJlZHJhdyB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIGpzb24gZGF0YSByZXR1cm4gZnJvbSB0aGUgc2VydmVyLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IGpzb24uc0VjaG8gVHJhY2tpbmcgZmxhZyBmb3IgRGF0YVRhYmxlcyB0byBtYXRjaCByZXF1ZXN0c1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsUmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIG5vdCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBqc29uLmlUb3RhbERpc3BsYXlSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgYWNjb3VudGluZyBmb3IgZmlsdGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBqc29uLmFhRGF0YSBUaGUgZGF0YSB0byBkaXNwbGF5IG9uIHRoaXMgcGFnZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtqc29uLnNDb2x1bW5zXSBDb2x1bW4gb3JkZXJpbmcgKHNOYW1lLCBjb21tYSBzZXBhcmF0ZWQpXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGVEcmF3KHNldHRpbmdzLCBqc29uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB2MS4xMCB1c2VzIGNhbWVsQ2FzZSB2YXJpYWJsZXMsIHdoaWxlIDEuOSB1c2VzIEh1bmdhcmlhbiBub3RhdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgYm90aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBhdCA9IGZ1bmN0aW9uIChvbGQsIG1vZGVybikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uW29sZF0gIT09IHVuZGVmaW5lZCA/IGpzb25bb2xkXSA6IGpzb25bbW9kZXJuXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyhzZXR0aW5ncywganNvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZHJhdyA9IGNvbXBhdCgnc0VjaG8nLCAnZHJhdycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZHNUb3RhbCA9IGNvbXBhdCgnaVRvdGFsUmVjb3JkcycsICdyZWNvcmRzVG90YWwnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRzRmlsdGVyZWQgPSBjb21wYXQoJ2lUb3RhbERpc3BsYXlSZWNvcmRzJywgJ3JlY29yZHNGaWx0ZXJlZCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG91dCBvZiBzZXF1ZW5jZSByZXR1cm5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXcgKiAxIDwgc2V0dGluZ3MuaURyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5pRHJhdyA9IGRyYXcgKiAxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNsZWFyVGFibGUoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgPSBwYXJzZUludChyZWNvcmRzVG90YWwsIDEwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSBwYXJzZUludChyZWNvcmRzRmlsdGVyZWQsIDEwKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gZGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkRGF0YShzZXR0aW5ncywgZGF0YVtpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5iQWpheERhdGFHZXQgPSBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuX2JJbml0Q29tcGxldGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Jbml0Q29tcGxldGUoc2V0dGluZ3MsIGpzb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmJBamF4RGF0YUdldCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBKU09OIGRhdGEgc291cmNlIHRvIHVzZSBmb3IgZHJhd2luZyBhIHRhYmxlLiBVc2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiBgX2ZuR2V0T2JqZWN0RGF0YUZuYCBhbGxvd3MgdGhlIGRhdGEgdG8gYmUgc291cmNlZCBmcm9tIGEgcHJvcGVydHkgb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIHNvdXJjZSBvYmplY3QsIG9yIGZyb20gYSBwcm9jZXNzaW5nIGZ1bmN0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtICB7b2JqZWN0fSBqc29uIERhdGEgc291cmNlIG9iamVjdCAvIGFycmF5IGZyb20gdGhlIHNlcnZlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIGRhdGEgdG8gdXNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BamF4RGF0YVNyYyhvU2V0dGluZ3MsIGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhU3JjID0gJC5pc1BsYWluT2JqZWN0KG9TZXR0aW5ncy5hamF4KSAmJiBvU2V0dGluZ3MuYWpheC5kYXRhU3JjICE9PSB1bmRlZmluZWQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5hamF4LmRhdGFTcmMgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5zQWpheERhdGFQcm9wOyAvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LS5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LS4gSW4gb3JkZXIgdG8gcmVhZCBmcm9tIGFhRGF0YSwgY2hlY2sgaWYgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGhhcyBiZWVuIGNoYW5nZWQsIGlmIG5vdCwgY2hlY2sgZm9yIGFhRGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFTcmMgPT09ICdkYXRhJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uLmFhRGF0YSB8fCBqc29uW2RhdGFTcmNdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhU3JjICE9PSBcIlwiID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5HZXRPYmplY3REYXRhRm4oZGF0YVNyYykoanNvbikgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpzb247XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgZmlsdGVyaW5nIHRleHRcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBGaWx0ZXIgY29udHJvbCBlbGVtZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sRmlsdGVyKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlSWQgPSBzZXR0aW5ncy5zVGFibGVJZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsYW5ndWFnZSA9IHNldHRpbmdzLm9MYW5ndWFnZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1NlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gJzxpbnB1dCB0eXBlPVwic2VhcmNoXCIgY2xhc3M9XCInICsgY2xhc3Nlcy5zRmlsdGVySW5wdXQgKyAnXCIvPic7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IGxhbmd1YWdlLnNTZWFyY2g7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIubWF0Y2goL19JTlBVVF8vKSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyLnJlcGxhY2UoJ19JTlBVVF8nLCBpbnB1dCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArIGlucHV0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSAkKCc8ZGl2Lz4nLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogIWZlYXR1cmVzLmYgPyB0YWJsZUlkICsgJ19maWx0ZXInIDogbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBjbGFzc2VzLnNGaWx0ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8bGFiZWwvPicpLmFwcGVuZChzdHIpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VhcmNoRm4gPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogVXBkYXRlIGFsbCBvdGhlciBmaWx0ZXIgaW5wdXQgZWxlbWVudHMgZm9yIHRoZSBuZXcgZGlzcGxheSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuID0gZmVhdHVyZXMuZjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gIXRoaXMudmFsdWUgPyBcIlwiIDogdGhpcy52YWx1ZTsgLy8gbWVudGFsIElFOCBmaXggOi0oXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIE5vdyBkbyB0aGUgZmlsdGVyICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCAhPSBwcmV2aW91c1NlYXJjaC5zU2VhcmNoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckNvbXBsZXRlKHNldHRpbmdzLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogdmFsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiUmVnZXhcIjogcHJldmlvdXNTZWFyY2guYlJlZ2V4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiU21hcnRcIjogcHJldmlvdXNTZWFyY2guYlNtYXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiQ2FzZUluc2Vuc2l0aXZlXCI6IHByZXZpb3VzU2VhcmNoLmJDYXNlSW5zZW5zaXRpdmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHJlZHJhdywgd2l0aG91dCByZXNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hEZWxheSA9IHNldHRpbmdzLnNlYXJjaERlbGF5ICE9PSBudWxsID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5zZWFyY2hEZWxheSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykgPT09ICdzc3AnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgNDAwIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIganFGaWx0ZXIgPSAkKCdpbnB1dCcsIGZpbHRlcilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAudmFsKHByZXZpb3VzU2VhcmNoLnNTZWFyY2gpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BsYWNlaG9sZGVyJywgbGFuZ3VhZ2Uuc1NlYXJjaFBsYWNlaG9sZGVyKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5iaW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAna2V5dXAuRFQgc2VhcmNoLkRUIGlucHV0LkRUIHBhc3RlLkRUIGN1dC5EVCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaERlbGF5ID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblRocm90dGxlKHNlYXJjaEZuLCBzZWFyY2hEZWxheSkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoRm5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmJpbmQoJ2tleXByZXNzLkRUJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogUHJldmVudCBmb3JtIHN1Ym1pc3Npb24gKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1jb250cm9scycsIHRhYmxlSWQpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgZWxlbWVudHMgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIGZpbHRlcmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkub24oJ3NlYXJjaC5kdC5EVCcsIGZ1bmN0aW9uIChldiwgcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncyA9PT0gcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTkgdGhyb3dzIGFuICd1bmtub3duIGVycm9yJyBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpxRmlsdGVyWzBdICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganFGaWx0ZXIudmFsKHByZXZpb3VzU2VhcmNoLnNTZWFyY2gpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyWzBdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEZpbHRlciB0aGUgdGFibGUgdXNpbmcgYm90aCB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgY29sdW1uIGJhc2VkIGZpbHRlcmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZWFyY2ggc2VhcmNoIGluZm9ybWF0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gW2lGb3JjZV0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJDb21wbGV0ZShvU2V0dGluZ3MsIG9JbnB1dCwgaUZvcmNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb1ByZXZTZWFyY2ggPSBvU2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5hb1ByZVNlYXJjaENvbHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZm5TYXZlRmlsdGVyID0gZnVuY3Rpb24gKG9GaWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBTYXZlIHRoZSBmaWx0ZXJpbmcgdmFsdWVzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1ByZXZTZWFyY2guc1NlYXJjaCA9IG9GaWx0ZXIuc1NlYXJjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvUHJldlNlYXJjaC5iUmVnZXggPSBvRmlsdGVyLmJSZWdleDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvUHJldlNlYXJjaC5iU21hcnQgPSBvRmlsdGVyLmJTbWFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvUHJldlNlYXJjaC5iQ2FzZUluc2Vuc2l0aXZlID0gb0ZpbHRlci5iQ2FzZUluc2Vuc2l0aXZlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmblJlZ2V4ID0gZnVuY3Rpb24gKG8pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBiRXNjYXBlUmVnZXggb3B0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uYkVzY2FwZVJlZ2V4ICE9PSB1bmRlZmluZWQgPyAhby5iRXNjYXBlUmVnZXggOiBvLmJSZWdleDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSBhbnkgY29sdW1uIHR5cGVzIHRoYXQgYXJlIHVua25vd24gZHVlIHRvIGFkZGl0aW9uIG9yIGludmFsaWRhdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG8gQXMgcGVyIHNvcnQgLSBjYW4gdGhpcyBiZSBtb3ZlZCBpbnRvIGFuIGV2ZW50IGhhbmRsZXI/XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5UeXBlcyhvU2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgYWxsIGZpbHRlcmluZyBpcyBkb25lIGJ5IHRoZSBzZXJ2ZXIsIHNvIG5vIHBvaW50IGhhbmdpbmcgYXJvdW5kIGhlcmUgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfZm5EYXRhU291cmNlKG9TZXR0aW5ncykgIT0gJ3NzcCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBHbG9iYWwgZmlsdGVyICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyKG9TZXR0aW5ncywgb0lucHV0LnNTZWFyY2gsIGlGb3JjZSwgZm5SZWdleChvSW5wdXQpLCBvSW5wdXQuYlNtYXJ0LCBvSW5wdXQuYkNhc2VJbnNlbnNpdGl2ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm5TYXZlRmlsdGVyKG9JbnB1dCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIE5vdyBkbyB0aGUgaW5kaXZpZHVhbCBjb2x1bW4gZmlsdGVyICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYW9QcmV2U2VhcmNoLmxlbmd0aCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDb2x1bW4ob1NldHRpbmdzLCBhb1ByZXZTZWFyY2hbaV0uc1NlYXJjaCwgaSwgZm5SZWdleChhb1ByZXZTZWFyY2hbaV0pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW9QcmV2U2VhcmNoW2ldLmJTbWFydCwgYW9QcmV2U2VhcmNoW2ldLmJDYXNlSW5zZW5zaXRpdmUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQ3VzdG9tIGZpbHRlcmluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckN1c3RvbShvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm5TYXZlRmlsdGVyKG9JbnB1dCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogVGVsbCB0aGUgZHJhdyBmdW5jdGlvbiB3ZSBoYXZlIGJlZW4gZmlsdGVyaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYkZpbHRlcmVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsIG51bGwsICdzZWFyY2gnLCBbb1NldHRpbmdzXSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQXBwbHkgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRmlsdGVyQ3VzdG9tKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZmlsdGVycyA9IERhdGFUYWJsZS5leHQuc2VhcmNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlSb3dzID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvdywgcm93SWR4O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBmaWx0ZXJzLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29wIG92ZXIgZWFjaCByb3cgYW5kIHNlZSBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamVuID0gZGlzcGxheVJvd3MubGVuZ3RoIDsgaiA8IGplbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dJZHggPSBkaXNwbGF5Um93c1tqXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyc1tpXShzZXR0aW5ncywgcm93Ll9hRmlsdGVyRGF0YSwgcm93SWR4LCByb3cuX2FEYXRhLCBqKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHJvd0lkeCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvIHRoZSBhcnJheSByZWZlcmVuY2UgZG9lc24ndCBicmVhayBzZXQgdGhlIHJlc3VsdHMgaW50byB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlSb3dzLmxlbmd0aCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheVJvd3MucHVzaC5hcHBseShkaXNwbGF5Um93cywgcm93cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRmlsdGVyIHRoZSB0YWJsZSBvbiBhIHBlci1jb2x1bW4gYmFzaXNcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzSW5wdXQgc3RyaW5nIHRvIGZpbHRlciBvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2x1bW4gY29sdW1uIHRvIGZpbHRlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBiUmVnZXggdHJlYXQgc2VhcmNoIHN0cmluZyBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYlNtYXJ0IHVzZSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJDYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnN0aXZlIG1hdGNoaW5nIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJDb2x1bW4oc2V0dGluZ3MsIHNlYXJjaFN0ciwgY29sSWR4LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaFN0ciA9PT0gJycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBycFNlYXJjaCA9IF9mbkZpbHRlckNyZWF0ZVNlYXJjaChzZWFyY2hTdHIsIHJlZ2V4LCBzbWFydCwgY2FzZUluc2Vuc2l0aXZlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZGlzcGxheS5sZW5ndGggLSAxIDsgaSA+PSAwIDsgaS0tKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVtkaXNwbGF5W2ldXS5fYUZpbHRlckRhdGFbY29sSWR4XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFycFNlYXJjaC50ZXN0KGRhdGEpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkuc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBGaWx0ZXIgdGhlIGRhdGEgdGFibGUgYmFzZWQgb24gdXNlciBpbnB1dCBhbmQgZHJhdyB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IGlucHV0IHN0cmluZyB0byBmaWx0ZXIgb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBmb3JjZSBvcHRpb25hbCAtIGZvcmNlIGEgcmVzZWFyY2ggb2YgdGhlIG1hc3RlciBhcnJheSAoMSkgb3Igbm90ICh1bmRlZmluZWQgb3IgMClcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gcmVnZXggdHJlYXQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IHNtYXJ0IHBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBjYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnN0aXZlIG1hdGNoaW5nIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXIoc2V0dGluZ3MsIGlucHV0LCBmb3JjZSwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBycFNlYXJjaCA9IF9mbkZpbHRlckNyZWF0ZVNlYXJjaChpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW5zaXRpdmUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2guc1NlYXJjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXksIGludmFsaWRhdGVkLCBpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gdGFrZSBhY2NvdW50IG9mIGN1c3RvbSBmaWx0ZXJpbmcgZnVuY3Rpb25zIC0gYWx3YXlzIGZpbHRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKERhdGFUYWJsZS5leHQuc2VhcmNoLmxlbmd0aCAhPT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgb2YgdGhlIHJvd3Mgd2VyZSBpbnZhbGlkYXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZWQgPSBfZm5GaWx0ZXJEYXRhKHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYmxhbmsgLSB3ZSBqdXN0IHdhbnQgdGhlIGZ1bGwgZGF0YSBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPD0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldyBzZWFyY2ggLSBzdGFydCBmcm9tIHRoZSBtYXN0ZXIgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZGF0ZWQgfHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2U2VhcmNoLmxlbmd0aCA+IGlucHV0Lmxlbmd0aCB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuaW5kZXhPZihwcmV2U2VhcmNoKSAhPT0gMCB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYlNvcnRlZCAvLyBPbiByZXNvcnQsIHRoZSBkaXNwbGF5IG1hc3RlciBuZWVkcyB0byBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZS1maWx0ZXJlZCBzaW5jZSBpbmRleGVzIHdpbGwgaGF2ZSBjaGFuZ2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCB0aGUgZGlzcGxheSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGRpc3BsYXkubGVuZ3RoIC0gMSA7IGkgPj0gMCA7IGktLSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJwU2VhcmNoLnRlc3Qoc2V0dGluZ3MuYW9EYXRhW2Rpc3BsYXlbaV1dLl9zRmlsdGVyUm93KSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheS5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQnVpbGQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IHN1aXRhYmxlIGZvciBzZWFyY2hpbmcgYSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNTZWFyY2ggc3RyaW5nIHRvIHNlYXJjaCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBiU21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJDYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnNpdGl2ZSBtYXRjaGluZyBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtSZWdFeHB9IGNvbnN0cnVjdGVkIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goc2VhcmNoLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2VhcmNoID0gcmVnZXggP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRXNjYXBlUmVnZXgoc2VhcmNoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc21hcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBGb3Igc21hcnQgZmlsdGVyaW5nIHdlIHdhbnQgdG8gYWxsb3cgdGhlIHNlYXJjaCB0byB3b3JrIHJlZ2FyZGxlc3Mgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB3b3JkIG9yZGVyLiBXZSBhbHNvIHdhbnQgZG91YmxlIHF1b3RlZCB0ZXh0IHRvIGJlIHByZXNlcnZlZCwgc28gd29yZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIG9yZGVyIGlzIGltcG9ydGFudCAtIGEgbGEgZ29vZ2xlLiBTbyB0aGlzIGlzIHdoYXQgd2Ugd2FudCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGdlbmVyYXRlOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIF4oPz0uKj9cXGJvbmVcXGIpKD89Lio/XFxidHdvIHRocmVlXFxiKSg/PS4qP1xcYmZvdXJcXGIpLiokXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSAkLm1hcChzZWFyY2gubWF0Y2goL1wiW15cIl0rXCJ8W14gXSsvZykgfHwgWycnXSwgZnVuY3Rpb24gKHdvcmQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQuY2hhckF0KDApID09PSAnXCInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHdvcmQubWF0Y2goL15cIiguKilcIiQvKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQgPSBtID8gbVsxXSA6IHdvcmQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JkLnJlcGxhY2UoJ1wiJywgJycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2ggPSAnXig/PS4qPycgKyBhLmpvaW4oJykoPz0uKj8nKSArICcpLiokJztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChzZWFyY2gsIGNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc1ZhbCBzdHJpbmcgdG8gZXNjYXBlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSBlc2NhcGVkIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Fc2NhcGVSZWdleChzVmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc1ZhbC5yZXBsYWNlKF9yZV9lc2NhcGVfcmVnZXgsICdcXFxcJDEnKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19maWx0ZXJfZGl2ID0gJCgnPGRpdj4nKVswXTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fZmlsdGVyX2Rpdl90ZXh0Q29udGVudCA9IF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBmaWx0ZXJpbmcgZGF0YSBmb3IgZWFjaCByb3cgaWYgbmVlZGVkIChieSBpbnZhbGlkYXRpb24gb3IgZmlyc3QgcnVuKVxyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJEYXRhKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaiwgaWVuLCBqZW4sIGZpbHRlckRhdGEsIGNlbGxEYXRhLCByb3c7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZm9tYXR0ZXJzID0gRGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB3YXNJbnZhbGlkYXRlZCA9IGZhbHNlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93ID0gc2V0dGluZ3MuYW9EYXRhW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdy5fYUZpbHRlckRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRGF0YSA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwgamVuID0gY29sdW1ucy5sZW5ndGggOyBqIDwgamVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2pdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uYlNlYXJjaGFibGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCBpLCBqLCAnZmlsdGVyJyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb21hdHRlcnNbY29sdW1uLnNUeXBlXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IGZvbWF0dGVyc1tjb2x1bW4uc1R5cGVdKGNlbGxEYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBpbiBEYXRhVGFibGVzIDEuMTAgaXMgc3RyaW5nIGJhc2VkLiBJbiAxLjExIHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYWx0ZXJlZCB0byBhbHNvIGFsbG93IHN0cmljdCB0eXBlIGNoZWNraW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRGF0YSA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsRGF0YSAhPT0gJ3N0cmluZycgJiYgY2VsbERhdGEudG9TdHJpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBjZWxsRGF0YS50b1N0cmluZygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGVyZSBpcyBhbiBIVE1MIGVudGl0eSBpbiB0aGUgc3RyaW5nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBkZWNvZGUgaXQgc28gc29ydGluZyB3b3JrcyBhcyBleHBlY3RlZC4gTm90ZSB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjb3VsZCB1c2UgYSBzaW5nbGUgbGluZSBvZiBqUXVlcnkgdG8gZG8gdGhpcywgYnV0IHRoZSBET01cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ldGhvZCB1c2VkIGhlcmUgaXMgbXVjaCBmYXN0ZXIgaHR0cDovL2pzcGVyZi5jb20vaHRtbC1kZWNvZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRGF0YS5pbmRleE9mICYmIGNlbGxEYXRhLmluZGV4T2YoJyYnKSAhPT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2ZpbHRlcl9kaXYuaW5uZXJIVE1MID0gY2VsbERhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2ZpbHRlcl9kaXYudGV4dENvbnRlbnQgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2ZpbHRlcl9kaXYuaW5uZXJUZXh0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsRGF0YS5yZXBsYWNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBjZWxsRGF0YS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyRGF0YS5wdXNoKGNlbGxEYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9hRmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fc0ZpbHRlclJvdyA9IGZpbHRlckRhdGEuam9pbignICAnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSW52YWxpZGF0ZWQgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FzSW52YWxpZGF0ZWQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ29udmVydCBmcm9tIHRoZSBpbnRlcm5hbCBIdW5nYXJpYW4gbm90YXRpb24gdG8gY2FtZWxDYXNlIGZvciBleHRlcm5hbFxyXG5cdCAgICAgICAgICAgICAgICAgKiBpbnRlcmFjdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgdG8gY29udmVydFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge29iamVjdH0gSW52ZXJ0ZWQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNlYXJjaFRvQ2FtZWwob2JqKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaDogb2JqLnNTZWFyY2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc21hcnQ6IG9iai5iU21hcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXg6IG9iai5iUmVnZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBvYmouYkNhc2VJbnNlbnNpdGl2ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ29udmVydCBmcm9tIGNhbWVsQ2FzZSBub3RhdGlvbiB0byB0aGUgaW50ZXJuYWwgSHVuZ2FyaWFuLiBXZSBjb3VsZCB1c2UgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIEh1bmdhcmlhbiBjb252ZXJ0IGZ1bmN0aW9uIGhlcmUsIGJ1dCB0aGlzIGlzIGNsZWFuZXJcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvYmogT2JqZWN0IHRvIGNvbnZlcnRcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IEludmVydGVkIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5TZWFyY2hUb0h1bmcob2JqKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNTZWFyY2g6IG9iai5zZWFyY2gsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYlNtYXJ0OiBvYmouc21hcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYlJlZ2V4OiBvYmoucmVnZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYkNhc2VJbnNlbnNpdGl2ZTogb2JqLmNhc2VJbnNlbnNpdGl2ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgaW5mbyBkaXNwbGF5XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gSW5mb3JtYXRpb24gZWxlbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbEluZm8oc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRpZCA9IHNldHRpbmdzLnNUYWJsZUlkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXMuaSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuID0gJCgnPGRpdi8+Jywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zSW5mbyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogIW5vZGVzID8gdGlkICsgJ19pbmZvJyA6IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGRpc3BsYXkgb24gZWFjaCBkcmF3XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm5cIjogX2ZuVXBkYXRlSW5mbyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzTmFtZVwiOiBcImluZm9ybWF0aW9uXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncm9sZScsICdzdGF0dXMnKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWJsZSBpcyBkZXNjcmliZWQgYnkgb3VyIGluZm8gZGl2XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJChzZXR0aW5ncy5uVGFibGUpLmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aWQgKyAnX2luZm8nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gblswXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIGVsZW1lbnRzIGluIHRoZSBkaXNwbGF5XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuVXBkYXRlSW5mbyhzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogU2hvdyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzLmk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCArIDEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbCA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSB0b3RhbCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcuc0luZm8gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5nLnNJbmZvRW1wdHk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsICE9PSBtYXgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBSZWNvcmQgc2V0IGFmdGVyIGZpbHRlcmluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSAnICcgKyBsYW5nLnNJbmZvRmlsdGVyZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbWFjcm9zXHJcblx0ICAgICAgICAgICAgICAgICAgICBvdXQgKz0gbGFuZy5zSW5mb1Bvc3RGaXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICBvdXQgPSBfZm5JbmZvTWFjcm9zKHNldHRpbmdzLCBvdXQpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGxhbmcuZm5JbmZvQ2FsbGJhY2s7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBjYWxsYmFjay5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MsIHN0YXJ0LCBlbmQsIG1heCwgdG90YWwsIG91dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgJChub2RlcykuaHRtbChvdXQpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuSW5mb01hY3JvcyhzZXR0aW5ncywgc3RyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGluZmluaXRlIHNjcm9sbGluZywgd2UgYXJlIGFsd2F5cyBzdGFydGluZyBhdCAxLiBfaURpc3BsYXlTdGFydCBpcyB1c2VkIG9ubHlcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGludGVybmFsbHlcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlciA9IHNldHRpbmdzLmZuRm9ybWF0TnVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgKyAxLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2aXMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWxsID0gbGVuID09PSAtMTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL19TVEFSVF8vZywgZm9ybWF0dGVyLmNhbGwoc2V0dGluZ3MsIHN0YXJ0KSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZSgvX0VORF8vZywgZm9ybWF0dGVyLmNhbGwoc2V0dGluZ3MsIHNldHRpbmdzLmZuRGlzcGxheUVuZCgpKSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZSgvX01BWF8vZywgZm9ybWF0dGVyLmNhbGwoc2V0dGluZ3MsIHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCkpKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9fVE9UQUxfL2csIGZvcm1hdHRlci5jYWxsKHNldHRpbmdzLCB2aXMpKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9fUEFHRV8vZywgZm9ybWF0dGVyLmNhbGwoc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoc3RhcnQgLyBsZW4pKSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZSgvX1BBR0VTXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgYWxsID8gMSA6IE1hdGguY2VpbCh2aXMgLyBsZW4pKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERyYXcgdGhlIHRhYmxlIGZvciB0aGUgZmlyc3QgdGltZSwgYWRkaW5nIGFsbCByZXF1aXJlZCBmZWF0dXJlc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkluaXRpYWxpc2Uoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpTGVuLCBpQWpheFN0YXJ0ID0gc2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucywgY29sdW1uO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEVuc3VyZSB0aGF0IHRoZSB0YWJsZSBkYXRhIGlzIGZ1bGx5IGluaXRpYWxpc2VkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmJJbml0aWFsaXNlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBfZm5Jbml0aWFsaXNlKHNldHRpbmdzKTsgfSwgMjAwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogU2hvdyB0aGUgZGlzcGxheSBIVE1MIG9wdGlvbnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFkZE9wdGlvbnNIdG1sKHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBCdWlsZCBhbmQgZHJhdyB0aGUgaGVhZGVyIC8gZm9vdGVyIGZvciB0aGUgdGFibGUgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkJ1aWxkSGVhZChzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5EcmF3SGVhZChzZXR0aW5ncywgc2V0dGluZ3MuYW9IZWFkZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRHJhd0hlYWQoc2V0dGluZ3MsIHNldHRpbmdzLmFvRm9vdGVyKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBPa2F5IHRvIHNob3cgdGhhdCBzb21ldGhpbmcgaXMgZ29pbmcgb24gbm93ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgdHJ1ZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQ2FsY3VsYXRlIHNpemVzIGZvciBjb2x1bW5zICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMuYkF1dG9XaWR0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGNvbHVtbnMubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNXaWR0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4ublRoLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoY29sdW1uLnNXaWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGRlZmF1bHQgc29ydGluZyByZXF1aXJlZCAtIGxldCdzIGRvIGl0LiBUaGUgc29ydCBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBkbyB0aGUgZHJhd2luZyBmb3IgdXMuIE90aGVyd2lzZSB3ZSBkcmF3IHRoZSB0YWJsZSByZWdhcmRsZXNzIG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQWpheCBzb3VyY2UgLSB0aGlzIGFsbG93cyB0aGUgdGFibGUgdG8gbG9vayBpbml0aWFsaXNlZCBmb3IgQWpheCBzb3VyY2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSAoc2hvdyAnbG9hZGluZycgbWVzc2FnZSBwb3NzaWJseSlcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblJlRHJhdyhzZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBpbml0IGNvbXBsZXRlIGlzIGRvbmUgYnkgX2ZuQWpheFVwZGF0ZURyYXdcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhU3JjID0gX2ZuRGF0YVNvdXJjZShzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVNyYyAhPSAnc3NwJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGFqYXggc291cmNlIGxvYWQgdGhlIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVNyYyA9PSAnYWpheCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQnVpbGRBamF4KHNldHRpbmdzLCBbXSwgZnVuY3Rpb24gKGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhRGF0YSA9IF9mbkFqYXhEYXRhU3JjKHNldHRpbmdzLCBqc29uKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHb3QgdGhlIGRhdGEgLSBhZGQgaXQgdG8gdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IGFEYXRhLmxlbmd0aCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkZERhdGEoc2V0dGluZ3MsIGFEYXRhW2ldKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgaW5pdCBkaXNwbGF5IGZvciBjb29raWUgc2F2aW5nLiBXZSd2ZSBhbHJlYWR5IGRvbmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZmlsdGVyLCBhbmQgdGhlcmVmb3JlIGNsZWFyZWQgaXQgYmVmb3JlLiBTbyB3ZSBuZWVkIHRvIG1ha2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGFwcGVhciAnZnJlc2gnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IGlBamF4U3RhcnQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdENvbXBsZXRlKHNldHRpbmdzLCBqc29uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdENvbXBsZXRlKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gW2pzb25dIEpTT04gZnJvbSB0aGUgc2VydmVyIHRoYXQgY29tcGxldGVkIHRoZSB0YWJsZSwgaWYgdXNpbmcgQWpheCBzb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICogICAgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIChvcHRpb25hbClcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuSW5pdENvbXBsZXRlKHNldHRpbmdzLCBqc29uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSA9IHRydWU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gT24gYW4gQWpheCBsb2FkIHdlIG5vdyBoYXZlIGRhdGEgYW5kIHRoZXJlZm9yZSB3YW50IHRvIGFwcGx5IHRoZSBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHNpemluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGp1c3RDb2x1bW5TaXppbmcoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgJ2FvSW5pdENvbXBsZXRlJywgJ2luaXQnLCBbc2V0dGluZ3MsIGpzb25dKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkxlbmd0aENoYW5nZShzZXR0aW5ncywgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGFyc2VJbnQodmFsLCAxMCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggPSBsZW47XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3coc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEZpcmUgbGVuZ3RoIGNoYW5nZSBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAnbGVuZ3RoJywgW3NldHRpbmdzLCBsZW5dKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdXNlciBkaXNwbGF5IGxlbmd0aCBjaGFuZ2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gRGlzcGxheSBsZW5ndGggZmVhdHVyZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sTGVuZ3RoKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVJZCA9IHNldHRpbmdzLnNUYWJsZUlkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1lbnUgPSBzZXR0aW5ncy5hTGVuZ3RoTWVudSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkMiA9ICQuaXNBcnJheShtZW51WzBdKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGhzID0gZDIgPyBtZW51WzBdIDogbWVudSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZSA9IGQyID8gbWVudVsxXSA6IG1lbnU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdCA9ICQoJzxzZWxlY3QvPicsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6IHRhYmxlSWQgKyAnX2xlbmd0aCcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiB0YWJsZUlkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IGNsYXNzZXMuc0xlbmd0aFNlbGVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGxlbmd0aHMubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdFswXVtpXSA9IG5ldyBPcHRpb24obGFuZ3VhZ2VbaV0sIGxlbmd0aHNbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSAkKCc8ZGl2PjxsYWJlbC8+PC9kaXY+JykuYWRkQ2xhc3MoY2xhc3Nlcy5zTGVuZ3RoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWFuRmVhdHVyZXMubCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdlswXS5pZCA9IHRhYmxlSWQgKyAnX2xlbmd0aCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGl2LmNoaWxkcmVuKCkuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9MYW5ndWFnZS5zTGVuZ3RoTWVudS5yZXBsYWNlKCdfTUVOVV8nLCBzZWxlY3RbMF0ub3V0ZXJIVE1MKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCB1c2UgYHNlbGVjdGAgdmFyaWFibGUgYXMgdXNlciBtaWdodCBwcm92aWRlIHRoZWlyIG93biBhbmQgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2UgaXMgYnJva2VuIGJ5IHRoZSB1c2Ugb2Ygb3V0ZXJIVE1MXHJcblx0ICAgICAgICAgICAgICAgICAgICAkKCdzZWxlY3QnLCBkaXYpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnZhbChzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmJpbmQoJ2NoYW5nZS5EVCcsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxlbmd0aENoYW5nZShzZXR0aW5ncywgJCh0aGlzKS52YWwoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBub2RlIHZhbHVlIHdoZW5ldmVyIGFueXRoaW5nIGNoYW5nZXMgdGhlIHRhYmxlJ3MgbGVuZ3RoXHJcblx0ICAgICAgICAgICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkuYmluZCgnbGVuZ3RoLmR0LkRUJywgZnVuY3Rpb24gKGUsIHMsIGxlbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncyA9PT0gcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCdzZWxlY3QnLCBkaXYpLnZhbChsZW4pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZbMF07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcclxuXHQgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IG1vc3Qgb2YgdGhlIHBhZ2luZyBsb2dpYyBpcyBkb25lIGluXHJcblx0ICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZS5leHQucGFnZXJcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2VuZXJhdGUgdGhlIG5vZGUgcmVxdWlyZWQgZm9yIGRlZmF1bHQgcGFnaW5hdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IFBhZ2luYXRpb24gZmVhdHVyZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBzZXR0aW5ncy5zUGFnaW5hdGlvblR5cGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luID0gRGF0YVRhYmxlLmV4dC5wYWdlclt0eXBlXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtb2Rlcm4gPSB0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlZHJhdyA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcyhzZXR0aW5ncy5vQ2xhc3Nlcy5zUGFnaW5nICsgdHlwZSlbMF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMgPSBzZXR0aW5ncy5hYW5GZWF0dXJlcztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1vZGVybikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbi5mbkluaXQoc2V0dGluZ3MsIG5vZGUsIHJlZHJhdyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQWRkIGEgZHJhdyBjYWxsYmFjayBmb3IgdGhlIHBhZ2luYXRpb24gb24gZmlyc3QgaW5zdGFuY2UsIHRvIHVwZGF0ZSB0aGUgcGFnaW5nIGRpc3BsYXkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZmVhdHVyZXMucCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaWQgPSBzZXR0aW5ncy5zVGFibGVJZCArICdfcGFnaW5hdGUnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hb0RyYXdDYWxsYmFjay5wdXNoKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmblwiOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2Rlcm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGwgPSBsZW4gPT09IC0xLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlID0gYWxsID8gMCA6IE1hdGguY2VpbChzdGFydCAvIGxlbiksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VzID0gYWxsID8gMSA6IE1hdGguY2VpbCh2aXNSZWNvcmRzIC8gbGVuKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IHBsdWdpbihwYWdlLCBwYWdlcyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGksIGllbjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gZmVhdHVyZXMucC5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblJlbmRlcmVyKHNldHRpbmdzLCAncGFnZUJ1dHRvbicpKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MsIGZlYXR1cmVzLnBbaV0sIGksIGJ1dHRvbnMsIHBhZ2UsIHBhZ2VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmZuVXBkYXRlKHNldHRpbmdzLCByZWRyYXcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNOYW1lXCI6IFwicGFnaW5hdGlvblwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWx0ZXIgdGhlIGRpc3BsYXkgc2V0dGluZ3MgdG8gY2hhbmdlIHRoZSBwYWdlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfGludH0gYWN0aW9uIFBhZ2luZyBhY3Rpb24gdG8gdGFrZTogXCJmaXJzdFwiLCBcInByZXZpb3VzXCIsXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIFwibmV4dFwiIG9yIFwibGFzdFwiIG9yIHBhZ2UgbnVtYmVyIHRvIGp1bXAgdG8gKGludGVnZXIpXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0gW2Jvb2xdIHJlZHJhdyBBdXRvbWF0aWNhbGx5IGRyYXcgdGhlIHVwZGF0ZSBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtib29sfSB0cnVlIHBhZ2UgaGFzIGNoYW5nZWQsIGZhbHNlIC0gbm8gY2hhbmdlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblBhZ2VDaGFuZ2Uoc2V0dGluZ3MsIGFjdGlvbiwgcmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzID09PSAwIHx8IGxlbiA9PT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYWN0aW9uID09PSBcIm51bWJlclwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBhY3Rpb24gKiBsZW47XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA+IHJlY29yZHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PSBcImZpcnN0XCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT0gXCJwcmV2aW91c1wiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBsZW4gPj0gMCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0IC0gbGVuIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwibmV4dFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbGVuIDwgcmVjb3Jkcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCArPSBsZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwibGFzdFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKChyZWNvcmRzIC0gMSkgLyBsZW4pICogbGVuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKHNldHRpbmdzLCAwLCBcIlVua25vd24gcGFnaW5nIGFjdGlvbjogXCIgKyBhY3Rpb24sIDUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgIT09IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBzdGFydDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ3BhZ2UnLCBbc2V0dGluZ3NdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgcHJvY2Vzc2luZyBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBQcm9jZXNzaW5nIGVsZW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCgnPGRpdi8+Jywge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICdpZCc6ICFzZXR0aW5ncy5hYW5GZWF0dXJlcy5yID8gc2V0dGluZ3Muc1RhYmxlSWQgKyAnX3Byb2Nlc3NpbmcnIDogbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zUHJvY2Vzc2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuaHRtbChzZXR0aW5ncy5vTGFuZ3VhZ2Uuc1Byb2Nlc3NpbmcpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydEJlZm9yZShzZXR0aW5ncy5uVGFibGUpWzBdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERpc3BsYXkgb3IgaGlkZSB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3JcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBzaG93IFNob3cgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yICh0cnVlKSBvciBub3QgKGZhbHNlKVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgc2hvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9GZWF0dXJlcy5iUHJvY2Vzc2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQoc2V0dGluZ3MuYWFuRmVhdHVyZXMucikuY3NzKCdkaXNwbGF5Jywgc2hvdyA/ICdibG9jaycgOiAnbm9uZScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ3Byb2Nlc3NpbmcnLCBbc2V0dGluZ3MsIHNob3ddKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFkZCBhbnkgY29udHJvbCBlbGVtZW50cyBmb3IgdGhlIHRhYmxlIC0gc3BlY2lmaWNhbGx5IHNjcm9sbGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gTm9kZSB0byBhZGQgdG8gdGhlIERPTVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFRhYmxlKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSAkKHNldHRpbmdzLm5UYWJsZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBBUklBIGdyaWQgcm9sZSB0byB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgIHRhYmxlLmF0dHIoJ3JvbGUnLCAnZ3JpZCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNjcm9sbGluZyBmcm9tIGhlcmUgb24gaW5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGwuc1ggPT09ICcnICYmIHNjcm9sbC5zWSA9PT0gJycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MublRhYmxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxYID0gc2Nyb2xsLnNYO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFkgPSBzY3JvbGwuc1k7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNhcHRpb24gPSB0YWJsZS5jaGlsZHJlbignY2FwdGlvbicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNhcHRpb25TaWRlID0gY2FwdGlvbi5sZW5ndGggPyBjYXB0aW9uWzBdLl9jYXB0aW9uU2lkZSA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyQ2xvbmUgPSAkKHRhYmxlWzBdLmNsb25lTm9kZShmYWxzZSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZvb3RlckNsb25lID0gJCh0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmb290ZXIgPSB0YWJsZS5jaGlsZHJlbigndGZvb3QnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfZGl2ID0gJzxkaXYvPic7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IGZ1bmN0aW9uIChzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzID8gbnVsbCA6IF9mblN0cmluZ1RvQ3NzKHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGZhaXJseSBtZXNzeSwgYnV0IHdpdGggeCBzY3JvbGxpbmcgZW5hYmxlZCwgaWYgdGhlIHRhYmxlIGhhcyBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB3aWR0aCBhdHRyaWJ1dGUsIHJlZ2FyZGxlc3Mgb2YgYW55IHdpZHRoIGFwcGxpZWQgdXNpbmcgdGhlIGNvbHVtbiB3aWR0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9ucywgdGhlIGJyb3dzZXIgd2lsbCBzaHJpbmsgb3IgZ3JvdyB0aGUgdGFibGUgYXMgbmVlZGVkIHRvIGZpdCBpbnRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IDEwMCUuIFRoYXQgd291bGQgbWFrZSB0aGUgd2lkdGggb3B0aW9ucyB1c2VsZXNzLiBTbyB3ZSByZW1vdmUgaXQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG9rYXksIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgd2lkdGg6MTAwJSBpcyBhcHBsaWVkIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdGFibGUgaW4gQ1NTIChpdCBpcyBpbiB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0KSB3aGljaCB3aWxsIHNldCB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHdpZHRoIGFzIGFwcHJvcHJpYXRlICh0aGUgYXR0cmlidXRlIGFuZCBjc3MgYmVoYXZlIGRpZmZlcmVudGx5Li4uKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbC5zWCAmJiB0YWJsZS5hdHRyKCd3aWR0aCcpID09PSAnMTAwJScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5yZW1vdmVBdHRyKCd3aWR0aCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZm9vdGVyLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBIVE1MIHN0cnVjdHVyZSB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgaW4gdGhpcyBmdW5jdGlvbiBpczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBkaXYgLSBzY3JvbGxlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGl2IC0gc2Nyb2xsIGhlYWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZGl2IC0gc2Nyb2xsIGhlYWQgaW5uZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBoZWFkIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB0aGVhZCAtIHRoZWFkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBkaXYgLSBzY3JvbGwgYm9keVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB0YWJsZSAtIHRhYmxlIChtYXN0ZXIgdGFibGUpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgdGhlYWQgLSB0aGVhZCBjbG9uZSBmb3Igc2l6aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgdGJvZHkgLSB0Ym9keVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGl2IC0gc2Nyb2xsIGZvb3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZGl2IC0gc2Nyb2xsIGZvb3QgaW5uZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBmb290IHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB0Zm9vdCAtIHRmb290XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxlciA9ICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxXcmFwcGVyIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEhlYWQgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbFggPyBzaXplKHNjcm9sbFgpIDogJzEwMCUnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZElubmVyIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JveC1zaXppbmcnOiAnY29udGVudC1ib3gnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbC5zWElubmVyIHx8ICcxMDAlJ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyQ2xvbmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignaWQnKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ21hcmdpbi1sZWZ0JywgMClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGNhcHRpb25TaWRlID09PSAndG9wJyA/IGNhcHRpb24gOiBudWxsKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxCb2R5IH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogc2l6ZShzY3JvbGxZKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2l6ZShzY3JvbGxYKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQodGFibGUpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZm9vdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsZXIuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsRm9vdCB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290SW5uZXIgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlckNsb25lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2lkJylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCdtYXJnaW4tbGVmdCcsIDApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChjYXB0aW9uU2lkZSA9PT0gJ2JvdHRvbScgPyBjYXB0aW9uIDogbnVsbClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gc2Nyb2xsZXIuY2hpbGRyZW4oKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxIZWFkID0gY2hpbGRyZW5bMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQm9keSA9IGNoaWxkcmVuWzFdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEZvb3QgPSBmb290ZXIgPyBjaGlsZHJlblsyXSA6IG51bGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgYm9keSBpcyBzY3JvbGxlZCwgdGhlbiB3ZSBhbHNvIHdhbnQgdG8gc2Nyb2xsIHRoZSBoZWFkZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQoc2Nyb2xsQm9keSkub24oJ3Njcm9sbC5EVCcsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSGVhZC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEZvb3Quc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uU2Nyb2xsSGVhZCA9IHNjcm9sbEhlYWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uU2Nyb2xsQm9keSA9IHNjcm9sbEJvZHk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uU2Nyb2xsRm9vdCA9IHNjcm9sbEZvb3Q7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gT24gcmVkcmF3IC0gYWxpZ24gY29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJmblwiOiBfZm5TY3JvbGxEcmF3LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic05hbWVcIjogXCJzY3JvbGxpbmdcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjcm9sbGVyWzBdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBVcGRhdGUgdGhlIGhlYWRlciwgZm9vdGVyIGFuZCBib2R5IHRhYmxlcyBmb3IgcmVzaXppbmcgLSBpLmUuIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgKiBhbGlnbm1lbnQuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIFdlbGNvbWUgdG8gdGhlIG1vc3QgaG9ycmlibGUgZnVuY3Rpb24gRGF0YVRhYmxlcy4gVGhlIHByb2Nlc3MgdGhhdCB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9uIGZvbGxvd3MgaXMgYmFzaWNhbGx5OlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIDEuIFJlLWNyZWF0ZSB0aGUgdGFibGUgaW5zaWRlIHRoZSBzY3JvbGxpbmcgZGl2XHJcblx0ICAgICAgICAgICAgICAgICAqICAgMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET01cclxuXHQgICAgICAgICAgICAgICAgICogICAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzIHRvIGFsaWduIHRoZSBjb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAqICAgNC4gQ2xlYW4gdXBcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5TY3JvbGxEcmF3KHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBHaXZlbiB0aGF0IHRoaXMgaXMgc3VjaCBhIG1vbnN0ZXIgZnVuY3Rpb24sIGEgbG90IG9mIHZhcmlhYmxlcyBhcmUgdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB0byB0cnkgYW5kIGtlZXAgdGhlIG1pbmltaXNlZCBzaXplIGFzIHNtYWxsIGFzIHBvc3NpYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFggPSBzY3JvbGwuc1gsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWElubmVyID0gc2Nyb2xsLnNYSW5uZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWSA9IHNjcm9sbC5zWSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBiYXJXaWR0aCA9IHNjcm9sbC5pQmFyV2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2SGVhZGVyID0gJChzZXR0aW5ncy5uU2Nyb2xsSGVhZCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2SGVhZGVyU3R5bGUgPSBkaXZIZWFkZXJbMF0uc3R5bGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2SGVhZGVySW5uZXIgPSBkaXZIZWFkZXIuY2hpbGRyZW4oJ2RpdicpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkhlYWRlcklubmVyU3R5bGUgPSBkaXZIZWFkZXJJbm5lclswXS5zdHlsZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZIZWFkZXJUYWJsZSA9IGRpdkhlYWRlcklubmVyLmNoaWxkcmVuKCd0YWJsZScpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkJvZHlFbCA9IHNldHRpbmdzLm5TY3JvbGxCb2R5LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkJvZHkgPSAkKGRpdkJvZHlFbCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Qm9keVN0eWxlID0gZGl2Qm9keUVsLnN0eWxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkZvb3RlciA9ICQoc2V0dGluZ3MublNjcm9sbEZvb3QpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkZvb3RlcklubmVyID0gZGl2Rm9vdGVyLmNoaWxkcmVuKCdkaXYnKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZGb290ZXJUYWJsZSA9IGRpdkZvb3RlcklubmVyLmNoaWxkcmVuKCd0YWJsZScpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9ICQoc2V0dGluZ3MublRIZWFkKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUVsID0gdGFibGVbMF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZSA9IHRhYmxlRWwuc3R5bGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyID0gc2V0dGluZ3MublRGb290ID8gJChzZXR0aW5ncy5uVEZvb3QpIDogbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyID0gc2V0dGluZ3Mub0Jyb3dzZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWU2NyA9IGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclRyZ0VscywgZm9vdGVyVHJnRWxzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlclNyY0VscywgZm9vdGVyU3JjRWxzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckNvcHksIGZvb3RlckNvcHksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyV2lkdGhzID0gW10sIGZvb3RlcldpZHRocyA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlckNvbnRlbnQgPSBbXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZHgsIGNvcnJlY3Rpb24sIHNhbml0eVdpZHRoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHplcm9PdXQgPSBmdW5jdGlvbiAoblNpemVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IG5TaXplci5zdHlsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUucGFkZGluZ1RvcCA9IFwiMFwiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZS5wYWRkaW5nQm90dG9tID0gXCIwXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmJvcmRlclRvcFdpZHRoID0gXCIwXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoID0gXCIwXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlLmhlaWdodCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMS4gUmUtY3JlYXRlIHRoZSB0YWJsZSBpbnNpZGUgdGhlIHNjcm9sbGluZyBkaXZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2xkIG1pbmltaXNlZCB0aGVhZCBhbmQgdGZvb3QgZWxlbWVudHMgaW4gdGhlIGlubmVyIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICB0YWJsZS5jaGlsZHJlbigndGhlYWQsIHRmb290JykucmVtb3ZlKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGN1cnJlbnQgaGVhZGVyIGFuZCBmb290ZXIgZWxlbWVudHMgYW5kIHRoZW4gcGxhY2UgaXQgaW50byB0aGUgaW5uZXIgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgIGhlYWRlckNvcHkgPSBoZWFkZXIuY2xvbmUoKS5wcmVwZW5kVG8odGFibGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGVhZGVyVHJnRWxzID0gaGVhZGVyLmZpbmQoJ3RyJyk7IC8vIG9yaWdpbmFsIGhlYWRlciBpcyBpbiBpdHMgb3duIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICBoZWFkZXJTcmNFbHMgPSBoZWFkZXJDb3B5LmZpbmQoJ3RyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBoZWFkZXJDb3B5LmZpbmQoJ3RoLCB0ZCcpLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlckNvcHkgPSBmb290ZXIuY2xvbmUoKS5wcmVwZW5kVG8odGFibGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlclRyZ0VscyA9IGZvb3Rlci5maW5kKCd0cicpOyAvLyB0aGUgb3JpZ2luYWwgdGZvb3QgaXMgaW4gaXRzIG93biB0YWJsZSBhbmQgbXVzdCBiZSBzaXplZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlclNyY0VscyA9IGZvb3RlckNvcHkuZmluZCgndHInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDIuIFRha2UgbGl2ZSBtZWFzdXJlbWVudHMgZnJvbSB0aGUgRE9NIC0gZG8gbm90IGFsdGVyIHRoZSBET00gaXRzZWxmIVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBzaXppbmcgYW5kIGFwcGx5IHRoZSBjYWxjdWxhdGVkIGNvbHVtbiB3aWR0aHNcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdW5pcXVlIGNvbHVtbiBoZWFkZXJzIGluIHRoZSBuZXdseSBjcmVhdGVkIChjbG9uZWQpIGhlYWRlci4gV2Ugd2FudCB0byBhcHBseSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZWQgc2l6ZXMgdG8gdGhpcyBoZWFkZXJcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc2Nyb2xsWCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpdkJvZHlTdHlsZS53aWR0aCA9ICcxMDAlJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZIZWFkZXJbMF0uc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgJC5lYWNoKF9mbkdldFVuaXF1ZVRocyhzZXR0aW5ncywgaGVhZGVyQ29weSksIGZ1bmN0aW9uIChpLCBlbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IF9mblZpc2libGVUb0NvbHVtbkluZGV4KHNldHRpbmdzLCBpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS53aWR0aCA9IHNldHRpbmdzLmFvQ29sdW1uc1tpZHhdLnNXaWR0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5zdHlsZS53aWR0aCA9IFwiXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgZm9vdGVyU3JjRWxzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiBzY3JvbGwgY29sbGFwc2UgaXMgZW5hYmxlZCwgd2hlbiB3ZSBwdXQgdGhlIGhlYWRlcnMgYmFjayBpbnRvIHRoZSBib2R5IGZvciBzaXppbmcsIHdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIGVuZCB1cCBmb3JjaW5nIHRoZSBzY3JvbGxiYXIgdG8gYXBwZWFyLCBtYWtpbmcgb3VyIG1lYXN1cmVtZW50cyB3cm9uZyBmb3Igd2hlbiB3ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBoaWRlIGl0IChlbmQgb2YgdGhpcyBmdW5jdGlvbiksIHNvIGFkZCB0aGUgaGVhZGVyIGhlaWdodCB0byB0aGUgYm9keSBzY3JvbGxlci5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGwuYkNvbGxhcHNlICYmIHNjcm9sbFkgIT09IFwiXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5U3R5bGUuaGVpZ2h0ID0gKGRpdkJvZHlbMF0ub2Zmc2V0SGVpZ2h0ICsgaGVhZGVyWzBdLm9mZnNldEhlaWdodCkgKyBcInB4XCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2l6ZSB0aGUgdGFibGUgYXMgYSB3aG9sZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgc2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWCA9PT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHggc2Nyb2xsaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTcgd2lsbCBtYWtlIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgd2hlbiAxMDAlIGluY2x1ZGUgdGhlIHNjcm9sbGJhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gd2hpY2ggaXMgc2hvdWxkbid0LiBXaGVuIHRoZXJlIGlzIGEgc2Nyb2xsYmFyIHdlIG5lZWQgdG8gdGFrZSB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50byBhY2NvdW50LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZTY3ICYmICh0YWJsZS5maW5kKCd0Ym9keScpLmhlaWdodCgpID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyh0YWJsZS5vdXRlcldpZHRoKCkgLSBiYXJXaWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8geCBzY3JvbGxpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWElubmVyICE9PSBcIlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHggc2Nyb2xsIGlubmVyIGhhcyBiZWVuIGdpdmVuIC0gdXNlIGl0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhzY3JvbGxYSW5uZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzYW5pdHlXaWR0aCA9PSBkaXZCb2R5LndpZHRoKCkgJiYgZGl2Qm9keS5oZWlnaHQoKSA8IHRhYmxlLmhlaWdodCgpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIHktc2Nyb2xsaW5nIC0gdHJ5IHRvIHRha2UgYWNjb3VudCBvZiB0aGUgeSBzY3JvbGwgYmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhzYW5pdHlXaWR0aCAtIGJhcldpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlLm91dGVyV2lkdGgoKSA+IHNhbml0eVdpZHRoIC0gYmFyV2lkdGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBwb3NzaWJsZSB0byB0YWtlIGFjY291bnQgb2YgaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhzYW5pdHlXaWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYWxsIGVsc2UgZmFpbHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHNhbml0eVdpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aCAtIG5vdyB0aGF0IHdlJ3ZlIGFwcGxpZWQgdGhlIHJlcXVpcmVkIHdpZHRoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYmVmb3JlIGl0IHdhcyBhIHRlbXBvcmFyeSB2YXJpYWJsZS4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIHRoZSBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHdpZHRoIGNhbGN1bGF0aW9uIGlzIGRvbmUgYmVmb3JlIHRoaXMgdGFibGUgRE9NIGlzIGNyZWF0ZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBIaWRkZW4gaGVhZGVyIHNob3VsZCBoYXZlIHplcm8gaGVpZ2h0LCBzbyByZW1vdmUgcGFkZGluZyBhbmQgYm9yZGVycy4gVGhlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB3aWR0aCBiYXNlZCBvbiB0aGUgcmVhbCBoZWFkZXJzXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgYWxsIHN0eWxlcyBpbiBvbmUgcGFzc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKHplcm9PdXQsIGhlYWRlclNyY0Vscyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBhbGwgd2lkdGhzIGluIG5leHQgcGFzc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuU2l6ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDb250ZW50LnB1c2goblNpemVyLmlubmVySFRNTCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyV2lkdGhzLnB1c2goX2ZuU3RyaW5nVG9Dc3MoJChuU2l6ZXIpLmNzcygnd2lkdGgnKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgaGVhZGVyU3JjRWxzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBhbGwgd2lkdGhzIGluIGZpbmFsIHBhc3NcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbihmdW5jdGlvbiAoblRvU2l6ZSwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5Ub1NpemUuc3R5bGUud2lkdGggPSBoZWFkZXJXaWR0aHNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCBoZWFkZXJUcmdFbHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICQoaGVhZGVyU3JjRWxzKS5oZWlnaHQoMCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogU2FtZSBhZ2FpbiB3aXRoIHRoZSBmb290ZXIgaWYgd2UgaGF2ZSBvbmUgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb290ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oemVyb091dCwgZm9vdGVyU3JjRWxzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuU2l6ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9vdGVyV2lkdGhzLnB1c2goX2ZuU3RyaW5nVG9Dc3MoJChuU2l6ZXIpLmNzcygnd2lkdGgnKSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZvb3RlclNyY0Vscyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbihmdW5jdGlvbiAoblRvU2l6ZSwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuVG9TaXplLnN0eWxlLndpZHRoID0gZm9vdGVyV2lkdGhzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZvb3RlclRyZ0Vscyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQoZm9vdGVyU3JjRWxzKS5oZWlnaHQoMCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAzLiBBcHBseSB0aGUgbWVhc3VyZW1lbnRzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBcIkhpZGVcIiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGhhdCB3ZSB1c2VkIGZvciB0aGUgc2l6aW5nLiBXZSBuZWVkIHRvIGtlZXBcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIHNvIHRoYXQgdGhlIHdpZHRoIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBhbmQgYm9keVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYm90aCBtYXRjaCwgYnV0IHdlIHdhbnQgdG8gaGlkZSBpdCBjb21wbGV0ZWx5LiBXZSB3YW50IHRvIGFsc28gZml4IHRoZWlyXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB3aWR0aCB0byB3aGF0IHRoZXkgY3VycmVudGx5IGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuU2l6ZXIsIGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuU2l6ZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiIHN0eWxlPVwiaGVpZ2h0OjA7b3ZlcmZsb3c6aGlkZGVuO1wiPicgKyBoZWFkZXJDb250ZW50W2ldICsgJzwvZGl2Pic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgblNpemVyLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgaGVhZGVyU3JjRWxzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZm9vdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuU2l6ZXIsIGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgblNpemVyLmlubmVySFRNTCA9IFwiXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCBmb290ZXJTcmNFbHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNhbml0eSBjaGVjayB0aGF0IHRoZSB0YWJsZSBpcyBvZiBhIHNlbnNpYmxlIHdpZHRoLiBJZiBub3QgdGhlbiB3ZSBhcmUgZ29pbmcgdG8gZ2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBtaXNhbGlnbm1lbnQgLSB0cnkgdG8gcHJldmVudCB0aGlzIGJ5IG5vdCBhbGxvd2luZyB0aGUgdGFibGUgdG8gc2hyaW5rIGJlbG93IGl0cyBtaW4gd2lkdGhcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZS5vdXRlcldpZHRoKCkgPCBzYW5pdHlXaWR0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtaW4gd2lkdGggZGVwZW5kcyB1cG9uIGlmIHdlIGhhdmUgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIgdmlzaWJsZSBvciBub3QgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb3JyZWN0aW9uID0gKChkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpKSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW5pdHlXaWR0aCArIGJhcldpZHRoIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhbml0eVdpZHRoO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTYvNyBhcmUgYSBsYXcgdW50byB0aGVtc2VsdmVzLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGllNjcgJiYgKGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8IGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGNvcnJlY3Rpb24gLSBiYXJXaWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbmQgZ2l2ZSB0aGUgdXNlciBhIHdhcm5pbmcgdGhhdCB3ZSd2ZSBzdG9wcGVkIHRoZSB0YWJsZSBnZXR0aW5nIHRvbyBzbWFsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxYID09PSBcIlwiIHx8IHNjcm9sbFhJbm5lciAhPT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2coc2V0dGluZ3MsIDEsICdQb3NzaWJsZSBjb2x1bW4gbWlzYWxpZ25tZW50JywgNik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29ycmVjdGlvbiA9ICcxMDAlJztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRzXHJcblx0ICAgICAgICAgICAgICAgICAgICBkaXZCb2R5U3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyhjb3JyZWN0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGRpdkhlYWRlclN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoY29ycmVjdGlvbik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxGb290LnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoY29ycmVjdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiA0LiBDbGVhbiB1cFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNjcm9sbFkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBJRTc8IHB1dHMgYSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaW4gcGxhY2UgKHdoZW4gaXQgc2hvdWxkbid0IGJlKSBkdWUgdG8gc3VidHJhY3RpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc2Nyb2xsYmFyIGhlaWdodCBmcm9tIHRoZSB2aXNpYmxlIGRpc3BsYXksIHJhdGhlciB0aGFuIGFkZGluZyBpdCBvbi4gV2UgbmVlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCB0aGUgaGVpZ2h0IGluIG9yZGVyIHRvIHNvcnQgdGhpcy4gRG9uJ3Qgd2FudCB0byBkbyBpdCBpbiBhbnkgb3RoZXIgYnJvd3NlcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGllNjcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKHRhYmxlRWwub2Zmc2V0SGVpZ2h0ICsgYmFyV2lkdGgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWSAmJiBzY3JvbGwuYkNvbGxhcHNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKHNjcm9sbFkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaUV4dHJhID0gKHNjcm9sbFggJiYgdGFibGVFbC5vZmZzZXRXaWR0aCA+IGRpdkJvZHlFbC5vZmZzZXRXaWR0aCkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXJXaWR0aCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZUVsLm9mZnNldEhlaWdodCA8IGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2Qm9keVN0eWxlLmhlaWdodCA9IF9mblN0cmluZ1RvQ3NzKHRhYmxlRWwub2Zmc2V0SGVpZ2h0ICsgaUV4dHJhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogRmluYWxseSBzZXQgdGhlIHdpZHRoJ3Mgb2YgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRhYmxlcyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlPdXRlcldpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGl2SGVhZGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhpT3V0ZXJXaWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkaXZIZWFkZXJJbm5lclN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoaU91dGVyV2lkdGgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgdGhlcmUgYXJlIHNjcm9sbGJhciBwcmVzZW50IC0gaWYgc28gdGhlbiB3ZSBuZWVkIGEgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYlNjcm9sbGluZyA9IHRhYmxlLmhlaWdodCgpID4gZGl2Qm9keUVsLmNsaWVudEhlaWdodCB8fCBkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9ICdwYWRkaW5nJyArIChicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID8gJ0xlZnQnIDogJ1JpZ2h0Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkaXZIZWFkZXJJbm5lclN0eWxlW3BhZGRpbmddID0gYlNjcm9sbGluZyA/IGJhcldpZHRoICsgXCJweFwiIDogXCIwcHhcIjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZm9vdGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Rm9vdGVyVGFibGVbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhpT3V0ZXJXaWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Rm9vdGVySW5uZXJbMF0uc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhpT3V0ZXJXaWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Rm9vdGVySW5uZXJbMF0uc3R5bGVbcGFkZGluZ10gPSBiU2Nyb2xsaW5nID8gYmFyV2lkdGggKyBcInB4XCIgOiBcIjBweFwiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEFkanVzdCB0aGUgcG9zaXRpb24gb2YgdGhlIGhlYWRlciBpbiBjYXNlIHdlIGxvb3NlIHRoZSB5LXNjcm9sbGJhciAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGl2Qm9keS5zY3JvbGwoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb3J0aW5nIG9yIGZpbHRlcmluZyBoYXMgb2NjdXJyZWQsIGp1bXAgdGhlIHNjcm9sbGluZyBiYWNrIHRvIHRoZSB0b3BcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgaWYgd2UgYXJlbid0IGhvbGRpbmcgdGhlIHBvc2l0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmJTb3J0ZWQgfHwgc2V0dGluZ3MuYkZpbHRlcmVkKSAmJiAhc2V0dGluZ3MuX2RyYXdIb2xkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGl2Qm9keUVsLnNjcm9sbFRvcCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFwcGx5IGEgZ2l2ZW4gZnVuY3Rpb24gdG8gdGhlIGRpc3BsYXkgY2hpbGQgbm9kZXMgb2YgYW4gZWxlbWVudCBhcnJheSAodHlwaWNhbGx5XHJcblx0ICAgICAgICAgICAgICAgICAqIFREIGNoaWxkcmVuIG9mIFRSIHJvd3NcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIE1ldGhvZCB0byBhcHBseSB0byB0aGUgb2JqZWN0c1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIGFycmF5IHtub2Rlc30gYW4xIExpc3Qgb2YgZWxlbWVudHMgdG8gbG9vayB0aHJvdWdoIGZvciBkaXNwbGF5IGNoaWxkcmVuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjIgQW5vdGhlciBsaXN0IChpZGVudGljYWwgc3RydWN0dXJlIHRvIHRoZSBmaXJzdCkgLSBvcHRpb25hbFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5BcHBseVRvQ2hpbGRyZW4oZm4sIGFuMSwgYW4yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSAwLCBpID0gMCwgaUxlbiA9IGFuMS5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbk5vZGUxLCBuTm9kZTI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpTGVuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbk5vZGUxID0gYW4xW2ldLmZpcnN0Q2hpbGQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbk5vZGUyID0gYW4yID8gYW4yW2ldLmZpcnN0Q2hpbGQgOiBudWxsO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobk5vZGUxKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuTm9kZTEubm9kZVR5cGUgPT09IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbjIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbihuTm9kZTEsIG5Ob2RlMiwgaW5kZXgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4obk5vZGUxLCBpbmRleCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk5vZGUxID0gbk5vZGUxLm5leHRTaWJsaW5nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTm9kZTIgPSBhbjIgPyBuTm9kZTIubmV4dFNpYmxpbmcgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX3JlX2h0bWxfcmVtb3ZlID0gLzwuKj8+L2c7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgY29sdW1ucyBmb3IgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyhvU2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlID0gb1NldHRpbmdzLm5UYWJsZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGwgPSBvU2V0dGluZ3Mub1Njcm9sbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxZID0gc2Nyb2xsLnNZLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFggPSBzY3JvbGwuc1gsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWElubmVyID0gc2Nyb2xsLnNYSW5uZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlQ29sdW1ucyA9IF9mbkdldENvbHVtbnMob1NldHRpbmdzLCAnYlZpc2libGUnKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDZWxscyA9ICQoJ3RoJywgb1NldHRpbmdzLm5USGVhZCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVXaWR0aEF0dHIgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIC8vIGZyb20gRE9NIGVsZW1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZUNvbnRhaW5lciA9IHRhYmxlLnBhcmVudE5vZGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklucHV0cyA9IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGksIGNvbHVtbiwgY29sdW1uSWR4LCB3aWR0aCwgb3V0ZXJXaWR0aDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVXaWR0aCA9IHRhYmxlLnN0eWxlLndpZHRoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlV2lkdGggJiYgc3R5bGVXaWR0aC5pbmRleE9mKCclJykgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVXaWR0aEF0dHIgPSBzdHlsZVdpZHRoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIENvbnZlcnQgYW55IHVzZXIgaW5wdXQgc2l6ZXMgaW50byBwaXhlbCBzaXplcyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCA7IGkgPCB2aXNpYmxlQ29sdW1ucy5sZW5ndGggOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW3Zpc2libGVDb2x1bW5zW2ldXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5zV2lkdGggIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNXaWR0aCA9IF9mbkNvbnZlcnRUb1dpZHRoKGNvbHVtbi5zV2lkdGhPcmlnLCB0YWJsZUNvbnRhaW5lcik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySW5wdXRzID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBET00gZXF1YWxzIHRoZSBudW1iZXIgdGhhdCB3ZSBoYXZlIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwcm9jZXNzIGluIERhdGFUYWJsZXMsIHRoZW4gd2UgY2FuIHVzZSB0aGUgb2Zmc2V0cyB0aGF0IGFyZSBjcmVhdGVkIGJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgd2ViLSBicm93c2VyLiBObyBjdXN0b20gc2l6ZXMgY2FuIGJlIHNldCBpbiBvcmRlciBmb3IgdGhpcyB0byBoYXBwZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBub3Igc2Nyb2xsaW5nIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VySW5wdXRzICYmICFzY3JvbGxYICYmICFzY3JvbGxZICYmXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPT0gX2ZuVmlzYmxlQ29sdW1ucyhvU2V0dGluZ3MpICYmXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPT0gaGVhZGVyQ2VsbHMubGVuZ3RoXHJcblx0ICAgICAgICAgICAgICAgICAgICApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IGNvbHVtbkNvdW50IDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnNbaV0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoaGVhZGVyQ2VsbHMuZXEoaSkud2lkdGgoKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNvbnN0cnVjdCBhIHNpbmdsZSByb3csIHdvcnN0IGNhc2UsIHRhYmxlIHdpdGggdGhlIHdpZGVzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgaW4gdGhlIGRhdGEsIGFzc2lnbiBhbnkgdXNlciBkZWZpbmVkIHdpZHRocywgdGhlbiBpbnNlcnQgaXQgaW50b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBET00gYW5kIGFsbG93IHRoZSBicm93c2VyIHRvIGRvIGFsbCB0aGUgaGFyZCB3b3JrIG9mIGNhbGN1bGF0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFibGUgd2lkdGhzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcFRhYmxlID0gJCh0YWJsZSkuY2xvbmUoKSAvLyBkb24ndCB1c2UgY2xvbmVOb2RlIC0gSUU4IHdpbGwgcmVtb3ZlIGV2ZW50cyBvbiB0aGUgbWFpbiB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdpZCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgdGFibGUgYm9keVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLmZpbmQoJ3Rib2R5IHRyJykucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyh0bXBUYWJsZS5maW5kKCd0Ym9keScpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBhc3NpZ25lZCB3aWR0aHMgZnJvbSB0aGUgZm9vdGVyIChmcm9tIHNjcm9sbGluZylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS5maW5kKCd0Zm9vdCB0aCwgdGZvb3QgdGQnKS5jc3MoJ3dpZHRoJywgJycpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjdXN0b20gc2l6aW5nIHRvIHRoZSBjbG9uZWQgaGVhZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyQ2VsbHMgPSBfZm5HZXRVbmlxdWVUaHMob1NldHRpbmdzLCB0bXBUYWJsZS5maW5kKCd0aGVhZCcpWzBdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCA7IGkgPCB2aXNpYmxlQ29sdW1ucy5sZW5ndGggOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1t2aXNpYmxlQ29sdW1uc1tpXV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDZWxsc1tpXS5zdHlsZS53aWR0aCA9IGNvbHVtbi5zV2lkdGhPcmlnICE9PSBudWxsICYmIGNvbHVtbi5zV2lkdGhPcmlnICE9PSAnJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5TdHJpbmdUb0Nzcyhjb2x1bW4uc1dpZHRoT3JpZykgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB3aWRlc3QgY2VsbCBmb3IgZWFjaCBjb2x1bW4gYW5kIHB1dCBpdCBpbnRvIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uSWR4ID0gdmlzaWJsZUNvbHVtbnNbaV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2NvbHVtbklkeF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChfZm5HZXRXaWRlc3ROb2RlKG9TZXR0aW5ncywgY29sdW1uSWR4KSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xvbmUoZmFsc2UpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChjb2x1bW4uc0NvbnRlbnRQYWRkaW5nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0cik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRhYmxlIGhhcyBiZWVuIGJ1aWx0LCBhdHRhY2ggdG8gdGhlIGRvY3VtZW50IHNvIHdlIGNhbiB3b3JrIHdpdGggaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS5hcHBlbmRUbyh0YWJsZUNvbnRhaW5lcik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIChYIG9yIFkpIHdlIHdhbnQgdG8gc2V0IHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgYXMgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXBwcm9wcmlhdGUuIEhvd2V2ZXIsIHdoZW4gbm90IHNjcm9sbGluZyBsZWF2ZSB0aGUgdGFibGUgd2lkdGggYXMgaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcy4gVGhpcyByZXN1bHRzIGluIHNsaWdodGx5IGRpZmZlcmVudCwgYnV0IEkgdGhpbmsgY29ycmVjdCBiZWhhdmlvdXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWCAmJiBzY3JvbGxYSW5uZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUud2lkdGgoc2Nyb2xsWElubmVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsWCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS5jc3MoJ3dpZHRoJywgJ2F1dG8nKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBUYWJsZS53aWR0aCgpIDwgdGFibGVDb250YWluZXIub2Zmc2V0V2lkdGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLndpZHRoKHRhYmxlQ29udGFpbmVyLm9mZnNldFdpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxZKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLndpZHRoKHRhYmxlQ29udGFpbmVyLm9mZnNldFdpZHRoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGFibGVXaWR0aEF0dHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUud2lkdGgodGFibGVXaWR0aEF0dHIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFrZSBpbnRvIGFjY291bnQgdGhlIHkgc2Nyb2xsYmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU2Nyb2xsaW5nV2lkdGhBZGp1c3Qob1NldHRpbmdzLCB0bXBUYWJsZVswXSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJyb3dzZXJzIG5lZWQgYSBiaXQgb2YgYSBoYW5kIHdoZW4gYSB3aWR0aCBpcyBhc3NpZ25lZCB0byBhbnkgY29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4geC1zY3JvbGxpbmcgYXMgdGhleSB0ZW5kIHRvIGNvbGxhcHNlIHRoZSB0YWJsZSB0byB0aGUgbWluLXdpZHRoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgd2Ugc2VudCB0aGUgY29sdW1uIHdpZHRocy4gU28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdGFibGUgd2lkdGggc2hvdWxkIGJlIGJ5IHN1bW1pbmcgdGhlIHVzZXIgZ2l2ZW4gdmFsdWVzLCBhbmQgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljIHZhbHVlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxYKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1t2aXNpYmxlQ29sdW1uc1tpXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlcldpZHRoID0gJChoZWFkZXJDZWxsc1tpXSkub3V0ZXJXaWR0aCgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGNvbHVtbi5zV2lkdGhPcmlnID09PSBudWxsID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlcldpZHRoIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChjb2x1bW4uc1dpZHRoLCAxMCkgKyBvdXRlcldpZHRoIC0gJChoZWFkZXJDZWxsc1tpXSkud2lkdGgoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUud2lkdGgoX2ZuU3RyaW5nVG9Dc3ModG90YWwpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyh0b3RhbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHdpZHRoIG9mIGVhY2ggY29sdW1uIGluIHRoZSBjb25zdHJ1Y3RlZCB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgdmlzaWJsZUNvbHVtbnMubGVuZ3RoIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbdmlzaWJsZUNvbHVtbnNbaV1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9ICQoaGVhZGVyQ2VsbHNbaV0pLndpZHRoKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zV2lkdGggPSBfZm5TdHJpbmdUb0Nzcyh3aWR0aCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3ModG1wVGFibGUuY3NzKCd3aWR0aCcpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluaXNoZWQgd2l0aCB0aGUgdGFibGUgLSBkaXRjaCBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLnJlbW92ZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgd2lkdGggYXR0ciwgd2Ugd2FudCB0byBhdHRhY2ggYW4gZXZlbnQgbGlzdGVuZXIgd2hpY2hcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93cyB0aGUgdGFibGUgc2l6aW5nIHRvIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHdoZW4gdGhlIHdpbmRvdyBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gcmVzaXplZC4gVXNlIHRoZSB3aWR0aCBhdHRyIHJhdGhlciB0aGFuIENTUywgc2luY2Ugd2UgY2FuJ3Qga25vdyBpZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENTUyBpcyBhIHJlbGF0aXZlIHZhbHVlIG9yIGFic29sdXRlIC0gRE9NIHJlYWQgaXMgYWx3YXlzIHB4LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlV2lkdGhBdHRyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUuc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyh0YWJsZVdpZHRoQXR0cik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWJsZVdpZHRoQXR0ciB8fCBzY3JvbGxYKSAmJiAhb1NldHRpbmdzLl9yZXN6RXZ0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQod2luZG93KS5iaW5kKCdyZXNpemUuRFQtJyArIG9TZXR0aW5ncy5zSW5zdGFuY2UsIF9mblRocm90dGxlKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZyhvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU2Lzcgd2lsbCBjcmFzaCBpZiB3ZSBiaW5kIGEgcmVzaXplIGV2ZW50IGhhbmRsZXIgb24gcGFnZSBsb2FkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvIGJlIHJlbW92ZWQgaW4gMS4xMSB3aGljaCBkcm9wcyBJRTYvNyBzdXBwb3J0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5vQnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChiaW5kUmVzaXplLCAxMDAwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRSZXNpemUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5fcmVzekV2dCA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogVGhyb3R0bGUgdGhlIGNhbGxzIHRvIGEgZnVuY3Rpb24uIEFyZ3VtZW50cyBhbmQgY29udGV4dCBhcmUgbWFpbnRhaW5lZCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICogdGhlIHRocm90dGxlZCBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gW2ZyZXE9MjAwXSBjYWxsIGZyZXF1ZW5jeSBpbiBtU1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2Z1bmN0aW9ufSB3cmFwcGVkIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblRocm90dGxlKGZuLCBmcmVxKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3kgPSBmcmVxICE9PSB1bmRlZmluZWQgPyBmcmVxIDogMjAwLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGltZXI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IHRoaXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyA9ICtuZXcgRGF0ZSgpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBub3cgPCBsYXN0ICsgZnJlcXVlbmN5KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmcmVxdWVuY3kpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IG5vdztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb252ZXJ0IGEgQ1NTIHVuaXQgd2lkdGggdG8gcGl4ZWxzIChlLmcuIDJlbSlcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCB3aWR0aCB0byBiZSBjb252ZXJ0ZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gcGFyZW50IHBhcmVudCB0byBnZXQgdGhlIHdpdGggZm9yIChyZXF1aXJlZCBmb3IgcmVsYXRpdmUgd2lkdGhzKSAtIG9wdGlvbmFsXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSB3aWR0aCBpbiBwaXhlbHNcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQ29udmVydFRvV2lkdGgod2lkdGgsIHBhcmVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF3aWR0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuID0gJCgnPGRpdi8+JylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKHdpZHRoKSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8ocGFyZW50IHx8IGRvY3VtZW50LmJvZHkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBuWzBdLm9mZnNldFdpZHRoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbi5yZW1vdmUoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFkanVzdCBhIHRhYmxlJ3Mgd2lkdGggdG8gdGFrZSBhY2NvdW50IG9mIHZlcnRpY2FsIHNjcm9sbCBiYXJcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbiB0YWJsZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5TY3JvbGxpbmdXaWR0aEFkanVzdChzZXR0aW5ncywgbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbC5zWCB8fCBzY3JvbGwuc1kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHktc2Nyb2xsaW5nIG9ubHksIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsIGJhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoZSB0YWJsZSArIHNjcm9sbCBiYXIgd2lsbCBmaXQgaW50byB0aGUgYXJlYSBhdmFpbGFibGUsIG90aGVyd2lzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZpeCB0aGUgdGFibGUgYXQgaXRzIGN1cnJlbnQgc2l6ZSB3aXRoIG5vIGFkanVzdG1lbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29ycmVjdGlvbiA9ICFzY3JvbGwuc1ggPyBzY3JvbGwuaUJhcldpZHRoIDogMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoJChuKS5vdXRlcldpZHRoKCkgLSBjb3JyZWN0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIHdpZGVzdCBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gd2lkZXN0IHRhYmxlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuR2V0V2lkZXN0Tm9kZShzZXR0aW5ncywgY29sSWR4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKHNldHRpbmdzLCBjb2xJZHgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVtpZHhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkYXRhLm5UciA/IC8vIE1pZ2h0IG5vdCBoYXZlIGJlZW4gY3JlYXRlZCB3aGVuIGRlZmVycmVkIHJlbmRlcmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQoJzx0ZC8+JykuaHRtbChfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgaWR4LCBjb2xJZHgsICdkaXNwbGF5JykpWzBdIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmFuQ2VsbHNbY29sSWR4XTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIG1heGltdW0gc3RybGVuIGZvciBlYWNoIGRhdGEgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSBtYXggc3RyaW5nIGxlbmd0aCBmb3IgZWFjaCBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuR2V0TWF4TGVuU3RyaW5nKHNldHRpbmdzLCBjb2xJZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzLCBtYXggPSAtMSwgbWF4SWR4ID0gLTE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcyA9IF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JykgKyAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKF9fcmVfaHRtbF9yZW1vdmUsICcnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMubGVuZ3RoID4gbWF4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IHMubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhJZHggPSBpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF4SWR4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFwcGVuZCBhIENTUyB1bml0IChvbmx5IGlmIHJlcXVpcmVkKSB0byBhIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRvIGNzcy1pZnlcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IHZhbHVlIHdpdGggY3NzIHVuaXRcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU3RyaW5nVG9Dc3Mocykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzBweCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMgPCAwID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzBweCcgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICsgJ3B4JztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpdCBoYXMgYSB1bml0IGNoYXJhY3RlciBhbHJlYWR5XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5tYXRjaCgvXFxkJC8pID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzICsgJ3B4JyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIHdpZHRoIG9mIGEgc2Nyb2xsIGJhciBpbiB0aGlzIGJyb3dzZXIgYmVpbmcgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2ludH0gd2lkdGggaW4gcGl4ZWxzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNjcm9sbEJhcldpZHRoKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gT24gZmlyc3QgcnVuIGEgc3RhdGljIHZhcmlhYmxlIGlzIHNldCwgc2luY2UgdGhpcyBpcyBvbmx5IG5lZWRlZCBvbmNlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2VxdWVudCBydW5zIHdpbGwganVzdCB1c2UgdGhlIHByZXZpb3VzbHkgY2FsY3VsYXRlZCB2YWx1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gRGF0YVRhYmxlLl9fc2Nyb2xsYmFyV2lkdGg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZXIgPSAkKCc8cC8+JykuY3NzKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxNTAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbidcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oJ2JvZHknKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzaXplclswXS5vZmZzZXRXaWR0aCAtIHNpemVyWzBdLmNsaWVudFdpZHRoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIERhdGFUYWJsZS5fX3Njcm9sbGJhcldpZHRoID0gd2lkdGg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNpemVyLnJlbW92ZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0RmxhdHRlbihzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSwgaUxlbiwgaywga0xlbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhU29ydCA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFpT3JpZyA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFvQ29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZml4ZWQgPSBzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXhlZE9iaiA9ICQuaXNQbGFpbk9iamVjdChmaXhlZCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkU29ydCA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZCA9IGZ1bmN0aW9uIChhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCAmJiAhJC5pc0FycmF5KGFbMF0pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxRCBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkU29ydC5wdXNoKGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMkQgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZFNvcnQucHVzaC5hcHBseShuZXN0ZWRTb3J0LCBhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHNvcnQgYXJyYXksIHdpdGggcHJlLWZpeCBhbmQgcG9zdC1maXggb3B0aW9ucyBpZiB0aGV5IGhhdmUgYmVlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGZpeGVkKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZChmaXhlZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZpeGVkT2JqICYmIGZpeGVkLnByZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZChmaXhlZC5wcmUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGFkZChzZXR0aW5ncy5hYVNvcnRpbmcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmaXhlZE9iaiAmJiBmaXhlZC5wb3N0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkKGZpeGVkLnBvc3QpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAgOyBpIDwgbmVzdGVkU29ydC5sZW5ndGggOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzcmNDb2wgPSBuZXN0ZWRTb3J0W2ldWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFEYXRhU29ydCA9IGFvQ29sdW1uc1tzcmNDb2xdLmFEYXRhU29ydDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCwga0xlbiA9IGFEYXRhU29ydC5sZW5ndGggOyBrIDwga0xlbiA7IGsrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpQ29sID0gYURhdGFTb3J0W2tdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzVHlwZSA9IGFvQ29sdW1uc1tpQ29sXS5zVHlwZSB8fCAnc3RyaW5nJztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRTb3J0W2ldLl9pZHggPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkU29ydFtpXS5faWR4ID0gJC5pbkFycmF5KG5lc3RlZFNvcnRbaV1bMV0sIGFvQ29sdW1uc1tpQ29sXS5hc1NvcnRpbmcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhU29ydC5wdXNoKHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYzogc3JjQ29sLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBpQ29sLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyOiBuZXN0ZWRTb3J0W2ldWzFdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG5lc3RlZFNvcnRbaV0uX2lkeCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHNUeXBlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbc1R5cGUgKyBcIi1wcmVcIl1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhU29ydDtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICogIEB0b2RvIFRoaXMgcmVhbGx5IG5lZWRzIHNwbGl0IHVwIVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU29ydChvU2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGksIGllbiwgaUxlbiwgaiwgakxlbiwgaywga0xlbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzRGF0YVR5cGUsIG5UaCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhaU9yaWcgPSBbXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvRXh0U29ydCA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhb0RhdGEgPSBvU2V0dGluZ3MuYW9EYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFvQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYURhdGFTb3J0LCBkYXRhLCBpQ29sLCBzVHlwZSwgb1NvcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVycyA9IDAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydENvbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TWFzdGVyID0gb1NldHRpbmdzLmFpRGlzcGxheU1hc3RlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhU29ydDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIGFueSBjb2x1bW4gdHlwZXMgdGhhdCBhcmUgdW5rbm93biBkdWUgdG8gYWRkaXRpb24gb3IgaW52YWxpZGF0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbyBDYW4gdGhpcyBiZSBtb3ZlZCBpbnRvIGEgJ2RhdGEtcmVhZHknIGhhbmRsZXIgd2hpY2ggaXMgY2FsbGVkIHdoZW5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vICAgZGF0YSBpcyBnb2luZyB0byBiZSB1c2VkIGluIHRoZSB0YWJsZT9cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtblR5cGVzKG9TZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYVNvcnQgPSBfZm5Tb3J0RmxhdHRlbihvU2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGFTb3J0Lmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzb3J0Q29sID0gYVNvcnRbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIGlmIHdlIGNhbiB1c2UgdGhlIGZhc3Qgc29ydCBhbGdvcml0aG1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydENvbC5mb3JtYXR0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVycysrO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgZGF0YSBuZWVkZWQgZm9yIHRoZSBzb3J0LCBmb3IgZWFjaCBjZWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydERhdGEob1NldHRpbmdzLCBzb3J0Q29sLmNvbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogTm8gc29ydGluZyByZXF1aXJlZCBpZiBzZXJ2ZXItc2lkZSBvciBubyBzb3J0aW5nIGFycmF5ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX2ZuRGF0YVNvdXJjZShvU2V0dGluZ3MpICE9ICdzc3AnICYmIGFTb3J0Lmxlbmd0aCAhPT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHZhbHVlIC0ga2V5IGFycmF5IG9mIHRoZSBjdXJyZW50IHJvdyBwb3NpdGlvbnMgc3VjaCB0aGF0IHdlIGNhbiB1c2UgdGhlaXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHBvc2l0aW9uIGR1cmluZyB0aGUgc29ydCwgaWYgdmFsdWVzIG1hdGNoLCBpbiBvcmRlciB0byBwZXJmb3JtIHN0YWJsZSBzb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGRpc3BsYXlNYXN0ZXIubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWlPcmlnW2Rpc3BsYXlNYXN0ZXJbaV1dID0gaTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIERvIHRoZSBzb3J0IC0gaGVyZSB3ZSB3YW50IG11bHRpLWNvbHVtbiBzb3J0aW5nIGJhc2VkIG9uIGEgZ2l2ZW4gZGF0YSBzb3VyY2UgKGNvbHVtbilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBhbmQgc29ydGluZyBmdW5jdGlvbiAoZnJvbSBvU29ydCkgaW4gYSBjZXJ0YWluIGRpcmVjdGlvbi4gSXQncyByZWFzb25hYmx5IGNvbXBsZXggdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBmb2xsb3cgb24gaXQncyBvd24sIGJ1dCB0aGlzIGlzIHdoYXQgd2Ugd2FudCAoZXhhbXBsZSB0d28gY29sdW1uIHNvcnRpbmcpOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBmbkxvY2FsU29ydGluZyA9IGZ1bmN0aW9uKGEsYil7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgdmFyIGlUZXN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIGlUZXN0ID0gb1NvcnRbJ3N0cmluZy1hc2MnXSgnZGF0YTExJywgJ2RhdGExMicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgaWYgKGlUZXN0ICE9PSAwKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gaVRlc3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgaVRlc3QgPSBvU29ydFsnbnVtZXJpYy1kZXNjJ10oJ2RhdGEyMScsICdkYXRhMjInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICBpZiAoaVRlc3QgIT09IDApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICByZXR1cm4gaVRlc3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgcmV0dXJuIG9Tb3J0WydudW1lcmljLWFzYyddKCBhaU9yaWdbYV0sIGFpT3JpZ1tiXSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQmFzaWNhbGx5IHdlIGhhdmUgYSB0ZXN0IGZvciBlYWNoIHNvcnRpbmcgY29sdW1uLCBpZiB0aGUgZGF0YSBpbiB0aGF0IGNvbHVtbiBpcyBlcXVhbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0ZXN0IHRoZSBuZXh0IGNvbHVtbi4gSWYgYWxsIGNvbHVtbnMgbWF0Y2gsIHRoZW4gd2UgdXNlIGEgbnVtZXJpYyBzb3J0IG9uIHRoZSByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBwb3NpdGlvbnMgaW4gdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkgdG8gcHJvdmlkZSBhIHN0YWJsZSBzb3J0LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSAtIEkga25vdyBpdCBzZWVtcyBleGNlc3NpdmUgdG8gaGF2ZSB0d28gc29ydGluZyBtZXRob2RzLCBidXQgdGhlIGZpcnN0IGlzIGFyb3VuZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIDE1JSBmYXN0ZXIsIHNvIHRoZSBzZWNvbmQgaXMgb25seSBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBtZXRob2RzIHdoaWNoIGRvIG5vdCBoYXZlIGEgcHJlLXNvcnQgZm9ybWF0dGluZyBmdW5jdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVycyA9PT0gYVNvcnQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBzb3J0IHR5cGVzIGhhdmUgZm9ybWF0dGluZyBmdW5jdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hc3Rlci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCBrLCB0ZXN0LCBzb3J0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGFTb3J0Lmxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQSA9IGFvRGF0YVthXS5fYVNvcnREYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCA7IGsgPCBsZW4gOyBrKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ID0gYVNvcnRba107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkYXRhQVtzb3J0LmNvbF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRhdGFCW3NvcnQuY29sXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVzdCA9IHggPCB5ID8gLTEgOiB4ID4geSA/IDEgOiAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0ICE9PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3J0LmRpciA9PT0gJ2FzYycgPyB0ZXN0IDogLXRlc3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBhaU9yaWdbYV07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYWlPcmlnW2JdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPCB5ID8gLTEgOiB4ID4geSA/IDEgOiAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcHJlY2lhdGVkIC0gcmVtb3ZlIGluIDEuMTEgKHByb3ZpZGluZyBhIHBsdWctaW4gb3B0aW9uKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWxsIHNvcnQgdHlwZXMgaGF2ZSBmb3JtYXR0aW5nIG1ldGhvZHMsIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGVpciBzb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYXN0ZXIuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgaywgbCwgdGVzdCwgc29ydCwgZm4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gYVNvcnQubGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFBID0gYW9EYXRhW2FdLl9hU29ydERhdGEsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUIgPSBhb0RhdGFbYl0uX2FTb3J0RGF0YTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwIDsgayA8IGxlbiA7IGsrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQgPSBhU29ydFtrXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGRhdGFBW3NvcnQuY29sXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gZGF0YUJbc29ydC5jb2xdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA9IG9FeHRTb3J0W3NvcnQudHlwZSArIFwiLVwiICsgc29ydC5kaXJdIHx8IG9FeHRTb3J0W1wic3RyaW5nLVwiICsgc29ydC5kaXJdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSBmbih4LCB5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVzdCAhPT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVzdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGFpT3JpZ1thXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBhaU9yaWdbYl07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHRoYXQgd2UgaGF2ZSBzb3J0ZWQgdGhlIGRhdGEgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5iU29ydGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNvcnRBcmlhKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFNvcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvQXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBUklBIGF0dHJpYnV0ZXMgLSBuZWVkIHRvIGxvb3AgYWxsIGNvbHVtbnMsIHRvIHVwZGF0ZSBhbGwgKHJlbW92aW5nIG9sZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlcyBhcyBuZWVkZWQpXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGNvbHVtbnMubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gY29sdW1uc1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc1RpdGxlID0gY29sLnNUaXRsZS5yZXBsYWNlKC88Lio/Pi9nLCBcIlwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGggPSBjb2wublRoO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTcgaXMgdGhyb3dpbmcgYW4gZXJyb3Igd2hlbiBzZXR0aW5nIHRoZXNlIHByb3BlcnRpZXMgd2l0aCBqUXVlcnknc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dHIoKSBhbmQgcmVtb3ZlQXR0cigpIG1ldGhvZHMuLi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtc29ydCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBJbiBBUklBIG9ubHkgdGhlIGZpcnN0IHNvcnRpbmcgY29sdW1uIGNhbiBiZSBtYXJrZWQgYXMgc29ydGluZyAtIG5vIG11bHRpLXNvcnQgb3B0aW9uICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5iU29ydGFibGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFTb3J0Lmxlbmd0aCA+IDAgJiYgYVNvcnRbMF0uY29sID09IGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoLnNldEF0dHJpYnV0ZSgnYXJpYS1zb3J0JywgYVNvcnRbMF0uZGlyID09IFwiYXNjXCIgPyBcImFzY2VuZGluZ1wiIDogXCJkZXNjZW5kaW5nXCIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNvcnQgPSBhc1NvcnRpbmdbYVNvcnRbMF0uaW5kZXggKyAxXSB8fCBhc1NvcnRpbmdbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U29ydCA9IGFzU29ydGluZ1swXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBzVGl0bGUgKyAobmV4dFNvcnQgPT09IFwiYXNjXCIgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0FyaWEuc1NvcnRBc2NlbmRpbmcgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0FyaWEuc1NvcnREZXNjZW5kaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHNUaXRsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbiB0byBydW4gb24gdXNlciBzb3J0IHJlcXVlc3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbYXBwZW5kPWZhbHNlXSBBcHBlbmQgdGhlIHJlcXVlc3RlZCBzb3J0IHRvIHRoZSBleGlzdGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBzb3J0IGlmIHRydWUgKGkuZS4gbXVsdGktY29sdW1uIHNvcnQpXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNvcnRMaXN0ZW5lcihzZXR0aW5ncywgY29sSWR4LCBhcHBlbmQsIGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTb3J0SWR4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoYSwgb3ZlcmZsb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYS5faWR4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSAkLmluQXJyYXkoYVsxXSwgYXNTb3J0aW5nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHggKyAxIDwgYXNTb3J0aW5nLmxlbmd0aCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCArIDEgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gMkQgYXJyYXkgaWYgbmVlZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvcnRpbmdbMF0gPT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZyA9IFtzb3J0aW5nXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiBhcHBlbmRpbmcgdGhlIHNvcnQgdGhlbiB3ZSBhcmUgbXVsdGktY29sdW1uIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhcHBlbmQgJiYgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0TXVsdGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcmUgd2UgYWxyZWFkeSBkb2luZyBzb21lIGtpbmQgb2Ygc29ydCBvbiB0aGlzIGNvbHVtbj9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29ydElkeCA9ICQuaW5BcnJheShjb2xJZHgsIF9wbHVjayhzb3J0aW5nLCAnMCcpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRJZHggIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFllcywgbW9kaWZ5IHRoZSBzb3J0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTb3J0SWR4ID0gbmV4dChzb3J0aW5nW3NvcnRJZHhdLCB0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U29ydElkeCA9PT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCA9PT0gMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNvcnRJZHggPSAwOyAvLyBjYW4ndCByZW1vdmUgc29ydGluZyBjb21wbGV0ZWx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U29ydElkeCA9PT0gbnVsbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZy5zcGxpY2Uoc29ydElkeCwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nW3NvcnRJZHhdWzFdID0gYXNTb3J0aW5nW25leHRTb3J0SWR4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbc29ydElkeF0uX2lkeCA9IG5leHRTb3J0SWR4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBzb3J0IG9uIHRoaXMgY29sdW1uIHlldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nLnB1c2goW2NvbElkeCwgYXNTb3J0aW5nWzBdLCAwXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbc29ydGluZy5sZW5ndGggLSAxXS5faWR4ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3J0aW5nLmxlbmd0aCAmJiBzb3J0aW5nWzBdWzBdID09IGNvbElkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBjb2x1bW4gLSBhbHJlYWR5IHNvcnRpbmcgb24gdGhpcyBjb2x1bW4sIG1vZGlmeSB0aGUgc29ydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTb3J0SWR4ID0gbmV4dChzb3J0aW5nWzBdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZy5sZW5ndGggPSAxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbMF1bMV0gPSBhc1NvcnRpbmdbbmV4dFNvcnRJZHhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbMF0uX2lkeCA9IG5leHRTb3J0SWR4O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luZ2xlIGNvbHVtbiAtIHNvcnQgb25seSBvbiB0aGlzIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmcubGVuZ3RoID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nLnB1c2goW2NvbElkeCwgYXNTb3J0aW5nWzBdXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZ1swXS5faWR4ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdGhlIHNvcnQgYnkgY2FsbGluZyBhIGZ1bGwgcmVkcmF3XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5SZURyYXcoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrIHVzZWQgZm9yIGFzeW5jIHVzZXIgaW50ZXJhY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBdHRhY2ggYSBzb3J0IGhhbmRsZXIgKGNsaWNrKSB0byBhIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIoc2V0dGluZ3MsIGF0dGFjaFRvLCBjb2xJZHgsIGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQmluZEFjdGlvbihhdHRhY2hUbywge30sIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhlIGNvbHVtbiBpcyBub3Qgc29ydGFibGUgLSBkb24ndCB0byBhbnl0aGluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wuYlNvcnRhYmxlID09PSBmYWxzZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcm9jZXNzaW5nIGlzIGVuYWJsZWQgdXNlIGEgdGltZW91dCB0byBhbGxvdyB0aGUgcHJvY2Vzc2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpc3BsYXkgdG8gYmUgc2hvd24gLSBvdGhlcndpc2UgdG8gaXQgc3luY2hyb25vdXNseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5vRmVhdHVyZXMuYlByb2Nlc3NpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0TGlzdGVuZXIoc2V0dGluZ3MsIGNvbElkeCwgZS5zaGlmdEtleSwgY2FsbGJhY2spO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIHRoZSBkcmF3IGNhbGxiYWNrIHdpbGwgcmVtb3ZlIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2Vzc2luZyBkaXNwbGF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykgIT09ICdzc3AnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0TGlzdGVuZXIoc2V0dGluZ3MsIGNvbElkeCwgZS5zaGlmdEtleSwgY2FsbGJhY2spO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFNldCB0aGUgc29ydGluZyBjbGFzc2VzIG9uIHRhYmxlJ3MgYm9keSwgTm90ZTogaXQgaXMgc2FmZSB0byBjYWxsIHRoaXMgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogd2hlbiBiU29ydCBhbmQgYlNvcnRDbGFzc2VzIGFyZSBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0aW5nQ2xhc3NlcyhzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFNvcnQgPSBzZXR0aW5ncy5hTGFzdFNvcnQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc29ydENsYXNzID0gc2V0dGluZ3Mub0NsYXNzZXMuc1NvcnRDb2x1bW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc29ydCA9IF9mblNvcnRGbGF0dGVuKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpZW4sIGNvbElkeDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMuYlNvcnQgJiYgZmVhdHVyZXMuYlNvcnRDbGFzc2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBzb3J0aW5nIGNsYXNzZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBvbGRTb3J0Lmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sSWR4ID0gb2xkU29ydFtpXS5zcmM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY29sdW1uIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChfcGx1Y2soc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCkpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc29ydENsYXNzICsgKGkgPCAyID8gaSArIDEgOiAzKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IGNvbHVtbiBzb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gc29ydC5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbElkeCA9IHNvcnRbaV0uc3JjO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChfcGx1Y2soc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCkpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3Moc29ydENsYXNzICsgKGkgPCAyID8gaSArIDEgOiAzKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFMYXN0U29ydCA9IHNvcnQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGRhdGEgdG8gc29ydCBhIGNvbHVtbiwgYmUgaXQgZnJvbSBjYWNoZSwgZnJlc2ggKHBvcHVsYXRpbmcgdGhlXHJcblx0ICAgICAgICAgICAgICAgIC8vIGNhY2hlKSwgb3IgZnJvbSBhIHNvcnQgZm9ybWF0dGVyXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mblNvcnREYXRhKHNldHRpbmdzLCBpZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uIC0gcHJvdmlkZWQgYnkgdGhlIHNvcnQgZGF0YSB0eXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uID0gc2V0dGluZ3MuYW9Db2x1bW5zW2lkeF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3VzdG9tU29ydCA9IERhdGFUYWJsZS5leHQub3JkZXJbY29sdW1uLnNTb3J0RGF0YVR5cGVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbURhdGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbVNvcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gY3VzdG9tU29ydC5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIGlkeCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoc2V0dGluZ3MsIGlkeClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFVzZSAvIHBvcHVsYXRlIGNhY2hlXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm93LCBjZWxsRGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZXIgPSBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbY29sdW1uLnNUeXBlICsgXCItcHJlXCJdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBzZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3cuX2FTb3J0RGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuX2FTb3J0RGF0YSA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3cuX2FTb3J0RGF0YVtpZHhdIHx8IGN1c3RvbVNvcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBjdXN0b21Tb3J0ID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbURhdGFbaV0gOiAvLyBJZiB0aGVyZSB3YXMgYSBjdXN0b20gc29ydCBmdW5jdGlvbiwgdXNlIGRhdGEgZnJvbSB0aGVyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIGksIGlkeCwgJ3NvcnQnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fYVNvcnREYXRhW2lkeF0gPSBmb3JtYXR0ZXIgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyKGNlbGxEYXRhKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFNhdmUgdGhlIHN0YXRlIG9mIGEgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuU2F2ZVN0YXRlKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlIHx8IHNldHRpbmdzLmJEZXN0cm95aW5nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFN0b3JlIHRoZSBpbnRlcmVzdGluZyB2YXJpYWJsZXMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiArbmV3IERhdGUoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXI6ICQuZXh0ZW5kKHRydWUsIFtdLCBzZXR0aW5ncy5hYVNvcnRpbmcpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaDogX2ZuU2VhcmNoVG9DYW1lbChzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6ICQubWFwKHNldHRpbmdzLmFvQ29sdW1ucywgZnVuY3Rpb24gKGNvbCwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZTogY29sLmJWaXNpYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoOiBfZm5TZWFyY2hUb0NhbWVsKHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIFwiYW9TdGF0ZVNhdmVQYXJhbXNcIiwgJ3N0YXRlU2F2ZVBhcmFtcycsIFtzZXR0aW5ncywgc3RhdGVdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vU2F2ZWRTdGF0ZSA9IHN0YXRlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHN0YXRlKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBdHRlbXB0IHRvIGxvYWQgYSBzYXZlZCB0YWJsZSBzdGF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9Jbml0IERhdGFUYWJsZXMgaW5pdCBvYmplY3Qgc28gd2UgY2FuIG92ZXJyaWRlIHNldHRpbmdzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkxvYWRTdGF0ZShzZXR0aW5ncywgb0luaXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpZW47XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHNldHRpbmdzLmZuU3RhdGVMb2FkQ2FsbGJhY2suY2FsbChzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLnRpbWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogQWxsb3cgY3VzdG9tIGFuZCBwbHVnLWluIG1hbmlwdWxhdGlvbiBmdW5jdGlvbnMgdG8gYWx0ZXIgdGhlIHNhdmVkIGRhdGEgc2V0IGFuZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2FuY2VsbGluZyBvZiBsb2FkaW5nIGJ5IHJldHVybmluZyBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYWJTdGF0ZUxvYWQgPSBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICdzdGF0ZUxvYWRQYXJhbXMnLCBbc2V0dGluZ3MsIHN0YXRlXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KGZhbHNlLCBhYlN0YXRlTG9hZCkgIT09IC0xKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFJlamVjdCBvbGQgZGF0YSAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gc2V0dGluZ3MuaVN0YXRlRHVyYXRpb247XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPiAwICYmIHN0YXRlLnRpbWUgPCArbmV3IERhdGUoKSAtIChkdXJhdGlvbiAqIDEwMDApKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE51bWJlciBvZiBjb2x1bW5zIGhhdmUgY2hhbmdlZCAtIGFsbCBiZXRzIGFyZSBvZmYsIG5vIHJlc3RvcmUgb2Ygc2V0dGluZ3NcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zLmxlbmd0aCAhPT0gc3RhdGUuY29sdW1ucy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIHNhdmVkIHN0YXRlIHNvIGl0IG1pZ2h0IGJlIGFjY2Vzc2VkIGF0IGFueSB0aW1lXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vTG9hZGVkU3RhdGUgPSAkLmV4dGVuZCh0cnVlLCB7fSwgc3RhdGUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUga2V5IGZlYXR1cmVzIC0gdG9kbyAtIGZvciAxLjExIHRoaXMgbmVlZHMgdG8gYmUgZG9uZSBieVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc3Vic2NyaWJlZCBldmVudHNcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBzdGF0ZS5zdGFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IHN0YXRlLnN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoID0gc3RhdGUubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE9yZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUub3JkZXIgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChzdGF0ZS5vcmRlciwgZnVuY3Rpb24gKGksIGNvbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hYVNvcnRpbmcucHVzaChjb2xbMF0gPj0gY29sdW1ucy5sZW5ndGggP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWzAsIGNvbFsxXV0gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIF9mblNlYXJjaFRvSHVuZyhzdGF0ZS5zZWFyY2gpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBzdGF0ZS5jb2x1bW5zLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sID0gc3RhdGUuY29sdW1uc1tpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmlzaWJpbGl0eVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wudmlzaWJsZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnNbaV0uYlZpc2libGUgPSBjb2wudmlzaWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzW2ldLCBfZm5TZWFyY2hUb0h1bmcoY29sLnNlYXJjaCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgJ3N0YXRlTG9hZGVkJywgW3NldHRpbmdzLCBzdGF0ZV0pO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFJldHVybiB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZvciBhIHBhcnRpY3VsYXIgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gdGFibGUgdGFibGUgd2UgYXJlIHVzaW5nIGFzIGEgZGF0YVRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7b2JqZWN0fSBTZXR0aW5ncyBvYmplY3QgLSBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5TZXR0aW5nc0Zyb21Ob2RlKHRhYmxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gJC5pbkFycmF5KHRhYmxlLCBfcGx1Y2soc2V0dGluZ3MsICduVGFibGUnKSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW2lkeF0gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogTG9nIGFuIGVycm9yIG1lc3NhZ2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGxldmVsIGxvZyBlcnJvciBtZXNzYWdlcywgb3IgZGlzcGxheSB0aGVtIHRvIHRoZSB1c2VyXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gbXNnIGVycm9yIG1lc3NhZ2VcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSB0biBUZWNobmljYWwgbm90ZSBpZCB0byBnZXQgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXJyb3IuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkxvZyhzZXR0aW5ncywgbGV2ZWwsIG1zZywgdG4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIG1zZyA9ICdEYXRhVGFibGVzIHdhcm5pbmc6ICcgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncyAhPT0gbnVsbCA/ICd0YWJsZSBpZD0nICsgc2V0dGluZ3Muc1RhYmxlSWQgKyAnIC0gJyA6ICcnKSArIG1zZztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodG4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBtc2cgKz0gJy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBlcnJvciwgcGxlYXNlIHNlZSAnICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cDovL2RhdGF0YWJsZXMubmV0L3RuLycgKyB0bjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWxldmVsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHJlIDEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ID0gRGF0YVRhYmxlLmV4dDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGV4dC5zRXJyTW9kZSB8fCBleHQuZXJyTW9kZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAnZXJyb3InLCBbc2V0dGluZ3MsIHRuLCBtc2ddKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gJ2FsZXJ0Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChtc2cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09ICd0aHJvdycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZShzZXR0aW5ncywgdG4sIG1zZyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtc2cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFNlZSBpZiBhIHByb3BlcnR5IGlzIGRlZmluZWQgb24gb25lIG9iamVjdCwgaWYgc28gYXNzaWduIGl0IHRvIHRoZSBvdGhlciBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSByZXQgdGFyZ2V0IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBzb3VyY2Ugb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gbmFtZSBwcm9wZXJ0eVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFttYXBwZWROYW1lXSBuYW1lIHRvIG1hcCB0b28gLSBvcHRpb25hbCwgbmFtZSB1c2VkIGlmIG5vdCBnaXZlblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5NYXAocmV0LCBzcmMsIG5hbWUsIG1hcHBlZE5hbWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkobmFtZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2gobmFtZSwgZnVuY3Rpb24gKGksIHZhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KHZhbCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbk1hcChyZXQsIHNyYywgdmFsWzBdLCB2YWxbMV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKHJldCwgc3JjLCB2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGVkTmFtZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkTmFtZSA9IG5hbWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0W21hcHBlZE5hbWVdID0gc3JjW25hbWVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIEV4dGVuZCBvYmplY3RzIC0gdmVyeSBzaW1pbGFyIHRvIGpRdWVyeS5leHRlbmQsIGJ1dCBkZWVwIGNvcHkgb2JqZWN0cywgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAqIHNoYWxsb3cgY29weSBhcnJheXMuIFRoZSByZWFzb24gd2UgbmVlZCB0byBkbyB0aGlzLCBpcyB0aGF0IHdlIGRvbid0IHdhbnQgdG9cclxuXHQgICAgICAgICAgICAgICAgICogZGVlcCBjb3B5IGFycmF5IGluaXQgdmFsdWVzIChzdWNoIGFzIGFhU29ydGluZykgc2luY2UgdGhlIGRldiB3b3VsZG4ndCBiZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBhYmxlIHRvIG92ZXJyaWRlIHRoZW0sIGJ1dCB3ZSBkbyB3YW50IHRvIGRlZXAgY29weSBhcnJheXMuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb3V0IE9iamVjdCB0byBleHRlbmRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBleHRlbmRlciBPYmplY3QgZnJvbSB3aGljaCB0aGUgcHJvcGVydGllcyB3aWxsIGJlIGFwcGxpZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICogICAgICBvdXRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gYnJlYWtSZWZzIElmIHRydWUsIHRoZW4gYXJyYXlzIHdpbGwgYmUgc2xpY2VkIHRvIHRha2UgYW5cclxuXHQgICAgICAgICAgICAgICAgICogICAgICBpbmRlcGVuZGVudCBjb3B5IHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgYGRhdGFgIG9yIGBhYURhdGFgIHBhcmFtZXRlcnNcclxuXHQgICAgICAgICAgICAgICAgICogICAgICBpZiB0aGV5IGFyZSBwcmVzZW50LiBUaGlzIGlzIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNvbGxlY3Rpb24gdG9cclxuXHQgICAgICAgICAgICAgICAgICogICAgICBEYXRhVGFibGVzIGFuZCBoYXZlIHRoYXQgdXNlZCBhcyB5b3VyIGRhdGEgc291cmNlIHdpdGhvdXQgYnJlYWtpbmcgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgcmVmZXJlbmNlc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge29iamVjdH0gb3V0IFJlZmVyZW5jZSwganVzdCBmb3IgY29udmVuaWVuY2UgLSBvdXQgPT09IHRoZSByZXR1cm4uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICogIEB0b2RvIFRoaXMgZG9lc24ndCB0YWtlIGFjY291bnQgb2YgYXJyYXlzIGluc2lkZSB0aGUgZGVlcCBjb3BpZWQgb2JqZWN0cy5cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkV4dGVuZChvdXQsIGV4dGVuZGVyLCBicmVha1JlZnMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHRlbmRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRlbmRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBleHRlbmRlcltwcm9wXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodmFsKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmlzUGxhaW5PYmplY3Qob3V0W3Byb3BdKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFtwcm9wXSA9IHt9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3V0W3Byb3BdLCB2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJyZWFrUmVmcyAmJiBwcm9wICE9PSAnZGF0YScgJiYgcHJvcCAhPT0gJ2FhRGF0YScgJiYgJC5pc0FycmF5KHZhbCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFtwcm9wXSA9IHZhbC5zbGljZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0W3Byb3BdID0gdmFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQmluZCBhbiBldmVudCBoYW5kZXJzIHRvIGFsbG93IGEgY2xpY2sgb3IgcmV0dXJuIGtleSB0byBhY3RpdmF0ZSB0aGUgY2FsbGJhY2suXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgZ29vZCBmb3IgYWNjZXNzaWJpbGl0eSBzaW5jZSBhIHJldHVybiBvbiB0aGUga2V5Ym9hcmQgd2lsbCBoYXZlIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBzYW1lIGVmZmVjdCBhcyBhIGNsaWNrLCBpZiB0aGUgZWxlbWVudCBoYXMgZm9jdXMuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2VsZW1lbnR9IG4gRWxlbWVudCB0byBiaW5kIHRoZSBhY3Rpb24gdG9cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvRGF0YSBEYXRhIG9iamVjdCB0byBwYXNzIHRvIHRoZSB0cmlnZ2VyZWQgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcclxuXHQgICAgICAgICAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuQmluZEFjdGlvbihuLCBvRGF0YSwgZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICQobilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYmluZCgnY2xpY2suRFQnLCBvRGF0YSwgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5ibHVyKCk7IC8vIFJlbW92ZSBmb2N1cyBvdXRsaW5lIGZvciBtb3VzZSB1c2Vyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbihlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5iaW5kKCdrZXlwcmVzcy5EVCcsIG9EYXRhLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMTMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuYmluZCgnc2VsZWN0c3RhcnQuRFQnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRha2UgdGhlIGJydXRhbCBhcHByb2FjaCB0byBjYW5jZWxsaW5nIHRleHQgc2VsZWN0aW9uICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZ1bmN0aW9uLiBFYXNpbHkgYWxsb3dzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgYWRkZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICogYW4gYXJyYXkgc3RvcmUgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIHRoYXQgY2FuIHRoZW4gYWxsIGJlIGNhbGxlZCB0b2dldGhlci5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzU3RvcmUgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpbiBvU2V0dGluZ3NcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc05hbWUgSWRlbnRpZnlpbmcgbmFtZSBmb3IgdGhlIGNhbGxiYWNrIChpLmUuIGEgbGFiZWwpXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgc1N0b3JlLCBmbiwgc05hbWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5nc1tzU3RvcmVdLnB1c2goe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZuXCI6IGZuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNOYW1lXCI6IHNOYW1lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRmlyZSBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHRyaWdnZXIgZXZlbnRzLiBOb3RlIHRoYXQgdGhlIGxvb3Agb3ZlciB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogY2FsbGJhY2sgYXJyYXkgc3RvcmUgaXMgZG9uZSBiYWNrd2FyZHMhIEZ1cnRoZXIgbm90ZSB0aGF0IHlvdSBkbyBub3Qgd2FudCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgKiBmaXJlIG9mZiB0cmlnZ2VycyBpbiB0aW1lIHNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgKGZvciBleGFtcGxlIGNlbGwgY3JlYXRpb24pXHJcblx0ICAgICAgICAgICAgICAgICAqIGFzIGl0cyBzbG93LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gY2FsbGJhY2tBcnIgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgIG9TZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBqUXVlcnkgY3VzdG9tIGV2ZW50IHRvIHRyaWdnZXIuIElmXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgbnVsbCBubyB0cmlnZ2VyIGlzIGZpcmVkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAvXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgdHJpZ2dlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIGNhbGxiYWNrQXJyLCBldmVudE5hbWUsIGFyZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tBcnIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSAkLm1hcChzZXR0aW5nc1tjYWxsYmFja0Fycl0uc2xpY2UoKS5yZXZlcnNlKCksIGZ1bmN0aW9uICh2YWwsIGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5mbi5hcHBseShzZXR0aW5ncy5vSW5zdGFuY2UsIGFyZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9ICQuRXZlbnQoZXZlbnROYW1lICsgJy5kdCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkudHJpZ2dlcihlLCBhcmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2goZS5yZXN1bHQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5MZW5ndGhPdmVyZmxvdyhzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogSWYgd2UgaGF2ZSBzcGFjZSB0byBzaG93IGV4dHJhIHJvd3MgKGJhY2tpbmcgdXAgZnJvbSB0aGUgZW5kIHBvaW50IC0gdGhlbiBkbyBzbyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IGVuZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kIC0gbGVuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIHN0YXJ0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICBzdGFydCAtPSAoc3RhcnQgJSBsZW4pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPT09IC0xIHx8IHN0YXJ0IDwgMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IHN0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24gX2ZuUmVuZGVyZXIoc2V0dGluZ3MsIHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJlciA9IHNldHRpbmdzLnJlbmRlcmVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3QgPSBEYXRhVGFibGUuZXh0LnJlbmRlcmVyW3R5cGVdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QocmVuZGVyZXIpICYmIHJlbmRlcmVyW3R5cGVdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lmaWMgcmVuZGVyZXIgZm9yIHRoaXMgdHlwZS4gSWYgYXZhaWxhYmxlIHVzZSBpdCwgb3RoZXJ3aXNlIHVzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBob3N0W3JlbmRlcmVyW3R5cGVdXSB8fCBob3N0Ll87XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmVuZGVyZXIgPT09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tbW9uIHJlbmRlcmVyIC0gaWYgdGhlcmUgaXMgb25lIGF2YWlsYWJsZSBmb3IgdGhpcyB0eXBlIHVzZSBpdCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBkZWZhdWx0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RbcmVuZGVyZXJdIHx8IGhvc3QuXztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHRcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBob3N0Ll87XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRGV0ZWN0IHRoZSBkYXRhIHNvdXJjZSBiZWluZyB1c2VkIGZvciB0aGUgdGFibGUuIFVzZWQgdG8gc2ltcGxpZnkgdGhlIGNvZGVcclxuXHQgICAgICAgICAgICAgICAgICogYSBsaXR0bGUgKGFqYXgpIGFuZCB0byBtYWtlIGl0IGNvbXByZXNzIGEgbGl0dGxlIHNtYWxsZXIuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IERhdGEgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIF9mbkRhdGFTb3VyY2Uoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5vRmVhdHVyZXMuYlNlcnZlclNpZGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3NzcCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5hamF4IHx8IHNldHRpbmdzLnNBamF4U291cmNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdhamF4JztcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAnZG9tJztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIERhdGFUYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3IgYWN0aW9uIG9uIHRoZSB0YWJsZSdzIFRSIGVsZW1lbnRzIChmcm9tIHRoZSB0Ym9keSkgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByZXR1cm4gdGhlIHJlc3VsdGluZyBqUXVlcnkgb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBzU2VsZWN0b3IgalF1ZXJ5IHNlbGVjdG9yIG9yIG5vZGUgY29sbGVjdGlvbiB0byBhY3Qgb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgVFIgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgY3JpdGVyaW9uIChcImFwcGxpZWRcIikgb3IgYWxsIFRSIGVsZW1lbnRzIChpLmUuIG5vIGZpbHRlcikuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgVFIgZWxlbWVudHMgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIENhbiBiZSBlaXRoZXIgJ2N1cnJlbnQnLCB3aGVyZWJ5IHRoZSBjdXJyZW50IHNvcnRpbmcgb2YgdGhlIHRhYmxlIGlzIHVzZWQsIG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAoXCJjdXJyZW50XCIpIG9yIG5vdCAoXCJhbGxcIikuIElmICdjdXJyZW50JyBpcyBnaXZlbiwgdGhlbiBvcmRlciBpcyBhc3N1bWVkIHRvIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IGpRdWVyeSBvYmplY3QsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBzZWxlY3Rvci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIEhpZ2hsaWdodCBldmVyeSBzZWNvbmQgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0cjpvZGQnKS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBGaWx0ZXIgdG8gcm93cyB3aXRoICdXZWJraXQnIGluIHRoZW0sIGFkZCBhIGJhY2tncm91bmQgY29sb3VyIGFuZCB0aGVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIHJlbW92ZSB0aGUgZmlsdGVyLCB0aHVzIGhpZ2hsaWdodGluZyB0aGUgJ1dlYmtpdCcgcm93cyBvbmx5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuJCgndHInLCB7XCJzZWFyY2hcIjogXCJhcHBsaWVkXCJ9KS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuJCA9IGZ1bmN0aW9uIChzU2VsZWN0b3IsIG9PcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpKHRydWUpLiQoc1NlbGVjdG9yLCBvT3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFsbW9zdCBpZGVudGljYWwgdG8gJCBpbiBvcGVyYXRpb24sIGJ1dCBpbiB0aGlzIGNhc2UgcmV0dXJucyB0aGUgZGF0YSBmb3IgdGhlIG1hdGNoZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJvd3MgLSBhcyBzdWNoLCB0aGUgalF1ZXJ5IHNlbGVjdG9yIHVzZWQgc2hvdWxkIG1hdGNoIFRSIHJvdyBub2RlcyBvciBURC9USCBjZWxsIG5vZGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByYXRoZXIgdGhhbiBhbnkgZGVzY2VuZGFudHMsIHNvIHRoZSBkYXRhIGNhbiBiZSBvYnRhaW5lZCBmb3IgdGhlIHJvdy9jZWxsLiBJZiBtYXRjaGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcm93cyBhcmUgZm91bmQsIHRoZSBkYXRhIHJldHVybmVkIGlzIHRoZSBvcmlnaW5hbCBkYXRhIGFycmF5L29iamVjdCB0aGF0IHdhcyB1c2VkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjcmVhdGUgdGhlIHJvdyAob3IgYSBnZW5lcmF0ZWQgYXJyYXkgaWYgZnJvbSBhIERPTSBzb3VyY2UpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIG9mdGVuIHVzZWZ1bCBpbi1jb21iaW5hdGlvbiB3aXRoICQgd2hlcmUgYm90aCBmdW5jdGlvbnMgYXJlIGdpdmVuIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2FtZSBwYXJhbWV0ZXJzIGFuZCB0aGUgYXJyYXkgaW5kZXhlcyB3aWxsIG1hdGNoIGlkZW50aWNhbGx5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBzU2VsZWN0b3IgalF1ZXJ5IHNlbGVjdG9yIG9yIG5vZGUgY29sbGVjdGlvbiB0byBhY3Qgb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgY3JpdGVyaW9uIChcImFwcGxpZWRcIikgb3IgYWxsIGVsZW1lbnRzIChpLmUuIG5vIGZpbHRlcikuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgZGF0YSBpbiB0aGUgcHJvY2Vzc2VkIGFycmF5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgQ2FuIGJlIGVpdGhlciAnY3VycmVudCcsIHdoZXJlYnkgdGhlIGN1cnJlbnQgc29ydGluZyBvZiB0aGUgdGFibGUgaXMgdXNlZCwgb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICdvcmlnaW5hbCcgd2hlcmVieSB0aGUgb3JpZ2luYWwgb3JkZXIgdGhlIGRhdGEgd2FzIHJlYWQgaW50byB0aGUgdGFibGUgaXMgdXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLnBhZ2U9YWxsXSBMaW1pdCB0aGUgc2VsZWN0aW9uIHRvIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIChcImN1cnJlbnRcIikgb3Igbm90IChcImFsbFwiKS4gSWYgJ2N1cnJlbnQnIGlzIGdpdmVuLCB0aGVuIG9yZGVyIGlzIGFzc3VtZWQgdG8gYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICdjdXJyZW50JyBhbmQgZmlsdGVyIGlzICdhcHBsaWVkJywgcmVnYXJkbGVzcyBvZiB3aGF0IHRoZXkgbWlnaHQgYmUgZ2l2ZW4gYXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBEYXRhIGZvciB0aGUgbWF0Y2hlZCBlbGVtZW50cy4gSWYgYW55IGVsZW1lbnRzLCBhcyBhIHJlc3VsdCBvZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHNlbGVjdG9yLCB3ZXJlIG5vdCBUUiwgVEQgb3IgVEggZWxlbWVudHMgaW4gdGhlIERhdGFUYWJsZSwgdGhleSB3aWxsIGhhdmUgYSBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBlbnRyeSBpbiB0aGUgYXJyYXkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBHZXQgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgcm93IGluIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgZGF0YSA9IG9UYWJsZS5fKCd0cjpmaXJzdCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gRG8gc29tZXRoaW5nIHVzZWZ1bCB3aXRoIHRoZSBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGFsZXJ0KCBcIkZpcnN0IGNlbGwgaXM6IFwiK2RhdGFbMF0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIEZpbHRlciB0byAnV2Via2l0JyBhbmQgZ2V0IGFsbCBkYXRhIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgZGF0YSA9IG9UYWJsZS5fKCd0cicsIHtcInNlYXJjaFwiOiBcImFwcGxpZWRcIn0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYWxlcnQoIGRhdGEubGVuZ3RoK1wiIHJvd3MgbWF0Y2hlZCB0aGUgc2VhcmNoXCIgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fID0gZnVuY3Rpb24gKHNTZWxlY3Rvciwgb09wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcGkodHJ1ZSkucm93cyhzU2VsZWN0b3IsIG9PcHRzKS5kYXRhKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENyZWF0ZSBhIERhdGFUYWJsZXMgQXBpIGluc3RhbmNlLCB3aXRoIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGFibGVzIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIEFwaSdzIGNvbnRleHQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFkaXRpb25hbD1mYWxzZV0gU2V0IHRoZSBBUEkgaW5zdGFuY2UncyBjb250ZXh0IHRvIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIG9ubHkgdGhlIHRhYmxlIHJlZmVycmVkIHRvIGJ5IHRoZSBgRGF0YVRhYmxlLmV4dC5pQXBpSW5kZXhgIG9wdGlvbiwgYXMgd2FzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIHVzZWQgaW4gdGhlIEFQSSBwcmVzZW50ZWQgYnkgRGF0YVRhYmxlcyAxLjktIChpLmUuIHRoZSB0cmFkaXRpb25hbCBtb2RlKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgb3IgaWYgYWxsIHRhYmxlcyBjYXB0dXJlZCBpbiB0aGUgalF1ZXJ5IG9iamVjdCBzaG91bGQgYmUgdXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0RhdGFUYWJsZXMuQXBpfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmFwaSA9IGZ1bmN0aW9uICh0cmFkaXRpb25hbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFkaXRpb25hbCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBfQXBpKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU2V0dGluZ3NGcm9tTm9kZSh0aGlzW19leHQuaUFwaUluZGV4XSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBfQXBpKHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBZGQgYSBzaW5nbGUgbmV3IHJvdyBvciBtdWx0aXBsZSByb3dzIG9mIGRhdGEgdG8gdGhlIHRhYmxlLiBQbGVhc2Ugbm90ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhhdCB0aGlzIGlzIHN1aXRhYmxlIGZvciBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIG9ubHkgLSBpZiB5b3UgYXJlIHVzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIChpLmUuIFwiYlNlcnZlclNpZGVcIjogdHJ1ZSksIHRoZW4gdG8gYWRkIGRhdGEsIHlvdVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbXVzdCBhZGQgaXQgdG8gdGhlIGRhdGEgc291cmNlLCBpLmUuIHRoZSBzZXJ2ZXItc2lkZSwgdGhyb3VnaCBhbiBBamF4IGNhbGwuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgYWRkZWQgdG8gdGhlIHRhYmxlLiBUaGlzIGNhbiBiZTpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgPGxpPjFEIGFycmF5IG9mIGRhdGEgLSBhZGQgYSBzaW5nbGUgcm93IHdpdGggdGhlIGRhdGEgcHJvdmlkZWQ8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICA8bGk+MkQgYXJyYXkgb2YgYXJyYXlzIC0gYWRkIG11bHRpcGxlIHJvd3MgaW4gYSBzaW5nbGUgY2FsbDwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxsaT5vYmplY3QgLSBkYXRhIG9iamVjdCB3aGVuIHVzaW5nIDxpPm1EYXRhPC9pPjwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxsaT5hcnJheSBvZiBvYmplY3RzIC0gbXVsdGlwbGUgZGF0YSBvYmplY3RzIHdoZW4gdXNpbmcgPGk+bURhdGE8L2k+PC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIDwvdWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIHJlZHJhdyB0aGUgdGFibGUgb3Igbm90XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBpbnRlZ2VycywgcmVwcmVzZW50aW5nIHRoZSBsaXN0IG9mIGluZGV4ZXMgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIDxpPmFvRGF0YTwvaT4gKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc30pIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB0aGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBHbG9iYWwgdmFyIGZvciBjb3VudGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB2YXIgZ2lDb3VudCA9IDI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZnVuY3Rpb24gZm5DbGlja0FkZFJvdygpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5mbkFkZERhdGEoIFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjFcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjNcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjRcIiBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBnaUNvdW50Kys7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5BZGREYXRhID0gZnVuY3Rpb24gKGRhdGEsIHJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgaWYgd2Ugd2FudCB0byBhZGQgbXVsdGlwbGUgcm93cyBvciBub3QgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9ICQuaXNBcnJheShkYXRhKSAmJiAoJC5pc0FycmF5KGRhdGFbMF0pIHx8ICQuaXNQbGFpbk9iamVjdChkYXRhWzBdKSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkucm93cy5hZGQoZGF0YSkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkucm93LmFkZChkYXRhKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IHJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvd3MuZmxhdHRlbigpLnRvQXJyYXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIG1ha2UgRGF0YVRhYmxlcyByZWNhbGN1bGF0ZSB0aGUgY29sdW1uIHNpemVzLCBiYXNlZCBvbiB0aGUgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29udGFpbmVkIGluIHRoZSB0YWJsZSBhbmQgdGhlIHNpemVzIGFwcGxpZWQgdG8gdGhlIGNvbHVtbnMgKGluIHRoZSBET00sIENTUyBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhyb3VnaCB0aGUgc1dpZHRoIHBhcmFtZXRlcikuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUnc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcGFyZW50IGVsZW1lbnQgY2hhbmdlcyAoZm9yIGV4YW1wbGUgYSB3aW5kb3cgcmVzaXplKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90LCB5b3Ugd2lsbCB0eXBpY2FsbHkgd2FudCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic1Njcm9sbFlcIjogXCIyMDBweFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiYlBhZ2luYXRlXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQod2luZG93KS5iaW5kKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgb1RhYmxlLmZuQWRqdXN0Q29sdW1uU2l6aW5nKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mbkFkanVzdENvbHVtblNpemluZyA9IGZ1bmN0aW9uIChiUmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpLmNvbHVtbnMuYWRqdXN0KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gYXBpLnNldHRpbmdzKClbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdyhmYWxzZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbC5zWCAhPT0gXCJcIiB8fCBzY3JvbGwuc1kgIT09IFwiXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgbm90IHJlZHJhd2luZywgYnV0IHNjcm9sbGluZywgd2Ugd2FudCB0byBhcHBseSB0aGUgbmV3IGNvbHVtbiBzaXplcyBhbnl3YXkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU2Nyb2xsRHJhdyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBRdWlja2x5IGFuZCBzaW1wbHkgY2xlYXIgYSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gcmVkcmF3IHRoZSB0YWJsZSBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIEltbWVkaWF0ZWx5ICdudWtlJyB0aGUgY3VycmVudCByb3dzIChwZXJoYXBzIHdhaXRpbmcgZm9yIGFuIEFqYXggY2FsbGJhY2suLi4pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkNsZWFyVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mbkNsZWFyVGFibGUgPSBmdW5jdGlvbiAoYlJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKS5jbGVhcigpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmRyYXcoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBleGFjdCBvcHBvc2l0ZSBvZiAnb3BlbmluZycgYSByb3csIHRoaXMgZnVuY3Rpb24gd2lsbCBjbG9zZSBhbnkgcm93cyB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYXJlIGN1cnJlbnRseSAnb3BlbicuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byAnY2xvc2UnXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCBvciAxIGlmIGZhaWxlZCAoY2FuJ3QgZmluZCB0aGUgcm93KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mbkNsb3NlID0gZnVuY3Rpb24gKG5Ucikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBpKHRydWUpLnJvdyhuVHIpLmNoaWxkLmhpZGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUmVtb3ZlIGEgcm93IGZvciB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge21peGVkfSB0YXJnZXQgVGhlIGluZGV4IG9mIHRoZSByb3cgZnJvbSBhb0RhdGEgdG8gYmUgZGVsZXRlZCwgb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHRoZSBUUiBlbGVtZW50IHlvdSB3YW50IHRvIGRlbGV0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gW2NhbGxCYWNrXSBDYWxsYmFjayBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW3JlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHthcnJheX0gVGhlIHJvdyB0aGF0IHdhcyBkZWxldGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBJbW1lZGlhdGVseSByZW1vdmUgdGhlIGZpcnN0IHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5EZWxldGVSb3coIDAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mbkRlbGV0ZVJvdyA9IGZ1bmN0aW9uICh0YXJnZXQsIGNhbGxiYWNrLCByZWRyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBhcGkucm93cyh0YXJnZXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHJvd3Muc2V0dGluZ3MoKVswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVtyb3dzWzBdWzBdXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5yZW1vdmUoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgc2V0dGluZ3MsIGRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IHJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFJlc3RvcmUgdGhlIHRhYmxlIHRvIGl0J3Mgb3JpZ2luYWwgc3RhdGUgaW4gdGhlIERPTSBieSByZW1vdmluZyBhbGwgb2YgRGF0YVRhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZW5oYW5jZW1lbnRzLCBhbHRlcmF0aW9ucyB0byB0aGUgRE9NIHN0cnVjdHVyZSBvZiB0aGUgdGFibGUgYW5kIGV2ZW50IGxpc3RlbmVycy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmU9ZmFsc2VdIENvbXBsZXRlbHkgcmVtb3ZlIHRoZSB0YWJsZSBmcm9tIHRoZSBET01cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyBUaGlzIGV4YW1wbGUgaXMgZmFpcmx5IHBvaW50bGVzcyBpbiByZWFsaXR5LCBidXQgc2hvd3MgaG93IGZuRGVzdHJveSBjYW4gYmUgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRGVzdHJveSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuRGVzdHJveSA9IGZ1bmN0aW9uIChyZW1vdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwaSh0cnVlKS5kZXN0cm95KHJlbW92ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFJlZHJhdyB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtjb21wbGV0ZT10cnVlXSBSZS1maWx0ZXIgYW5kIHJlc29ydCAoaWYgZW5hYmxlZCkgdGhlIHRhYmxlIGJlZm9yZSB0aGUgZHJhdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIFJlLWRyYXcgdGhlIHRhYmxlIC0geW91IHdvdWxkbid0IHdhbnQgdG8gZG8gaXQgaGVyZSwgYnV0IGl0J3MgYW4gZXhhbXBsZSA6LSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRHJhdygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuRHJhdyA9IGZ1bmN0aW9uIChjb21wbGV0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzbid0IGFuIGV4YWN0IG1hdGNoIHRvIHRoZSBvbGQgY2FsbCB0byBfZm5EcmF3IC0gaXQgdGFrZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRvIGFjY291bnQgdGhlIG5ldyBkYXRhLCBidXQgY2FuIGhvbGQgcG9zaXRpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcGkodHJ1ZSkuZHJhdyhjb21wbGV0ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZpbHRlciB0aGUgaW5wdXQgYmFzZWQgb24gZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzSW5wdXQgU3RyaW5nIHRvIGZpbHRlciB0aGUgdGFibGUgb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludHxudWxsfSBbaUNvbHVtbl0gQ29sdW1uIHRvIGxpbWl0IGZpbHRlcmluZyB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JSZWdleD1mYWxzZV0gVHJlYXQgYXMgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JTbWFydD10cnVlXSBQZXJmb3JtIHNtYXJ0IGZpbHRlcmluZyBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiU2hvd0dsb2JhbD10cnVlXSBTaG93IHRoZSBpbnB1dCBnbG9iYWwgZmlsdGVyIGluIGl0J3MgaW5wdXQgYm94KGVzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JDYXNlSW5zZW5zaXRpdmU9dHJ1ZV0gRG8gY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyAodHJ1ZSkgb3Igbm90IChmYWxzZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIFNvbWV0aW1lIGxhdGVyIC0gZmlsdGVyLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkZpbHRlciggJ3Rlc3Qgc3RyaW5nJyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuRmlsdGVyID0gZnVuY3Rpb24gKHNJbnB1dCwgaUNvbHVtbiwgYlJlZ2V4LCBiU21hcnQsIGJTaG93R2xvYmFsLCBiQ2FzZUluc2Vuc2l0aXZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaUNvbHVtbiA9PT0gbnVsbCB8fCBpQ29sdW1uID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnNlYXJjaChzSW5wdXQsIGJSZWdleCwgYlNtYXJ0LCBiQ2FzZUluc2Vuc2l0aXZlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5jb2x1bW4oaUNvbHVtbikuc2VhcmNoKHNJbnB1dCwgYlJlZ2V4LCBiU21hcnQsIGJDYXNlSW5zZW5zaXRpdmUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmRyYXcoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogR2V0IHRoZSBkYXRhIGZvciB0aGUgd2hvbGUgdGFibGUsIGFuIGluZGl2aWR1YWwgcm93IG9yIGFuIGluZGl2aWR1YWwgY2VsbCBiYXNlZCBvbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByb3ZpZGVkIHBhcmFtZXRlcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR8bm9kZX0gW3NyY10gQSBUUiByb3cgbm9kZSwgVEQvVEggY2VsbCBub2RlIG9yIGFuIGludGVnZXIuIElmIGdpdmVuIGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBhIFRSIG5vZGUgdGhlbiB0aGUgZGF0YSBzb3VyY2UgZm9yIHRoZSB3aG9sZSByb3cgd2lsbCBiZSByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgVEQvVEggY2VsbCBub2RlIHRoZW4gaUNvbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBhbmQgdGhlIGRhdGEgZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgY2VsbCByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYW4gaW50ZWdlciwgdGhlbiB0aGlzIGlzIHRyZWF0ZWQgYXMgdGhlIGFvRGF0YSBpbnRlcm5hbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZGF0YSBpbmRleCBmb3IgdGhlIHJvdyAoc2VlIGZuR2V0UG9zaXRpb24pIGFuZCB0aGUgZGF0YSBmb3IgdGhhdCByb3cgdXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gW2NvbF0gT3B0aW9uYWwgY29sdW1uIGluZGV4IHRoYXQgeW91IHdhbnQgdGhlIGRhdGEgb2YuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fG9iamVjdHxzdHJpbmd9IElmIG1Sb3cgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBkYXRhIGZvciBhbGwgcm93cyBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgcmV0dXJuZWQuIElmIG1Sb3cgaXMgZGVmaW5lZCwganVzdCBkYXRhIGZvciB0aGF0IHJvdywgYW5kIGlzIGlDb2wgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGRlZmluZWQsIG9ubHkgZGF0YSBmb3IgdGhlIGRlc2lnbmF0ZWQgY2VsbCBpcyByZXR1cm5lZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFJvdyBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgdmFyIGRhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBhcnJheSAvIG9iamVjdCBvZiBkYXRhIGZvciB0aGUgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIEluZGl2aWR1YWwgY2VsbCBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0ZCcpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgdmFyIHNEYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggdGhpcyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGFsZXJ0KCAnVGhlIGNlbGwgY2xpY2tlZCBvbiBoYWQgdGhlIHZhbHVlIG9mICcrc0RhdGEgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuR2V0RGF0YSA9IGZ1bmN0aW9uIChzcmMsIGNvbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyYyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc3JjLm5vZGVOYW1lID8gc3JjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2wgIT09IHVuZGVmaW5lZCB8fCB0eXBlID09ICd0ZCcgfHwgdHlwZSA9PSAndGgnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5jZWxsKHNyYywgY29sKS5kYXRhKCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnJvdyhzcmMpLmRhdGEoKSB8fCBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5kYXRhKCkudG9BcnJheSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBHZXQgYW4gYXJyYXkgb2YgdGhlIFRSIG5vZGVzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlJ3MgYm9keS4gTm90ZSB0aGF0IHlvdSB3aWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0eXBpY2FsbHkgd2FudCB0byB1c2UgdGhlICckJyBBUEkgbWV0aG9kIGluIHByZWZlcmVuY2UgdG8gdGhpcyBhcyBpdCBpcyBtb3JlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmbGV4aWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gW2lSb3ddIE9wdGlvbmFsIHJvdyBpbmRleCBmb3IgdGhlIFRSIGVsZW1lbnQgeW91IHdhbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl8bm9kZX0gSWYgaVJvdyBpcyB1bmRlZmluZWQsIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIFRSIGVsZW1lbnRzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBpbiB0aGUgdGFibGUncyBib2R5LCBvciBpUm93IGlzIGRlZmluZWQsIGp1c3QgdGhlIFRSIGVsZW1lbnQgcmVxdWVzdGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gR2V0IHRoZSBub2RlcyBmcm9tIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgbk5vZGVzID0gb1RhYmxlLmZuR2V0Tm9kZXMoICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5HZXROb2RlcyA9IGZ1bmN0aW9uIChpUm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVJvdyAhPT0gdW5kZWZpbmVkID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnJvdyhpUm93KS5ub2RlKCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkucm93cygpLm5vZGVzKCkuZmxhdHRlbigpLnRvQXJyYXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogR2V0IHRoZSBhcnJheSBpbmRleGVzIG9mIGEgcGFydGljdWxhciBjZWxsIGZyb20gaXQncyBET00gZWxlbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW5kIGNvbHVtbiBpbmRleCBpbmNsdWRpbmcgaGlkZGVuIGNvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5vZGUgdGhpcyBjYW4gZWl0aGVyIGJlIGEgVFIsIFREIG9yIFRIIGluIHRoZSB0YWJsZSdzIGJvZHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSBJZiBuTm9kZSBpcyBnaXZlbiBhcyBhIFRSLCB0aGVuIGEgc2luZ2xlIGluZGV4IGlzIHJldHVybmVkLCBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgaWYgZ2l2ZW4gYXMgYSBjZWxsLCBhbiBhcnJheSBvZiBbcm93IGluZGV4LCBjb2x1bW4gaW5kZXggKHZpc2libGUpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgY29sdW1uIGluZGV4IChhbGwpXSBpcyBnaXZlbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0ZCcpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgLy8gR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBkYXRhIGZyb20gdGhlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB2YXIgYVBvcyA9IG9UYWJsZS5mbkdldFBvc2l0aW9uKCB0aGlzICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIC8vIEdldCB0aGUgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB2YXIgYURhdGEgPSBvVGFibGUuZm5HZXREYXRhKCBhUG9zWzBdICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIC8vIFVwZGF0ZSB0aGUgZGF0YSBhcnJheSBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGFEYXRhWyBhUG9zWzFdIF0gPSAnY2xpY2tlZCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnY2xpY2tlZCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIEluaXQgRGF0YVRhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuR2V0UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSAnVFInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcGkucm93KG5vZGUpLmluZGV4KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09ICdURCcgfHwgbm9kZU5hbWUgPT0gJ1RIJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IGFwaS5jZWxsKG5vZGUpLmluZGV4KCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5yb3csXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbHVtblZpc2libGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2hlY2sgdG8gc2VlIGlmIGEgcm93IGlzICdvcGVuJyBvciBub3QuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byBjaGVja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSByb3cgaXMgY3VycmVudGx5IG9wZW4sIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mbklzT3BlbiA9IGZ1bmN0aW9uIChuVHIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcGkodHJ1ZSkucm93KG5UcikuY2hpbGQuaXNTaG93bigpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGxhY2UgYSBuZXcgcm93IGRpcmVjdGx5IGFmdGVyIGEgcm93IHdoaWNoIGlzIGN1cnJlbnRseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb24gZGlzcGxheSBvbiB0aGUgcGFnZSwgd2l0aCB0aGUgSFRNTCBjb250ZW50cyB0aGF0IGlzIHBhc3NlZCBpbnRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZnVuY3Rpb24uIFRoaXMgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCB0byBhc2sgZm9yIGNvbmZpcm1hdGlvbiB0aGF0IGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBhcnRpY3VsYXIgcmVjb3JkIHNob3VsZCBiZSBkZWxldGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gblRyIFRoZSB0YWJsZSByb3cgdG8gJ29wZW4nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IG1IdG1sIFRoZSBIVE1MIHRvIHB1dCBpbnRvIHRoZSByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc0NsYXNzIENsYXNzIHRvIGdpdmUgdGhlIG5ldyBURCBjZWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IFRoZSByb3cgb3BlbmVkLiBOb3RlIHRoYXQgaWYgdGhlIHRhYmxlIHJvdyBwYXNzZWQgaW4gYXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBmaXJzdCBwYXJhbWV0ZXIsIGlzIG5vdCBmb3VuZCBpbiB0aGUgdGFibGUsIHRoaXMgbWV0aG9kIHdpbGwgc2lsZW50bHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHJldHVybi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gJ29wZW4nIGFuIGluZm9ybWF0aW9uIHJvdyB3aGVuIGEgcm93IGlzIGNsaWNrZWQgb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUgdGJvZHkgdHInKS5jbGljayggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGlmICggb1RhYmxlLmZuSXNPcGVuKHRoaXMpICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgb1RhYmxlLmZuQ2xvc2UoIHRoaXMgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgb1RhYmxlLmZuT3BlbiggdGhpcywgXCJUZW1wb3Jhcnkgcm93IG9wZW5lZFwiLCBcImluZm9fcm93XCIgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5PcGVuID0gZnVuY3Rpb24gKG5UciwgbUh0bWwsIHNDbGFzcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaSh0cnVlKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAucm93KG5UcilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoaWxkKG1IdG1sLCBzQ2xhc3MpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zaG93KClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNoaWxkKClbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENoYW5nZSB0aGUgcGFnaW5hdGlvbiAtIHByb3ZpZGVzIHRoZSBpbnRlcm5hbCBsb2dpYyBmb3IgcGFnaW5hdGlvbiBpbiBhIHNpbXBsZSBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9uLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBoYXZlIGEgRGF0YVRhYmxlcyB0YWJsZSBnbyB0byB0aGUgbmV4dCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByZXZpb3VzLCBmaXJzdCBvciBsYXN0IHBhZ2VzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfGludH0gbUFjdGlvbiBQYWdpbmcgYWN0aW9uIHRvIHRha2U6IFwiZmlyc3RcIiwgXCJwcmV2aW91c1wiLCBcIm5leHRcIiBvciBcImxhc3RcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgb3IgcGFnZSBudW1iZXIgdG8ganVtcCB0byAoaW50ZWdlciksIG5vdGUgdGhhdCBwYWdlIDAgaXMgdGhlIGZpcnN0IHBhZ2UuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5QYWdlQ2hhbmdlKCAnbmV4dCcgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mblBhZ2VDaGFuZ2UgPSBmdW5jdGlvbiAobUFjdGlvbiwgYlJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKS5wYWdlKG1BY3Rpb24pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmRyYXcoZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU2hvdyBhIHBhcnRpY3VsYXIgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2wgVGhlIGNvbHVtbiB3aG9zZSBkaXNwbGF5IHNob3VsZCBiZSBjaGFuZ2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBiU2hvdyBTaG93ICh0cnVlKSBvciBoaWRlIChmYWxzZSkgdGhlIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIEhpZGUgdGhlIHNlY29uZCBjb2x1bW4gYWZ0ZXIgaW5pdGlhbGlzYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuU2V0Q29sdW1uVmlzKCAxLCBmYWxzZSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuU2V0Q29sdW1uVmlzID0gZnVuY3Rpb24gKGlDb2wsIGJTaG93LCBiUmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpLmNvbHVtbihpQ29sKS52aXNpYmxlKGJTaG93KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJSZWRyYXcgPT09IHVuZGVmaW5lZCB8fCBiUmVkcmF3KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5jb2x1bW5zLmFkanVzdCgpLmRyYXcoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEdldCB0aGUgc2V0dGluZ3MgZm9yIGEgcGFydGljdWxhciB0YWJsZSBmb3IgZXh0ZXJuYWwgbWFuaXB1bGF0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge29iamVjdH0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QuIFNlZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1NldHRpbmdzID0gb1RhYmxlLmZuU2V0dGluZ3MoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIC8vIFNob3cgYW4gZXhhbXBsZSBwYXJhbWV0ZXIgZnJvbSB0aGUgc2V0dGluZ3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYWxlcnQoIG9TZXR0aW5ncy5faURpc3BsYXlTdGFydCApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmZuU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mblNldHRpbmdzRnJvbU5vZGUodGhpc1tfZXh0LmlBcGlJbmRleF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTb3J0IHRoZSB0YWJsZSBieSBhIHBhcnRpY3VsYXIgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2wgdGhlIGRhdGEgaW5kZXggdG8gc29ydCBvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgbWF0Y2ggdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAnZGlzcGxheSBpbmRleCcgaWYgeW91IGhhdmUgaGlkZGVuIGRhdGEgZW50cmllc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gU29ydCBpbW1lZGlhdGVseSB3aXRoIGNvbHVtbnMgMCBhbmQgMVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5Tb3J0KCBbIFswLCdhc2MnXSwgWzEsJ2FzYyddIF0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mblNvcnQgPSBmdW5jdGlvbiAoYWFTb3J0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcGkodHJ1ZSkub3JkZXIoYWFTb3J0KS5kcmF3KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudCBmb3IgYSBnaXZlbiBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5Ob2RlIHRoZSBlbGVtZW50IHRvIGF0dGFjaCB0aGUgc29ydCBsaXN0ZW5lciB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBpQ29sdW1uIHRoZSBjb2x1bW4gdGhhdCBhIGNsaWNrIG9uIHRoaXMgbm9kZSB3aWxsIHNvcnQgb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5DYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBzb3J0IGlzIHJ1blxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gU29ydCBvbiBjb2x1bW4gMSwgd2hlbiAnc29ydGVyJyBpcyBjbGlja2VkIG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblNvcnRMaXN0ZW5lciggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NvcnRlcicpLCAxICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5Tb3J0TGlzdGVuZXIgPSBmdW5jdGlvbiAobk5vZGUsIGlDb2x1bW4sIGZuQ2FsbGJhY2spIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwaSh0cnVlKS5vcmRlci5saXN0ZW5lcihuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjayk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFVwZGF0ZSBhIHRhYmxlIGNlbGwgb3Igcm93IC0gdGhpcyBtZXRob2Qgd2lsbCBhY2NlcHQgZWl0aGVyIGEgc2luZ2xlIHZhbHVlIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB1cGRhdGUgdGhlIGNlbGwgd2l0aCwgYW4gYXJyYXkgb2YgdmFsdWVzIHdpdGggb25lIGVsZW1lbnQgZm9yIGVhY2ggY29sdW1uIG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbiBvYmplY3QgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZS4gVGhlIGZ1bmN0aW9uIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZWxmLXJlZmVyZW5jaW5nIGluIG9yZGVyIHRvIG1ha2UgdGhlIG11bHRpIGNvbHVtbiB1cGRhdGVzIGVhc2llci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdHxhcnJheXxzdHJpbmd9IG1EYXRhIERhdGEgdG8gdXBkYXRlIHRoZSBjZWxsL3JvdyB3aXRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfGludH0gbVJvdyBUUiBlbGVtZW50IHlvdSB3YW50IHRvIHVwZGF0ZSBvciB0aGUgYW9EYXRhIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IFtpQ29sdW1uXSBUaGUgY29sdW1uIHRvIHVwZGF0ZSwgZ2l2ZSBhcyBudWxsIG9yIHVuZGVmaW5lZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgdXBkYXRlIGEgd2hvbGUgcm93LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiQWN0aW9uPXRydWVdIFBlcmZvcm0gcHJlLWRyYXcgYWN0aW9ucyBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSAwIG9uIHN1Y2Nlc3MsIDEgb24gZXJyb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuVXBkYXRlKCAnRXhhbXBsZSB1cGRhdGUnLCAwLCAwICk7IC8vIFNpbmdsZSBjZWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSwgJCgndGJvZHkgdHInKVswXSApOyAvLyBSb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mblVwZGF0ZSA9IGZ1bmN0aW9uIChtRGF0YSwgbVJvdywgaUNvbHVtbiwgYlJlZHJhdywgYkFjdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlDb2x1bW4gPT09IHVuZGVmaW5lZCB8fCBpQ29sdW1uID09PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5yb3cobVJvdykuZGF0YShtRGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuY2VsbChtUm93LCBpQ29sdW1uKS5kYXRhKG1EYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiQWN0aW9uID09PSB1bmRlZmluZWQgfHwgYkFjdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuY29sdW1ucy5hZGp1c3QoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUHJvdmlkZSBhIGNvbW1vbiBtZXRob2QgZm9yIHBsdWctaW5zIHRvIGNoZWNrIHRoZSB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgYmVpbmcgdXNlZCwgaW4gb3JkZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzVmVyc2lvbiBWZXJzaW9uIHN0cmluZyB0byBjaGVjayBmb3IsIGluIHRoZSBmb3JtYXQgXCJYLlkuWlwiLiBOb3RlIHRoYXQgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgcmVxdWlyZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHZlcnNpb24sIG9yIGZhbHNlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFsZXMgaXMgbm90IHN1aXRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBhbGVydCggb1RhYmxlLmZuVmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5mblZlcnNpb25DaGVjayA9IF9leHQuZm5WZXJzaW9uQ2hlY2s7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfdGhhdCA9IHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW1wdHlJbml0ID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eUluaXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5vQXBpID0gdGhpcy5pbnRlcm5hbCA9IF9leHQuaW50ZXJuYWw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHdpdGggb2xkIHN0eWxlIHBsdWctaW4gQVBJIG1ldGhvZHNcclxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZuIGluIERhdGFUYWJsZS5leHQuaW50ZXJuYWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmbl0gPSBfZm5FeHRlcm5BcGlGdW5jKGZuKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBpbml0aWFsaXNhdGlvbiB3ZSB3YW50IHRvIGdpdmUgaXQgYSBjbGVhbiBpbml0aWFsaXNhdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0IGNhbiBiZSBiYXNoZWQgYXJvdW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG8gPSB7fTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb0luaXQgPSBsZW4gPiAxID8gLy8gb3B0aW1pc2F0aW9uIGZvciBzaW5nbGUgdGFibGUgY2FzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5FeHRlbmQobywgb3B0aW9ucywgdHJ1ZSkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKmdsb2JhbCBvSW5pdCxfdGhhdCxlbXB0eUluaXQqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMCwgaUxlbiwgaiwgakxlbiwgaywga0xlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc0lkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJJbml0SGFuZGVkT2ZmID0gZmFsc2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBTYW5pdHkgY2hlY2sgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICd0YWJsZScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKG51bGwsIDAsICdOb24tdGFibGUgbm9kZSBpbml0aWFsaXNhdGlvbiAoJyArIHRoaXMubm9kZU5hbWUgKyAnKScsIDIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIGRlZmF1bHRzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0T3B0cyhkZWZhdWx0cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ29tcGF0Q29scyhkZWZhdWx0cy5jb2x1bW4pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDb252ZXJ0IHRoZSBjYW1lbC1jYXNlIGRlZmF1bHRzIHRvIEh1bmdhcmlhbiAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oZGVmYXVsdHMsIGRlZmF1bHRzLCB0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuKGRlZmF1bHRzLmNvbHVtbiwgZGVmYXVsdHMuY29sdW1uLCB0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogU2V0dGluZyB1cCB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihkZWZhdWx0cywgJC5leHRlbmQob0luaXQsICR0aGlzLmRhdGEoKSkpO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgcmUtaW5pdGlhbGlzaW5nIGEgdGFibGUgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGFsbFNldHRpbmdzLmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzID0gYWxsU2V0dGluZ3NbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBCYXNlIGNoZWNrIG9uIHRhYmxlIG5vZGUgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMublRhYmxlID09IHRoaXMgfHwgcy5uVEhlYWQucGFyZW50Tm9kZSA9PSB0aGlzIHx8IChzLm5URm9vdCAmJiBzLm5URm9vdC5wYXJlbnROb2RlID09IHRoaXMpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYkRlc3Ryb3kgPSBvSW5pdC5iRGVzdHJveSAhPT0gdW5kZWZpbmVkID8gb0luaXQuYkRlc3Ryb3kgOiBkZWZhdWx0cy5iRGVzdHJveTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHlJbml0IHx8IGJSZXRyaWV2ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLm9JbnN0YW5jZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJEZXN0cm95KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5vSW5zdGFuY2UuZm5EZXN0cm95KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2cocywgMCwgJ0Nhbm5vdCByZWluaXRpYWxpc2UgRGF0YVRhYmxlJywgMyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGUgZWxlbWVudCB3ZSBhcmUgaW5pdGlhbGlzaW5nIGhhcyB0aGUgc2FtZSBJRCBhcyBhIHRhYmxlIHdoaWNoIHdhcyBwcmV2aW91c2x5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGluaXRpYWxpc2VkLCBidXQgdGhlIHRhYmxlIG5vZGVzIGRvbid0IG1hdGNoIChmcm9tIGJlZm9yZSkgdGhlbiB3ZSBkZXN0cm95IHRoZSBvbGRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5zdGFuY2UgYnkgc2ltcGx5IGRlbGV0aW5nIGl0LiBUaGlzIGlzIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhlIHRhYmxlIGhhcyBiZWVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRlc3Ryb3llZCBieSBvdGhlciBtZXRob2RzLiBBbnlvbmUgdXNpbmcgbm9uLWlkIHNlbGVjdG9ycyB3aWxsIG5lZWQgdG8gZG8gdGhpcyBtYW51YWxseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc1RhYmxlSWQgPT0gdGhpcy5pZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsU2V0dGluZ3Muc3BsaWNlKGksIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc0lkID09PSBudWxsIHx8IHNJZCA9PT0gXCJcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzSWQgPSBcIkRhdGFUYWJsZXNfVGFibGVfXCIgKyAoRGF0YVRhYmxlLmV4dC5fdW5pcXVlKyspO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gc0lkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQ3JlYXRlIHRoZSBzZXR0aW5ncyBvYmplY3QgZm9yIHRoaXMgdGFibGUgYW5kIHNldCBzb21lIG9mIHRoZSBkZWZhdWx0IHBhcmFtZXRlcnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb1NldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic0Rlc3Ryb3lXaWR0aFwiOiAkdGhpc1swXS5zdHlsZS53aWR0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzSW5zdGFuY2VcIjogc0lkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNUYWJsZUlkXCI6IHNJZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5uVGFibGUgPSB0aGlzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5vQXBpID0gX3RoYXQuaW50ZXJuYWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm9Jbml0ID0gb0luaXQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFsbFNldHRpbmdzLnB1c2gob1NldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBhZGQgdGhlIGluc3RhbmNlIGFmdGVyIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIGFkZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3Mub0luc3RhbmNlID0gKF90aGF0Lmxlbmd0aCA9PT0gMSkgPyBfdGhhdCA6ICR0aGlzLmRhdGFUYWJsZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmVmb3JlIHdlIGFwcGx5IGFsbCB0aGUgZGVmYXVsdHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5Db21wYXRPcHRzKG9Jbml0KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0Lm9MYW5ndWFnZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5MYW5ndWFnZUNvbXBhdChvSW5pdC5vTGFuZ3VhZ2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxlbmd0aCBtZW51IGlzIGdpdmVuLCBidXQgdGhlIGluaXQgZGlzcGxheSBsZW5ndGggaXMgbm90LCB1c2UgdGhlIGxlbmd0aCBtZW51XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFMZW5ndGhNZW51ICYmICFvSW5pdC5pRGlzcGxheUxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvSW5pdC5pRGlzcGxheUxlbmd0aCA9ICQuaXNBcnJheShvSW5pdC5hTGVuZ3RoTWVudVswXSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb0luaXQuYUxlbmd0aE1lbnVbMF1bMF0gOiBvSW5pdC5hTGVuZ3RoTWVudVswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBkZWZhdWx0cyBhbmQgaW5pdCBvcHRpb25zIHRvIG1ha2UgYSBzaW5nbGUgaW5pdCBvYmplY3Qgd2lsbCBhbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvSW5pdCA9IF9mbkV4dGVuZCgkLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMpLCBvSW5pdCk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXAgdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMgb250byB0aGUgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKG9TZXR0aW5ncy5vRmVhdHVyZXMsIG9Jbml0LCBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlBhZ2luYXRlXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYkxlbmd0aENoYW5nZVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJGaWx0ZXJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiU29ydFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJTb3J0TXVsdGlcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiSW5mb1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJQcm9jZXNzaW5nXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYkF1dG9XaWR0aFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJTb3J0Q2xhc3Nlc1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJTZXJ2ZXJTaWRlXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYkRlZmVyUmVuZGVyXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5NYXAob1NldHRpbmdzLCBvSW5pdCwgW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFzU3RyaXBlQ2xhc3Nlc1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFqYXhcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmblNlcnZlckRhdGFcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbkZvcm1hdE51bWJlclwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNTZXJ2ZXJNZXRob2RcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhYVNvcnRpbmdcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhYVNvcnRpbmdGaXhlZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFMZW5ndGhNZW51XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic1BhZ2luYXRpb25UeXBlXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic0FqYXhTb3VyY2VcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzQWpheERhdGFQcm9wXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaVN0YXRlRHVyYXRpb25cIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzRG9tXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRDZWxsc1RvcFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlUYWJJbmRleFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZuU3RhdGVMb2FkQ2FsbGJhY2tcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmblN0YXRlU2F2ZUNhbGxiYWNrXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVuZGVyZXJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzZWFyY2hEZWxheVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJpQ29va2llRHVyYXRpb25cIiwgXCJpU3RhdGVEdXJhdGlvblwiXSwgLy8gYmFja3dhcmRzIGNvbXBhdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJvU2VhcmNoXCIsIFwib1ByZXZpb3VzU2VhcmNoXCJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJhb1NlYXJjaENvbHNcIiwgXCJhb1ByZVNlYXJjaENvbHNcIl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImlEaXNwbGF5TGVuZ3RoXCIsIFwiX2lEaXNwbGF5TGVuZ3RoXCJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJiSlF1ZXJ5VUlcIiwgXCJiSlVJXCJdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKG9TZXR0aW5ncy5vU2Nyb2xsLCBvSW5pdCwgW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzU2Nyb2xsWFwiLCBcInNYXCJdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzU2Nyb2xsWElubmVyXCIsIFwic1hJbm5lclwiXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic1Njcm9sbFlcIiwgXCJzWVwiXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYlNjcm9sbENvbGxhcHNlXCIsIFwiYkNvbGxhcHNlXCJdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKG9TZXR0aW5ncy5vTGFuZ3VhZ2UsIG9Jbml0LCBcImZuSW5mb0NhbGxiYWNrXCIpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDYWxsYmFjayBmdW5jdGlvbnMgd2hpY2ggYXJlIGFycmF5IGRyaXZlbiAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgb0luaXQuZm5EcmF3Q2FsbGJhY2ssICd1c2VyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9TZXJ2ZXJQYXJhbXMnLCBvSW5pdC5mblNlcnZlclBhcmFtcywgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1N0YXRlU2F2ZVBhcmFtcycsIG9Jbml0LmZuU3RhdGVTYXZlUGFyYW1zLCAndXNlcicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvU3RhdGVMb2FkUGFyYW1zJywgb0luaXQuZm5TdGF0ZUxvYWRQYXJhbXMsICd1c2VyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRlZCcsIG9Jbml0LmZuU3RhdGVMb2FkZWQsICd1c2VyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9Sb3dDYWxsYmFjaycsIG9Jbml0LmZuUm93Q2FsbGJhY2ssICd1c2VyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9Sb3dDcmVhdGVkQ2FsbGJhY2snLCBvSW5pdC5mbkNyZWF0ZWRSb3csICd1c2VyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9IZWFkZXJDYWxsYmFjaycsIG9Jbml0LmZuSGVhZGVyQ2FsbGJhY2ssICd1c2VyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9Gb290ZXJDYWxsYmFjaycsIG9Jbml0LmZuRm9vdGVyQ2FsbGJhY2ssICd1c2VyJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCBvSW5pdC5mbkluaXRDb21wbGV0ZSwgJ3VzZXInKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrLCAndXNlcicpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb0NsYXNzZXMgPSBvU2V0dGluZ3Mub0NsYXNzZXM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIFJlbW92ZSBpbiAxLjExXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmJKUXVlcnlVSSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBVc2UgdGhlIEpVSSBjbGFzc2VzIG9iamVjdCBmb3IgZGlzcGxheS4gWW91IGNvdWxkIGNsb25lIHRoZSBvU3RkQ2xhc3NlcyBvYmplY3QgaWZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogeW91IHdhbnQgdG8gaGF2ZSBtdWx0aXBsZSB0YWJsZXMgd2l0aCBtdWx0aXBsZSBpbmRlcGVuZGVudCBjbGFzc2VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChvQ2xhc3NlcywgRGF0YVRhYmxlLmV4dC5vSlVJQ2xhc3Nlcywgb0luaXQub0NsYXNzZXMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LnNEb20gPT09IGRlZmF1bHRzLnNEb20gJiYgZGVmYXVsdHMuc0RvbSA9PT0gXCJsZnJ0aXBcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogU2V0IHRoZSBET00gdG8gdXNlIGEgbGF5b3V0IHN1aXRhYmxlIGZvciBqUXVlcnkgVUkncyB0aGVtaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3Muc0RvbSA9ICc8XCJIXCJsZnI+dDxcIkZcImlwPic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb1NldHRpbmdzLnJlbmRlcmVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MucmVuZGVyZXIgPSAnanF1ZXJ5dWknO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChvU2V0dGluZ3MucmVuZGVyZXIpICYmICFvU2V0dGluZ3MucmVuZGVyZXIuaGVhZGVyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MucmVuZGVyZXIuaGVhZGVyID0gJ2pxdWVyeXVpJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQob0NsYXNzZXMsIERhdGFUYWJsZS5leHQuY2xhc3Nlcywgb0luaXQub0NsYXNzZXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyhvQ2xhc3Nlcy5zVGFibGUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDYWxjdWxhdGUgdGhlIHNjcm9sbCBiYXIgd2lkdGggYW5kIGNhY2hlIGl0IGZvciB1c2UgbGF0ZXIgb24gKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLm9TY3JvbGwuc1ggIT09IFwiXCIgfHwgb1NldHRpbmdzLm9TY3JvbGwuc1kgIT09IFwiXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm9TY3JvbGwuaUJhcldpZHRoID0gX2ZuU2Nyb2xsQmFyV2lkdGgoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5vU2Nyb2xsLnNYID09PSB0cnVlKSB7IC8vIEVhc3kgaW5pdGlhbGlzYXRpb24gb2YgeC1zY3JvbGxpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm9TY3JvbGwuc1ggPSAnMTAwJSc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogRGlzcGxheSBzdGFydCBwb2ludCwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgc2F2ZSBzYXZpbmcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gb0luaXQuaURpc3BsYXlTdGFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gb0luaXQuaURpc3BsYXlTdGFydDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvSW5pdC5pRGVmZXJMb2FkaW5nICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9ICQuaXNBcnJheShvSW5pdC5pRGVmZXJMb2FkaW5nKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSB0bXAgPyBvSW5pdC5pRGVmZXJMb2FkaW5nWzBdIDogb0luaXQuaURlZmVyTG9hZGluZztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLl9pUmVjb3Jkc1RvdGFsID0gdG1wID8gb0luaXQuaURlZmVyTG9hZGluZ1sxXSA6IG9Jbml0LmlEZWZlckxvYWRpbmc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBMYW5ndWFnZSBkZWZpbml0aW9ucyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvTGFuZ3VhZ2UgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9MYW5ndWFnZSwgb0luaXQub0xhbmd1YWdlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9MYW5ndWFnZS5zVXJsICE9PSBcIlwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEdldCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgZnJvbSBhIGZpbGUgLSBiZWNhdXNlIHRoaXMgQWpheCBjYWxsIG1ha2VzIHRoZSBsYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXQgYXN5bmMgdG8gdGhlIHJlbWFpbmRlciBvZiB0aGlzIGZ1bmN0aW9uIHdlIHVzZSBiSW5pdEhhbmRlZE9mZiB0byBpbmRpY2F0ZSB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIF9mbkluaXRpYWxpc2Ugd2lsbCBiZSBmaXJlZCBieSB0aGUgcmV0dXJuZWQgQWpheCBoYW5kbGVyLCByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuYWpheCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBvTGFuZ3VhZ2Uuc1VybCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChqc29uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTGFuZ3VhZ2VDb21wYXQoanNvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihkZWZhdWx0cy5vTGFuZ3VhZ2UsIGpzb24pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9MYW5ndWFnZSwganNvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdGlhbGlzZShvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3Igb2NjdXJyZWQgbG9hZGluZyBsYW5ndWFnZSBmaWxlLCBjb250aW51ZSBvbiBhcyBiZXN0IHdlIGNhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkluaXRpYWxpc2Uob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJJbml0SGFuZGVkT2ZmID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogU3RyaXBlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvSW5pdC5hc1N0cmlwZUNsYXNzZXMgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcyA9IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9DbGFzc2VzLnNTdHJpcGVPZGQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvQ2xhc3Nlcy5zU3RyaXBlRXZlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVtb3ZlIHJvdyBzdHJpcGUgY2xhc3NlcyBpZiB0aGV5IGFyZSBhbHJlYWR5IG9uIHRoZSB0YWJsZSByb3cgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyaXBlQ2xhc3NlcyA9IG9TZXR0aW5ncy5hc1N0cmlwZUNsYXNzZXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd09uZSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpLmZpbmQoJ3RyJykuZXEoMCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheSh0cnVlLCAkLm1hcChzdHJpcGVDbGFzc2VzLCBmdW5jdGlvbiAoZWwsIGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvd09uZS5oYXNDbGFzcyhlbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCd0Ym9keSB0cicsIHRoaXMpLnJlbW92ZUNsYXNzKHN0cmlwZUNsYXNzZXMuam9pbignICcpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMgPSBzdHJpcGVDbGFzc2VzLnNsaWNlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZWUgaWYgd2Ugc2hvdWxkIGxvYWQgY29sdW1ucyBhdXRvbWF0aWNhbGx5IG9yIHVzZSBkZWZpbmVkIG9uZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5UaHMgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW9Db2x1bW5zSW5pdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgblRoZWFkID0gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGhlYWQnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoblRoZWFkLmxlbmd0aCAhPT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5EZXRlY3RIZWFkZXIob1NldHRpbmdzLmFvSGVhZGVyLCBuVGhlYWRbMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhblRocyA9IF9mbkdldFVuaXF1ZVRocyhvU2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgbm90IGdpdmVuIGEgY29sdW1uIGFycmF5LCBnZW5lcmF0ZSBvbmUgd2l0aCBudWxscyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvSW5pdC5hb0NvbHVtbnMgPT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW9Db2x1bW5zSW5pdCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gYW5UaHMubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFvQ29sdW1uc0luaXQucHVzaChudWxsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW9Db2x1bW5zSW5pdCA9IG9Jbml0LmFvQ29sdW1ucztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFkZCB0aGUgY29sdW1ucyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb0NvbHVtbnNJbml0Lmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkZENvbHVtbihvU2V0dGluZ3MsIGFuVGhzID8gYW5UaHNbaV0gOiBudWxsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIEFwcGx5IHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BcHBseUNvbHVtbkRlZnMob1NldHRpbmdzLCBvSW5pdC5hb0NvbHVtbkRlZnMsIGFvQ29sdW1uc0luaXQsIGZ1bmN0aW9uIChpQ29sLCBvRGVmKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtbk9wdGlvbnMob1NldHRpbmdzLCBpQ29sLCBvRGVmKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogSFRNTDUgYXR0cmlidXRlIGRldGVjdGlvbiAtIGJ1aWxkIGFuIG1EYXRhIG9iamVjdCBhdXRvbWF0aWNhbGx5IGlmIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd09uZS5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBmdW5jdGlvbiAoY2VsbCwgbmFtZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBuYW1lKSAhPT0gbnVsbCA/IG5hbWUgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKF9mbkdldFJvd0VsZW1lbnRzKG9TZXR0aW5ncywgcm93T25lWzBdKS5jZWxscywgZnVuY3Rpb24gKGksIGNlbGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wubURhdGEgPT09IGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29ydCA9IGEoY2VsbCwgJ3NvcnQnKSB8fCBhKGNlbGwsICdvcmRlcicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBhKGNlbGwsICdmaWx0ZXInKSB8fCBhKGNlbGwsICdzZWFyY2gnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnQgIT09IG51bGwgfHwgZmlsdGVyICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5tRGF0YSA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF86IGkgKyAnLmRpc3BsYXknLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydDogc29ydCAhPT0gbnVsbCA/IGkgKyAnLkBkYXRhLScgKyBzb3J0IDogdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogc29ydCAhPT0gbnVsbCA/IGkgKyAnLkBkYXRhLScgKyBzb3J0IDogdW5kZWZpbmVkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIgIT09IG51bGwgPyBpICsgJy5AZGF0YS0nICsgZmlsdGVyIDogdW5kZWZpbmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5PcHRpb25zKG9TZXR0aW5ncywgaSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG9TZXR0aW5ncy5vRmVhdHVyZXM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIE11c3QgYmUgZG9uZSBhZnRlciBldmVyeXRoaW5nIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdGF0ZSBzYXZpbmchICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmJTdGF0ZVNhdmUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMuYlN0YXRlU2F2ZSA9IHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkxvYWRTdGF0ZShvU2V0dGluZ3MsIG9Jbml0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBfZm5TYXZlU3RhdGUsICdzdGF0ZV9zYXZlJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBTb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQHRvZG8gRm9yIG1vZHVsYXJpc2F0aW9uICgxLjExKSB0aGlzIG5lZWRzIHRvIGRvIGludG8gYSBzb3J0IHN0YXJ0IHVwIGhhbmRsZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYWFTb3J0aW5nIGlzIG5vdCBkZWZpbmVkLCB0aGVuIHdlIHVzZSB0aGUgZmlyc3QgaW5kaWNhdG9yIGluIGFzU29ydGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhhdCBoYXMgYmVlbiBhbHRlcmVkLCBzbyB0aGUgZGVmYXVsdCBzb3J0IHJlZmxlY3RzIHRoYXQgb3B0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFhU29ydGluZyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0aW5nID0gb1NldHRpbmdzLmFhU29ydGluZztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IHNvcnRpbmcubGVuZ3RoIDsgaSA8IGlMZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbaV1bMV0gPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldLmFzU29ydGluZ1swXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogRG8gYSBmaXJzdCBwYXNzIG9uIHRoZSBzb3J0aW5nIGNsYXNzZXMgKGFsbG93cyBhbnkgc2l6ZSBjaGFuZ2VzIHRvIGJlIHRha2VuIGludG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBhY2NvdW50LCBhbmQgYWxzbyB3aWxsIGFwcGx5IHNvcnRpbmcgZGlzYWJsZWQgY2xhc3NlcyBpZiBkaXNhYmxlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mblNvcnRpbmdDbGFzc2VzKG9TZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iU29ydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuYlNvcnRlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnRlZENvbHVtbnMgPSB7fTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGFTb3J0LCBmdW5jdGlvbiAoaSwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZENvbHVtbnNbdmFsLnNyY10gPSB2YWwuZGlyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCBudWxsLCAnb3JkZXInLCBbb1NldHRpbmdzLCBhU29ydCwgc29ydGVkQ29sdW1uc10pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblNvcnRBcmlhKG9TZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuYlNvcnRlZCB8fCBfZm5EYXRhU291cmNlKG9TZXR0aW5ncykgPT09ICdzc3AnIHx8IGZlYXR1cmVzLmJEZWZlclJlbmRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydGluZ0NsYXNzZXMob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sICdzYycpO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBGaW5hbCBpbml0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQ2FjaGUgdGhlIGhlYWRlciwgYm9keSBhbmQgZm9vdGVyIGFzIHJlcXVpcmVkLCBjcmVhdGluZyB0aGVtIGlmIG5lZWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBCcm93c2VyIHN1cHBvcnQgZGV0ZWN0aW9uICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQnJvd3NlckRldGVjdChvU2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmb3IgV2Via2l0IGJ1ZyA4Mzg2NyAtIHN0b3JlIHRoZSBjYXB0aW9uLXNpZGUgYmVmb3JlIHJlbW92aW5nIGZyb20gZG9jXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcHRpb25zID0gJHRoaXMuY2hpbGRyZW4oJ2NhcHRpb24nKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FwdGlvblNpZGUgPSAkdGhpcy5jc3MoJ2NhcHRpb24tc2lkZScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlYWQgPSAkdGhpcy5jaGlsZHJlbigndGhlYWQnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhlYWQubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZWFkID0gJCgnPHRoZWFkLz4nKS5hcHBlbmRUbyh0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm5USGVhZCA9IHRoZWFkWzBdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGJvZHkgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGJvZHkubGVuZ3RoID09PSAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRib2R5ID0gJCgnPHRib2R5Lz4nKS5hcHBlbmRUbyh0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm5UQm9keSA9IHRib2R5WzBdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGZvb3QgPSAkdGhpcy5jaGlsZHJlbigndGZvb3QnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGZvb3QubGVuZ3RoID09PSAwICYmIGNhcHRpb25zLmxlbmd0aCA+IDAgJiYgKG9TZXR0aW5ncy5vU2Nyb2xsLnNYICE9PSBcIlwiIHx8IG9TZXR0aW5ncy5vU2Nyb2xsLnNZICE9PSBcIlwiKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYSBzY3JvbGxpbmcgdGFibGUsIGFuZCBubyBmb290ZXIgaGFzIGJlZW4gZ2l2ZW4sIHRoZW4gd2UgbmVlZCB0byBjcmVhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSB0Zm9vdCBlbGVtZW50IGZvciB0aGUgY2FwdGlvbiBlbGVtZW50IHRvIGJlIGFwcGVuZGVkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmb290ID0gJCgnPHRmb290Lz4nKS5hcHBlbmRUbyh0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Zm9vdC5sZW5ndGggPT09IDAgfHwgdGZvb3QuY2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3Mob0NsYXNzZXMuc05vRm9vdGVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGZvb3QubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRGb290ID0gdGZvb3RbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRldGVjdEhlYWRlcihvU2V0dGluZ3MuYW9Gb290ZXIsIG9TZXR0aW5ncy5uVEZvb3QpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgaWYgdGhlcmUgaXMgZGF0YSBwYXNzaW5nIGludG8gdGhlIGNvbnN0cnVjdG9yICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFhRGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwIDsgaSA8IG9Jbml0LmFhRGF0YS5sZW5ndGggOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkZERhdGEob1NldHRpbmdzLCBvSW5pdC5hYURhdGFbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nIHx8IF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PSAnZG9tJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBHcmFiIHRoZSBkYXRhIGZyb20gdGhlIHBhZ2UgLSBvbmx5IGRvIHRoaXMgd2hlbiBkZWZlcnJlZCBsb2FkaW5nIG9yIG5vIEFqYXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc291cmNlIHNpbmNlIHRoZXJlIGlzIG5vIHBvaW50IGluIHJlYWRpbmcgdGhlIERPTSBkYXRhIGlmIHdlIGFyZSB0aGVuIGdvaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRvIHJlcGxhY2UgaXQgd2l0aCBBamF4IGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkZFRyKG9TZXR0aW5ncywgJChvU2V0dGluZ3MublRCb2R5KS5jaGlsZHJlbigndHInKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBDb3B5IHRoZSBkYXRhIGluZGV4IGFycmF5ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogSW5pdGlhbGlzYXRpb24gY29tcGxldGUgLSB0YWJsZSBjYW4gYmUgZHJhd24gKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYkluaXRpYWxpc2VkID0gdHJ1ZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgaWYgd2UgbmVlZCB0byBpbml0aWFsaXNlIHRoZSB0YWJsZSAoaXQgbWlnaHQgbm90IGhhdmUgYmVlbiBoYW5kZWQgb2ZmIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGxhbmd1YWdlIHByb2Nlc3NvcilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYkluaXRIYW5kZWRPZmYgPT09IGZhbHNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkluaXRpYWxpc2Uob1NldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF90aGF0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ29tcHV0ZWQgc3RydWN0dXJlIG9mIHRoZSBEYXRhVGFibGVzIEFQSSwgZGVmaW5lZCBieSB0aGUgb3B0aW9ucyBwYXNzZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICogYERhdGFUYWJsZS5BcGkucmVnaXN0ZXIoKWAgd2hlbiBidWlsZGluZyB0aGUgQVBJLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUaGUgc3RydWN0dXJlIGlzIGJ1aWx0IGluIG9yZGVyIHRvIHNwZWVkIGNyZWF0aW9uIGFuZCBleHRlbnNpb24gb2YgdGhlIEFwaVxyXG5cdCAgICAgICAgICAgICAgICAgKiBvYmplY3RzIHNpbmNlIHRoZSBleHRlbnNpb25zIGFyZSBlZmZlY3RpdmVseSBwcmUtcGFyc2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUaGUgYXJyYXkgaXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlLCB3aGVyZSB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAqIGJhc2UgYXJyYXkgcmVwcmVzZW50cyB0aGUgQXBpIHByb3RvdHlwZSBiYXNlOlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgW1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgIG5hbWU6ICAgICAncm93J1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgIHZhbDogICAgICAge30sXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgIHByb3BFeHQ6ICAgW1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgICAgIC4uLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICAgICAgICAgICAgICAgICAqIEBpZ25vcmVcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX2FwaVN0cnVjdCA9IFtdO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBgQXJyYXkucHJvdG90eXBlYCByZWZlcmVuY2UuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiBAaWdub3JlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19hcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBBYnN0cmFjdGlvbiBmb3IgYGNvbnRleHRgIHBhcmFtZXRlciBvZiB0aGUgYEFwaWAgY29uc3RydWN0b3IgdG8gYWxsb3cgaXQgdG9cclxuXHQgICAgICAgICAgICAgICAgICogdGFrZSBzZXZlcmFsIGRpZmZlcmVudCBmb3JtcyBmb3IgZWFzZSBvZiB1c2UuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEVhY2ggb2YgdGhlIGlucHV0IHBhcmFtZXRlciB0eXBlcyB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIERhdGFUYWJsZXMgc2V0dGluZ3NcclxuXHQgICAgICAgICAgICAgICAgICogb2JqZWN0IHdoZXJlIHBvc3NpYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd8bm9kZXxqUXVlcnl8b2JqZWN0fSBtaXhlZCBEYXRhVGFibGUgaWRlbnRpZmllci4gQ2FuIGJlIG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIG9mOlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICogYHN0cmluZ2AgLSBqUXVlcnkgc2VsZWN0b3IuIEFueSBEYXRhVGFibGVzJyBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgbm9kZWAgLSBgVEFCTEVgIG5vZGUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBmb3JtZWQgaW50byBhIERhdGFUYWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBqUXVlcnlgIC0gQSBqUXVlcnkgb2JqZWN0IG9mIGBUQUJMRWAgbm9kZXMuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgRGF0YVRhYmxlcy5BcGlgIC0gQVBJIGluc3RhbmNlXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2FycmF5fG51bGx9IE1hdGNoaW5nIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cy4gYG51bGxgIG9yXHJcblx0ICAgICAgICAgICAgICAgICAqICAgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgaWYgbm8gbWF0Y2hpbmcgRGF0YVRhYmxlIGlzIGZvdW5kLlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAaWdub3JlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3RvU2V0dGluZ3MgPSBmdW5jdGlvbiAobWl4ZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsIGpxO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlcyA9ICQubWFwKHNldHRpbmdzLCBmdW5jdGlvbiAoZWwsIGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwublRhYmxlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFtaXhlZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1peGVkLm5UYWJsZSAmJiBtaXhlZC5vQXBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21peGVkXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1peGVkLm5vZGVOYW1lICYmIG1peGVkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWJsZScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWJsZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gJC5pbkFycmF5KG1peGVkLCB0YWJsZXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHggIT09IC0xID8gW3NldHRpbmdzW2lkeF1dIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1peGVkICYmIHR5cGVvZiBtaXhlZC5zZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtaXhlZC5zZXR0aW5ncygpLnRvQXJyYXkoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkgc2VsZWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqcSA9ICQobWl4ZWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiAkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8galF1ZXJ5IG9iamVjdCAoYWxzbyBEYXRhVGFibGVzIGluc3RhbmNlKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpxID0gbWl4ZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGpxKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxLm1hcChmdW5jdGlvbiAoaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSAkLmluQXJyYXkodGhpcywgdGFibGVzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTEgPyBzZXR0aW5nc1tpZHhdIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS50b0FycmF5KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgQVBJIGNsYXNzIC0gdXNlZCB0byBjb250cm9sIGFuZCBpbnRlcmZhY2Ugd2l0aCAgb25lIG9yIG1vcmVcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIFRoZSBBUEkgY2xhc3MgaXMgaGVhdmlseSBiYXNlZCBvbiBqUXVlcnksIHByZXNlbnRpbmcgYSBjaGFpbmFibGUgaW50ZXJmYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqIHRoYXQgeW91IGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0YWJsZXMuIEVhY2ggaW5zdGFuY2Ugb2YgdGhlIEFQSSBjbGFzcyBoYXNcclxuXHQgICAgICAgICAgICAgICAgICogYSBcImNvbnRleHRcIiAtIGkuZS4gdGhlIHRhYmxlcyB0aGF0IGl0IHdpbGwgb3BlcmF0ZSBvbi4gVGhpcyBjb3VsZCBiZSBhIHNpbmdsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiB0YWJsZSwgYWxsIHRhYmxlcyBvbiBhIHBhZ2Ugb3IgYSBzdWItc2V0IHRoZXJlb2YuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEFkZGl0aW9uYWxseSB0aGUgQVBJIGlzIGRlc2lnbmVkIHRvIGFsbG93IHlvdSB0byBlYXNpbHkgd29yayB3aXRoIHRoZSBkYXRhIGluXHJcblx0ICAgICAgICAgICAgICAgICAqIHRoZSB0YWJsZXMsIHJldHJpZXZpbmcgYW5kIG1hbmlwdWxhdGluZyBpdCBhcyByZXF1aXJlZC4gVGhpcyBpcyBkb25lIGJ5XHJcblx0ICAgICAgICAgICAgICAgICAqIHByZXNlbnRpbmcgdGhlIEFQSSBjbGFzcyBhcyBhbiBhcnJheSBsaWtlIGludGVyZmFjZS4gVGhlIGNvbnRlbnRzIG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBhcnJheSBkZXBlbmQgdXBvbiB0aGUgYWN0aW9ucyByZXF1ZXN0ZWQgYnkgZWFjaCBtZXRob2QgKGZvciBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAqIGByb3dzKCkubm9kZXMoKWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygbm9kZXMsIHdoaWxlIGByb3dzKCkuZGF0YSgpYCB3aWxsXHJcblx0ICAgICAgICAgICAgICAgICAqIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGFycmF5cyBkZXBlbmRpbmcgdXBvbiB5b3VyIHRhYmxlJ3NcclxuXHQgICAgICAgICAgICAgICAgICogY29uZmlndXJhdGlvbikuIFRoZSBBUEkgb2JqZWN0IGhhcyBhIG51bWJlciBvZiBhcnJheSBsaWtlIG1ldGhvZHMgKGBwdXNoYCxcclxuXHQgICAgICAgICAgICAgICAgICogYHBvcGAsIGByZXZlcnNlYCBldGMpIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyAoYGVhY2hgLCBgcGx1Y2tgLFxyXG5cdCAgICAgICAgICAgICAgICAgKiBgdW5pcXVlYCBldGMpIHRvIGFzc2lzdCB5b3VyIHdvcmtpbmcgd2l0aCB0aGUgZGF0YSBoZWxkIGluIGEgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIE1vc3QgbWV0aG9kcyAodGhvc2Ugd2hpY2ggcmV0dXJuIGFuIEFwaSBpbnN0YW5jZSkgYXJlIGNoYWluYWJsZSwgd2hpY2ggbWVhbnNcclxuXHQgICAgICAgICAgICAgICAgICogdGhlIHJldHVybiBmcm9tIGEgbWV0aG9kIGNhbGwgYWxzbyBoYXMgYWxsIG9mIHRoZSBtZXRob2RzIGF2YWlsYWJsZSB0aGF0IHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiB0b3AgbGV2ZWwgb2JqZWN0IGhhZC4gRm9yIGV4YW1wbGUsIHRoZXNlIHR3byBjYWxscyBhcmUgZXF1aXZhbGVudDpcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogICAgIC8vIE5vdCBjaGFpbmVkXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICBhcGkucm93LmFkZCggey4uLn0gKTtcclxuXHQgICAgICAgICAgICAgICAgICogICAgIGFwaS5kcmF3KCk7XHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAvLyBDaGFpbmVkXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICBhcGkucm93LmFkZCggey4uLn0gKS5kcmF3KCk7XHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBjbGFzcyBEYXRhVGFibGUuQXBpXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fHN0cmluZ3xqUXVlcnl9IGNvbnRleHQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIFRoaXMgaXNcclxuXHQgICAgICAgICAgICAgICAgICogICB1c2VkIHRvIGRlZmluZSB3aGljaCBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcyB0aGlzIEFQSSB3aWxsIG9wZXJhdGUgb24uXHJcblx0ICAgICAgICAgICAgICAgICAqICAgQ2FuIGJlIG9uZSBvZjpcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBbZGF0YV0gRGF0YSB0byBpbml0aWFsaXNlIHRoZSBBcGkgaW5zdGFuY2Ugd2l0aC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAvLyBEaXJlY3QgaW5pdGlhbGlzYXRpb24gZHVyaW5nIERhdGFUYWJsZXMgY29uc3RydWN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuRGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgLy8gSW5pdGlhbGlzYXRpb24gdXNpbmcgYSBEYXRhVGFibGVzIGpRdWVyeSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5hcGkoKTtcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAvLyBJbml0aWFsaXNhdGlvbiBhcyBhIGNvbnN0cnVjdG9yXHJcblx0ICAgICAgICAgICAgICAgICAqICAgdmFyIGFwaSA9IG5ldyAkLmZuLkRhdGFUYWJsZS5BcGkoICd0YWJsZS5kYXRhVGFibGUnICk7XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBfQXBpID0gZnVuY3Rpb24gKGNvbnRleHQsIGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfQXBpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaShjb250ZXh0LCBkYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHhTZXR0aW5ncyA9IGZ1bmN0aW9uIChvKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBfdG9TZXR0aW5ncyhvKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5wdXNoLmFwcGx5KHNldHRpbmdzLCBhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzQXJyYXkoY29udGV4dCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gY29udGV4dC5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eFNldHRpbmdzKGNvbnRleHRbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN0eFNldHRpbmdzKGNvbnRleHQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBfdW5pcXVlKHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJbml0aWFsIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoLmFwcGx5KHRoaXMsIGRhdGEudG9BcnJheSA/IGRhdGEudG9BcnJheSgpIDogZGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93czogbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2xzOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHM6IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgX0FwaS5leHRlbmQodGhpcywgdGhpcywgX19hcGlTdHJ1Y3QpO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLkFwaSA9IF9BcGk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfQXBpLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgRGF0YVRhYmxlcy5BcGkgKi97XHJcblx0ICAgICAgICAgICAgICAgICAgICBhbnk6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCkubGVuZ3RoICE9PSAwO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29uY2F0OiBfX2FycmF5UHJvdG8uY29uY2F0LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBbXSwgLy8gYXJyYXkgb2YgdGFibGUgc2V0dGluZ3Mgb2JqZWN0c1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBlYWNoOiBmdW5jdGlvbiAoZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gdGhpcy5sZW5ndGggOyBpIDwgaWVuOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCB0aGlzW2ldLCBpLCB0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZXE6IGZ1bmN0aW9uIChpZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCA+IGlkeCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBfQXBpKGN0eFtpZHhdLCB0aGlzW2lkeF0pIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKGZuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fYXJyYXlQcm90by5maWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IF9fYXJyYXlQcm90by5maWx0ZXIuY2FsbCh0aGlzLCBmbiwgdGhpcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB3aXRob3V0IEVNQ0EtMjUyLTUgKEpTIDEuNilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHRoaXMubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZuLmNhbGwodGhpcywgdGhpc1tpXSwgaSwgdGhpcykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2godGhpc1tpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaSh0aGlzLmNvbnRleHQsIGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZmxhdHRlbjogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXBpKHRoaXMuY29udGV4dCwgYS5jb25jYXQuYXBwbHkoYSwgdGhpcy50b0FycmF5KCkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGpvaW46IF9fYXJyYXlQcm90by5qb2luLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbmRleE9mOiBfX2FycmF5UHJvdG8uaW5kZXhPZiB8fCBmdW5jdGlvbiAob2JqLCBzdGFydCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAoc3RhcnQgfHwgMCksIGllbiA9IHRoaXMubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gb2JqKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yOiBmdW5jdGlvbiAoZmxhdHRlbiwgdHlwZSwgZm4sIGFsd2F5c05ldykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhID0gW10sIHJldCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSwgaWVuLCBqLCBqZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLmNvbnRleHQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MsIGl0ZW1zLCBpdGVtLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZ3VtZW50IHNoaWZ0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGF0dGVuID09PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNOZXcgPSBmbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSB0eXBlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gZmxhdHRlbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdHRlbiA9IGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY29udGV4dC5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcGlJbnN0ID0gbmV3IF9BcGkoY29udGV4dFtpXSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RhYmxlJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gZm4uY2FsbChhcGlJbnN0LCBjb250ZXh0W2ldLCBpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gocmV0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnY29sdW1ucycgfHwgdHlwZSA9PT0gJ3Jvd3MnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcyBzYW1lIGxlbmd0aCBhcyBjb250ZXh0IC0gb25lIGVudHJ5IGZvciBlYWNoIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIHRoaXNbaV0sIGkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChyZXQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdjb2x1bW4nIHx8IHR5cGUgPT09ICdjb2x1bW4tcm93cycgfHwgdHlwZSA9PT0gJ3JvdycgfHwgdHlwZSA9PT0gJ2NlbGwnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb2x1bW5zIGFuZCByb3dzIHNoYXJlIHRoZSBzYW1lIHN0cnVjdHVyZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICd0aGlzJyBpcyBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyBmb3IgZWFjaCBjb250ZXh0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtcyA9IHRoaXNbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjb2x1bW4tcm93cycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKGNvbnRleHRbaV0sIHNlbGVjdG9yLm9wdHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGl0ZW1zLmxlbmd0aCA7IGogPCBqZW4gOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gaXRlbXNbal07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY2VsbCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gZm4uY2FsbChhcGlJbnN0LCBjb250ZXh0W2ldLCBpdGVtLnJvdywgaXRlbS5jb2x1bW4sIGksIGopO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gZm4uY2FsbChhcGlJbnN0LCBjb250ZXh0W2ldLCBpdGVtLCBpLCBqLCByb3dzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gocmV0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCB8fCBhbHdheXNOZXcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IG5ldyBfQXBpKGNvbnRleHQsIGZsYXR0ZW4gPyBhLmNvbmNhdC5hcHBseShbXSwgYSkgOiBhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaVNlbGVjdG9yID0gYXBpLnNlbGVjdG9yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlTZWxlY3Rvci5yb3dzID0gc2VsZWN0b3Iucm93cztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpU2VsZWN0b3IuY29scyA9IHNlbGVjdG9yLmNvbHM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVNlbGVjdG9yLm9wdHMgPSBzZWxlY3Rvci5vcHRzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleE9mOiBfX2FycmF5UHJvdG8ubGFzdEluZGV4T2YgfHwgZnVuY3Rpb24gKG9iaiwgc3RhcnQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXQgY2hlZWt5Li4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZi5hcHBseSh0aGlzLnRvQXJyYXkucmV2ZXJzZSgpLCBhcmd1bWVudHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiAwLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBtYXA6IGZ1bmN0aW9uIChmbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfX2FycmF5UHJvdG8ubWFwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBfX2FycmF5UHJvdG8ubWFwLmNhbGwodGhpcywgZm4sIHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGF0aWJpbGl0eSBmb3IgYnJvd3NlcnMgd2l0aG91dCBFTUNBLTI1Mi01IChKUyAxLjYpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSB0aGlzLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChmbi5jYWxsKHRoaXMsIHRoaXNbaV0sIGkpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXBpKHRoaXMuY29udGV4dCwgYSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBwbHVjazogZnVuY3Rpb24gKHByb3ApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGVsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbFtwcm9wXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcG9wOiBfX2FycmF5UHJvdG8ucG9wLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBwdXNoOiBfX2FycmF5UHJvdG8ucHVzaCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRG9lcyBub3QgcmV0dXJuIGFuIEFQSSBpbnN0YW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVkdWNlOiBfX2FycmF5UHJvdG8ucmVkdWNlIHx8IGZ1bmN0aW9uIChmbiwgaW5pdCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5SZWR1Y2UodGhpcywgZm4sIGluaXQsIDAsIHRoaXMubGVuZ3RoLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJlZHVjZVJpZ2h0OiBfX2FycmF5UHJvdG8ucmVkdWNlUmlnaHQgfHwgZnVuY3Rpb24gKGZuLCBpbml0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mblJlZHVjZSh0aGlzLCBmbiwgaW5pdCwgdGhpcy5sZW5ndGggLSAxLCAtMSwgLTEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogX19hcnJheVByb3RvLnJldmVyc2UsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE9iamVjdCB3aXRoIHJvd3MsIGNvbHVtbnMgYW5kIG9wdHNcclxuXHQgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzaGlmdDogX19hcnJheVByb3RvLnNoaWZ0LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBzb3J0OiBfX2FycmF5UHJvdG8uc29ydCwgLy8gPyBuYW1lIC0gb3JkZXI/XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNwbGljZTogX19hcnJheVByb3RvLnNwbGljZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2FycmF5UHJvdG8uc2xpY2UuY2FsbCh0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHRvJDogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdG9KUXVlcnk6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJCh0aGlzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaSh0aGlzLmNvbnRleHQsIF91bmlxdWUodGhpcykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdW5zaGlmdDogX19hcnJheVByb3RvLnVuc2hpZnRcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfQXBpLmV4dGVuZCA9IGZ1bmN0aW9uIChzY29wZSwgb2JqLCBleHQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZXh0ZW5kIEFQSSBpbnN0YW5jZXMgYW5kIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBBUElcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZXh0Lmxlbmd0aCB8fCAhb2JqIHx8ICghKG9iaiBpbnN0YW5jZW9mIF9BcGkpICYmICFvYmouX19kdF93cmFwcGVyKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpLCBpZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaiwgamVuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdCwgaW5uZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kU2NvcGluZyA9IGZ1bmN0aW9uIChzY29wZSwgZm4sIHN0cnVjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gZm4uYXBwbHkoc2NvcGUsIGFyZ3VtZW50cyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWV0aG9kIGV4dGVuc2lvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX0FwaS5leHRlbmQocmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gZXh0Lmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3QgPSBleHRbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbHVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqW3N0cnVjdC5uYW1lXSA9IHR5cGVvZiBzdHJ1Y3QudmFsID09PSAnZnVuY3Rpb24nID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kU2NvcGluZyhzY29wZSwgc3RydWN0LnZhbCwgc3RydWN0KSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuaXNQbGFpbk9iamVjdChzdHJ1Y3QudmFsKSA/XHJcblx0XHRcdFx0XHRcdHt9IDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cnVjdC52YWw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9ialtzdHJ1Y3QubmFtZV0uX19kdF93cmFwcGVyID0gdHJ1ZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydHkgZXh0ZW5zaW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX0FwaS5leHRlbmQoc2NvcGUsIG9ialtzdHJ1Y3QubmFtZV0sIHN0cnVjdC5wcm9wRXh0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBAdG9kbyAtIElzIHRoZXJlIG5lZWQgZm9yIGFuIGF1Z21lbnQgZnVuY3Rpb24/XHJcblx0ICAgICAgICAgICAgICAgIC8vIF9BcGkuYXVnbWVudCA9IGZ1bmN0aW9uICggaW5zdCwgbmFtZSApXHJcblx0ICAgICAgICAgICAgICAgIC8vIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gXHQvLyBGaW5kIHNyYyBvYmplY3QgaW4gdGhlIHN0cnVjdHVyZSBmcm9tIHRoZSBuYW1lXHJcblx0ICAgICAgICAgICAgICAgIC8vIFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gXHRfQXBpLmV4dGVuZCggaW5zdCwgb2JqICk7XHJcblx0ICAgICAgICAgICAgICAgIC8vIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gICAgIFtcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICBuYW1lOiAgICAgJ3JvdydcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICB2YWw6ICAgICAgIHt9LFxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICBwcm9wRXh0OiAgIFtcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxyXG5cdCAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAuLi5cclxuXHQgICAgICAgICAgICAgICAgLy8gICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgIC8vICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgLy8gICAgIF1cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9BcGkucmVnaXN0ZXIgPSBfYXBpX3JlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShuYW1lKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqZW4gPSBuYW1lLmxlbmd0aCA7IGogPCBqZW4gOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX0FwaS5yZWdpc3RlcihuYW1lW2pdLCB2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaSwgaWVuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlaXIgPSBuYW1lLnNwbGl0KCcuJyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0ID0gX19hcGlTdHJ1Y3QsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5LCBtZXRob2Q7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmQgPSBmdW5jdGlvbiAoc3JjLCBuYW1lKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHNyYy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmNbaV0ubmFtZSA9PT0gbmFtZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNyY1tpXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gaGVpci5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gaGVpcltpXS5pbmRleE9mKCcoKScpICE9PSAtMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBtZXRob2QgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlyW2ldLnJlcGxhY2UoJygpJywgJycpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpcltpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyYyA9IGZpbmQoc3RydWN0LCBrZXkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3JjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbDoge30sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RFeHQ6IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEV4dDogW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RydWN0LnB1c2goc3JjKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpZW4gLSAxKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYy52YWwgPSB2YWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3QgPSBtZXRob2QgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjLm1ldGhvZEV4dCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmMucHJvcEV4dDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX0FwaS5yZWdpc3RlclBsdXJhbCA9IF9hcGlfcmVnaXN0ZXJQbHVyYWwgPSBmdW5jdGlvbiAocGx1cmFsTmFtZSwgc2luZ3VsYXJOYW1lLCB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9BcGkucmVnaXN0ZXIocGx1cmFsTmFtZSwgdmFsKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBfQXBpLnJlZ2lzdGVyKHNpbmd1bGFyTmFtZSwgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB2YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gdGhpcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm5lZCBpdGVtIGlzIHRoZSBBUEkgaW5zdGFuY2UgdGhhdCB3YXMgcGFzc2VkIGluLCByZXR1cm4gaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJldCBpbnN0YW5jZW9mIF9BcGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV3IEFQSSBpbnN0YW5jZSByZXR1cm5lZCwgd2FudCB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlbVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgZm9yIHRoZSBzaW5ndWxhciByZXN1bHQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQubGVuZ3RoID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuaXNBcnJheShyZXRbMF0pID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgX0FwaShyZXQuY29udGV4dCwgcmV0WzBdKSA6IC8vIEFycmF5IHJlc3VsdHMgYXJlICdlbmhhbmNlZCdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRbMF0gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9uLUFQSSByZXR1cm4gLSBqdXN0IGZpcmUgaXQgYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogU2VsZWN0b3IgZm9yIEhUTUwgdGFibGVzLiBBcHBseSB0aGUgZ2l2ZW4gc2VsZWN0b3IgdG8gdGhlIGdpdmUgYXJyYXkgb2ZcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcgb3IgaW50ZWdlclxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHthcnJheX0gQXJyYXkgb2YgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzIHRvIGJlIGZpbHRlcmVkXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2FycmF5fVxyXG5cdCAgICAgICAgICAgICAgICAgKiBAaWdub3JlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgX190YWJsZV9zZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvciwgYSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSW50ZWdlciBpcyB1c2VkIHRvIHBpY2sgb3V0IGEgdGFibGUgYnkgaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthW3NlbGVjdG9yXV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgdGFibGUgbm9kZXNcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9ICQubWFwKGEsIGZ1bmN0aW9uIChlbCwgaSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5uVGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gJChub2RlcylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNlbGVjdG9yKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byB0cmFuc2xhdGUgYmFjayBmcm9tIHRoZSB0YWJsZSBub2RlIHRvIHRoZSBzZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gJC5pbkFycmF5KHRoaXMsIG5vZGVzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbaWR4XTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb250ZXh0IHNlbGVjdG9yIGZvciB0aGUgQVBJJ3MgY29udGV4dCAoaS5lLiB0aGUgdGFibGVzIHRoZSBBUEkgaW5zdGFuY2VcclxuXHQgICAgICAgICAgICAgICAgICogcmVmZXJzIHRvLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAbmFtZSAgICBEYXRhVGFibGUuQXBpI3RhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIFNlbGVjdG9yIHRvIHBpY2sgd2hpY2ggdGFibGVzIHRoZSBpdGVyYXRvclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHNob3VsZCBvcGVyYXRlIG9uLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhcmVcclxuXHQgICAgICAgICAgICAgICAgICogICB1c2VkLiBUaGlzIGNhbiBiZSBnaXZlbiBhcyBhIGpRdWVyeSBzZWxlY3RvciAoZm9yIGV4YW1wbGUgYCc6Z3QoMCknYCkgdG9cclxuXHQgICAgICAgICAgICAgICAgICogICBzZWxlY3QgbXVsdGlwbGUgdGFibGVzIG9yIGFzIGFuIGludGVnZXIgdG8gc2VsZWN0IGEgc2luZ2xlIHRhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlLkFwaX0gUmV0dXJucyBhIG5ldyBBUEkgaW5zdGFuY2UgaWYgYSBzZWxlY3RvciBpcyBnaXZlbi5cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3RhYmxlcygpJywgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBBIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGlmIHRoZXJlIHdhcyBhIHNlbGVjdG9yIHNwZWNpZmllZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXcgX0FwaShfX3RhYmxlX3NlbGVjdG9yKHNlbGVjdG9yLCB0aGlzLmNvbnRleHQpKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcigndGFibGUoKScsIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlcyA9IHRoaXMudGFibGVzKHNlbGVjdG9yKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0YWJsZXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3QgbWF0Y2hlZCB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBfQXBpKGN0eFswXSkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlcztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgndGFibGVzKCkubm9kZXMoKScsICd0YWJsZSgpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lm5UYWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5ib2R5KCknLCAndGFibGUoKS5ib2R5KCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5uVEJvZHk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgndGFibGVzKCkuaGVhZGVyKCknLCAndGFibGUoKS5oZWFkZXIoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lm5USGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5mb290ZXIoKScsICd0YWJsZSgpLmZvb3RlcigpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgublRGb290O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3RhYmxlcygpLmNvbnRhaW5lcnMoKScsICd0YWJsZSgpLmNvbnRhaW5lcigpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgublRhYmxlV3JhcHBlcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFJlZHJhdyB0aGUgdGFibGVzIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0PXRydWVdIFJlc2V0IChkZWZhdWx0KSBvciBob2xkIHRoZSBjdXJyZW50IHBhZ2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIHBvc2l0aW9uLiBBIGZ1bGwgcmUtc29ydCBhbmQgcmUtZmlsdGVyIGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgbWV0aG9kIGlzXHJcblx0ICAgICAgICAgICAgICAgICAqICAgY2FsbGVkLCB3aGljaCBpcyB3aHkgdGhlIHBhZ2luYXRpb24gcmVzZXQgaXMgdGhlIGRlZmF1bHQgYWN0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2RyYXcoKScsIGZ1bmN0aW9uIChyZXNldFBhZ2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzLCByZXNldFBhZ2luZyA9PT0gZmFsc2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHBhZ2UgaW5kZXguXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2ludGVnZXJ9IEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZClcclxuXHQgICAgICAgICAgICAgICAgICovLyoqXHJcblx0XHQgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZS5cclxuXHRcdCAqXHJcblx0XHQgKiBOb3RlIHRoYXQgaWYgeW91IGF0dGVtcHQgdG8gc2hvdyBhIHBhZ2Ugd2hpY2ggZG9lcyBub3QgZXhpc3QsIERhdGFUYWJsZXMgd2lsbFxyXG5cdFx0ICogbm90IHRocm93IGFuIGVycm9yLCBidXQgcmF0aGVyIHJlc2V0IHRoZSBwYWdpbmcuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHtpbnRlZ2VyfHN0cmluZ30gYWN0aW9uIFRoZSBwYWdpbmcgYWN0aW9uIHRvIHRha2UuIFRoaXMgY2FuIGJlIG9uZSBvZjpcclxuXHRcdCAqICAqIGBpbnRlZ2VyYCAtIFRoZSBwYWdlIGluZGV4IHRvIGp1bXAgdG9cclxuXHRcdCAqICAqIGBzdHJpbmdgIC0gQW4gYWN0aW9uIHRvIHRha2U6XHJcblx0XHQgKiAgICAqIGBmaXJzdGAgLSBKdW1wIHRvIGZpcnN0IHBhZ2UuXHJcblx0XHQgKiAgICAqIGBuZXh0YCAtIEp1bXAgdG8gdGhlIG5leHQgcGFnZVxyXG5cdFx0ICogICAgKiBgcHJldmlvdXNgIC0gSnVtcCB0byBwcmV2aW91cyBwYWdlXHJcblx0XHQgKiAgICAqIGBsYXN0YCAtIEp1bXAgdG8gdGhlIGxhc3QgcGFnZS5cclxuXHRcdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG5cdFx0ICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3BhZ2UoKScsIGZ1bmN0aW9uIChhY3Rpb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhZ2UuaW5mbygpLnBhZ2U7IC8vIG5vdCBhbiBleHBlbnNpdmUgY2FsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UsIGhhdmUgYW4gYWN0aW9uIHRvIHRha2Ugb24gYWxsIHRhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUGFnZUNoYW5nZShzZXR0aW5ncywgYWN0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUGFnaW5nIGluZm9ybWF0aW9uIGZvciB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogSWYgeW91IHJlcXVpcmUgcGFnaW5nIGluZm9ybWF0aW9uIGZvciBhbm90aGVyIHRhYmxlLCB1c2UgdGhlIGB0YWJsZSgpYCBtZXRob2RcclxuXHQgICAgICAgICAgICAgICAgICogd2l0aCBhIHN1aXRhYmxlIHNlbGVjdG9yLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBzZXQ6XHJcblx0ICAgICAgICAgICAgICAgICAqICAqIGBwYWdlYCAtIEN1cnJlbnQgcGFnZSBpbmRleCAoemVybyBiYXNlZCAtIGkuZS4gdGhlIGZpcnN0IHBhZ2UgaXMgYDBgKVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgKiBgcGFnZXNgIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzXHJcblx0ICAgICAgICAgICAgICAgICAqICAqIGBzdGFydGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgZmlyc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICogICogYGVuZGAgLSBEaXNwbGF5IGluZGV4IGZvciB0aGUgbGFzdCByZWNvcmQgc2hvd24gb24gdGhlIGN1cnJlbnQgcGFnZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgKiBgbGVuZ3RoYCAtIERpc3BsYXkgbGVuZ3RoIChudW1iZXIgb2YgcmVjb3JkcykuIE5vdGUgdGhhdCBnZW5lcmFsbHkgYHN0YXJ0XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICsgbGVuZ3RoID0gZW5kYCwgYnV0IHRoaXMgaXMgbm90IGFsd2F5cyB0cnVlLCBmb3IgZXhhbXBsZSBpZiB0aGVyZSBhcmVcclxuXHQgICAgICAgICAgICAgICAgICogICAgb25seSAyIHJlY29yZHMgdG8gc2hvdyBvbiB0aGUgZmluYWwgcGFnZSwgd2l0aCBhIGxlbmd0aCBvZiAxMC5cclxuXHQgICAgICAgICAgICAgICAgICogICogYHJlY29yZHNUb3RhbGAgLSBGdWxsIGRhdGEgc2V0IGxlbmd0aFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgKiBgcmVjb3Jkc0Rpc3BsYXlgIC0gRGF0YSBzZXQgbGVuZ3RoIG9uY2UgdGhlIGN1cnJlbnQgZmlsdGVyaW5nIGNyaXRlcmlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBhcmUgYXBwbGllZC5cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3BhZ2UuaW5mbygpJywgZnVuY3Rpb24gKGFjdGlvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5jb250ZXh0WzBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZpc1JlY29yZHMgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWxsID0gbGVuID09PSAtMTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwicGFnZVwiOiBhbGwgPyAwIDogTWF0aC5mbG9vcihzdGFydCAvIGxlbiksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWdlc1wiOiBhbGwgPyAxIDogTWF0aC5jZWlsKHZpc1JlY29yZHMgLyBsZW4pLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic3RhcnRcIjogc3RhcnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJlbmRcIjogc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogbGVuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwicmVjb3Jkc1RvdGFsXCI6IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWNvcmRzRGlzcGxheVwiOiB2aXNSZWNvcmRzXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBDdXJyZW50IHBhZ2UgbGVuZ3RoLiBOb3RlIGAtMWAgaW5kaWNhdGVzIHRoYXQgYWxsIHJlY29yZHNcclxuXHQgICAgICAgICAgICAgICAgICogICBhcmUgdG8gYmUgc2hvd24uXHJcblx0ICAgICAgICAgICAgICAgICAqLy8qKlxyXG5cdFx0ICogU2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gUGFnZSBsZW5ndGggdG8gc2V0LiBVc2UgYC0xYCB0byBzaG93IGFsbCByZWNvcmRzLlxyXG5cdFx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcblx0XHQgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcigncGFnZS5sZW4oKScsIGZ1bmN0aW9uIChsZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjYWxsIHRoaXMgZnVuY3Rpb24gJ2xlbmd0aCgpJyBiZWNhdXNlIGBsZW5ndGhgXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBpcyBhIEphdmFzY3JpcHQgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHdoaWNoIGRlZmluZXMgaG93IG1hbnkgYXJndW1lbnRzXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gZXhwZWN0cy5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0WzBdLl9pRGlzcGxheUxlbmd0aCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBlbHNlLCBzZXQgdGhlIHBhZ2UgbGVuZ3RoXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5MZW5ndGhDaGFuZ2Uoc2V0dGluZ3MsIGxlbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX3JlbG9hZCA9IGZ1bmN0aW9uIChzZXR0aW5ncywgaG9sZFBvc2l0aW9uLCBjYWxsYmFjaykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkcmF3IGV2ZW50IHRvIHRyaWdnZXIgYSBjYWxsYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IG5ldyBfQXBpKHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXBpLm9uZSgnZHJhdycsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soYXBpLmFqYXguanNvbigpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykgPT0gJ3NzcCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5SZURyYXcoc2V0dGluZ3MsIGhvbGRQb3NpdGlvbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHhoclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCB0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQnVpbGRBamF4KHNldHRpbmdzLCBbXSwgZnVuY3Rpb24gKGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2xlYXJUYWJsZShzZXR0aW5ncyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKHNldHRpbmdzLCBqc29uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkRGF0YShzZXR0aW5ncywgZGF0YVtpXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblJlRHJhdyhzZXR0aW5ncywgaG9sZFBvc2l0aW9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IHRoZSBKU09OIHJlc3BvbnNlIGZyb20gdGhlIGxhc3QgQWpheCByZXF1ZXN0IHRoYXQgRGF0YVRhYmxlcyBtYWRlIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBzZXJ2ZXIuIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgdGhlIEpTT04gZnJvbSB0aGUgZmlyc3QgdGFibGUgaW4gdGhlIGN1cnJlbnRcclxuXHQgICAgICAgICAgICAgICAgICogY29udGV4dC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBKU09OIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2FqYXguanNvbigpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4WzBdLmpzb247XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IHRoZSBkYXRhIHN1Ym1pdHRlZCBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3RcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2FqYXgucGFyYW1zKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoID4gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhbMF0ub0FqYXhEYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFJlbG9hZCB0YWJsZXMgZnJvbSB0aGUgQWpheCBkYXRhIHNvdXJjZS4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbFxyXG5cdCAgICAgICAgICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHJlLWRyYXcgdGhlIHRhYmxlIHdoZW4gdGhlIHJlbW90ZSBkYXRhIGhhcyBiZWVuIGxvYWRlZC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbcmVzZXQ9dHJ1ZV0gUmVzZXQgKGRlZmF1bHQpIG9yIGhvbGQgdGhlIGN1cnJlbnQgcGFnaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICAgcG9zaXRpb24uIEEgZnVsbCByZS1zb3J0IGFuZCByZS1maWx0ZXIgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBtZXRob2QgaXNcclxuXHQgICAgICAgICAgICAgICAgICogICBjYWxsZWQsIHdoaWNoIGlzIHdoeSB0aGUgcGFnaW5hdGlvbiByZXNldCBpcyB0aGUgZGVmYXVsdCBhY3Rpb24uXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC5yZWxvYWQoKScsIGZ1bmN0aW9uIChjYWxsYmFjaywgcmVzZXRQYWdpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9fcmVsb2FkKHNldHRpbmdzLCByZXNldFBhZ2luZyA9PT0gZmFsc2UsIGNhbGxiYWNrKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBVUkwgZnJvbSB0aGUgZmlyc3RcclxuXHQgICAgICAgICAgICAgICAgICogdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IEFqYXggc291cmNlIFVSTFxyXG5cdCAgICAgICAgICAgICAgICAgKi8vKipcclxuXHRcdCAqIFNldCB0aGUgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2V0IHRoZSBVUkwgZm9yIGFsbCB0YWJsZXMgaW4gdGhlXHJcblx0XHQgKiBjdXJyZW50IGNvbnRleHQuXHJcblx0XHQgKlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gc2V0LlxyXG5cdFx0ICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXHJcblx0XHQgKi9cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC51cmwoKScsIGZ1bmN0aW9uICh1cmwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHVybCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggPT09IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4ID0gY3R4WzBdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4LmFqYXggP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmlzUGxhaW5PYmplY3QoY3R4LmFqYXgpID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hamF4LnVybCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYWpheCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zQWpheFNvdXJjZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3Qoc2V0dGluZ3MuYWpheCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWpheC51cmwgPSB1cmw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hamF4ID0gdXJsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNvbnNpZGVyIHNBamF4U291cmNlIGhlcmUgc2luY2UgRGF0YVRhYmxlcyBnaXZlcyBwcmlvcml0eVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGBhamF4YCBvdmVyIGBzQWpheFNvdXJjZWAuIFNvIHNldHRpbmcgYGFqYXhgIGhlcmUsIHJlbmRlcnMgYW55XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgb2YgYHNBamF4U291cmNlYCByZWR1bmRhbnQuXHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIExvYWQgZGF0YSBmcm9tIHRoZSBuZXdseSBzZXQgQWpheCBVUkwuIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5XHJcblx0ICAgICAgICAgICAgICAgICAqIGF2YWlsYWJsZSB3aGVuIGBhamF4LnVybCgpYCBpcyB1c2VkIHRvIHNldCBhIFVSTC4gQWRkaXRpb25hbGx5LCB0aGlzIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGNhbGxpbmcgYGFqYXgucmVsb2FkKClgIGJ1dCBpcyBwcm92aWRlZCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICogY29udmVuaWVuY2Ugd2hlbiBzZXR0aW5nIGEgbmV3IFVSTC4gTGlrZSBgYWpheC5yZWxvYWQoKWAgaXQgd2lsbFxyXG5cdCAgICAgICAgICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHJlZHJhdyB0aGUgdGFibGUgb25jZSB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2FqYXgudXJsKCkubG9hZCgpJywgZnVuY3Rpb24gKGNhbGxiYWNrLCByZXNldFBhZ2luZykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2FtZSBhcyBhIHJlbG9hZCwgYnV0IG1ha2VzIHNlbnNlIHRvIHByZXNlbnQgaXQgZm9yIGVhc3kgYWNjZXNzIGFmdGVyIGFcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHVybCBjaGFuZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfX3JlbG9hZChjdHgsIHJlc2V0UGFnaW5nID09PSBmYWxzZSwgY2FsbGJhY2spO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9zZWxlY3Rvcl9ydW4gPSBmdW5jdGlvbiAodHlwZSwgc2VsZWN0b3IsIHNlbGVjdEZuLCBzZXR0aW5ncywgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gW10sIHJlcyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhLCBpLCBpZW4sIGosIGplbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvclR5cGUgPSB0eXBlb2Ygc2VsZWN0b3I7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ2FuJ3QganVzdCBjaGVjayBmb3IgaXNBcnJheSBoZXJlLCBhcyBhbiBBUEkgb3IgalF1ZXJ5IGluc3RhbmNlIG1pZ2h0IGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBnaXZlbiB3aXRoIHRoZWlyIGFycmF5IGxpa2UgbG9va1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvclR5cGUgPT09ICdzdHJpbmcnIHx8IHNlbGVjdG9yVHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCBzZWxlY3Rvci5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gW3NlbGVjdG9yXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBzZWxlY3Rvci5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYSA9IHNlbGVjdG9yW2ldICYmIHNlbGVjdG9yW2ldLnNwbGl0ID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JbaV0uc3BsaXQoJywnKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3RvcltpXV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGEubGVuZ3RoIDsgaiA8IGplbiA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBzZWxlY3RGbih0eXBlb2YgYVtqXSA9PT0gJ3N0cmluZycgPyAkLnRyaW0oYVtqXSkgOiBhW2pdKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2guYXBwbHkob3V0LCByZXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yIGV4dGVuc2lvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBleHQgPSBfZXh0LnNlbGVjdG9yW3R5cGVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGV4dC5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBleHQubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBleHRbaV0oc2V0dGluZ3MsIG9wdHMsIG91dCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9zZWxlY3Rvcl9vcHRzID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSB7fTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgMS45LSB3aGljaCB1c2VkIHRoZSB0ZXJtaW5vbG9neSBmaWx0ZXIgcmF0aGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB0aGFuIHNlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZmlsdGVyICYmIG9wdHMuc2VhcmNoID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnNlYXJjaCA9IG9wdHMuZmlsdGVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLmV4dGVuZCh7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoOiAnbm9uZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXI6ICdjdXJyZW50JyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiAnYWxsJ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9zZWxlY3Rvcl9maXJzdCA9IGZ1bmN0aW9uIChpbnN0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZWR1Y2UgdGhlIEFQSSBpbnN0YW5jZSB0byB0aGUgZmlyc3QgaXRlbSBmb3VuZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGluc3QubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0W2ldLmxlbmd0aCA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRoZSBmaXJzdCBlbGVtZW50IHRvIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBpbnN0YW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdHJ1bmNhdGUgdGhlIGluc3RhbmNlIGFuZCBjb250ZXh0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RbMF0gPSBpbnN0W2ldO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0WzBdLmxlbmd0aCA9IDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3QubGVuZ3RoID0gMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdC5jb250ZXh0ID0gW2luc3QuY29udGV4dFtpXV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTm90IGZvdW5kIC0gcmV0dXJuIGFuIGVtcHR5IGluc3RhbmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbnN0Lmxlbmd0aCA9IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX3NlbGVjdG9yX3Jvd19pbmRleGVzID0gZnVuY3Rpb24gKHNldHRpbmdzLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpLCBpZW4sIHRtcCwgYSA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlGaWx0ZXJlZCA9IHNldHRpbmdzLmFpRGlzcGxheSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyID0gb3B0cy5vcmRlciwgICAvLyBhcHBsaWVkLCBjdXJyZW50LCBpbmRleCAob3JpZ2luYWwgLSBjb21wYXRpYmlsaXR5IHdpdGggMS45KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBvcHRzLnBhZ2U7ICAgIC8vIGFsbCwgY3VycmVudFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfZm5EYXRhU291cmNlKHNldHRpbmdzKSA9PSAnc3NwJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgbW9kZSwgbW9zdCBvcHRpb25zIGFyZSBpcnJlbGV2YW50IHNpbmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm93cyBub3Qgc2hvd24gZG9uJ3QgZXhpc3QgYW5kIHRoZSBpbmRleCBvcmRlciBpcyB0aGUgYXBwbGllZCBvcmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZWQgaXMgYSBzcGVjaWFsIGNhc2UgLSBmb3IgY29uc2lzdGVuY3kganVzdCByZXR1cm4gYW4gZW1wdHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWFyY2ggPT09ICdyZW1vdmVkJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JhbmdlKDAsIGRpc3BsYXlNYXN0ZXIubGVuZ3RoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhZ2UgPT0gJ2N1cnJlbnQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3VycmVudCBwYWdlIGltcGxpZXMgdGhhdCBvcmRlcj1jdXJyZW50IGFuZCBmaXRsZXI9YXBwbGllZCwgc2luY2UgaXQgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWlybHkgc2Vuc2VsZXNzIG90aGVyd2lzZSwgcmVnYXJkbGVzcyBvZiB3aGF0IG9yZGVyIGFuZCBzZWFyY2ggYWN0dWFsbHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCwgaWVuID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCkgOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChkaXNwbGF5RmlsdGVyZWRbaV0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9yZGVyID09ICdjdXJyZW50JyB8fCBvcmRlciA9PSAnYXBwbGllZCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhID0gc2VhcmNoID09ICdub25lJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYXN0ZXIuc2xpY2UoKSA6ICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHNlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2ggPT0gJ2FwcGxpZWQnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlGaWx0ZXJlZC5zbGljZSgpIDogICAgICAgICAgICAgICAgLy8gYXBwbGllZCBzZWFyY2hcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQubWFwKGRpc3BsYXlNYXN0ZXIsIGZ1bmN0aW9uIChlbCwgaSkgeyAvLyByZW1vdmVkIHNlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLmluQXJyYXkoZWwsIGRpc3BsYXlGaWx0ZXJlZCkgPT09IC0xID8gZWwgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcmRlciA9PSAnaW5kZXgnIHx8IG9yZGVyID09ICdvcmlnaW5hbCcpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBzZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09ICdub25lJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhcHBsaWVkIHwgcmVtb3ZlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gJC5pbkFycmF5KGksIGRpc3BsYXlGaWx0ZXJlZCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0bXAgPT09IC0xICYmIHNlYXJjaCA9PSAncmVtb3ZlZCcpIHx8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRtcCA+PSAwICYmIHNlYXJjaCA9PSAnYXBwbGllZCcpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBSb3dzXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIHt9ICAgICAgICAgIC0gbm8gc2VsZWN0b3IgLSB1c2UgYWxsIGF2YWlsYWJsZSByb3dzXHJcblx0ICAgICAgICAgICAgICAgICAqIHtpbnRlZ2VyfSAgIC0gcm93IGFvRGF0YSBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgKiB7bm9kZX0gICAgICAtIFRSIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICoge3N0cmluZ30gICAgLSBqUXVlcnkgc2VsZWN0b3IgdG8gYXBwbHkgdG8gdGhlIFRSIGVsZW1lbnRzXHJcblx0ICAgICAgICAgICAgICAgICAqIHthcnJheX0gICAgIC0galF1ZXJ5IGFycmF5IG9mIG5vZGVzLCBvciBzaW1wbHkgYW4gYXJyYXkgb2YgVFIgbm9kZXNcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fcm93X3NlbGVjdG9yID0gZnVuY3Rpb24gKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChzZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsSW50ID0gX2ludFZhbChzZWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpZW47XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0IGN1dCAtIHNlbGVjdG9yIGlzIGEgbnVtYmVyIGFuZCBubyBvcHRpb25zIHByb3ZpZGVkIChkZWZhdWx0IGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIHJlY29yZHMsIHNvIG5vIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGluZGV4IGlzIGluIHRoZXJlLCBzaW5jZSBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgLSBkZXYgZXJyb3IgaWYgdGhlIGluZGV4IGRvZXNuJ3QgZXhpc3QpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxJbnQgIT09IG51bGwgJiYgIW9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWxJbnRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoc2V0dGluZ3MsIG9wdHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsSW50ICE9PSBudWxsICYmICQuaW5BcnJheShzZWxJbnQsIHJvd3MpICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGludGVnZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzZWxJbnRdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2VsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gbm9uZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93cztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5tYXAocm93cywgZnVuY3Rpb24gKGlkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpZHhdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbChpZHgsIHJvdy5fYURhdGEsIHJvdy5uVHIpID8gaWR4IDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgbm9kZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIGByb3dzYCBhcnJheSB3aXRoIG51bGwgdmFsdWVzIHJlbW92ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBfcmVtb3ZlRW1wdHkoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wbHVja19vcmRlcihzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICduVHInKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWwubm9kZU5hbWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaW5BcnJheShzZWwsIG5vZGVzKSAhPT0gLTEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbc2VsLl9EVF9Sb3dJbmRleF07IC8vIHNlbCBpcyBhIFRSIG5vZGUgdGhhdCBpcyBpbiB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBEYXRhVGFibGVzIGFkZHMgYSBwcm9wIGZvciBmYXN0IGxvb2t1cFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcsIGFycmF5IG9mIG5vZGVzIG9yIGpRdWVyeSBvYmplY3QvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXMgalF1ZXJ5J3MgLmZpbHRlcigpIGFsbG93cyBqUXVlcnkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW4gZmlsdGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGFsc28gYWxsb3dzIGFycmF5cywgc28gdGhpcyB3aWxsIGNvcGUgd2l0aCBhbGwgdGhyZWUgb3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKG5vZGVzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNlbClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fRFRfUm93SW5kZXg7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2VsZWN0b3JfcnVuKCdyb3cnLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93cygpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBzaGlmdGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KHNlbGVjdG9yKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBzZWxlY3RvcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBfc2VsZWN0b3Jfb3B0cyhvcHRzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fcm93X3NlbGVjdG9yKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9fcm93X3NlbGVjdG9yP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaW5zdC5zZWxlY3Rvci5yb3dzID0gc2VsZWN0b3I7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3Jvd3MoKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3JvdycsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmFvRGF0YVtyb3ddLm5UciB8fCB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3dzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IodHJ1ZSwgJ3Jvd3MnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvd3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3BsdWNrX29yZGVyKHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ19hRGF0YScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgncm93cygpLmNhY2hlKCknLCAncm93KCkuY2FjaGUoKScsIGZ1bmN0aW9uICh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHNldHRpbmdzLmFvRGF0YVtyb3ddO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnc2VhcmNoJyA/IHIuX2FGaWx0ZXJEYXRhIDogci5fYVNvcnREYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgncm93cygpLmludmFsaWRhdGUoKScsICdyb3coKS5pbnZhbGlkYXRlKCknLCBmdW5jdGlvbiAoc3JjKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5JbnZhbGlkYXRlKHNldHRpbmdzLCByb3csIHNyYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdyb3dzKCkuaW5kZXhlcygpJywgJ3JvdygpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgncm93cygpLnJlbW92ZSgpJywgJ3JvdygpLnJlbW92ZSgpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdywgdGhhdElkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNwbGljZShyb3csIDEpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIF9EVF9Sb3dJbmRleCBwYXJhbWV0ZXIgb24gYWxsIHJvd3MgaW4gdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5uVHIgIT09IG51bGwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0ublRyLl9EVF9Sb3dJbmRleCA9IGk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdGFyZ2V0IHJvdyBmcm9tIHRoZSBzZWFyY2ggYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcGxheUluZGV4ID0gJC5pbkFycmF5KHJvdywgc2V0dGluZ3MuYWlEaXNwbGF5KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIGZyb20gdGhlIGRpc3BsYXkgYXJyYXlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRGVsZXRlSW5kZXgoc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLCByb3cpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkRlbGV0ZUluZGV4KHNldHRpbmdzLmFpRGlzcGxheSwgcm93KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5EZWxldGVJbmRleCh0aGF0W3RoYXRJZHhdLCByb3csIGZhbHNlKTsgLy8gbWFpbnRhaW4gbG9jYWwgaW5kZXhlc1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYW4gJ292ZXJmbG93JyB0aGV5IGNhc2UgZm9yIGRpc3BsYXlpbmcgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3coc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3Jvd3MuYWRkKCknLCBmdW5jdGlvbiAocm93cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Jvd3MgPSB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3csIGksIGllbjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0ID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHJvd3MubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSByb3dzW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goX2ZuQWRkVHIoc2V0dGluZ3MsIHJvdylbMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goX2ZuQWRkRGF0YShzZXR0aW5ncywgcm93KSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYW4gQXBpLnJvd3MoKSBleHRlbmRlZCBpbnN0YW5jZSwgc28gcm93cygpLm5vZGVzKCkgZXRjIGNhbiBiZSB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbW9kUm93cyA9IHRoaXMucm93cygtMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBtb2RSb3dzLnBvcCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbW9kUm93cy5wdXNoLmFwcGx5KG1vZFJvd3MsIG5ld1Jvd3MudG9BcnJheSgpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kUm93cztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3coKScsIGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zZWxlY3Rvcl9maXJzdCh0aGlzLnJvd3Moc2VsZWN0b3IsIG9wdHMpKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93KCkuZGF0YSgpJywgZnVuY3Rpb24gKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4WzBdLmFvRGF0YVt0aGlzWzBdXS5fYURhdGEgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLl9hRGF0YSA9IGRhdGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSBpbnZhbGlkYXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5JbnZhbGlkYXRlKGN0eFswXSwgdGhpc1swXSwgJ2RhdGEnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93KCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3R4WzBdLmFvRGF0YVt0aGlzWzBdXS5uVHIgfHwgbnVsbCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93LmFkZCgpJywgZnVuY3Rpb24gKHJvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgYSBqUXVlcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiAtIG9ubHkgYSBzaW5nbGUgcm93IGlzIGFkZGVkIGZyb21cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGl0IHRob3VnaCAtIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyb3cgaW5zdGFuY2VvZiAkICYmIHJvdy5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSByb3dbMF07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cubm9kZU5hbWUgJiYgcm93Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUUicpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mbkFkZFRyKHNldHRpbmdzLCByb3cpWzBdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuQWRkRGF0YShzZXR0aW5ncywgcm93KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCB3aXRoIHRoZSBuZXdseSBhZGRlZCByb3cgc2VsZWN0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdyhyb3dzWzBdKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX2RldGFpbHNfYWRkID0gZnVuY3Rpb24gKGN0eCwgcm93LCBkYXRhLCBrbGFzcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhZGRSb3cgPSBmdW5jdGlvbiAociwgaykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShyKSB8fCByIGluc3RhbmNlb2YgJCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gci5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSb3cocltpXSwgayk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhZGQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMgZXRjXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIubm9kZU5hbWUgJiYgci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndHInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWF0ZWQgPSAkKCc8dHI+PHRkLz48L3RyPicpLmFkZENsYXNzKGspO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCd0ZCcsIGNyZWF0ZWQpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoaylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKHIpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMF0uY29sU3BhbiA9IF9mblZpc2JsZUNvbHVtbnMoY3R4KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChjcmVhdGVkWzBdKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGFkZFJvdyhkYXRhLCBrbGFzcyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5fZGV0YWlscykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5yZW1vdmUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByb3cuX2RldGFpbHMgPSAkKHJvd3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjaGlsZHJlbiB3ZXJlIGFscmVhZHkgc2hvd24sIHRoYXQgc3RhdGUgc2hvdWxkIGJlIHJldGFpbmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm93Ll9kZXRhaWxzU2hvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlcihyb3cublRyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19kZXRhaWxzX3JlbW92ZSA9IGZ1bmN0aW9uIChhcGksIGlkeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGFwaS5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbaWR4ICE9PSB1bmRlZmluZWQgPyBpZHggOiBhcGlbMF1dO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93Ll9kZXRhaWxzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5yZW1vdmUoKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlsc1Nob3cgPSB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscyA9IHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fZGV0YWlsc19kaXNwbGF5ID0gZnVuY3Rpb24gKGFwaSwgc2hvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IGFwaS5jb250ZXh0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoICYmIGFwaS5sZW5ndGgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVthcGlbMF1dO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93Ll9kZXRhaWxzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlsc1Nob3cgPSBzaG93O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3cpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlcihyb3cublRyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5kZXRhY2goKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kZXRhaWxzX2V2ZW50cyhjdHhbMF0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19kZXRhaWxzX2V2ZW50cyA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFwaSA9IG5ldyBfQXBpKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSAnLmR0LkRUX2RldGFpbHMnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdFdmVudCA9ICdkcmF3JyArIG5hbWVzcGFjZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x2aXNFdmVudCA9ICdjb2x1bW4tdmlzaWJpbGl0eScgKyBuYW1lc3BhY2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVzdHJveUV2ZW50ID0gJ2Rlc3Ryb3knICsgbmFtZXNwYWNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgYXBpLm9mZihkcmF3RXZlbnQgKyAnICcgKyBjb2x2aXNFdmVudCArICcgJyArIGRlc3Ryb3lFdmVudCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKF9wbHVjayhkYXRhLCAnX2RldGFpbHMnKS5sZW5ndGggPiAwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT24gZWFjaCBkcmF3LCBpbnNlcnQgdGhlIHJlcXVpcmVkIGVsZW1lbnRzIGludG8gdGhlIGRvY3VtZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXBpLm9uKGRyYXdFdmVudCwgZnVuY3Rpb24gKGUsIGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkucm93cyh7IHBhZ2U6ICdjdXJyZW50JyB9KS5lcSgwKS5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludGVybmFsIGRhdGEgZ3JhYlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRhdGFbaWR4XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93Ll9kZXRhaWxzU2hvdykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5pbnNlcnRBZnRlcihyb3cublRyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZSAtIHVwZGF0ZSB0aGUgY29sc3BhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5vbihjb2x2aXNFdmVudCwgZnVuY3Rpb24gKGUsIGN0eCwgaWR4LCB2aXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzICE9PSBjdHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjb2xzcGFuIGZvciB0aGUgZGV0YWlscyByb3dzIChub3RlLCBvbmx5IGlmIGl0IGFscmVhZHkgaGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgY29sc3BhbilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdywgdmlzaWJsZSA9IF9mblZpc2JsZUNvbHVtbnMoY3R4KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBkYXRhLmxlbmd0aCA7IGkgPCBpZW4gOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGRhdGFbaV07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5fZGV0YWlscykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5jaGlsZHJlbigndGRbY29sc3Bhbl0nKS5hdHRyKCdjb2xzcGFuJywgdmlzaWJsZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFibGUgZGVzdHJveWVkIC0gbnVrZSBhbnkgY2hpbGQgcm93c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5vbihkZXN0cm95RXZlbnQsIGZ1bmN0aW9uIChlLCBjdHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzICE9PSBjdHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0uX2RldGFpbHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX2RldGFpbHNfcmVtb3ZlKGFwaSwgaSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIFN0cmluZ3MgZm9yIHRoZSBtZXRob2QgbmFtZXMgdG8gaGVscCBtaW5pZmljYXRpb25cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9lbXAgPSAnJztcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9jaGlsZF9vYmogPSBfZW1wICsgJ3JvdygpLmNoaWxkJztcclxuXHQgICAgICAgICAgICAgICAgdmFyIF9jaGlsZF9tdGggPSBfY2hpbGRfb2JqICsgJygpJztcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIGRhdGEgY2FuIGJlOlxyXG5cdCAgICAgICAgICAgICAgICAvLyAgdHJcclxuXHQgICAgICAgICAgICAgICAgLy8gIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAvLyAgalF1ZXJ5IG9yIGFycmF5IG9mIGFueSBvZiB0aGUgYWJvdmVcclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcihfY2hpbGRfbXRoLCBmdW5jdGlvbiAoZGF0YSwga2xhc3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4WzBdLmFvRGF0YVt0aGlzWzBdXS5fZGV0YWlscyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEgPT09IHRydWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zaG93KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSBmYWxzZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9fZGV0YWlsc19yZW1vdmUodGhpcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX19kZXRhaWxzX2FkZChjdHhbMF0sIGN0eFswXS5hb0RhdGFbdGhpc1swXV0sIGRhdGEsIGtsYXNzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcihbXHJcblx0ICAgICAgICAgICAgICAgICAgICBfY2hpbGRfb2JqICsgJy5zaG93KCknLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2NoaWxkX210aCArICcuc2hvdygpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XHJcblx0ICAgICAgICAgICAgICAgIF0sIGZ1bmN0aW9uIChzaG93KSB7ICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcclxuXHQgICAgICAgICAgICAgICAgICAgIF9fZGV0YWlsc19kaXNwbGF5KHRoaXMsIHRydWUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2NoaWxkX29iaiArICcuaGlkZSgpJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9jaGlsZF9tdGggKyAnLmhpZGUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxyXG5cdCAgICAgICAgICAgICAgICBdLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcclxuXHQgICAgICAgICAgICAgICAgICAgIF9fZGV0YWlsc19kaXNwbGF5KHRoaXMsIGZhbHNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKFtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9jaGlsZF9vYmogKyAnLnJlbW92ZSgpJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9jaGlsZF9tdGggKyAnLnJlbW92ZSgpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XHJcblx0ICAgICAgICAgICAgICAgIF0sIGZ1bmN0aW9uICgpIHsgICAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXHJcblx0ICAgICAgICAgICAgICAgICAgICBfX2RldGFpbHNfcmVtb3ZlKHRoaXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoX2NoaWxkX29iaiArICcuaXNTaG93bigpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIF9kZXRhaWxzU2hvd24gYXMgZmFsc2Ugb3IgdW5kZWZpbmVkIHdpbGwgZmFsbCB0aHJvdWdoIHRvIHJldHVybiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLl9kZXRhaWxzU2hvdyB8fCBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIHtpbnRlZ2VyfSAgICAgICAgICAgLSBjb2x1bW4gaW5kZXggKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXHJcblx0ICAgICAgICAgICAgICAgICAqIFwie2ludGVnZXJ9OnZpc0lkeFwiICAtIHZpc2libGUgY29sdW1uIGluZGV4IChpLmUuIHRyYW5zbGF0ZSB0byBjb2x1bW4gaW5kZXgpICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcclxuXHQgICAgICAgICAgICAgICAgICogXCJ7aW50ZWdlcn06dmlzaWJsZVwiIC0gYWxpYXMgZm9yIHtpbnRlZ2VyfTp2aXNJZHggICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxyXG5cdCAgICAgICAgICAgICAgICAgKiBcIntzdHJpbmd9Om5hbWVcIiAgICAgLSBjb2x1bW4gbmFtZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBcIntzdHJpbmd9XCIgICAgICAgICAgLSBqUXVlcnkgc2VsZWN0b3Igb24gY29sdW1uIGhlYWRlciBub2Rlc1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIGNhbiBiZSBhbiBhcnJheSBvZiB0aGVzZSBpdGVtcywgY29tbWEgc2VwYXJhdGVkIGxpc3QsIG9yIGFuIGFycmF5IG9mIGNvbW1hXHJcblx0ICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRlZCBsaXN0c1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fcmVfY29sdW1uX3NlbGVjdG9yID0gL14oLispOihuYW1lfHZpc0lkeHx2aXNpYmxlKSQvO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIHIxIGFuZCByMiBhcmUgcmVkdW5kYW50IC0gYnV0IGl0IG1lYW5zIHRoYXQgdGhlIHBhcmFtZXRlcnMgbWF0Y2ggZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAvLyBpdGVyYXRvciBjYWxsYmFjayBpbiBjb2x1bW5zKCkuZGF0YSgpXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX2NvbHVtbkRhdGEgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbiwgcjEsIHIyLCByb3dzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMCwgaWVuID0gcm93cy5sZW5ndGggOyByb3cgPCBpZW4gOyByb3crKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93c1tyb3ddLCBjb2x1bW4pKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX2NvbHVtbl9zZWxlY3RvciA9IGZ1bmN0aW9uIChzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMgPSBfcGx1Y2soY29sdW1ucywgJ3NOYW1lJyksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSBfcGx1Y2soY29sdW1ucywgJ25UaCcpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBydW4gPSBmdW5jdGlvbiAocykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWxJbnQgPSBfaW50VmFsKHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGFsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09PSAnJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JhbmdlKGNvbHVtbnMubGVuZ3RoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsSW50ICE9PSBudWxsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbc2VsSW50ID49IDAgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsSW50IDogLy8gQ291bnQgZnJvbSBsZWZ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLmxlbmd0aCArIHNlbEludCAvLyBDb3VudCBmcm9tIHJpZ2h0ICgrIGJlY2F1c2UgaXRzIGEgbmVnYXRpdmUgdmFsdWUpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciA9IGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKHNldHRpbmdzLCBvcHRzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fY29sdW1uRGF0YShzZXR0aW5ncywgaWR4LCAwLCAwLCByb3dzKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbaWR4XVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgPyBpZHggOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBvciBzdHJpbmcgc2VsZWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0eXBlb2YgcyA9PT0gJ3N0cmluZycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm1hdGNoKF9fcmVfY29sdW1uX3NlbGVjdG9yKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtYXRjaFsyXSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlzSWR4JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Zpc2libGUnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZpc2libGUgaW5kZXggZ2l2ZW4sIGNvbnZlcnQgdG8gY29sdW1uIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnRpbmcgZnJvbSB0aGUgcmlnaHRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc0NvbHVtbnMgPSAkLm1hcChjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sLmJWaXNpYmxlID8gaSA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Zpc0NvbHVtbnNbdmlzQ29sdW1ucy5sZW5ndGggKyBpZHhdXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnRpbmcgZnJvbSB0aGUgbGVmdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoc2V0dGluZ3MsIGlkeCldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoIGJ5IG5hbWUuIGBuYW1lc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChuYW1lcywgZnVuY3Rpb24gKG5hbWUsIGkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IG1hdGNoWzFdID8gaSA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgVEggZWxlbWVudHMgZm9yIHRoZSBjb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKG5vZGVzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQuaW5BcnJheSh0aGlzLCBub2Rlcyk7IC8vIGBub2Rlc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX3J1bignY29sdW1uJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMpO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBfX3NldENvbHVtblZpcyA9IGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCB2aXMsIHJlY2FsYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29scyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2wgPSBjb2xzW2NvbHVtbl0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHNldHRpbmdzLmFvRGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByb3csIGNlbGxzLCBpLCBpZW4sIHRyO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZpcyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbC5iVmlzaWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE5vIGNoYW5nZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5iVmlzaWJsZSA9PT0gdmlzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh2aXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBkZWNpZGUgaWYgd2Ugc2hvdWxkIHVzZSBhcHBlbmRDaGlsZCBvciBpbnNlcnRCZWZvcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0QmVmb3JlID0gJC5pbkFycmF5KHRydWUsIF9wbHVjayhjb2xzLCAnYlZpc2libGUnKSwgY29sdW1uICsgMSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoIDsgaSA8IGllbiA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ciA9IGRhdGFbaV0ublRyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxscyA9IGRhdGFbaV0uYW5DZWxscztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0QmVmb3JlIGNhbiBhY3QgbGlrZSBhcHBlbmRDaGlsZCBpZiAybmQgYXJnIGlzIG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmluc2VydEJlZm9yZShjZWxsc1tjb2x1bW5dLCBjZWxsc1tpbnNlcnRCZWZvcmVdIHx8IG51bGwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQoX3BsdWNrKHNldHRpbmdzLmFvRGF0YSwgJ2FuQ2VsbHMnLCBjb2x1bW4pKS5kZXRhY2goKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDb21tb24gYWN0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sLmJWaXNpYmxlID0gdmlzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRHJhd0hlYWQoc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkRyYXdIZWFkKHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3Rlcik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2FsYyA9PT0gdW5kZWZpbmVkIHx8IHJlY2FsYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgYWRqdXN0IGNvbHVtbiBzaXppbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGp1c3RDb2x1bW5TaXppbmcoc2V0dGluZ3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWFsaWduIGNvbHVtbnMgZm9yIHNjcm9sbGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5vU2Nyb2xsLnNYIHx8IHNldHRpbmdzLm9TY3JvbGwuc1kpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU2Nyb2xsRHJhdyhzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ2NvbHVtbi12aXNpYmlsaXR5JywgW3NldHRpbmdzLCBjb2x1bW4sIHZpc10pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNhdmVTdGF0ZShzZXR0aW5ncyk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY29sdW1ucygpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBzaGlmdGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KHNlbGVjdG9yKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBzZWxlY3RvcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBfc2VsZWN0b3Jfb3B0cyhvcHRzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fY29sdW1uX3NlbGVjdG9yKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9yb3dfc2VsZWN0b3I/XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbnN0LnNlbGVjdG9yLmNvbHMgPSBzZWxlY3RvcjtcclxuXHQgICAgICAgICAgICAgICAgICAgIGluc3Quc2VsZWN0b3Iub3B0cyA9IG9wdHM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3Q7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmhlYWRlcigpJywgJ2NvbHVtbigpLmhlYWRlcigpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmZvb3RlcigpJywgJ2NvbHVtbigpLmZvb3RlcigpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0ublRmO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmRhdGEoKScsICdjb2x1bW4oKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uLXJvd3MnLCBfX2NvbHVtbkRhdGEsIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NvbHVtbnMoKS5kYXRhU3JjKCknLCAnY29sdW1uKCkuZGF0YVNyYygpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NvbHVtbicsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm1EYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmNhY2hlKCknLCAnY29sdW1uKCkuY2FjaGUoKScsIGZ1bmN0aW9uICh0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcGx1Y2tfb3JkZXIoc2V0dGluZ3MuYW9EYXRhLCByb3dzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnc2VhcmNoJyA/ICdfYUZpbHRlckRhdGEnIDogJ19hU29ydERhdGEnLCBjb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLm5vZGVzKCknLCAnY29sdW1uKCkubm9kZXMoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4tcm93cycsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9wbHVja19vcmRlcihzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdhbkNlbGxzJywgY29sdW1uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NvbHVtbnMoKS52aXNpYmxlKCknLCAnY29sdW1uKCkudmlzaWJsZSgpJywgZnVuY3Rpb24gKHZpcywgY2FsYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NvbHVtbicsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpcyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5iVmlzaWJsZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfX3NldENvbHVtblZpcyhzZXR0aW5ncywgY29sdW1uLCB2aXMsIGNhbGMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmluZGV4ZXMoKScsICdjb2x1bW4oKS5pbmRleCgpJywgZnVuY3Rpb24gKHR5cGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAndmlzaWJsZScgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZShzZXR0aW5ncywgY29sdW1uKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2NvbHVtbnMuYWRqdXN0KCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGp1c3RDb2x1bW5TaXppbmcoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY29sdW1uLmluZGV4KCknLCBmdW5jdGlvbiAodHlwZSwgaWR4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZnJvbVZpc2libGUnIHx8IHR5cGUgPT09ICd0b0RhdGEnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChjdHgsIGlkeCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmcm9tRGF0YScgfHwgdHlwZSA9PT0gJ3RvVmlzaWJsZScpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKGN0eCwgaWR4KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY29sdW1uKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2VsZWN0b3JfZmlyc3QodGhpcy5jb2x1bW5zKHNlbGVjdG9yLCBvcHRzKSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIF9fY2VsbF9zZWxlY3RvciA9IGZ1bmN0aW9uIChzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoc2V0dGluZ3MsIG9wdHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gX3JlbW92ZUVtcHR5KF9wbHVja19vcmRlcihkYXRhLCByb3dzLCAnYW5DZWxscycpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhbGxDZWxscyA9ICQoW10uY29uY2F0LmFwcGx5KFtdLCBjZWxscykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvdztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBhLCBpLCBpZW4sIGosIG8sIGhvc3Q7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuU2VsZWN0b3IgPSB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09IG51bGwgfHwgcyA9PT0gdW5kZWZpbmVkIHx8IGZuU2VsZWN0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGNlbGxzIGFuZCBmdW5jdGlvbiBzZWxlY3RvcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gcm93cy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSByb3dzW2ldO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAgOyBqIDwgY29sdW1ucyA7IGorKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG8gPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm5TZWxlY3Rvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3QgPSBzZXR0aW5ncy5hb0RhdGFbcm93XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzKG8sIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3csIGopLCBob3N0LmFuQ2VsbHMgPyBob3N0LmFuQ2VsbHNbal0gOiBudWxsKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG8pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGFsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gobyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gaW5kZXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHMpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbc107XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGpRdWVyeSBmaWx0ZXJlZCBjZWxsc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxDZWxsc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHMpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGksIGVsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBlbC5wYXJlbnROb2RlLl9EVF9Sb3dJbmRleDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogJC5pbkFycmF5KGVsLCBkYXRhW3Jvd10uYW5DZWxscylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2VsZWN0b3JfcnVuKCdjZWxsJywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMpO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY2VsbHMoKScsIGZ1bmN0aW9uIChyb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEFyZ3VtZW50IHNoaWZ0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHJvd1NlbGVjdG9yKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluZGV4ZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93U2VsZWN0b3Iucm93ID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3Igb3B0aW9ucyBpbiBmaXJzdCBwYXJhbWV0ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IHJvd1NlbGVjdG9yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3dTZWxlY3RvciA9IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDZWxsIGluZGV4IG9iamVjdHMgaW4gZmlyc3QgcGFyYW1ldGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMgPSBjb2x1bW5TZWxlY3RvcjtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uU2VsZWN0b3IgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoY29sdW1uU2VsZWN0b3IpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0cyA9IGNvbHVtblNlbGVjdG9yO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblNlbGVjdG9yID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBDZWxsIHNlbGVjdG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uU2VsZWN0b3IgPT09IG51bGwgfHwgY29sdW1uU2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19jZWxsX3NlbGVjdG9yKHNldHRpbmdzLCByb3dTZWxlY3RvciwgX3NlbGVjdG9yX29wdHMob3B0cykpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJvdyArIGNvbHVtbiBzZWxlY3RvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoY29sdW1uU2VsZWN0b3IsIG9wdHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLnJvd3Mocm93U2VsZWN0b3IsIG9wdHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGEsIGksIGllbiwgaiwgamVuO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzLCBpZHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHJvd3NbaWR4XS5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGNvbHVtbnNbaWR4XS5sZW5ndGggOyBqIDwgamVuIDsgaisrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93c1tpZHhdW2ldLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogY29sdW1uc1tpZHhdW2pdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChjZWxscy5zZWxlY3Rvciwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbHM6IGNvbHVtblNlbGVjdG9yLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvd3M6IHJvd1NlbGVjdG9yLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdHM6IG9wdHNcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxscztcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY2VsbHMoKS5ub2RlcygpJywgJ2NlbGwoKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbHMgPSBzZXR0aW5ncy5hb0RhdGFbcm93XS5hbkNlbGxzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWxscyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxzW2NvbHVtbl0gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY2VsbHMoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvdywgY29sdW1uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLmNhY2hlKCknLCAnY2VsbCgpLmNhY2hlKCknLCBmdW5jdGlvbiAodHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YSc7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NlbGwnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdywgY29sdW1uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmFvRGF0YVtyb3ddW3R5cGVdW2NvbHVtbl07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY2VsbHMoKS5yZW5kZXIoKScsICdjZWxsKCkucmVuZGVyKCknLCBmdW5jdGlvbiAodHlwZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NlbGwnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdywgY29sdW1uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3csIGNvbHVtbiwgdHlwZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LCAxKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY2VsbHMoKS5pbmRleGVzKCknLCAnY2VsbCgpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY2VsbCcsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93LCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblZpc2libGU6IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKHNldHRpbmdzLCBjb2x1bW4pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sIDEpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLmludmFsaWRhdGUoKScsICdjZWxsKCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKHNyYykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NlbGwnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdywgY29sdW1uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW52YWxpZGF0ZShzZXR0aW5ncywgcm93LCBzcmMsIGNvbHVtbik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2NlbGwoKScsIGZ1bmN0aW9uIChyb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfc2VsZWN0b3JfZmlyc3QodGhpcy5jZWxscyhyb3dTZWxlY3RvciwgY29sdW1uU2VsZWN0b3IsIG9wdHMpKTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY2VsbCgpLmRhdGEoKScsIGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzWzBdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCAmJiBjZWxsLmxlbmd0aCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkdldENlbGxEYXRhKGN0eFswXSwgY2VsbFswXS5yb3csIGNlbGxbMF0uY29sdW1uKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNldENlbGxEYXRhKGN0eFswXSwgY2VsbFswXS5yb3csIGNlbGxbMF0uY29sdW1uLCBkYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkludmFsaWRhdGUoY3R4WzBdLCBjZWxsWzBdLnJvdywgJ2RhdGEnLCBjZWxsWzBdLmNvbHVtbik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IGN1cnJlbnQgb3JkZXJpbmcgKHNvcnRpbmcpIHRoYXQgaGFzIGJlZW4gYXBwbGllZCB0byB0aGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHthcnJheX0gMkQgYXJyYXkgY29udGFpbmluZyB0aGUgc29ydGluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0XHJcblx0ICAgICAgICAgICAgICAgICAqICAgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC4gRWFjaCBlbGVtZW50IGluIHRoZSBwYXJlbnQgYXJyYXkgcmVwcmVzZW50c1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgMiBpbm5lciBhcnJheXMpLiBUaGUgaW5uZXIgYXJyYXlzIG1heSBoYXZlIDIgb3IgMyBlbGVtZW50cy4gVGhlIGZpcnN0IGlzXHJcblx0ICAgICAgICAgICAgICAgICAqICAgdGhlIGNvbHVtbiBpbmRleCB0aGF0IHRoZSBzb3J0aW5nIGNvbmRpdGlvbiBhcHBsaWVzIHRvLCB0aGUgc2Vjb25kIGlzIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICogICBpbmRleCBvZiB0aGUgc29ydGluZyBvcmRlciBmcm9tIHRoZSBgY29sdW1uLnNvcnRpbmdgIGluaXRpYWxpc2F0aW9uIGFycmF5LlxyXG5cdCAgICAgICAgICAgICAgICAgKi8vKipcclxuXHRcdCAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge2ludGVnZXJ9IG9yZGVyIENvbHVtbiBpbmRleCB0byBzb3J0IHVwb24uXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIERpcmVjdGlvbiBvZiB0aGUgc29ydCB0byBiZSBhcHBsaWVkIChgYXNjYCBvciBgZGVzY2ApXHJcblx0XHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuXHRcdCAqLy8qKlxyXG5cdFx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDFEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cclxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IFsuLi5dIE9wdGlvbmFsIGFkZGl0aW9uYWwgc29ydGluZyBjb25kaXRpb25zXHJcblx0XHQgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuXHRcdCAqLy8qKlxyXG5cdFx0ICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDJEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cclxuXHRcdCAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xyXG5cdFx0ICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ29yZGVyKCknLCBmdW5jdGlvbiAob3JkZXIsIGRpcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXIgPT09IHVuZGVmaW5lZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4WzBdLmFhU29ydGluZyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JkZXIgPT09ICdudW1iZXInKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGxlIGNvbHVtbiAvIGRpcmVjdGlvbiBwYXNzZWQgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmRlciA9IFtbb3JkZXIsIGRpcl1dO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoISQuaXNBcnJheShvcmRlclswXSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcmd1bWVudHMgcGFzc2VkIGluIChsaXN0IG9mIDFEIGFycmF5cylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgYSAyRCBhcnJheSB3YXMgcGFzc2VkIGluXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nID0gb3JkZXIuc2xpY2UoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge25vZGV8alF1ZXJ5fHN0cmluZ30gbm9kZSBJZGVudGlmaWVyIGZvciB0aGUgZWxlbWVudChzKSB0byBhdHRhY2ggdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgbGlzdGVuZXIgdG8uIFRoaXMgY2FuIHRha2UgdGhlIGZvcm0gb2YgYSBzaW5nbGUgRE9NIG5vZGUsIGEgalF1ZXJ5XHJcblx0ICAgICAgICAgICAgICAgICAqICAgY29sbGVjdGlvbiBvZiBub2RlcyBvciBhIGpRdWVyeSBzZWxlY3RvciB3aGljaCB3aWxsIGlkZW50aWZ5IHRoZSBub2RlKHMpLlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGNvbHVtbiB0aGUgY29sdW1uIHRoYXQgYSBjbGljayBvbiB0aGlzIG5vZGUgd2lsbCBzb3J0IG9uXHJcblx0ICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBzb3J0IGlzIHJ1blxyXG5cdCAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ29yZGVyLmxpc3RlbmVyKCknLCBmdW5jdGlvbiAobm9kZSwgY29sdW1uLCBjYWxsYmFjaykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydEF0dGFjaExpc3RlbmVyKHNldHRpbmdzLCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbnMoKS5vcmRlcigpJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICdjb2x1bW4oKS5vcmRlcigpJ1xyXG5cdCAgICAgICAgICAgICAgICBdLCBmdW5jdGlvbiAoZGlyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzLCBpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnQgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHRoYXRbaV0sIGZ1bmN0aW9uIChqLCBjb2wpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydC5wdXNoKFtjb2wsIGRpcl0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hYVNvcnRpbmcgPSBzb3J0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzZWFyY2goKScsIGZ1bmN0aW9uIChpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCAhPT0gMCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eFswXS5vUHJldmlvdXNTZWFyY2guc1NlYXJjaCA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ29tcGxldGUoc2V0dGluZ3MsICQuZXh0ZW5kKHt9LCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzU2VhcmNoXCI6IGlucHV0ICsgXCJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiUmVnZXhcIjogcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJTbWFydFwiOiBzbWFydCA9PT0gbnVsbCA/IHRydWUgOiBzbWFydCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiQ2FzZUluc2Vuc2l0aXZlXCI6IGNhc2VJbnNlbiA9PT0gbnVsbCA/IHRydWUgOiBjYXNlSW5zZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbChcclxuXHQgICAgICAgICAgICAgICAgICAgICdjb2x1bW5zKCkuc2VhcmNoKCknLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbigpLnNlYXJjaCgpJyxcclxuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZVNlYXJjaCA9IHNldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVTZWFyY2hbY29sdW1uXS5zU2VhcmNoO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChwcmVTZWFyY2hbY29sdW1uXSwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzU2VhcmNoXCI6IGlucHV0ICsgXCJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlJlZ2V4XCI6IHJlZ2V4ID09PSBudWxsID8gZmFsc2UgOiByZWdleCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNtYXJ0XCI6IHNtYXJ0ID09PSBudWxsID8gdHJ1ZSA6IHNtYXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiQ2FzZUluc2Vuc2l0aXZlXCI6IGNhc2VJbnNlbiA9PT0gbnVsbCA/IHRydWUgOiBjYXNlSW5zZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDb21wbGV0ZShzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qXHJcblx0ICAgICAgICAgICAgICAgICAqIFN0YXRlIEFQSSBtZXRob2RzXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcignc3RhdGUoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRbMF0ub1NhdmVkU3RhdGUgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3N0YXRlLmNsZWFyKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIGFuIGVtcHR5IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmZuU3RhdGVTYXZlQ2FsbGJhY2suY2FsbChzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCB7fSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcignc3RhdGUubG9hZGVkKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0WzBdLm9Mb2FkZWRTdGF0ZSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3Rlcignc3RhdGUuc2F2ZSgpJywgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU2F2ZVN0YXRlKHNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFByb3ZpZGUgYSBjb21tb24gbWV0aG9kIGZvciBwbHVnLWlucyB0byBjaGVjayB0aGUgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGJlaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqIHVzZWQsIGluIG9yZGVyIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gVmVyc2lvbiBzdHJpbmcgdG8gY2hlY2sgZm9yLCBpbiB0aGUgZm9ybWF0IFwiWC5ZLlpcIi5cclxuXHQgICAgICAgICAgICAgICAgICogICAgTm90ZSB0aGF0IHRoZSBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIHRoZSByZXF1aXJlZCB2ZXJzaW9uLCBvciBmYWxzZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhbGVzIGlzIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBzdWl0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHN0YXRpY1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSS1TdGF0aWNcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGFsZXJ0KCAkLmZuLmRhdGFUYWJsZS52ZXJzaW9uQ2hlY2soICcxLjkuMCcgKSApO1xyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLnZlcnNpb25DaGVjayA9IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYVRoaXMgPSBEYXRhVGFibGUudmVyc2lvbi5zcGxpdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFUaGF0ID0gdmVyc2lvbi5zcGxpdCgnLicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlUaGlzLCBpVGhhdDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGFUaGF0Lmxlbmd0aCA7IGkgPCBpTGVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaVRoaXMgPSBwYXJzZUludChhVGhpc1tpXSwgMTApIHx8IDA7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaVRoYXQgPSBwYXJzZUludChhVGhhdFtpXSwgMTApIHx8IDA7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnRzIGFyZSB0aGUgc2FtZSwga2VlcCBjb21wYXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaVRoaXMgPT09IGlUaGF0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFydHMgYXJlIGRpZmZlcmVudCwgcmV0dXJuIGltbWVkaWF0ZWx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlUaGlzID4gaVRoYXQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIENoZWNrIGlmIGEgYDx0YWJsZT5gIG5vZGUgaXMgYSBEYXRhVGFibGUgdGFibGUgYWxyZWFkeSBvciBub3QuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV8anF1ZXJ5fHN0cmluZ30gdGFibGUgVGFibGUgbm9kZSwgalF1ZXJ5IG9iamVjdCBvciBqUXVlcnlcclxuXHQgICAgICAgICAgICAgICAgICogICAgICBzZWxlY3RvciBmb3IgdGhlIHRhYmxlIHRvIHRlc3QuIE5vdGUgdGhhdCBpZiBtb3JlIHRoYW4gbW9yZSB0aGFuIG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgIHRhYmxlIGlzIHBhc3NlZCBvbiwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBjaGVja2VkXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB0aGUgdGFibGUgZ2l2ZW4gaXMgYSBEYXRhVGFibGUsIG9yIGZhbHNlIG90aGVyd2lzZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHN0YXRpY1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEFQSS1TdGF0aWNcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGlmICggISAkLmZuLkRhdGFUYWJsZS5pc0RhdGFUYWJsZSggJyNleGFtcGxlJyApICkge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIERhdGFUYWJsZS5pc0RhdGFUYWJsZSA9IERhdGFUYWJsZS5mbklzRGF0YVRhYmxlID0gZnVuY3Rpb24gKHRhYmxlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9ICQodGFibGUpLmdldCgwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpcyA9IGZhbHNlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICQuZWFjaChEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChpLCBvKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvb3QgPSBvLm5TY3JvbGxGb290ID8gJCgndGFibGUnLCBvLm5TY3JvbGxGb290KVswXSA6IG51bGw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvLm5UYWJsZSA9PT0gdCB8fCBoZWFkID09PSB0IHx8IGZvb3QgPT09IHQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpcztcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogR2V0IGFsbCBEYXRhVGFibGUgdGFibGVzIHRoYXQgaGF2ZSBiZWVuIGluaXRpYWxpc2VkIC0gb3B0aW9uYWxseSB5b3UgY2FuXHJcblx0ICAgICAgICAgICAgICAgICAqIHNlbGVjdCB0byBnZXQgb25seSBjdXJyZW50bHkgdmlzaWJsZSB0YWJsZXMuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IFt2aXNpYmxlPWZhbHNlXSBGbGFnIHRvIGluZGljYXRlIGlmIHlvdSB3YW50IGFsbCAoZGVmYXVsdClcclxuXHQgICAgICAgICAgICAgICAgICogICAgb3IgdmlzaWJsZSB0YWJsZXMgb25seS5cclxuXHQgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgYHRhYmxlYCBub2RlcyAobm90IERhdGFUYWJsZSBpbnN0YW5jZXMpIHdoaWNoIGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBEYXRhVGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICAqICBAc3RhdGljXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQVBJLVN0YXRpY1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAgJC5lYWNoKCAkLmZuLmRhdGFUYWJsZS50YWJsZXModHJ1ZSksIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAkKHRhYmxlKS5EYXRhVGFibGUoKS5jb2x1bW5zLmFkanVzdCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUudGFibGVzID0gRGF0YVRhYmxlLmZuVGFibGVzID0gZnVuY3Rpb24gKHZpc2libGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChvKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpYmxlIHx8ICh2aXNpYmxlICYmICQoby5uVGFibGUpLmlzKCc6dmlzaWJsZScpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5uVGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgdXRpbGl0eSBtZXRob2RzXHJcblx0ICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgKiBUaGlzIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgbWV0aG9kcyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbnRlcm5hbGx5IHRvXHJcblx0ICAgICAgICAgICAgICAgICAqIGNyZWF0ZSBhIERhdGFUYWJsZSwgYnV0IHdoaWNoIGFyZSBub3QgZXhjbHVzaXZlbHkgdXNlZCBvbmx5IGZvciBEYXRhVGFibGVzLlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUaGVzZSBtZXRob2RzIGNhbiBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBhdXRob3JzIHRvIHNhdmUgdGhlIGR1cGxpY2F0aW9uIG9mXHJcblx0ICAgICAgICAgICAgICAgICAqIGNvZGUuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUudXRpbCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhyb3R0bGUgdGhlIGNhbGxzIHRvIGEgZnVuY3Rpb24uIEFyZ3VtZW50cyBhbmQgY29udGV4dCBhcmUgbWFpbnRhaW5lZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZm9yIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGZyZXEgQ2FsbCBmcmVxdWVuY3kgaW4gbVNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHRocm90dGxlOiBfZm5UaHJvdHRsZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzVmFsIHN0cmluZyB0byBlc2NhcGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSBlc2NhcGVkIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBlc2NhcGVSZWdleDogX2ZuRXNjYXBlUmVnZXhcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ29udmVydCBmcm9tIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBIdW5nYXJpYW4gbm90YXRpb24uIFRoaXMgaXMgbWFkZSBwdWJsaWNcclxuXHQgICAgICAgICAgICAgICAgICogZm9yIHRoZSBleHRlbnNpb25zIHRvIHByb3ZpZGUgdGhlIHNhbWUgYWJpbGl0eSBhcyBEYXRhVGFibGVzIGNvcmUgdG8gYWNjZXB0XHJcblx0ICAgICAgICAgICAgICAgICAqIGVpdGhlciB0aGUgMS45IHN0eWxlIEh1bmdhcmlhbiBub3RhdGlvbiwgb3IgdGhlIDEuMTArIHN0eWxlIGNhbWVsQ2FzZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBwYXJhbWV0ZXJzLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBUaGUgbW9kZWwgb2JqZWN0IHdoaWNoIGhvbGRzIGFsbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIG1hcHBlZC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGVuIHNldCB0byBgdHJ1ZWAsIHByb3BlcnRpZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGFcclxuXHQgICAgICAgICAgICAgICAgICogICAgSHVuZ2FyaWFuIHZhbHVlIGluIHRoZSBgdXNlcmAgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIE90aGVyd2lzZSB0aGV5XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIHdvbid0IGJlLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLmNhbWVsVG9IdW5nYXJpYW4gPSBfZm5DYW1lbFRvSHVuZ2FyaWFuO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJyQoKScsIGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm93cyA9IHRoaXMucm93cyhvcHRzKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqcVJvd3MgPSAkKHJvd3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAkKFtdLmNvbmNhdChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBqcVJvd3MuZmlsdGVyKHNlbGVjdG9yKS50b0FycmF5KCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganFSb3dzLmZpbmQoc2VsZWN0b3IpLnRvQXJyYXkoKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgKSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiB0aGUgdGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICQuZWFjaChbJ29uJywgJ29uZScsICdvZmYnXSwgZnVuY3Rpb24gKGksIGtleSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcihrZXkgKyAnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGBkdGAgbmFtZXNwYWNlIGF1dG9tYXRpY2FsbHkgaWYgaXQgaXNuJ3QgYWxyZWFkeSBwcmVzZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhcmdzWzBdLm1hdGNoKC9cXC5kdFxcYi8pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gKz0gJy5kdCc7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdCA9ICQodGhpcy50YWJsZXMoKS5ub2RlcygpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbnN0W2tleV0uYXBwbHkoaW5zdCwgYXJncyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNsZWFyVGFibGUoc2V0dGluZ3MpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3NldHRpbmdzKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9BcGkodGhpcy5jb250ZXh0LCB0aGlzLmNvbnRleHQpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdpbml0KCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggPyBjdHhbMF0ub0luaXQgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdkYXRhKCknLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3BsdWNrKHNldHRpbmdzLmFvRGF0YSwgJ19hRGF0YScpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSkuZmxhdHRlbigpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKCdkZXN0cm95KCknLCBmdW5jdGlvbiAocmVtb3ZlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZW1vdmUgPSByZW1vdmUgfHwgZmFsc2U7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLnBhcmVudE5vZGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3NlcztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBzZXR0aW5ncy5uVGFibGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRib2R5ID0gc2V0dGluZ3MublRCb2R5O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVhZCA9IHNldHRpbmdzLm5USGVhZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGZvb3QgPSBzZXR0aW5ncy5uVEZvb3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpxVGFibGUgPSAkKHRhYmxlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIganFUYm9keSA9ICQodGJvZHkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqcVdyYXBwZXIgPSAkKHNldHRpbmdzLm5UYWJsZVdyYXBwZXIpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dzID0gJC5tYXAoc2V0dGluZ3MuYW9EYXRhLCBmdW5jdGlvbiAocikgeyByZXR1cm4gci5uVHI7IH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBpZW47XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsYWcgdG8gbm90ZSB0aGF0IHRoZSB0YWJsZSBpcyBjdXJyZW50bHkgYmVpbmcgZGVzdHJveWVkIC0gbm8gYWN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHRha2VuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYkRlc3Ryb3lpbmcgPSB0cnVlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJlIG9mZiB0aGUgZGVzdHJveSBjYWxsYmFja3MgZm9yIHBsdWctaW5zIGV0Y1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLCBcImRlc3Ryb3lcIiwgW3NldHRpbmdzXSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCBiZWluZyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50LCBtYWtlIGFsbCBjb2x1bW5zIHZpc2libGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbW92ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgX0FwaShzZXR0aW5ncykuY29sdW1ucygpLnZpc2libGUodHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBCbGl0eiBhbGwgYERUYCBuYW1lc3BhY2VkIGV2ZW50cyAodGhlc2UgYXJlIGludGVybmFsIGV2ZW50cywgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG93ZXJjYXNlLCBgZHRgIGV2ZW50cyBhcmUgdXNlciBzdWJzY3JpYmVkIGFuZCB0aGV5IGFyZSByZXNwb25zaWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciByZW1vdmluZyB0aGVtXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganFXcmFwcGVyLnVuYmluZCgnLkRUJykuZmluZCgnOm5vdCh0Ym9keSAqKScpLnVuYmluZCgnLkRUJyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLnVuYmluZCgnLkRULScgKyBzZXR0aW5ncy5zSW5zdGFuY2UpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHNjcm9sbGluZyB3ZSBoYWQgdG8gYnJlYWsgdGhlIHRhYmxlIHVwIC0gcmVzdG9yZSBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZSAhPSB0aGVhZC5wYXJlbnROb2RlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxVGFibGUuY2hpbGRyZW4oJ3RoZWFkJykuZGV0YWNoKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxVGFibGUuYXBwZW5kKHRoZWFkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Zm9vdCAmJiB0YWJsZSAhPSB0Zm9vdC5wYXJlbnROb2RlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxVGFibGUuY2hpbGRyZW4oJ3Rmb290JykuZGV0YWNoKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxVGFibGUuYXBwZW5kKHRmb290KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgRGF0YVRhYmxlcyBnZW5lcmF0ZWQgbm9kZXMsIGV2ZW50cyBhbmQgY2xhc3Nlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpxVGFibGUuZGV0YWNoKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganFXcmFwcGVyLmRldGFjaCgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hYVNvcnRpbmcgPSBbXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9mblNvcnRpbmdDbGFzc2VzKHNldHRpbmdzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJChyb3dzKS5yZW1vdmVDbGFzcyhzZXR0aW5ncy5hc1N0cmlwZUNsYXNzZXMuam9pbignICcpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJCgndGgsIHRkJywgdGhlYWQpLnJlbW92ZUNsYXNzKGNsYXNzZXMuc1NvcnRhYmxlICsgJyAnICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydGFibGVBc2MgKyAnICcgKyBjbGFzc2VzLnNTb3J0YWJsZURlc2MgKyAnICcgKyBjbGFzc2VzLnNTb3J0YWJsZU5vbmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYkpVSSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCd0aCBzcGFuLicgKyBjbGFzc2VzLnNTb3J0SWNvbiArICcsIHRkIHNwYW4uJyArIGNsYXNzZXMuc1NvcnRJY29uLCB0aGVhZCkuZGV0YWNoKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJ3RoLCB0ZCcsIHRoZWFkKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gJCgnZGl2LicgKyBjbGFzc2VzLnNTb3J0SlVJV3JhcHBlciwgdGhpcyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFwcGVuZCh3cmFwcGVyLmNvbnRlbnRzKCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5kZXRhY2goKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlbW92ZSAmJiBvcmlnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydEJlZm9yZSBhY3RzIGxpa2UgYXBwZW5kQ2hpbGQgaWYgIWFyZ1sxXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmluc2VydEJlZm9yZSh0YWJsZSwgc2V0dGluZ3MublRhYmxlUmVpbnNlcnRCZWZvcmUpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBUUiBlbGVtZW50cyBiYWNrIGludG8gdGhlIHRhYmxlIGluIHRoZWlyIG9yaWdpbmFsIG9yZGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganFUYm9keS5jaGlsZHJlbigpLmRldGFjaCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpxVGJvZHkuYXBwZW5kKHJvd3MpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSB3aWR0aCBvZiB0aGUgb3JpZ2luYWwgdGFibGUgLSB3YXMgcmVhZCBmcm9tIHRoZSBzdHlsZSBwcm9wZXJ0eSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4gcmVzdG9yZSBkaXJlY3RseSB0byB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAganFUYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCd3aWR0aCcsIHNldHRpbmdzLnNEZXN0cm95V2lkdGgpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhjbGFzc2VzLnNUYWJsZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB3ZXJlIG9yaWdpbmFsbHkgc3RyaXBlIGNsYXNzZXMgLSB0aGVuIHdlIGFkZCB0aGVtIGJhY2sgaGVyZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoaXMgaXMgbm90IGZvb2wgcHJvb2YgKGZvciBleGFtcGxlIGlmIG5vdCBhbGwgcm93cyBoYWQgc3RyaXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xhc3NlcyAtIGJ1dCBpdCdzIGEgZ29vZCBlZmZvcnQgd2l0aG91dCBnZXR0aW5nIGNhcnJpZWQgYXdheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGllbiA9IHNldHRpbmdzLmFzRGVzdHJveVN0cmlwZXMubGVuZ3RoO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWVuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxVGJvZHkuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uIChpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKHNldHRpbmdzLmFzRGVzdHJveVN0cmlwZXNbaSAlIGllbl0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlbW92ZSB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZyb20gdGhlIHNldHRpbmdzIGFycmF5ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9ICQuaW5BcnJheShzZXR0aW5ncywgRGF0YVRhYmxlLnNldHRpbmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXRhVGFibGUuc2V0dGluZ3Muc3BsaWNlKGlkeCwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgYGV2ZXJ5KClgIG1ldGhvZCBmb3Igcm93cywgY29sdW1ucyBhbmQgY2VsbHMgaW4gYSBjb21wYWN0IGZvcm1cclxuXHQgICAgICAgICAgICAgICAgJC5lYWNoKFsnY29sdW1uJywgJ3JvdycsICdjZWxsJ10sIGZ1bmN0aW9uIChpLCB0eXBlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfYXBpX3JlZ2lzdGVyKHR5cGUgKyAncygpLmV2ZXJ5KCknLCBmdW5jdGlvbiAoZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcih0eXBlLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGlkeCwgaWR4Mikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZHgyIGlzIHVuZGVmaW5lZCBmb3Igcm93cyBhbmQgY29sdW1ucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChuZXcgX0FwaShzZXR0aW5ncylbdHlwZV0oaWR4LCBpZHgyKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gaTE4biBtZXRob2QgZm9yIGV4dGVuc2lvbnMgdG8gYmUgYWJsZSB0byB1c2UgdGhlIGxhbmd1YWdlIG9iamVjdCBmcm9tIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVcclxuXHQgICAgICAgICAgICAgICAgX2FwaV9yZWdpc3RlcignaTE4bigpJywgZnVuY3Rpb24gKHRva2VuLCBkZWYsIHBsdXJhbCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IF9mbkdldE9iamVjdERhdGFGbih0b2tlbikoY3R4Lm9MYW5ndWFnZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9IGRlZjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGx1cmFsICE9PSB1bmRlZmluZWQgJiYgJC5pc1BsYWluT2JqZWN0KHJlc29sdmVkKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gcmVzb2x2ZWRbcGx1cmFsXSAhPT0gdW5kZWZpbmVkID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRbcGx1cmFsXSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkLl87XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkLnJlcGxhY2UoJyVkJywgcGx1cmFsKTsgLy8gbmI6IHBsdXJhbCBtaWdodCBiZSB1bmRlZmluZWQsXHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFZlcnNpb24gc3RyaW5nIGZvciBwbHVnLWlucyB0byBjaGVjayBjb21wYXRpYmlsaXR5LiBBbGxvd2VkIGZvcm1hdCBpc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBgYS5iLmMtZGAgd2hlcmU6IGE6aW50LCBiOmludCwgYzppbnQsIGQ6c3RyaW5nKGRldnxiZXRhfGFscGhhKS4gYGRgIGlzIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICogb25seSBmb3Igbm9uLXJlbGVhc2UgYnVpbGRzLiBTZWUgaHR0cDovL3NlbXZlci5vcmcvIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBWZXJzaW9uIG51bWJlclxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLnZlcnNpb24gPSBcIjEuMTAuN1wiO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFByaXZhdGUgZGF0YSBzdG9yZSwgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzIG9iamVjdHMgdGhhdCBhcmVcclxuXHQgICAgICAgICAgICAgICAgICogY3JlYXRlZCBmb3IgdGhlIHRhYmxlcyBvbiBhIGdpdmVuIHBhZ2UuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5zZXR0aW5nc2Agb2JqZWN0IGlzIGFsaWFzZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICogYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIHRocm91Z2ggd2hpY2ggaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBtYW5pcHVsYXRlZCwgb3IgYGpRdWVyeS5mbi5kYXRhVGFibGUuc2V0dGluZ3NgLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG1lbWJlclxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLnNldHRpbmdzID0gW107XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogT2JqZWN0IG1vZGVscyBjb250YWluZXIsIGZvciB0aGUgdmFyaW91cyBtb2RlbHMgdGhhdCBEYXRhVGFibGVzIGhhc1xyXG5cdCAgICAgICAgICAgICAgICAgKiBhdmFpbGFibGUgdG8gaXQuIFRoZXNlIG1vZGVscyBkZWZpbmUgdGhlIG9iamVjdHMgdGhhdCBhcmUgdXNlZCB0byBob2xkXHJcblx0ICAgICAgICAgICAgICAgICAqIHRoZSBhY3RpdmUgc3RhdGUgYW5kIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHRhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLm1vZGVscyA9IHt9O1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcclxuXHQgICAgICAgICAgICAgICAgICogc2VhcmNoIGluZm9ybWF0aW9uIGZvciB0aGUgZ2xvYmFsIGZpbHRlciBhbmQgaW5kaXZpZHVhbCBjb2x1bW4gZmlsdGVycy5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlIG9yIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYkNhc2VJbnNlbnNpdGl2ZVwiOiB0cnVlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXBwbGllZCBzZWFyY2ggdGVybVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU2VhcmNoXCI6IFwiXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcmVndWxhciBleHByZXNzaW9uICh0cnVlKSBvciBub3QgKGZhbHNlKSBhbmQgdGhlcmVmb3JlIGFuZCBzcGVjaWFsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByZWdleCBjaGFyYWN0ZXJzIGVzY2FwZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlJlZ2V4XCI6IGZhbHNlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRmxhZyB0byBpbmRpY2F0ZSBpZiBEYXRhVGFibGVzIGlzIHRvIHVzZSBpdHMgc21hcnQgZmlsdGVyaW5nIG9yIG5vdC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTbWFydFwiOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgd2F5IGluIHdoaWNoIERhdGFUYWJsZXMgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXRcclxuXHQgICAgICAgICAgICAgICAgICogZWFjaCBpbmRpdmlkdWFsIHJvdy4gVGhpcyBpcyB0aGUgb2JqZWN0IGZvcm1hdCB1c2VkIGZvciB0aGUgc2V0dGluZ3NcclxuXHQgICAgICAgICAgICAgICAgICogYW9EYXRhIGFycmF5LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLm1vZGVscy5vUm93ID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUUiBlbGVtZW50IGZvciB0aGUgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJuVHJcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFycmF5IG9mIFREIGVsZW1lbnRzIGZvciBlYWNoIHJvdy4gVGhpcyBpcyBudWxsIHVudGlsIHRoZSByb3cgaGFzIGJlZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNyZWF0ZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXkgbm9kZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFuQ2VsbHNcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERhdGEgb2JqZWN0IGZyb20gdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93LiBUaGlzIGlzIGVpdGhlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW4gYXJyYXkgaWYgdXNpbmcgdGhlIHRyYWRpdGlvbmFsIGZvcm0gb2YgRGF0YVRhYmxlcywgb3IgYW4gb2JqZWN0IGlmXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB1c2luZyBtRGF0YSBvcHRpb25zLiBUaGUgZXhhY3QgdHlwZSB3aWxsIGRlcGVuZCBvbiB0aGUgcGFzc2VkIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlLCBvciB3aWxsIGJlIGFuIGFycmF5IGlmIHVzaW5nIERPTSBhIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNvdXJjZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheXxvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9hRGF0YVwiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNvcnRpbmcgZGF0YSBjYWNoZSAtIHRoaXMgYXJyYXkgaXMgb3N0ZW5zaWJseSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBudW1iZXIgb2YgY29sdW1ucyAoYWx0aG91Z2ggZWFjaCBpbmRleCBpcyBnZW5lcmF0ZWQgb25seSBhcyBpdCBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbmVlZGVkKSwgYW5kIGhvbGRzIHRoZSBkYXRhIHRoYXQgaXMgdXNlZCBmb3Igc29ydGluZyBlYWNoIGNvbHVtbiBpbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJvdy4gV2UgZG8gdGhpcyBjYWNoZSBnZW5lcmF0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgc29ydCBpbiBvcmRlciB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZm9ybWF0dGluZyBvZiB0aGUgc29ydCBkYXRhIG5lZWQgYmUgZG9uZSBvbmx5IG9uY2UgZm9yIGVhY2ggY2VsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcGVyIHNvcnQuIFRoaXMgYXJyYXkgc2hvdWxkIG5vdCBiZSByZWFkIGZyb20gb3Igd3JpdHRlbiB0byBieSBhbnl0aGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3RoZXIgdGhhbiB0aGUgbWFzdGVyIHNvcnRpbmcgbWV0aG9kcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9hU29ydERhdGFcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFBlciBjZWxsIGZpbHRlcmluZyBkYXRhIGNhY2hlLiBBcyBwZXIgdGhlIHNvcnQgZGF0YSBjYWNoZSwgdXNlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwcml2YXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiX2FGaWx0ZXJEYXRhXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGaWx0ZXJpbmcgZGF0YSBjYWNoZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgY2VsbCBmaWx0ZXJpbmcgY2FjaGUsIGJ1dFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW4gdGhpcyBjYXNlIGEgc3RyaW5nIHJhdGhlciB0aGFuIGFuIGFycmF5LiBUaGlzIGlzIGVhc2lseSBjb21wdXRlZCB3aXRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhIGpvaW4gb24gYF9hRmlsdGVyRGF0YWAsIGJ1dCBpcyBwcm92aWRlZCBhcyBhIGNhY2hlIHNvIHRoZSBqb2luIGlzbid0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBuZWVkZWQgb24gZXZlcnkgc2VhcmNoIChtZW1vcnkgdHJhZGVkIGZvciBwZXJmb3JtYW5jZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9zRmlsdGVyUm93XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWNoZSBvZiB0aGUgY2xhc3MgbmFtZSB0aGF0IERhdGFUYWJsZXMgaGFzIGFwcGxpZWQgdG8gdGhlIHJvdywgc28gd2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNhbiBxdWlja2x5IGxvb2sgYXQgdGhpcyB2YXJpYWJsZSByYXRoZXIgdGhhbiBuZWVkaW5nIHRvIGRvIGEgRE9NIGNoZWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvbiBjbGFzc05hbWUgZm9yIHRoZSBuVHIgcHJvcGVydHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwcml2YXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiX3NSb3dTdHJpcGVcIjogXCJcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERlbm90ZSBpZiB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2Ugd2FzIGZyb20gdGhlIERPTSwgb3IgdGhlIGRhdGEgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3IgaW52YWxpZGF0aW5nIGRhdGEsIHNvIERhdGFUYWJsZXMgY2FuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHJlYWQgZGF0YSBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHVubGVzcyB1bmluc3RydWN0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG90aGVyd2lzZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHByaXZhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzcmNcIjogbnVsbFxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSBjb2x1bW4gaW5mb3JtYXRpb24gb2JqZWN0IGluIERhdGFUYWJsZXMuIFRoaXMgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqIGlzIGhlbGQgaW4gdGhlIHNldHRpbmdzIGFvQ29sdW1ucyBhcnJheSBhbmQgY29udGFpbnMgYWxsIHRoZSBpbmZvcm1hdGlvbiB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgbmVlZHMgYWJvdXQgZWFjaCBpbmRpdmlkdWFsIGNvbHVtbi5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIHJlbGF0ZWQgdG8ge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59XHJcblx0ICAgICAgICAgICAgICAgICAqIGJ1dCB0aGlzIG9uZSBpcyB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBmb3IgRGF0YVRhYmxlcydzIGNhY2hlIG9mIGNvbHVtbnMuXHJcblx0ICAgICAgICAgICAgICAgICAqIEl0IHNob3VsZCBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGRcclxuXHQgICAgICAgICAgICAgICAgICogYmUgZG9uZSB0aHJvdWdoIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLm1vZGVscy5vQ29sdW1uID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDb2x1bW4gaW5kZXguIFRoaXMgY291bGQgYmUgd29ya2VkIG91dCBvbi10aGUtZmx5IHdpdGggJC5pbkFycmF5LCBidXQgaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIGZhc3RlciB0byBqdXN0IGhvbGQgaXQgYXMgYSB2YXJpYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludGVnZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaWR4XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBIGxpc3Qgb2YgdGhlIGNvbHVtbnMgdGhhdCBzb3J0aW5nIHNob3VsZCBvY2N1ciBvbiB3aGVuIHRoaXMgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyBzb3J0ZWQuIFRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheSBhbGxvd3MgbXVsdGktY29sdW1uIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvIGJlIGRlZmluZWQgZm9yIGEgY29sdW1uIChmb3IgZXhhbXBsZSBmaXJzdCBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHdvdWxkIGJlbmVmaXQgZnJvbSB0aGlzKS4gVGhlIHZhbHVlcyBhcmUgaW50ZWdlcnMgcG9pbnRpbmcgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjb2x1bW5zIHRvIGJlIHNvcnRlZCBvbiAodHlwaWNhbGx5IGl0IHdpbGwgYmUgYSBzaW5nbGUgaW50ZWdlciBwb2ludGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYXQgaXRzZWxmLCBidXQgdGhhdCBkb2Vzbid0IG5lZWQgdG8gYmUgdGhlIGNhc2UpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYURhdGFTb3J0XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEZWZpbmUgdGhlIHNvcnRpbmcgZGlyZWN0aW9ucyB0aGF0IGFyZSBhcHBsaWVkIHRvIHRoZSBjb2x1bW4sIGluIHNlcXVlbmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhcyB0aGUgY29sdW1uIGlzIHJlcGVhdGVkbHkgc29ydGVkIHVwb24gLSBpLmUuIHRoZSBmaXJzdCB2YWx1ZSBpcyB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhcyB0aGUgc29ydGluZyBkaXJlY3Rpb24gd2hlbiB0aGUgY29sdW1uIGlmIGZpcnN0IHNvcnRlZCAoY2xpY2tlZCBvbikuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTb3J0IGl0IGFnYWluIChjbGljayBhZ2FpbikgYW5kIGl0IHdpbGwgbW92ZSBvbiB0byB0aGUgbmV4dCBpbmRleC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFJlcGVhdCB1bnRpbCBsb29wLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYXNTb3J0aW5nXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgc2VhcmNoYWJsZSwgYW5kIHRodXMgc2hvdWxkIGJlIGluY2x1ZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbiB0aGUgZmlsdGVyaW5nIG9yIG5vdC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNlYXJjaGFibGVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSBvciBub3QuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTb3J0YWJsZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSB2aXNpYmxlIGluIHRoZSB0YWJsZSBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlZpc2libGVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0b3JlIGZvciBtYW51YWwgdHlwZSBhc3NpZ25tZW50IHVzaW5nIHRoZSBgY29sdW1uLnR5cGVgIG9wdGlvbi4gVGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgaGVsZCBpbiBzdG9yZSBzbyB3ZSBjYW4gbWFuaXB1bGF0ZSB0aGUgY29sdW1uJ3MgYHNUeXBlYCBwcm9wZXJ0eS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHByaXZhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJfc01hbnVhbFR5cGVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzb3VyY2UgZm9yIGZpbHRlcmluZyBvciBzb3J0aW5nLiBUcnVlIGlzIGVpdGhlciBhcmUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHByaXZhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJfYkF0dHJTcmNcIjogZmFsc2UsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEZXZlbG9wZXIgZGVmaW5hYmxlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgY2VsbCBpcyBjcmVhdGVkIChBamF4IHNvdXJjZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50IGlzIGF2YWlsYWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZWxlbWVudH0gblRkIFRoZSBURCBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7Kn0gc0RhdGEgVGhlIERhdGEgZm9yIHRoZSBjZWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGZvciB0aGUgd2hvbGUgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlSb3cgVGhlIHJvdyBpbmRleCBmb3IgdGhlIGFvRGF0YSBkYXRhIHN0b3JlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuQ3JlYXRlZENlbGxcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9uIHRvIGdldCBkYXRhIGZyb20gYSBjZWxsIGluIGEgY29sdW1uLiBZb3Ugc2hvdWxkIDxiPm5ldmVyPC9iPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWNjZXNzIGRhdGEgZGlyZWN0bHkgdGhyb3VnaCBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIG1ldGhvZCBhdHRhY2hlZCB0byB0aGlzIHByb3BlcnR5LiBJdCBhbGxvd3MgbURhdGEgdG8gZnVuY3Rpb24gYXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW5pdGlhbGlzYXRpb24gbWV0aG9kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gb0RhdGEgVGhlIGRhdGEgYXJyYXkvb2JqZWN0IGZvciB0aGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIChpLmUuIGFvRGF0YVtdLl9hRGF0YSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc1NwZWNpZmljIFRoZSBzcGVjaWZpYyBkYXRhIHR5cGUgeW91IHdhbnQgdG8gZ2V0IC1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICdkaXNwbGF5JywgJ3R5cGUnICdmaWx0ZXInICdzb3J0J1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHsqfSBUaGUgZGF0YSBmb3IgdGhlIGNlbGwgZnJvbSB0aGUgZ2l2ZW4gcm93J3MgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkdldERhdGFcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9uIHRvIHNldCBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCB0aGUgZGF0YSBkaXJlY3RseSB0byBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhpcyBtZXRob2QuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhcyByZXF1aXJlZC4gVGhpcyBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGFycmF5L29iamVjdCBmb3IgdGhlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSBzVmFsdWUgVmFsdWUgdG8gc2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuU2V0RGF0YVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydHkgdG8gcmVhZCB0aGUgdmFsdWUgZm9yIHRoZSBjZWxscyBpbiB0aGUgY29sdW1uIGZyb20gdGhlIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNvdXJjZSBhcnJheSAvIG9iamVjdC4gSWYgbnVsbCwgdGhlbiB0aGUgZGVmYXVsdCBjb250ZW50IGlzIHVzZWQsIGlmIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9uIGlzIGdpdmVuIHRoZW4gdGhlIHJldHVybiBmcm9tIHRoZSBmdW5jdGlvbiBpcyB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJtRGF0YVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUGFydG5lciBwcm9wZXJ0eSB0byBtRGF0YSB3aGljaCBpcyB1c2VkIChvbmx5IHdoZW4gZGVmaW5lZCkgdG8gZ2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZGF0YSAtIGkuZS4gaXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIG1EYXRhLCBidXQgd2l0aG91dCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICdzZXQnIG9wdGlvbiwgYW5kIGFsc28gdGhlIGRhdGEgZmVkIHRvIGl0IGlzIHRoZSByZXN1bHQgZnJvbSBtRGF0YS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgdGhlIHJlbmRlcmluZyBtZXRob2QgdG8gbWF0Y2ggdGhlIGRhdGEgbWV0aG9kIG9mIG1EYXRhLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9ufGludHxzdHJpbmd8bnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJtUmVuZGVyXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBVbmlxdWUgaGVhZGVyIFRIL1REIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uIC0gdGhpcyBpcyB3aGF0IHRoZSBzb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBsaXN0ZW5lciBpcyBhdHRhY2hlZCB0byAoaWYgc29ydGluZyBpcyBlbmFibGVkLilcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm5UaFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVW5pcXVlIGZvb3RlciBUSC9URCBlbGVtZW50IGZvciB0aGlzIGNvbHVtbiAoaWYgdGhlcmUgaXMgb25lKS4gTm90IHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluIERhdGFUYWJsZXMgYXMgc3VjaCwgYnV0IGNhbiBiZSB1c2VkIGZvciBwbHVnLWlucyB0byByZWZlcmVuY2UgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmb290ZXIgZm9yIGVhY2ggY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiblRmXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY2xhc3MgdG8gYXBwbHkgdG8gYWxsIFREIGVsZW1lbnRzIGluIHRoZSB0YWJsZSdzIFRCT0RZIGZvciB0aGUgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNDbGFzc1wiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzQ29udGVudFBhZGRpbmdcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFsbG93cyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgZ2l2ZW4gZm9yIGEgY29sdW1uJ3MgZGF0YSwgYW5kIHdpbGwgYmUgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIG1EYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzRGVmYXVsdENvbnRlbnRcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5hbWUgZm9yIHRoZSBjb2x1bW4sIGFsbG93aW5nIHJlZmVyZW5jZSB0byB0aGUgY29sdW1uIGJ5IG5hbWUgYXMgd2VsbCBhc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYnkgaW5kZXggKG5lZWRzIGEgbG9va3VwIHRvIHdvcmsgYnkgbmFtZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic05hbWVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEN1c3RvbSBzb3J0aW5nIGRhdGEgdHlwZSAtIGRlZmluZXMgd2hpY2ggb2YgdGhlIGF2YWlsYWJsZSBwbHVnLWlucyBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWZuU29ydERhdGEgdGhlIGN1c3RvbSBzb3J0aW5nIHdpbGwgdXNlIC0gaWYgYW55IGlzIGRlZmluZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgc3RkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnREYXRhVHlwZVwiOiAnc3RkJyxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydGluZ0NsYXNzXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgZWxlbWVudCB3aGVuIHNvcnRpbmcgb24gdGhpcyBjb2x1bW4gLVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2hlbiBqUXVlcnkgVUkgdGhlbWluZyBpcyB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydGluZ0NsYXNzSlVJXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaXRsZSBvZiB0aGUgY29sdW1uIC0gd2hhdCBpcyBzZWVuIGluIHRoZSBUSCBlbGVtZW50IChuVGgpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNUaXRsZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ29sdW1uIHNvcnRpbmcgYW5kIGZpbHRlcmluZyB0eXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNUeXBlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBXaWR0aCBvZiB0aGUgY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNXaWR0aFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogV2lkdGggb2YgdGhlIGNvbHVtbiB3aGVuIGl0IHdhcyBmaXJzdCBcImVuY291bnRlcmVkXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1dpZHRoT3JpZ1wiOiBudWxsXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICogRGV2ZWxvcGVyIG5vdGU6IFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYmVsb3cgYXJlIGdpdmVuIGluIEh1bmdhcmlhblxyXG5cdCAgICAgICAgICAgICAgICAgKiBub3RhdGlvbiwgdGhhdCB3YXMgdXNlZCBhcyB0aGUgaW50ZXJmYWNlIGZvciBEYXRhVGFibGVzIHByaW9yIHRvIHYxLjEwLCBob3dldmVyXHJcblx0ICAgICAgICAgICAgICAgICAqIGZyb20gdjEuMTAgb253YXJkcyB0aGUgcHJpbWFyeSBpbnRlcmZhY2UgaXMgY2FtZWwgY2FzZS4gSW4gb3JkZXIgdG8gYXZvaWRcclxuXHQgICAgICAgICAgICAgICAgICogYnJlYWtpbmcgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdXR0ZXJseSB3aXRoIHRoaXMgY2hhbmdlLCB0aGUgSHVuZ2FyaWFuXHJcblx0ICAgICAgICAgICAgICAgICAqIHZlcnNpb24gaXMgc3RpbGwsIGludGVybmFsbHkgdGhlIHByaW1hcnkgaW50ZXJmYWNlLCBidXQgaXMgaXMgbm90IGRvY3VtZW50ZWRcclxuXHQgICAgICAgICAgICAgICAgICogLSBoZW5jZSB0aGUgQG5hbWUgdGFncyBpbiBlYWNoIGRvYyBjb21tZW50LiBUaGlzIGFsbG93cyBhIEphdmFzY3JpcHQgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogdG8gY3JlYXRlIGEgbWFwIGZyb20gSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGNhbWVsIGNhc2UgKGdvaW5nIHRoZSBvdGhlciBkaXJlY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICogd291bGQgcmVxdWlyZSBlYWNoIHByb3BlcnR5IHRvIGJlIGxpc3RlZCwgd2hpY2ggd291bGQgYXQgYXJvdW5kIDNLIHRvIHRoZSBzaXplXHJcblx0ICAgICAgICAgICAgICAgICAqIG9mIERhdGFUYWJsZXMsIHdoaWxlIHRoaXMgbWV0aG9kIGlzIGFib3V0IGEgMC41SyBoaXQuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIFVsdGltYXRlbHkgdGhpcyBkb2VzIHBhdmUgdGhlIHdheSBmb3IgSHVuZ2FyaWFuIG5vdGF0aW9uIHRvIGJlIGRyb3BwZWRcclxuXHQgICAgICAgICAgICAgICAgICogY29tcGxldGVseSwgYnV0IHRoYXQgaXMgYSBtYXNzaXZlIGFtb3VudCBvZiB3b3JrIGFuZCB3aWxsIGJyZWFrIGN1cnJlbnRcclxuXHQgICAgICAgICAgICAgICAgICogaW5zdGFsbHMgKHRoZXJlZm9yZSBpcyBvbi1ob2xkIHVudGlsIHYyKS5cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogSW5pdGlhbGlzYXRpb24gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqIHRpbWUuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUuZGVmYXVsdHMgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFuIGFycmF5IG9mIGRhdGEgdG8gdXNlIGZvciB0aGUgdGFibGUsIHBhc3NlZCBpbiBhdCBpbml0aWFsaXNhdGlvbiB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2lsbCBiZSB1c2VkIGluIHByZWZlcmVuY2UgdG8gYW55IGRhdGEgd2hpY2ggaXMgYWxyZWFkeSBpbiB0aGUgRE9NLiBUaGlzIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBjb25zdHJ1Y3RpbmcgdGFibGVzIHB1cmVseSBpbiBKYXZhc2NyaXB0LCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGV4YW1wbGUgd2l0aCBhIGN1c3RvbSBBamF4IGNhbGwuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYSAyRCBhcnJheSBkYXRhIHNvdXJjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImRhdGFcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgWydUcmlkZW50JywgJ0ludGVybmV0IEV4cGxvcmVyIDQuMCcsICdXaW4gOTUrJywgNCwgJ1gnXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFsnVHJpZGVudCcsICdJbnRlcm5ldCBFeHBsb3JlciA1LjAnLCAnV2luIDk1KycsIDUsICdDJ10sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiRW5naW5lXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkJyb3dzZXJcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiUGxhdGZvcm1cIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiVmVyc2lvblwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJHcmFkZVwiIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYXMgYSBkYXRhIHNvdXJjZSAoYGRhdGFgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImRhdGFcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImVuZ2luZVwiOiAgIFwiVHJpZGVudFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNC4wXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwicGxhdGZvcm1cIjogXCJXaW4gOTUrXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwidmVyc2lvblwiOiAgNCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIlhcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJlbmdpbmVcIjogICBcIlRyaWRlbnRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJicm93c2VyXCI6ICBcIkludGVybmV0IEV4cGxvcmVyIDUuMFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInBsYXRmb3JtXCI6IFwiV2luIDk1K1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInZlcnNpb25cIjogIDUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZ3JhZGVcIjogICAgXCJDXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiwgICBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiQnJvd3NlclwiLCAgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJQbGF0Zm9ybVwiLCBcImRhdGFcIjogXCJwbGF0Zm9ybVwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIsICBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkdyYWRlXCIsICAgIFwiZGF0YVwiOiBcImdyYWRlXCIgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFhRGF0YVwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIElmIG9yZGVyaW5nIGlzIGVuYWJsZWQsIHRoZW4gRGF0YVRhYmxlcyB3aWxsIHBlcmZvcm0gYSBmaXJzdCBwYXNzIHNvcnQgb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluaXRpYWxpc2F0aW9uLiBZb3UgY2FuIGRlZmluZSB3aGljaCBjb2x1bW4ocykgdGhlIHNvcnQgaXMgcGVyZm9ybWVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB1cG9uLCBhbmQgdGhlIHNvcnRpbmcgZGlyZWN0aW9uLCB3aXRoIHRoaXMgdmFyaWFibGUuIFRoZSBgc29ydGluZ2AgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCBjb250YWluIGFuIGFycmF5IGZvciBlYWNoIGNvbHVtbiB0byBiZSBzb3J0ZWQgaW5pdGlhbGx5IGNvbnRhaW5pbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSBjb2x1bW4ncyBpbmRleCBhbmQgYSBkaXJlY3Rpb24gc3RyaW5nICgnYXNjJyBvciAnZGVzYycpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW1swLCdhc2MnXV1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gU29ydCBieSAzcmQgY29sdW1uIGZpcnN0LCBhbmQgdGhlbiA0dGggY29sdW1uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlclwiOiBbWzIsJ2FzYyddLCBbMywnZGVzYyddXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gTm8gaW5pdGlhbCBzb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlclwiOiBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYWFTb3J0aW5nXCI6IFtbMCwgJ2FzYyddXSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBpcyBiYXNpY2FsbHkgaWRlbnRpY2FsIHRvIHRoZSBgc29ydGluZ2AgcGFyYW1ldGVyLCBidXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNhbm5vdCBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgdGFibGUuIFdoYXQgdGhpcyBtZWFuc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgdGhhdCB5b3UgY291bGQgaGF2ZSBhIGNvbHVtbiAodmlzaWJsZSBvciBoaWRkZW4pIHdoaWNoIHRoZSBzb3J0aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aWxsIGFsd2F5cyBiZSBmb3JjZWQgb24gZmlyc3QgLSBhbnkgc29ydGluZyBhZnRlciB0aGF0IChmcm9tIHRoZSB1c2VyKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2lsbCB0aGVuIGJlIHBlcmZvcm1lZCBhcyByZXF1aXJlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBncm91cGluZyByb3dzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0b2dldGhlci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckZpeGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlckZpeGVkXCI6IFtbMCwnYXNjJ11dXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgY2FuIGJlIGluc3RydWN0ZWQgdG8gbG9hZCBkYXRhIHRvIGRpc3BsYXkgaW4gdGhlIHRhYmxlIGZyb20gYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQWpheCBzb3VyY2UuIFRoaXMgb3B0aW9uIGRlZmluZXMgaG93IHRoYXQgQWpheCBjYWxsIGlzIG1hZGUgYW5kIHdoZXJlIHRvLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBgYWpheGAgcHJvcGVydHkgaGFzIHRocmVlIGRpZmZlcmVudCBtb2RlcyBvZiBvcGVyYXRpb24sIGRlcGVuZGluZyBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaG93IGl0IGlzIGRlZmluZWQuIFRoZXNlIGFyZTpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBzdHJpbmdgIC0gU2V0IHRoZSBVUkwgZnJvbSB3aGVyZSB0aGUgZGF0YSBzaG91bGQgYmUgbG9hZGVkIGZyb20uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBvYmplY3RgIC0gRGVmaW5lIHByb3BlcnRpZXMgZm9yIGBqUXVlcnkuYWpheGAuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBmdW5jdGlvbmAgLSBDdXN0b20gZGF0YSBnZXQgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBgc3RyaW5nYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogLS0tLS0tLS1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBcyBhIHN0cmluZywgdGhlIGBhamF4YCBwcm9wZXJ0eSBzaW1wbHkgZGVmaW5lcyB0aGUgVVJMIGZyb20gd2hpY2hcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgd2lsbCBsb2FkIGRhdGEuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYG9iamVjdGBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIC0tLS0tLS0tXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXMgYW4gb2JqZWN0LCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgb2JqZWN0IGFyZSBwYXNzZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFtqUXVlcnkuYWpheF0oaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5hamF4LykgYWxsb3dpbmcgZmluZSBjb250cm9sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvZiB0aGUgQWpheCByZXF1ZXN0LiBEYXRhVGFibGVzIGhhcyBhIG51bWJlciBvZiBkZWZhdWx0IHBhcmFtZXRlcnMgd2hpY2hcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHlvdSBjYW4gb3ZlcnJpZGUgdXNpbmcgdGhpcyBvcHRpb24uIFBsZWFzZSByZWZlciB0byB0aGUgalF1ZXJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkb2N1bWVudGF0aW9uIGZvciBhIGZ1bGwgZGVzY3JpcHRpb24gb2YgdGhlIG9wdGlvbnMgYXZhaWxhYmxlLCBhbHRob3VnaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzIHByb3ZpZGUgYWRkaXRpb25hbCBvcHRpb25zIGluIERhdGFUYWJsZXMgb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlcXVpcmUgc3BlY2lhbCBjb25zaWRlcmF0aW9uOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGRhdGFgIC0gQXMgd2l0aCBqUXVlcnksIGBkYXRhYCBjYW4gYmUgcHJvdmlkZWQgYXMgYW4gb2JqZWN0LCBidXQgaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGZ1bmN0aW9uIHRvIG1hbmlwdWxhdGUgdGhlIGRhdGEgRGF0YVRhYmxlcyBzZW5kc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB0byB0aGUgc2VydmVyLiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLCBhbiBvYmplY3Qgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgcGFyYW1ldGVycyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCBEYXRhVGFibGVzIGhhcyByZWFkaWVkIGZvciBzZW5kaW5nLiBBblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBvYmplY3QgbWF5IGJlIHJldHVybmVkIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIERhdGFUYWJsZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgZGVmYXVsdHMsIG9yIHlvdSBjYW4gYWRkIHRoZSBpdGVtcyB0byB0aGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBpbiBhbmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgbm90IHJldHVybiBhbnl0aGluZyBmcm9tIHRoZSBmdW5jdGlvbi4gVGhpcyBzdXBlcnNlZGVzIGBmblNlcnZlclBhcmFtc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgZGF0YVNyY2AgLSBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBgYWFEYXRhYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIERhdGFUYWJsZXMgMS45LSkgd2hlbiBvYnRhaW5pbmcgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBmcm9tIGFuIEFqYXggc291cmNlIG9yIGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gdGhpcyBwYXJhbWV0ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgYWxsb3dzIHRoYXQgcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgb2JqZWN0IG5vdGF0aW9uIHRvIGdldCBhIGRhdGEgc291cmNlIGZvciBtdWx0aXBsZSBsZXZlbHMgb2YgbmVzdGluZywgb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgaXQgbXkgYmUgdXNlZCBhcyBhIGZ1bmN0aW9uLiBBcyBhIGZ1bmN0aW9uIGl0IHRha2VzIGEgc2luZ2xlIHBhcmFtZXRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgdGhlIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCB3aGljaCBjYW4gYmUgbWFuaXB1bGF0ZWQgYXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgcmVxdWlyZWQsIHdpdGggdGhlIHJldHVybmVkIHZhbHVlIGJlaW5nIHRoYXQgdXNlZCBieSBEYXRhVGFibGVzIGFzIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIHN1cGVyc2VkZXMgYHNBamF4RGF0YVByb3BgIGZyb21cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgRGF0YVRhYmxlcyAxLjktLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYHN1Y2Nlc3NgIC0gU2hvdWxkIG5vdCBiZSBvdmVycmlkZGVuIGl0IGlzIHVzZWQgaW50ZXJuYWxseSBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBEYXRhVGFibGVzLiBUbyBtYW5pcHVsYXRlIC8gdHJhbnNmb3JtIHRoZSBkYXRhIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgdXNlIGBhamF4LmRhdGFTcmNgLCBvciB1c2UgYGFqYXhgIGFzIGEgZnVuY3Rpb24gKHNlZSBiZWxvdykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYGZ1bmN0aW9uYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogLS0tLS0tLS0tLVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFzIGEgZnVuY3Rpb24sIG1ha2luZyB0aGUgQWpheCBjYWxsIGlzIGxlZnQgdXAgdG8geW91cnNlbGYgYWxsb3dpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNvbXBsZXRlIGNvbnRyb2wgb2YgdGhlIEFqYXggcmVxdWVzdC4gSW5kZWVkLCBpZiBkZXNpcmVkLCBhIG1ldGhvZCBvdGhlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhhbiBBamF4IGNvdWxkIGJlIHVzZWQgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhLCBzdWNoIGFzIFdlYiBzdG9yYWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvciBhbiBBSVIgZGF0YWJhc2UuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGlzIGdpdmVuIGZvdXIgcGFyYW1ldGVycyBhbmQgbm8gcmV0dXJuIGlzIHJlcXVpcmVkLiBUaGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBhcmFtZXRlcnMgYXJlOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDEuIF9vYmplY3RfIC0gRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDIuIF9mdW5jdGlvbl8gLSBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IG11c3QgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgcmVxdWlyZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGRhdGEgaGFzIGJlZW4gb2J0YWluZWQuIFRoYXQgZGF0YSBzaG91bGQgYmUgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBhcyB0aGUgb25seSBwYXJhbWV0ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDMuIF9vYmplY3RfIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgZm9yIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyRGF0YWAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ3xvYmplY3R8ZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuYWpheFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBzaW5jZSAxLjEwLjBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBOb3RlIERhdGFUYWJsZXMgZXhwZWN0cyBkYXRhIGluIHRoZSBmb3JtIGB7IGRhdGE6IFsgLi4uZGF0YS4uLiBdIH1gIGJ5IGRlZmF1bHQpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiBcImRhdGEuanNvblwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LCB1c2luZyBgZGF0YVNyY2AgdG8gY2hhbmdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIGBkYXRhYCB0byBgdGFibGVEYXRhYCAoaS5lLiBgeyB0YWJsZURhdGE6IFsgLi4uZGF0YS4uLiBdIH1gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgXCJkYXRhU3JjXCI6IFwidGFibGVEYXRhXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBHZXQgSlNPTiBkYXRhIGZyb20gYSBmaWxlIHZpYSBBamF4LCB1c2luZyBgZGF0YVNyY2AgdG8gcmVhZCBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIGZyb20gYSBwbGFpbiBhcnJheSByYXRoZXIgdGhhbiBhbiBhcnJheSBpbiBhbiBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICBcImFqYXhcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIFwiZGF0YVNyY1wiOiBcIlwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgLy8gTWFuaXB1bGF0ZSB0aGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgLSBhZGQgYSBsaW5rIHRvIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgLy8gKG5vdGUgdGhpcyBjYW4sIHNob3VsZCwgYmUgZG9uZSB1c2luZyBgcmVuZGVyYCBmb3IgdGhlIGNvbHVtbiAtIHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgLy8gaXMganVzdCBhIHNpbXBsZSBleGFtcGxlIG9mIGhvdyB0aGUgZGF0YSBjYW4gYmUgbWFuaXB1bGF0ZWQpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgXCJkYXRhU3JjXCI6IGZ1bmN0aW9uICgganNvbiApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgZm9yICggdmFyIGk9MCwgaWVuPWpzb24ubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAganNvbltpXVswXSA9ICc8YSBocmVmPVwiL21lc3NhZ2UvJytqc29uW2ldWzBdKyc+VmlldyBtZXNzYWdlPC9hPic7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgcmV0dXJuIGpzb247XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgLy8gQWRkIGRhdGEgdG8gdGhlIHJlcXVlc3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICBcImFqYXhcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgXCJ1cmxcIjogXCJkYXRhLmpzb25cIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIGQgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgXCJleHRyYV9zZWFyY2hcIjogJCgnI2V4dHJhJykudmFsKClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAvLyBTZW5kIHJlcXVlc3QgYXMgUE9TVFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgXCJ0eXBlXCI6IFwiUE9TVFwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgLy8gR2V0IHRoZSBkYXRhIGZyb20gbG9jYWxTdG9yYWdlIChjb3VsZCBpbnRlcmZhY2Ugd2l0aCBhIGZvcm0gZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIC8vIGFkZGluZywgZWRpdGluZyBhbmQgcmVtb3Zpbmcgcm93cykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaywgc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIGNhbGxiYWNrKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICBKU09OLnBhcnNlKCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGF0YVRhYmxlc0RhdGEnKSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFqYXhcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHJlYWRpbHkgc3BlY2lmeSB0aGUgZW50cmllcyBpbiB0aGUgbGVuZ3RoIGRyb3BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRvd24gbWVudSB0aGF0IERhdGFUYWJsZXMgc2hvd3Mgd2hlbiBwYWdpbmF0aW9uIGlzIGVuYWJsZWQuIEl0IGNhbiBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZWl0aGVyIGEgMUQgYXJyYXkgb2Ygb3B0aW9ucyB3aGljaCB3aWxsIGJlIHVzZWQgZm9yIGJvdGggdGhlIGRpc3BsYXllZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3B0aW9uIGFuZCB0aGUgdmFsdWUsIG9yIGEgMkQgYXJyYXkgd2hpY2ggd2lsbCB1c2UgdGhlIGFycmF5IGluIHRoZSBmaXJzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcG9zaXRpb24gYXMgdGhlIHZhbHVlLCBhbmQgdGhlIGFycmF5IGluIHRoZSBzZWNvbmQgcG9zaXRpb24gYXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkaXNwbGF5ZWQgb3B0aW9ucyAodXNlZnVsIGZvciBsYW5ndWFnZSBzdHJpbmdzIHN1Y2ggYXMgJ0FsbCcpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgYHBhZ2VMZW5ndGhgIHByb3BlcnR5IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmaXJzdCB2YWx1ZSBnaXZlbiBpbiB0aGlzIGFycmF5LCB1bmxlc3MgYHBhZ2VMZW5ndGhgIGlzIGFsc28gcHJvdmlkZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbIDEwLCAyNSwgNTAsIDEwMCBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGVuZ3RoTWVudVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGVuZ3RoTWVudVwiOiBbWzEwLCAyNSwgNTAsIC0xXSwgWzEwLCAyNSwgNTAsIFwiQWxsXCJdXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYUxlbmd0aE1lbnVcIjogWzEwLCAyNSwgNTAsIDEwMF0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGBjb2x1bW5zYCBvcHRpb24gaW4gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGRlZmluZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGV0YWlscyBhYm91dCB0aGUgd2F5IGluZGl2aWR1YWwgY29sdW1ucyBiZWhhdmUuIEZvciBhIGZ1bGwgbGlzdCBvZlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29sdW1uIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0LCBwbGVhc2Ugc2VlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0uIE5vdGUgdGhhdCBpZiB5b3UgdXNlIGBjb2x1bW5zYCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGVmaW5lIHlvdXIgY29sdW1ucywgeW91IG11c3QgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IHNpbmdsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29sdW1uIHRoYXQgeW91IGhhdmUgaW4geW91ciB0YWJsZSAodGhlc2UgY2FuIGJlIG51bGwgaWYgeW91IGRvbid0IHdoaWNoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0byBzcGVjaWZ5IGFueSBvcHRpb25zKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbWVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb0NvbHVtbnNcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFZlcnkgc2ltaWxhciB0byBgY29sdW1uc2AsIGBjb2x1bW5EZWZzYCBhbGxvd3MgeW91IHRvIHRhcmdldCBhIHNwZWNpZmljXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjb2x1bW4sIG11bHRpcGxlIGNvbHVtbnMsIG9yIGFsbCBjb2x1bW5zLCB1c2luZyB0aGUgYHRhcmdldHNgIHByb3BlcnR5IG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFRoaXMgYWxsb3dzIGdyZWF0IGZsZXhpYmlsaXR5IHdoZW4gY3JlYXRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRhYmxlcywgYXMgdGhlIGBjb2x1bW5EZWZzYCBhcnJheXMgY2FuIGJlIG9mIGFueSBsZW5ndGgsIHRhcmdldGluZyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNvbHVtbnMgeW91IHNwZWNpZmljYWxseSB3YW50LiBgY29sdW1uRGVmc2AgbWF5IHVzZSBhbnkgb2YgdGhlIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3B0aW9ucyBhdmFpbGFibGU6IHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1ufSwgYnV0IGl0IF9tdXN0X1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaGF2ZSBgdGFyZ2V0c2AgZGVmaW5lZCBpbiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkuIFZhbHVlcyBpbiB0aGUgYHRhcmdldHNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhcnJheSBtYXkgYmU6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+YSBzdHJpbmcgLSBjbGFzcyBuYW1lIHdpbGwgYmUgbWF0Y2hlZCBvbiB0aGUgVEggZm9yIHRoZSBjb2x1bW48L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT4wIG9yIGEgcG9zaXRpdmUgaW50ZWdlciAtIGNvbHVtbiBpbmRleCBjb3VudGluZyBmcm9tIHRoZSBsZWZ0PC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+YSBuZWdhdGl2ZSBpbnRlZ2VyIC0gY29sdW1uIGluZGV4IGNvdW50aW5nIGZyb20gdGhlIHJpZ2h0PC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+dGhlIHN0cmluZyBcIl9hbGxcIiAtIGFsbCBjb2x1bW5zIChpLmUuIGFzc2lnbiBhIGRlZmF1bHQpPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPC91bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbWVtYmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW5EZWZzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9Db2x1bW5EZWZzXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQmFzaWNhbGx5IHRoZSBzYW1lIGFzIGBzZWFyY2hgLCB0aGlzIHBhcmFtZXRlciBkZWZpbmVzIHRoZSBpbmRpdmlkdWFsIGNvbHVtblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZmlsdGVyaW5nIHN0YXRlIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuIFRoZSBhcnJheSBtdXN0IGJlIG9mIHRoZSBzYW1lIHNpemVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucywgYW5kIGVhY2ggZWxlbWVudCBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyYW1ldGVyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYHNlYXJjaGAgYW5kIGBlc2NhcGVSZWdleGAgKHRoZSBsYXR0ZXIgaXMgb3B0aW9uYWwpLiAnbnVsbCcgaXMgYWxzb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWNjZXB0ZWQgYW5kIHRoZSBkZWZhdWx0IHdpbGwgYmUgdXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoQ29sc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoQ29sc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIk15IGZpbHRlclwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIl5bMC05XVwiLCBcImVzY2FwZVJlZ2V4XCI6IGZhbHNlIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvU2VhcmNoQ29sc1wiOiBbXSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBbiBhcnJheSBvZiBDU1MgY2xhc3NlcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGRpc3BsYXllZCByb3dzLiBUaGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhcnJheSBtYXkgYmUgb2YgYW55IGxlbmd0aCwgYW5kIERhdGFUYWJsZXMgd2lsbCBhcHBseSBlYWNoIGNsYXNzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXF1ZW50aWFsbHksIGxvb3Bpbmcgd2hlbiByZXF1aXJlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGwgPGk+V2lsbCB0YWtlIHRoZSB2YWx1ZXMgZGV0ZXJtaW5lZCBieSB0aGUgYG9DbGFzc2VzLnN0cmlwZSpgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBvcHRpb25zPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0cmlwZUNsYXNzZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0cmlwZUNsYXNzZXNcIjogWyAnc3RyaXAxJywgJ3N0cmlwMicsICdzdHJpcDMnIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYXNTdHJpcGVDbGFzc2VzXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgYXV0b21hdGljIGNvbHVtbiB3aWR0aCBjYWxjdWxhdGlvbi4gVGhpcyBjYW4gYmUgZGlzYWJsZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFzIGFuIG9wdGltaXNhdGlvbiAoaXQgdGFrZXMgc29tZSB0aW1lIHRvIGNhbGN1bGF0ZSB0aGUgd2lkdGhzKSBpZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRhYmxlcyB3aWR0aHMgYXJlIHBhc3NlZCBpbiB1c2luZyBgY29sdW1uc2AuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmF1dG9XaWR0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImF1dG9XaWR0aFwiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYkF1dG9XaWR0aFwiOiB0cnVlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERlZmVycmVkIHJlbmRlcmluZyBjYW4gcHJvdmlkZSBEYXRhVGFibGVzIHdpdGggYSBodWdlIHNwZWVkIGJvb3N0IHdoZW4geW91XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhcmUgdXNpbmcgYW4gQWpheCBvciBKUyBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIG9wdGlvbiwgd2hlbiBzZXQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRydWUsIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBkZWZlciB0aGUgY3JlYXRpb24gb2YgdGhlIHRhYmxlIGVsZW1lbnRzIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZWFjaCByb3cgdW50aWwgdGhleSBhcmUgbmVlZGVkIGZvciBhIGRyYXcgLSBzYXZpbmcgYSBzaWduaWZpY2FudCBhbW91bnQgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRpbWUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZWZlclJlbmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiYWpheFwiOiBcInNvdXJjZXMvYXJyYXlzLnR4dFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZGVmZXJSZW5kZXJcIjogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYkRlZmVyUmVuZGVyXCI6IGZhbHNlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFJlcGxhY2UgYSBEYXRhVGFibGUgd2hpY2ggbWF0Y2hlcyB0aGUgZ2l2ZW4gc2VsZWN0b3IgYW5kIHJlcGxhY2UgaXQgd2l0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb25lIHdoaWNoIGhhcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbmV3IGluaXRpYWxpc2F0aW9uIG9iamVjdCBwYXNzZWQuIElmIG5vXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0YWJsZSBtYXRjaGVzIHRoZSBzZWxlY3RvciwgdGhlbiB0aGUgbmV3IERhdGFUYWJsZSB3aWxsIGJlIGNvbnN0cnVjdGVkIGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwZXIgbm9ybWFsLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZXN0cm95XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzcm9sbFlcIjogXCIyMDBweFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gU29tZSB0aW1lIGxhdGVyLi4uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZmlsdGVyXCI6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZGVzdHJveVwiOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiRGVzdHJveVwiOiBmYWxzZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBmaWx0ZXJpbmcgb2YgZGF0YS4gRmlsdGVyaW5nIGluIERhdGFUYWJsZXMgaXMgXCJzbWFydFwiIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IGl0IGFsbG93cyB0aGUgZW5kIHVzZXIgdG8gaW5wdXQgbXVsdGlwbGUgd29yZHMgKHNwYWNlIHNlcGFyYXRlZCkgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aWxsIG1hdGNoIGEgcm93IGNvbnRhaW5pbmcgdGhvc2Ugd29yZHMsIGV2ZW4gaWYgbm90IGluIHRoZSBvcmRlciB0aGF0IHdhc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc3BlY2lmaWVkICh0aGlzIGFsbG93IG1hdGNoaW5nIGFjcm9zcyBtdWx0aXBsZSBjb2x1bW5zKS4gTm90ZSB0aGF0IGlmIHlvdVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2lzaCB0byB1c2UgZmlsdGVyaW5nIGluIERhdGFUYWJsZXMgdGhpcyBtdXN0IHJlbWFpbiAndHJ1ZScgLSB0byByZW1vdmUgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkZWZhdWx0IGZpbHRlcmluZyBpbnB1dCBib3ggYW5kIHJldGFpbiBmaWx0ZXJpbmcgYWJpbGl0aWVzLCBwbGVhc2UgdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbX0uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNlYXJjaGluZ1wiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYkZpbHRlclwiOiB0cnVlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSB0YWJsZSBpbmZvcm1hdGlvbiBkaXNwbGF5LiBUaGlzIHNob3dzIGluZm9ybWF0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhYm91dCB0aGUgZGF0YSB0aGF0IGlzIGN1cnJlbnRseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBpbmNsdWRpbmcgaW5mb3JtYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFib3V0IGZpbHRlcmVkIGRhdGEgaWYgdGhhdCBhY3Rpb24gaXMgYmVpbmcgcGVyZm9ybWVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbmZvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiaW5mb1wiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYkluZm9cIjogdHJ1ZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgalF1ZXJ5IFVJIFRoZW1lUm9sbGVyIHN1cHBvcnQgKHJlcXVpcmVkIGFzIFRoZW1lUm9sbGVyIHJlcXVpcmVzIHNvbWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNsaWdodGx5IGRpZmZlcmVudCBhbmQgYWRkaXRpb25hbCBtYXJrLXVwIGZyb20gd2hhdCBEYXRhVGFibGVzIGhhc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdHJhZGl0aW9uYWxseSB1c2VkKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmpRdWVyeVVJXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJqUXVlcnlVSVwiOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiSlF1ZXJ5VUlcIjogZmFsc2UsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQWxsb3dzIHRoZSBlbmQgdXNlciB0byBzZWxlY3QgdGhlIHNpemUgb2YgYSBmb3JtYXR0ZWQgcGFnZSBmcm9tIGEgc2VsZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBtZW51IChzaXplcyBhcmUgMTAsIDI1LCA1MCBhbmQgMTAwKS4gUmVxdWlyZXMgcGFnaW5hdGlvbiAoYHBhZ2luYXRlYCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxlbmd0aENoYW5nZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxlbmd0aENoYW5nZVwiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYkxlbmd0aENoYW5nZVwiOiB0cnVlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHBhZ2luYXRpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInBhZ2luZ1wiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlBhZ2luYXRlXCI6IHRydWUsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGRpc3BsYXkgb2YgYSAncHJvY2Vzc2luZycgaW5kaWNhdG9yIHdoZW4gdGhlIHRhYmxlIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBiZWluZyBwcm9jZXNzZWQgKGUuZy4gYSBzb3J0KS4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciB0YWJsZXMgd2l0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbGFyZ2UgYW1vdW50cyBvZiBkYXRhIHdoZXJlIGl0IGNhbiB0YWtlIGEgbm90aWNlYWJsZSBhbW91bnQgb2YgdGltZSB0byBzb3J0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZW50cmllcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnByb2Nlc3NpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJwcm9jZXNzaW5nXCI6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJQcm9jZXNzaW5nXCI6IGZhbHNlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFJldHJpZXZlIHRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yLiBOb3RlIHRoYXQgaWYgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0YWJsZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpc2VkLCB0aGlzIHBhcmFtZXRlciB3aWxsIGNhdXNlIERhdGFUYWJsZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvIHNpbXBseSByZXR1cm4gdGhlIG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2V0IHVwIC0gaXQgd2lsbCBub3QgdGFrZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWNjb3VudCBvZiBhbnkgY2hhbmdlcyB5b3UgbWlnaHQgaGF2ZSBtYWRlIHRvIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBhc3NlZCB0byBEYXRhVGFibGVzIChzZXR0aW5nIHRoaXMgcGFyYW1ldGVyIHRvIHRydWUgaXMgYW4gYWNrbm93bGVkZ2VtZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHlvdSB1bmRlcnN0YW5kIHRoaXMpLiBgZGVzdHJveWAgY2FuIGJlIHVzZWQgdG8gcmVpbml0aWFsaXNlIGEgdGFibGUgaWZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHlvdSBuZWVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5yZXRyaWV2ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBpbml0VGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgdGFibGVBY3Rpb25zKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgZnVuY3Rpb24gaW5pdFRhYmxlICgpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHJldHVybiAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMHB4XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInJldHJpZXZlXCI6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGZ1bmN0aW9uIHRhYmxlQWN0aW9ucyAoKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB2YXIgdGFibGUgPSBpbml0VGFibGUoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgLy8gcGVyZm9ybSBBUEkgb3BlcmF0aW9ucyB3aXRoIG9UYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJSZXRyaWV2ZVwiOiBmYWxzZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIHZlcnRpY2FsICh5KSBzY3JvbGxpbmcgaXMgZW5hYmxlZCwgRGF0YVRhYmxlcyB3aWxsIGZvcmNlIHRoZSBoZWlnaHQgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSB0YWJsZSdzIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBoZWlnaHQgYXQgYWxsIHRpbWVzICh1c2VmdWwgZm9yIGxheW91dCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBIb3dldmVyLCB0aGlzIGNhbiBsb29rIG9kZCB3aGVuIGZpbHRlcmluZyBkYXRhIGRvd24gdG8gYSBzbWFsbCBkYXRhIHNldCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFuZCB0aGUgZm9vdGVyIGlzIGxlZnQgXCJmbG9hdGluZ1wiIGZ1cnRoZXIgZG93bi4gVGhpcyBwYXJhbWV0ZXIgKHdoZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGVuYWJsZWQpIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBjb2xsYXBzZSB0aGUgdGFibGUncyB2aWV3cG9ydCBkb3duIHdoZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoZSByZXN1bHQgc2V0IHdpbGwgZml0IHdpdGhpbiB0aGUgZ2l2ZW4gWSBoZWlnaHQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbENvbGxhcHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU2Nyb2xsQ29sbGFwc2VcIjogZmFsc2UsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ29uZmlndXJlIERhdGFUYWJsZXMgdG8gdXNlIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIE5vdGUgdGhhdCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGBhamF4YCBwYXJhbWV0ZXIgbXVzdCBhbHNvIGJlIGdpdmVuIGluIG9yZGVyIHRvIGdpdmUgRGF0YVRhYmxlcyBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzb3VyY2UgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhIGZvciBlYWNoIGRyYXcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJTaWRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiYWpheFwiOiBcInhoci5waHBcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNlcnZlclNpZGVcIjogZmFsc2UsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgc29ydGluZyBvZiBjb2x1bW5zLiBTb3J0aW5nIG9mIGluZGl2aWR1YWwgY29sdW1ucyBjYW4gYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRpc2FibGVkIGJ5IHRoZSBgc29ydGFibGVgIG9wdGlvbiBmb3IgZWFjaCBjb2x1bW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJpbmdcIjogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTb3J0XCI6IHRydWUsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc3BsYXkgRGF0YVRhYmxlcycgYWJpbGl0eSB0byBzb3J0IG11bHRpcGxlIGNvbHVtbnMgYXQgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzYW1lIHRpbWUgKGFjdGl2YXRlZCBieSBzaGlmdC1jbGljayBieSB0aGUgdXNlcikuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJNdWx0aVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gRGlzYWJsZSBtdWx0aXBsZSBjb2x1bW4gc29ydGluZyBhYmlsaXR5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJNdWx0aVwiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRNdWx0aVwiOiB0cnVlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFsbG93cyBjb250cm9sIG92ZXIgd2hldGhlciBEYXRhVGFibGVzIHNob3VsZCB1c2UgdGhlIHRvcCAodHJ1ZSkgdW5pcXVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjZWxsIHRoYXQgaXMgZm91bmQgZm9yIGEgc2luZ2xlIGNvbHVtbiwgb3IgdGhlIGJvdHRvbSAoZmFsc2UgLSBkZWZhdWx0KS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgY29tcGxleCBoZWFkZXJzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNlbGxzVG9wXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlckNlbGxzVG9wXCI6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTb3J0Q2VsbHNUb3BcIjogZmFsc2UsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGFkZGl0aW9uIG9mIHRoZSBjbGFzc2VzIGBzb3J0aW5nXFxfMWAsIGBzb3J0aW5nXFxfMmAgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBgc29ydGluZ1xcXzNgIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBjdXJyZW50bHkgYmVpbmcgc29ydGVkIG9uLiBUaGlzIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwcmVzZW50ZWQgYXMgYSBmZWF0dXJlIHN3aXRjaCBhcyBpdCBjYW4gaW5jcmVhc2UgcHJvY2Vzc2luZyB0aW1lICh3aGlsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2xhc3NlcyBhcmUgcmVtb3ZlZCBhbmQgYWRkZWQpIHNvIGZvciBsYXJnZSBkYXRhIHNldHMgeW91IG1pZ2h0IHdhbnQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHR1cm4gdGhpcyBvZmYuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2xhc3Nlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyQ2xhc3Nlc1wiOiBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRDbGFzc2VzXCI6IHRydWUsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgc3RhdGUgc2F2aW5nLiBXaGVuIGVuYWJsZWQgSFRNTDUgYGxvY2FsU3RvcmFnZWAgd2lsbCBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdXNlZCB0byBzYXZlIHRhYmxlIGRpc3BsYXkgaW5mb3JtYXRpb24gc3VjaCBhcyBwYWdpbmF0aW9uIGluZm9ybWF0aW9uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZGlzcGxheSBsZW5ndGgsIGZpbHRlcmluZyBhbmQgc29ydGluZy4gQXMgc3VjaCB3aGVuIHRoZSBlbmQgdXNlciByZWxvYWRzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgcGFnZSB0aGUgZGlzcGxheSBkaXNwbGF5IHdpbGwgbWF0Y2ggd2hhdCB0aHkgaGFkIHByZXZpb3VzbHkgc2V0IHVwLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIER1ZSB0byB0aGUgdXNlIG9mIGBsb2NhbFN0b3JhZ2VgIHRoZSBkZWZhdWx0IHN0YXRlIHNhdmluZyBpcyBub3Qgc3VwcG9ydGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbiBJRTYgb3IgNy4gSWYgc3RhdGUgc2F2aW5nIGlzIHJlcXVpcmVkIGluIHRob3NlIGJyb3dzZXJzLCB1c2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGBzdGF0ZVNhdmVDYWxsYmFja2AgdG8gcHJvdmlkZSBhIHN0b3JhZ2Ugc29sdXRpb24gc3VjaCBhcyBjb29raWVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJTdGF0ZVNhdmVcIjogZmFsc2UsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhIFRSIGVsZW1lbnQgaXMgY3JlYXRlZCAoYW5kIGFsbCBURCBjaGlsZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZWxlbWVudHMgaGF2ZSBiZWVuIGluc2VydGVkKSwgb3IgcmVnaXN0ZXJlZCBpZiB1c2luZyBhIERPTSBzb3VyY2UsIGFsbG93aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBtYW5pcHVsYXRpb24gb2YgdGhlIFRSIGVsZW1lbnQgKGFkZGluZyBjbGFzc2VzIGV0YykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBSYXcgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZGF0YUluZGV4IFRoZSBpbmRleCBvZiB0aGlzIHJvdyBpbiB0aGUgaW50ZXJuYWwgYW9EYXRhIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY3JlYXRlZFJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY3JlYXRlZFJvd1wiOiBmdW5jdGlvbiggcm93LCBkYXRhLCBkYXRhSW5kZXggKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAvLyBCb2xkIHRoZSBncmFkZSBmb3IgYWxsICdBJyBncmFkZSBicm93c2Vyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgaWYgKCBkYXRhWzRdID09IFwiQVwiIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkNyZWF0ZWRSb3dcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSAnZHJhdycgZXZlbnQsIGFuZCBhbGxvd3MgeW91IHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkeW5hbWljYWxseSBtb2RpZnkgYW55IGFzcGVjdCB5b3Ugd2FudCBhYm91dCB0aGUgY3JlYXRlZCBET00uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kcmF3Q2FsbGJhY2tcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImRyYXdDYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIHJlZHJhd24gdGhlIHRhYmxlJyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuRHJhd0NhbGxiYWNrXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSWRlbnRpY2FsIHRvIGZuSGVhZGVyQ2FsbGJhY2soKSBidXQgZm9yIHRoZSB0YWJsZSBmb290ZXIgdGhpcyBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWxsb3dzIHlvdSB0byBtb2RpZnkgdGhlIHRhYmxlIGZvb3RlciBvbiBldmVyeSAnZHJhdycgZXZlbnQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IGZvb3QgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBmb290ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBzdGFydCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBzdGFydGluZyBwb2ludCBpbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGRpc3BsYXkgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGRpc3BsYXkgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5IGludH0gZGlzcGxheSBJbmRleCBhcnJheSB0byB0cmFuc2xhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvb3RlckNhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJmb290ZXJDYWxsYmFja1wiOiBmdW5jdGlvbiggdGZvb3QsIGRhdGEsIHN0YXJ0LCBlbmQsIGRpc3BsYXkgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB0Zm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIlN0YXJ0aW5nIGluZGV4IGlzIFwiK3N0YXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5Gb290ZXJDYWxsYmFja1wiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFdoZW4gcmVuZGVyaW5nIGxhcmdlIG51bWJlcnMgaW4gdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgZm9yIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKGkuZS4gXCJTaG93aW5nIDEgdG8gMTAgb2YgNTcgZW50cmllc1wiKSBEYXRhVGFibGVzIHdpbGwgcmVuZGVyIGxhcmdlIG51bWJlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRvIGhhdmUgYSBjb21tYSBzZXBhcmF0b3IgZm9yIHRoZSAndGhvdXNhbmRzJyB1bml0cyAoZS5nLiAxIG1pbGxpb24gaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlbmRlcmVkIGFzIFwiMSwwMDAsMDAwXCIpIHRvIGhlbHAgcmVhZGFiaWxpdHkgZm9yIHRoZSBlbmQgdXNlci4gVGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZnVuY3Rpb24gd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2QgRGF0YVRhYmxlcyB1c2VzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG1lbWJlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSB0b0Zvcm1hdCBudW1iZXIgdG8gYmUgZm9ybWF0dGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gZm9ybWF0dGVkIHN0cmluZyBmb3IgRGF0YVRhYmxlcyB0byBzaG93IHRoZSBudW1iZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5mb3JtYXROdW1iZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIEZvcm1hdCBhIG51bWJlciB1c2luZyBhIHNpbmdsZSBxdW90ZSBmb3IgdGhlIHNlcGFyYXRvciAobm90ZSB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyB0aGlzIGNhbiBhbHNvIGJlIGRvbmUgd2l0aCB0aGUgbGFuZ3VhZ2UudGhvdXNhbmRzIG9wdGlvbilcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAoIHRvRm9ybWF0ICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRvRm9ybWF0LnRvU3RyaW5nKCkucmVwbGFjZShcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIFwiJ1wiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAodG9Gb3JtYXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9Gb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vTGFuZ3VhZ2Uuc1Rob3VzYW5kc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGR5bmFtaWNhbGx5IG1vZGlmeSB0aGUgaGVhZGVyIHJvdy4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkaXNwbGF5IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IGhlYWQgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBoZWFkZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBzdGFydCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBzdGFydGluZyBwb2ludCBpbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGRpc3BsYXkgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIGRpc3BsYXkgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5IGludH0gZGlzcGxheSBJbmRleCBhcnJheSB0byB0cmFuc2xhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmhlYWRlckNhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJmaGVhZGVyQ2FsbGJhY2tcIjogZnVuY3Rpb24oIGhlYWQsIGRhdGEsIHN0YXJ0LCBlbmQsIGRpc3BsYXkgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBoZWFkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0aCcpWzBdLmlubmVySFRNTCA9IFwiRGlzcGxheWluZyBcIisoZW5kLXN0YXJ0KStcIiByZWNvcmRzXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9IClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkhlYWRlckNhbGxiYWNrXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzdGF0ZSBvZiB0aGUgdGFibGUuIEFsdGhvdWdoIHRoZSBpbnRlcm5hdGlvbmFsaXNhdGlvbiBvcHRpb25zIHByZXNlbnRlZCBieVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBhcmUgcXVpdGUgY2FwYWJsZSBvZiBkZWFsaW5nIHdpdGggbW9zdCBjdXN0b21pc2F0aW9ucywgdGhlcmUgbWF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBiZSB0aW1lcyB3aGVyZSB5b3Ugd2lzaCB0byBjdXN0b21pc2UgdGhlIHN0cmluZyBmdXJ0aGVyLiBUaGlzIGNhbGxiYWNrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbGxvd3MgeW91IHRvIGRvIGV4YWN0bHkgdGhhdC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gc3RhcnQgU3RhcnRpbmcgcG9zaXRpb24gaW4gZGF0YSBmb3IgdGhlIGRyYXdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZW5kIEVuZCBwb3NpdGlvbiBpbiBkYXRhIGZvciB0aGUgZHJhd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBtYXggVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRhYmxlIChyZWdhcmRsZXNzIG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBmaWx0ZXJpbmcpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHRvdGFsIFRvdGFsIG51bWJlciBvZiByb3dzIGluIHRoZSBkYXRhIHNldCwgYWZ0ZXIgZmlsdGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHByZSBUaGUgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBoYXMgZm9ybWF0dGVkIHVzaW5nIGl0J3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIG93biBydWxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluZm9DYWxsYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgXCJpbmZvQ2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBwcmUgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIHN0YXJ0ICtcIiB0byBcIisgZW5kO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5JbmZvQ2FsbGJhY2tcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuIE5vcm1hbGx5IERhdGFUYWJsZXMgd2lsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW5pdGlhbGlzZSBzZXF1ZW50aWFsbHkgYW5kIHRoZXJlIHdpbGwgYmUgbm8gbmVlZCBmb3IgdGhpcyBmdW5jdGlvbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGhvd2V2ZXIsIHRoaXMgZG9lcyBub3QgaG9sZCB0cnVlIHdoZW4gdXNpbmcgZXh0ZXJuYWwgbGFuZ3VhZ2UgaW5mb3JtYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNpbmNlIHRoYXQgaXMgb2J0YWluZWQgdXNpbmcgYW4gYXN5bmMgWEhSIGNhbGwuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgSlNPTiBvYmplY3QgcmVxdWVzdCBmcm9tIHRoZSBzZXJ2ZXIgLSBvbmx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBwcmVzZW50IGlmIGNsaWVudC1zaWRlIEFqYXggc291cmNlZCBkYXRhIGlzIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbml0Q29tcGxldGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImluaXRDb21wbGV0ZVwiOiBmdW5jdGlvbihzZXR0aW5ncywganNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgYWxlcnQoICdEYXRhVGFibGVzIGhhcyBmaW5pc2hlZCBpdHMgaW5pdGlhbGlzYXRpb24uJyApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5Jbml0Q29tcGxldGVcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWxsZWQgYXQgdGhlIHZlcnkgc3RhcnQgb2YgZWFjaCB0YWJsZSBkcmF3IGFuZCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkcmF3IGJ5IHJldHVybmluZyBmYWxzZSwgYW55IG90aGVyIHJldHVybiAoaW5jbHVkaW5nIHVuZGVmaW5lZCkgcmVzdWx0cyBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIGZ1bGwgZHJhdyBvY2N1cnJpbmcpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IEZhbHNlIHdpbGwgY2FuY2VsIHRoZSBkcmF3LCBhbnl0aGluZyBlbHNlIChpbmNsdWRpbmcgbm9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHJldHVybikgd2lsbCBhbGxvdyBpdCB0byBjb21wbGV0ZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wcmVEcmF3Q2FsbGJhY2tcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInByZURyYXdDYWxsYmFja1wiOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBpZiAoICQoJyN0ZXN0JykudmFsKCkgPT0gMSApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuUHJlRHJhd0NhbGxiYWNrXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvICdwb3N0IHByb2Nlc3MnIGVhY2ggcm93IGFmdGVyIGl0IGhhdmUgYmVlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZ2VuZXJhdGVkIGZvciBlYWNoIHRhYmxlIGRyYXcsIGJ1dCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgb24gc2NyZWVuLiBUaGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbiBtaWdodCBiZSB1c2VkIGZvciBzZXR0aW5nIHRoZSByb3cgY2xhc3MgbmFtZSBldGMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBSYXcgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZGlzcGxheUluZGV4IFRoZSBkaXNwbGF5IGluZGV4IGZvciB0aGUgY3VycmVudCB0YWJsZSBkcmF3XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleEZ1bGwgVGhlIGluZGV4IG9mIHRoZSBkYXRhIGluIHRoZSBmdWxsIGxpc3Qgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHJvd3MgKGFmdGVyIGZpbHRlcmluZylcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5yb3dDYWxsYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwicm93Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGlzcGxheUluZGV4LCBkaXNwbGF5SW5kZXhGdWxsICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgLy8gQm9sZCB0aGUgZ3JhZGUgZm9yIGFsbCAnQScgZ3JhZGUgYnJvd3NlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIGlmICggZGF0YVs0XSA9PSBcIkFcIiApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblJvd0NhbGxiYWNrXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBmdW5jdGlvbiB3aGljaCBvYnRhaW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgc28gc29tZXRoaW5nIG1vcmUgc3VpdGFibGUgZm9yIHlvdXIgYXBwbGljYXRpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGb3IgZXhhbXBsZSB5b3UgY291bGQgdXNlIFBPU1QgZGF0YSwgb3IgcHVsbCBpbmZvcm1hdGlvbiBmcm9tIGEgR2VhcnMgb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFJUiBkYXRhYmFzZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBtZW1iZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc291cmNlIEhUVFAgc291cmNlIHRvIG9idGFpbiB0aGUgZGF0YSBmcm9tIChgYWpheGApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBBIGtleS92YWx1ZSBwYWlyIG9iamVjdCBjb250YWluaW5nIHRoZSBkYXRhIHRvIHNlbmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHRvIHRoZSBzZXJ2ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbiBvZiB0aGUgZGF0YSBnZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHByb2Nlc3MgdGhhdCB3aWxsIGRyYXcgdGhlIGRhdGEgb24gdGhlIHBhZ2UuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgU2VydmVyLXNpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VydmVyRGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblNlcnZlckRhdGFcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgSXQgaXMgb2Z0ZW4gdXNlZnVsIHRvIHNlbmQgZXh0cmEgZGF0YSB0byB0aGUgc2VydmVyIHdoZW4gbWFraW5nIGFuIEFqYXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlcXVlc3QgLSBmb3IgZXhhbXBsZSBjdXN0b20gZmlsdGVyaW5nIGluZm9ybWF0aW9uLCBhbmQgdGhpcyBjYWxsYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZnVuY3Rpb24gbWFrZXMgaXQgdHJpdmlhbCB0byBzZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBzZXJ2ZXIuIFRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcGFzc2VkIGluIHBhcmFtZXRlciBpcyB0aGUgZGF0YSBzZXQgdGhhdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBieVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcywgYW5kIHlvdSBjYW4gYWRkIHRvIHRoaXMgb3IgbW9kaWZ5IGl0IGFzIHlvdSByZXF1aXJlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBEYXRhIGFycmF5IChhcnJheSBvZiBvYmplY3RzIHdoaWNoIGFyZSBuYW1lL3ZhbHVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBwYWlycykgdGhhdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBieSBEYXRhVGFibGVzIGFuZCB3aWxsIGJlIHNlbnQgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBzZXJ2ZXIuIEluIHRoZSBjYXNlIG9mIEFqYXggc291cmNlZCBkYXRhIHdpdGggc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgdGhpcyB3aWxsIGJlIGFuIGVtcHR5IGFycmF5LCBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0aGVyZSB3aWxsIGJlIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHNpZ25pZmljYW50IG51bWJlciBvZiBwYXJhbWV0ZXJzIVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEByZXR1cm5zIHt1bmRlZmluZWR9IEVuc3VyZSB0aGF0IHlvdSBtb2RpZnkgdGhlIGRhdGEgYXJyYXkgcGFzc2VkIGluLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgYXMgdGhpcyBpcyBwYXNzZWQgYnkgcmVmZXJlbmNlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclBhcmFtc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblNlcnZlclBhcmFtc1wiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIExvYWQgdGhlIHRhYmxlIHN0YXRlLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBkZWZpbmUgZnJvbSB3aGVyZSwgYW5kIGhvdywgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzdGF0ZSBvZiBhIHRhYmxlIGlzIGxvYWRlZC4gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9hZCBmcm9tIGBsb2NhbFN0b3JhZ2VgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBtZW1iZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcmV0dXJuIHtvYmplY3R9IFRoZSBEYXRhVGFibGVzIHN0YXRlIG9iamVjdCB0byBiZSBsb2FkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRDYWxsYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHZhciBvO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIC8vIFNlbmQgYW4gQWpheCByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSBkYXRhLiBOb3RlIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIC8vIHRoaXMgaXMgYSBzeW5jaHJvbm91cyByZXF1ZXN0LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgJC5hamF4KCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwidXJsXCI6IFwiL3N0YXRlX2xvYWRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJhc3luY1wiOiBmYWxzZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkYXRhVHlwZVwiOiBcImpzb25cIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uIChqc29uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgbyA9IGpzb247XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gbztcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmblN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5nZXRJdGVtKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdEYXRhVGFibGVzXycgKyBzZXR0aW5ncy5zSW5zdGFuY2UgKyAnXycgKyBsb2NhdGlvbi5wYXRobmFtZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzYXZlZCBzdGF0ZSBwcmlvciB0byBsb2FkaW5nIHRoYXQgc3RhdGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGNhbGxiYWNrIGlzIGNhbGxlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZCBkYXRhLCBidXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByaW9yIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgYmVpbmcgbW9kaWZpZWQgYnkgdGhlIHNhdmVkIHN0YXRlLiBOb3RlIHRoYXQgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGQgdXNlIHRoZSBgc3RhdGVMb2FkUGFyYW1zYCBldmVudCB0byBsb2FkIHBhcmFtZXRlcnMgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhIHBsdWctaW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgc3RhdGUgb2JqZWN0IHRoYXQgaXMgdG8gYmUgbG9hZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkUGFyYW1zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBSZW1vdmUgYSBzYXZlZCBmaWx0ZXIsIHNvIGZpbHRlcmluZyBpcyBuZXZlciBsb2FkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgZGF0YS5vU2VhcmNoLnNTZWFyY2ggPSBcIlwiO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gRGlzYWxsb3cgc3RhdGUgbG9hZGluZyBieSByZXR1cm5pbmcgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVMb2FkUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuU3RhdGVMb2FkUGFyYW1zXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaGFzIGJlZW4gbG9hZGVkIGZyb20gdGhlIHN0YXRlIHNhdmluZyBtZXRob2RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFuZCB0aGUgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgYXMgYSByZXN1bHQgb2YgdGhlIGxvYWRlZCBzdGF0ZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCB3YXMgbG9hZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFNob3cgYW4gYWxlcnQgd2l0aCB0aGUgZmlsdGVyaW5nIHZhbHVlIHRoYXQgd2FzIHNhdmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlTG9hZGVkXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgYWxlcnQoICdTYXZlZCBmaWx0ZXIgd2FzOiAnK2RhdGEub1NlYXJjaC5zU2VhcmNoICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5TdGF0ZUxvYWRlZFwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNhdmUgdGhlIHRhYmxlIHN0YXRlLiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gZGVmaW5lIHdoZXJlIGFuZCBob3cgdGhlIHN0YXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlIGlzIHN0b3JlZCBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCB1c2UgYGxvY2FsU3RvcmFnZWBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJ1dCB5b3UgbWlnaHQgd2lzaCB0byB1c2UgYSBzZXJ2ZXItc2lkZSBkYXRhYmFzZSBvciBjb29raWVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG1lbWJlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdG8gYmUgc2F2ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZVNhdmVDYWxsYmFja1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIC8vIFNlbmQgYW4gQWpheCByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgd2l0aCB0aGUgc3RhdGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAkLmFqYXgoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJ1cmxcIjogXCIvc3RhdGVfc2F2ZVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFcIjogZGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkYXRhVHlwZVwiOiBcImpzb25cIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJtZXRob2RcIjogXCJQT1NUXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJzdWNjZXNzXCI6IGZ1bmN0aW9uICgpIHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5TdGF0ZVNhdmVDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLnNldEl0ZW0oXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRGF0YVRhYmxlc18nICsgc2V0dGluZ3Muc0luc3RhbmNlICsgJ18nICsgbG9jYXRpb24ucGF0aG5hbWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShkYXRhKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSB0byBiZSBzYXZlZC4gQ2FsbGVkIHdoZW4gdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBoYXMgY2hhbmdlZCBzdGF0ZSBhIG5ldyBzdGF0ZSBzYXZlIGlzIHJlcXVpcmVkLiBUaGlzIG1ldGhvZCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdGUgc2F2aW5nIG9iamVjdCBwcmlvciB0byBhY3R1YWxseSBkb2luZyB0aGUgc2F2ZSwgaW5jbHVkaW5nIGFkZGl0aW9uIG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBvdGhlciBzdGF0ZSBwcm9wZXJ0aWVzIG9yIG1vZGlmaWNhdGlvbi4gTm90ZSB0aGF0IGZvciBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHVzZSB0aGUgYHN0YXRlU2F2ZVBhcmFtc2AgZXZlbnQgdG8gc2F2ZSBwYXJhbWV0ZXJzIGZvciBhIHBsdWctaW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gZGF0YSBUaGUgc3RhdGUgb2JqZWN0IHRvIGJlIHNhdmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlUGFyYW1zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBSZW1vdmUgYSBzYXZlZCBmaWx0ZXIsIHNvIGZpbHRlcmluZyBpcyBuZXZlciBzYXZlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVQYXJhbXNcIjogZnVuY3Rpb24gKHNldHRpbmdzLCBkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBkYXRhLm9TZWFyY2guc1NlYXJjaCA9IFwiXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5TdGF0ZVNhdmVQYXJhbXNcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uIGlzIGNvbnNpZGVyZWQgdmFsaWQuIEFmdGVyIHRoaXMgcGVyaW9kXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBoYXMgZWxhcHNlZCB0aGUgc3RhdGUgd2lsbCBiZSByZXR1cm5lZCB0byB0aGUgZGVmYXVsdC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFZhbHVlIGlzIGdpdmVuIGluIHNlY29uZHMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgNzIwMCA8aT4oMiBob3Vycyk8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlRHVyYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlRHVyYXRpb25cIjogNjAqNjAqMjQ7IC8vIDEgZGF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImlTdGF0ZUR1cmF0aW9uXCI6IDcyMDAsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogV2hlbiBlbmFibGVkIERhdGFUYWJsZXMgd2lsbCBub3QgbWFrZSBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciBmb3IgdGhlIGZpcnN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwYWdlIGRyYXcgLSByYXRoZXIgaXQgd2lsbCB1c2UgdGhlIGRhdGEgYWxyZWFkeSBvbiB0aGUgcGFnZSAobm8gc29ydGluZyBldGNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHdpbGwgYmUgYXBwbGllZCB0byBpdCksIHRodXMgc2F2aW5nIG9uIGFuIFhIUiBhdCBsb2FkIHRpbWUuIGBkZWZlckxvYWRpbmdgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyB1c2VkIHRvIGluZGljYXRlIHRoYXQgZGVmZXJyZWQgbG9hZGluZyBpcyByZXF1aXJlZCwgYnV0IGl0IGlzIGFsc28gdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdG8gdGVsbCBEYXRhVGFibGVzIGhvdyBtYW55IHJlY29yZHMgdGhlcmUgYXJlIGluIHRoZSBmdWxsIHRhYmxlIChhbGxvd2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgYW5kIHBhZ2luYXRpb24gdG8gYmUgZGlzcGxheWVkIGNvcnJlY3RseSkuIEluIHRoZSBjYXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aGVyZSBhIGZpbHRlcmluZyBpcyBhcHBsaWVkIHRvIHRoZSB0YWJsZSBvbiBpbml0aWFsIGxvYWQsIHRoaXMgY2FuIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbmRpY2F0ZWQgYnkgZ2l2aW5nIHRoZSBwYXJhbWV0ZXIgYXMgYW4gYXJyYXksIHdoZXJlIHRoZSBmaXJzdCBlbGVtZW50IGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgbnVtYmVyIG9mIHJlY29yZHMgYXZhaWxhYmxlIGFmdGVyIGZpbHRlcmluZyBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbnVtYmVyIG9mIHJlY29yZHMgd2l0aG91dCBmaWx0ZXJpbmcgKGFsbG93aW5nIHRoZSB0YWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0byBiZSBzaG93biBjb3JyZWN0bHkpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludCB8IGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZWZlckxvYWRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIDU3IHJlY29yZHMgYXZhaWxhYmxlIGluIHRoZSB0YWJsZSwgbm8gZmlsdGVyaW5nIGFwcGxpZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImFqYXhcIjogXCJzY3JpcHRzL3NlcnZlcl9wcm9jZXNzaW5nLnBocFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZGVmZXJMb2FkaW5nXCI6IDU3XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIDU3IHJlY29yZHMgYWZ0ZXIgZmlsdGVyaW5nLCAxMDAgd2l0aG91dCBmaWx0ZXJpbmcgKGFuIGluaXRpYWwgZmlsdGVyIGFwcGxpZWQpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJhamF4XCI6IFwic2NyaXB0cy9zZXJ2ZXJfcHJvY2Vzc2luZy5waHBcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImRlZmVyTG9hZGluZ1wiOiBbIDU3LCAxMDAgXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNlYXJjaFwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIm15X2ZpbHRlclwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaURlZmVyTG9hZGluZ1wiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgb24gYSBzaW5nbGUgcGFnZSB3aGVuIHVzaW5nIHBhZ2luYXRpb24uIElmXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmZWF0dXJlIGVuYWJsZWQgKGBsZW5ndGhDaGFuZ2VgKSB0aGVuIHRoZSBlbmQgdXNlciB3aWxsIGJlIGFibGUgdG8gb3ZlcnJpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRoaXMgdG8gYSBjdXN0b20gc2V0dGluZyB1c2luZyBhIHBvcC11cCBtZW51LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2VMZW5ndGhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInBhZ2VMZW5ndGhcIjogNTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaURpc3BsYXlMZW5ndGhcIjogMTAsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGVmaW5lIHRoZSBzdGFydGluZyBwb2ludCBmb3IgZGF0YSBkaXNwbGF5IHdoZW4gdXNpbmcgRGF0YVRhYmxlcyB3aXRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwYWdpbmF0aW9uLiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBvZiByZWNvcmRzLCByYXRoZXIgdGhhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIHBhZ2UgbnVtYmVyLCBzbyBpZiB5b3UgaGF2ZSAxMCByZWNvcmRzIHBlciBwYWdlIGFuZCB3YW50IHRvIHN0YXJ0IG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgdGhpcmQgcGFnZSwgaXQgc2hvdWxkIGJlIFwiMjBcIi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRpc3BsYXlTdGFydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZGlzcGxheVN0YXJ0XCI6IDIwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImlEaXNwbGF5U3RhcnRcIjogMCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgYWxsb3dzIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIHRhYmxlIChzb3J0aW5nLCBwYWdpbmcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbmQgZmlsdGVyaW5nKSBieSBhZGRpbmcgYSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSB0byB0aGUgcmVxdWlyZWQgZWxlbWVudHMuIFRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFsbG93cyB5b3UgdG8gdGFiIHRocm91Z2ggdGhlIGNvbnRyb2xzIGFuZCBwcmVzcyB0aGUgZW50ZXIga2V5IHRvIGFjdGl2YXRlIHRoZW0uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgdGFiaW5kZXggaXMgZGVmYXVsdCAwLCBtZWFuaW5nIHRoYXQgdGhlIHRhYiBmb2xsb3dzIHRoZSBmbG93IG9mIHRoZSBkb2N1bWVudC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFlvdSBjYW4gb3ZlcnJ1bGUgdGhpcyB1c2luZyB0aGlzIHBhcmFtZXRlciBpZiB5b3Ugd2lzaC4gVXNlIGEgdmFsdWUgb2YgLTEgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRpc2FibGUgYnVpbHQtaW4ga2V5Ym9hcmQgbmF2aWdhdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnRhYkluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJ0YWJJbmRleFwiOiAxXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJpVGFiSW5kZXhcIjogMCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDbGFzc2VzIHRoYXQgRGF0YVRhYmxlcyBhc3NpZ25zIHRvIHRoZSB2YXJpb3VzIGNvbXBvbmVudHMgYW5kIGZlYXR1cmVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IGl0IGFkZHMgdG8gdGhlIEhUTUwgdGFibGUuIFRoaXMgYWxsb3dzIGNsYXNzZXMgdG8gYmUgY29uZmlndXJlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZHVyaW5nIGluaXRpYWxpc2F0aW9uIGluIGFkZGl0aW9uIHRvIHRocm91Z2ggdGhlIHN0YXRpY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICoge0BsaW5rIERhdGFUYWJsZS5leHQub1N0ZENsYXNzZXN9IG9iamVjdCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jbGFzc2VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwib0NsYXNzZXNcIjoge30sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQWxsIHN0cmluZ3MgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW4gdGhlIHVzZXIgaW50ZXJmYWNlIHRoYXQgaXQgY3JlYXRlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYXJlIGRlZmluZWQgaW4gdGhpcyBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBtb2RpZmllZCB0aGVtIGluZGl2aWR1YWxseSBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29tcGxldGVseSByZXBsYWNlIHRoZW0gYWxsIGFzIHJlcXVpcmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvTGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFN0cmluZ3MgdGhhdCBhcmUgdXNlZCBmb3IgV0FJLUFSSUEgbGFiZWxzIGFuZCBjb250cm9scyBvbmx5ICh0aGVzZSBhcmUgbm90XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYWN0dWFsbHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgYnV0IHdpbGwgYmUgcmVhZCBieSBzY3JlZW5yZWFkZXJzLCBhbmQgdGh1c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIG11c3QgYmUgaW50ZXJuYXRpb25hbGlzZWQgYXMgd2VsbCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIm9BcmlhXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHNvcnRlZCBhc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydEFzY2VuZGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJhcmlhXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInNvcnRBc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBhc2NlbmRpbmdcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0QXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBUklBIGxhYmVsIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRhYmxlIGhlYWRlcnMgd2hlbiB0aGUgY29sdW1uIG1heSBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzb3J0ZWQgZGVzY2VuZGluZyBieSBhY3RpdmluZyB0aGUgY29sdW1uIChjbGljayBvciByZXR1cm4gd2hlbiBmb2N1c2VkKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoZSBjb2x1bW4gaGVhZGVyIGlzIHByZWZpeGVkIHRvIHRoaXMgc3RyaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA6IGFjdGl2YXRlIHRvIHNvcnQgY29sdW1uIGFzY2VuZGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuYXJpYS5zb3J0RGVzY2VuZGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJhcmlhXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInNvcnREZXNjZW5kaW5nXCI6IFwiIC0gY2xpY2svcmV0dXJuIHRvIHNvcnQgZGVzY2VuZGluZ1wiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnREZXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBkZXNjZW5kaW5nXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBQYWdpbmF0aW9uIHN0cmluZyB1c2VkIGJ5IERhdGFUYWJsZXMgZm9yIHRoZSBidWlsdC1pbiBwYWdpbmF0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogY29udHJvbCB0eXBlcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIm9QYWdpbmF0ZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUZXh0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnZnVsbF9udW1iZXJzJyB0eXBlIG9mIHBhZ2luYXRpb24gZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBidXR0b24gdG8gdGFrZSB0aGUgdXNlciB0byB0aGUgZmlyc3QgcGFnZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgRmlyc3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLmZpcnN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImZpcnN0XCI6IFwiRmlyc3QgcGFnZVwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic0ZpcnN0XCI6IFwiRmlyc3RcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGV4dCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ2Z1bGxfbnVtYmVycycgdHlwZSBvZiBwYWdpbmF0aW9uIGZvciB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYnV0dG9uIHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlIGxhc3QgcGFnZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgTGFzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUubGFzdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJsYXN0XCI6IFwiTGFzdCBwYWdlXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzTGFzdFwiOiBcIkxhc3RcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGV4dCB0byB1c2UgZm9yIHRoZSAnbmV4dCcgcGFnaW5hdGlvbiBidXR0b24gKHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG5leHQgcGFnZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IE5leHRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLm5leHRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwibmV4dFwiOiBcIk5leHQgcGFnZVwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic05leHRcIjogXCJOZXh0XCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRleHQgdG8gdXNlIGZvciB0aGUgJ3ByZXZpb3VzJyBwYWdpbmF0aW9uIGJ1dHRvbiAodG8gdGFrZSB0aGUgdXNlciB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgcHJldmlvdXMgcGFnZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFByZXZpb3VzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZS5wcmV2aW91c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJwYWdpbmF0ZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJwcmV2aW91c1wiOiBcIlByZXZpb3VzIHBhZ2VcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNQcmV2aW91c1wiOiBcIlByZXZpb3VzXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHN0cmluZyBpcyBzaG93biBpbiBwcmVmZXJlbmNlIHRvIGB6ZXJvUmVjb3Jkc2Agd2hlbiB0aGUgdGFibGUgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBlbXB0eSBvZiBkYXRhIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuIE5vdGUgdGhhdCB0aGlzIGlzIGFuIG9wdGlvbmFsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogcGFyYW1ldGVyIC0gaWYgaXQgaXMgbm90IGdpdmVuLCB0aGUgdmFsdWUgb2YgYHplcm9SZWNvcmRzYCB3aWxsIGJlIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbnN0ZWFkIChlaXRoZXIgdGhlIGRlZmF1bHQgb3IgZ2l2ZW4gdmFsdWUpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmVtcHR5VGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZW1wdHlUYWJsZVwiOiBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNFbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgc3RyaW5nIGdpdmVzIGluZm9ybWF0aW9uIHRvIHRoZSBlbmQgdXNlciBhYm91dCB0aGUgaW5mb3JtYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IGlzIGN1cnJlbnQgb24gZGlzcGxheSBvbiB0aGUgcGFnZS4gVGhlIGZvbGxvd2luZyB0b2tlbnMgY2FuIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdXNlZCBpbiB0aGUgc3RyaW5nIGFuZCB3aWxsIGJlIGR5bmFtaWNhbGx5IHJlcGxhY2VkIGFzIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGRpc3BsYXkgdXBkYXRlcy4gVGhpcyB0b2tlbnMgY2FuIGJlIHBsYWNlZCBhbnl3aGVyZSBpbiB0aGUgc3RyaW5nLCBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHJlbW92ZWQgYXMgbmVlZGVkIGJ5IHRoZSBsYW5ndWFnZSByZXF1aXJlczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICogYFxcX1NUQVJUXFxfYCAtIERpc3BsYXkgaW5kZXggb2YgdGhlIGZpcnN0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBgXFxfRU5EXFxfYCAtIERpc3BsYXkgaW5kZXggb2YgdGhlIGxhc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGBcXF9UT1RBTFxcX2AgLSBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgdGFibGUgYWZ0ZXIgZmlsdGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBgXFxfTUFYXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSB3aXRob3V0IGZpbHRlcmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICogYFxcX1BBR0VcXF9gIC0gQ3VycmVudCBwYWdlIG51bWJlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICogYFxcX1BBR0VTXFxfYCAtIFRvdGFsIG51bWJlciBvZiBwYWdlcyBvZiBkYXRhIGluIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBTaG93aW5nIF9TVEFSVF8gdG8gX0VORF8gb2YgX1RPVEFMXyBlbnRyaWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImluZm9cIjogXCJTaG93aW5nIHBhZ2UgX1BBR0VfIG9mIF9QQUdFU19cIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0luZm9cIjogXCJTaG93aW5nIF9TVEFSVF8gdG8gX0VORF8gb2YgX1RPVEFMXyBlbnRyaWVzXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBEaXNwbGF5IGluZm9ybWF0aW9uIHN0cmluZyBmb3Igd2hlbiB0aGUgdGFibGUgaXMgZW1wdHkuIFR5cGljYWxseSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBmb3JtYXQgb2YgdGhpcyBzdHJpbmcgc2hvdWxkIG1hdGNoIGBpbmZvYC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFNob3dpbmcgMCB0byAwIG9mIDAgZW50cmllc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuaW5mb0VtcHR5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImluZm9FbXB0eVwiOiBcIk5vIGVudHJpZXMgdG8gc2hvd1wiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzSW5mb0VtcHR5XCI6IFwiU2hvd2luZyAwIHRvIDAgb2YgMCBlbnRyaWVzXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIGEgdXNlciBmaWx0ZXJzIHRoZSBpbmZvcm1hdGlvbiBpbiBhIHRhYmxlLCB0aGlzIHN0cmluZyBpcyBhcHBlbmRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRvIHRoZSBpbmZvcm1hdGlvbiAoYGluZm9gKSB0byBnaXZlIGFuIGlkZWEgb2YgaG93IHN0cm9uZyB0aGUgZmlsdGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogaXMuIFRoZSB2YXJpYWJsZSBfTUFYXyBpcyBkeW5hbWljYWxseSB1cGRhdGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgKGZpbHRlcmVkIGZyb20gX01BWF8gdG90YWwgZW50cmllcylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9GaWx0ZXJlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJpbmZvRmlsdGVyZWRcIjogXCIgLSBmaWx0ZXJpbmcgZnJvbSBfTUFYXyByZWNvcmRzXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNJbmZvRmlsdGVyZWRcIjogXCIoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgY2FuIGJlIHVzZWZ1bCB0byBhcHBlbmQgZXh0cmEgaW5mb3JtYXRpb24gdG8gdGhlIGluZm8gc3RyaW5nIGF0IHRpbWVzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGFuZCB0aGlzIHZhcmlhYmxlIGRvZXMgZXhhY3RseSB0aGF0LiBUaGlzIGluZm9ybWF0aW9uIHdpbGwgYmUgYXBwZW5kZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgYGluZm9gIChgaW5mb0VtcHR5YCBhbmQgYGluZm9GaWx0ZXJlZGAgaW4gd2hhdGV2ZXIgY29tYmluYXRpb24gdGhleSBhcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBiZWluZyB1c2VkKSBhdCBhbGwgdGltZXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5pbmZvUG9zdEZpeFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJpbmZvUG9zdEZpeFwiOiBcIkFsbCByZWNvcmRzIHNob3duIGFyZSBkZXJpdmVkIGZyb20gcmVhbCBpbmZvcm1hdGlvbi5cIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0luZm9Qb3N0Rml4XCI6IFwiXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGRlY2ltYWwgcGxhY2Ugb3BlcmF0b3IgaXMgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIG90aGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogbGFuZ3VhZ2Ugb3B0aW9ucyBzaW5jZSBEYXRhVGFibGVzIGRvZXNuJ3Qgb3V0cHV0IGZsb2F0aW5nIHBvaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogbnVtYmVycywgc28gaXQgd29uJ3QgZXZlciB1c2UgdGhpcyBmb3IgZGlzcGxheSBvZiBhIG51bWJlci4gUmF0aGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHdoYXQgdGhpcyBwYXJhbWV0ZXIgZG9lcyBpcyBtb2RpZnkgdGhlIHNvcnQgbWV0aG9kcyBvZiB0aGUgdGFibGUgc29cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IG51bWJlcnMgd2hpY2ggYXJlIGluIGEgZm9ybWF0IHdoaWNoIGhhcyBhIGNoYXJhY3RlciBvdGhlciB0aGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYSBwZXJpb2QgKGAuYCkgYXMgYSBkZWNpbWFsIHBsYWNlIHdpbGwgYmUgc29ydGVkIG51bWVyaWNhbGx5LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IG51bWJlcnMgd2l0aCBkaWZmZXJlbnQgZGVjaW1hbCBwbGFjZXMgY2Fubm90IGJlIHNob3duIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIHNhbWUgdGFibGUgYW5kIHN0aWxsIGJlIHNvcnRhYmxlLCB0aGUgdGFibGUgbXVzdCBiZSBjb25zaXN0ZW50LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEhvd2V2ZXIsIG11bHRpcGxlIGRpZmZlcmVudCB0YWJsZXMgb24gdGhlIHBhZ2UgY2FuIHVzZSBkaWZmZXJlbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBkZWNpbWFsIHBsYWNlIGNoYXJhY3RlcnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmRlY2ltYWxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZGVjaW1hbFwiOiBcIixcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiLlwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzRGVjaW1hbFwiOiBcIlwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBoYXMgYSBidWlsZCBpbiBudW1iZXIgZm9ybWF0dGVyIChgZm9ybWF0TnVtYmVyYCkgd2hpY2ggaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB1c2VkIHRvIGZvcm1hdCBsYXJnZSBudW1iZXJzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRhYmxlIGluZm9ybWF0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEJ5IGRlZmF1bHQgYSBjb21tYSBpcyB1c2VkLCBidXQgdGhpcyBjYW4gYmUgdHJpdmlhbGx5IGNoYW5nZWQgdG8gYW55XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogY2hhcmFjdGVyIHlvdSB3aXNoIHdpdGggdGhpcyBwYXJhbWV0ZXIuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS50aG91c2FuZHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiJ1wiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzVGhvdXNhbmRzXCI6IFwiLFwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogRGV0YWlsIHRoZSBhY3Rpb24gdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIGRyb3AgZG93biBtZW51IGZvciB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBwYWdpbmF0aW9uIGxlbmd0aCBvcHRpb24gaXMgY2hhbmdlZC4gVGhlICdfTUVOVV8nIHZhcmlhYmxlIGlzIHJlcGxhY2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogd2l0aCBhIGRlZmF1bHQgc2VsZWN0IGxpc3Qgb2YgMTAsIDI1LCA1MCBhbmQgMTAwLCBhbmQgY2FuIGJlIHJlcGxhY2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogd2l0aCBhIGN1c3RvbSBzZWxlY3QgYm94IGlmIHJlcXVpcmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgU2hvdyBfTUVOVV8gZW50cmllc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubGVuZ3RoTWVudVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgLy8gTGFuZ3VhZ2UgY2hhbmdlIG9ubHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImxlbmd0aE1lbnVcIjogXCJEaXNwbGF5IF9NRU5VXyByZWNvcmRzXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIExhbmd1YWdlIGFuZCBvcHRpb25zIGNoYW5nZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwibGVuZ3RoTWVudVwiOiAnRGlzcGxheSA8c2VsZWN0PicrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjEwXCI+MTA8L29wdGlvbj4nK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIyMFwiPjIwPC9vcHRpb24+JytcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMzBcIj4zMDwvb3B0aW9uPicrXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjQwXCI+NDA8L29wdGlvbj4nK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCI1MFwiPjUwPC9vcHRpb24+JytcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiLTFcIj5BbGw8L29wdGlvbj4nK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJzwvc2VsZWN0PiByZWNvcmRzJ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0xlbmd0aE1lbnVcIjogXCJTaG93IF9NRU5VXyBlbnRyaWVzXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIHVzaW5nIEFqYXggc291cmNlZCBkYXRhIGFuZCBkdXJpbmcgdGhlIGZpcnN0IGRyYXcgd2hlbiBEYXRhVGFibGVzIGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZ2F0aGVyaW5nIHRoZSBkYXRhLCB0aGlzIG1lc3NhZ2UgaXMgc2hvd24gaW4gYW4gZW1wdHkgcm93IGluIHRoZSB0YWJsZSB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGluZGljYXRlIHRvIHRoZSBlbmQgdXNlciB0aGUgdGhlIGRhdGEgaXMgYmVpbmcgbG9hZGVkLiBOb3RlIHRoYXQgdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHBhcmFtZXRlciBpcyBub3QgdXNlZCB3aGVuIGxvYWRpbmcgZGF0YSBieSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCBqdXN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgTG9hZGluZy4uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubG9hZGluZ1JlY29yZHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwibG9hZGluZ1JlY29yZHNcIjogXCJQbGVhc2Ugd2FpdCAtIGxvYWRpbmcuLi5cIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0xvYWRpbmdSZWNvcmRzXCI6IFwiTG9hZGluZy4uLlwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVGV4dCB3aGljaCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgdGFibGUgaXMgcHJvY2Vzc2luZyBhIHVzZXIgYWN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKHVzdWFsbHkgYSBzb3J0IGNvbW1hbmQgb3Igc2ltaWxhcikuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBQcm9jZXNzaW5nLi4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wcm9jZXNzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInByb2Nlc3NpbmdcIjogXCJEYXRhVGFibGVzIGlzIGN1cnJlbnRseSBidXN5XCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNQcm9jZXNzaW5nXCI6IFwiUHJvY2Vzc2luZy4uLlwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogRGV0YWlscyB0aGUgYWN0aW9ucyB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgdXNlciB0eXBlcyBpbnRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZpbHRlcmluZyBpbnB1dCB0ZXh0IGJveC4gVGhlIHZhcmlhYmxlIFwiX0lOUFVUX1wiLCBpZiB1c2VkIGluIHRoZSBzdHJpbmcsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogaXMgcmVwbGFjZWQgd2l0aCB0aGUgSFRNTCB0ZXh0IGJveCBmb3IgdGhlIGZpbHRlcmluZyBpbnB1dCBhbGxvd2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGNvbnRyb2wgb3ZlciB3aGVyZSBpdCBhcHBlYXJzIGluIHRoZSBzdHJpbmcuIElmIFwiX0lOUFVUX1wiIGlzIG5vdCBnaXZlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZW4gdGhlIGlucHV0IGJveCBpcyBhcHBlbmRlZCB0byB0aGUgc3RyaW5nIGF1dG9tYXRpY2FsbHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBTZWFyY2g6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIElucHV0IHRleHQgYm94IHdpbGwgYmUgYXBwZW5kZWQgYXQgdGhlIGVuZCBhdXRvbWF0aWNhbGx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJzZWFyY2hcIjogXCJGaWx0ZXIgcmVjb3JkczpcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgLy8gU3BlY2lmeSB3aGVyZSB0aGUgZmlsdGVyIHNob3VsZCBhcHBlYXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInNlYXJjaFwiOiBcIkFwcGx5IGZpbHRlciBfSU5QVVRfIHRvIHRhYmxlXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogXCJTZWFyY2g6XCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBBc3NpZ24gYSBgcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSB0byB0aGUgc2VhcmNoIGBpbnB1dGAgZWxlbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hQbGFjZWhvbGRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NlYXJjaFBsYWNlaG9sZGVyXCI6IFwiXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBBbGwgb2YgdGhlIGxhbmd1YWdlIGluZm9ybWF0aW9uIGNhbiBiZSBzdG9yZWQgaW4gYSBmaWxlIG9uIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNlcnZlci1zaWRlLCB3aGljaCBEYXRhVGFibGVzIHdpbGwgbG9vayB1cCBpZiB0aGlzIHBhcmFtZXRlciBpcyBwYXNzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogSXQgbXVzdCBzdG9yZSB0aGUgVVJMIG9mIHRoZSBsYW5ndWFnZSBmaWxlLCB3aGljaCBpcyBpbiBhIEpTT04gZm9ybWF0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGFuZCB0aGUgb2JqZWN0IGhhcyB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoZSBvTGFuZ3VhZ2Ugb2JqZWN0IGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGluaXRpYWxpc2VyIG9iamVjdCAoaS5lLiB0aGUgYWJvdmUgcGFyYW1ldGVycykuIFBsZWFzZSByZWZlciB0byBvbmUgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZXhhbXBsZSBsYW5ndWFnZSBmaWxlcyB0byBzZWUgaG93IHRoaXMgd29ya3MgaW4gYWN0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nIC0gaS5lLiBkaXNhYmxlZDwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnVybFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ1cmxcIjogXCJodHRwOi8vd3d3LnNwcnltZWRpYS5jby51ay9kYXRhVGFibGVzL2xhbmcudHh0XCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNVcmxcIjogXCJcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRleHQgc2hvd24gaW5zaWRlIHRoZSB0YWJsZSByZWNvcmRzIHdoZW4gdGhlIGlzIG5vIGluZm9ybWF0aW9uIHRvIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZGlzcGxheWVkIGFmdGVyIGZpbHRlcmluZy4gYGVtcHR5VGFibGVgIGlzIHNob3duIHdoZW4gdGhlcmUgaXMgc2ltcGx5IG5vXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogaW5mb3JtYXRpb24gaW4gdGhlIHRhYmxlIGF0IGFsbCAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuemVyb1JlY29yZHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiemVyb1JlY29yZHNcIjogXCJObyByZWNvcmRzIHRvIGRpc3BsYXlcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1plcm9SZWNvcmRzXCI6IFwiTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFwiXHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gaGF2ZSBkZWZpbmUgdGhlIGdsb2JhbCBmaWx0ZXJpbmcgc3RhdGUgYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluaXRpYWxpc2F0aW9uIHRpbWUuIEFzIGFuIG9iamVjdCB0aGUgYHNlYXJjaGAgcGFyYW1ldGVyIG11c3QgYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRlZmluZWQsIGJ1dCBhbGwgb3RoZXIgcGFyYW1ldGVycyBhcmUgb3B0aW9uYWwuIFdoZW4gYHJlZ2V4YCBpcyB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlIHNlYXJjaCBzdHJpbmcgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCB3aGVuIGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAoZGVmYXVsdCkgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgc3RyYWlnaHQgc3RyaW5nLiBXaGVuIGBzbWFydGBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgd2lsbCB1c2UgaXQncyBzbWFydCBmaWx0ZXJpbmcgbWV0aG9kcyAodG8gd29yZCBtYXRjaCBhdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW55IHBvaW50IGluIHRoZSBkYXRhKSwgd2hlbiBmYWxzZSB0aGlzIHdpbGwgbm90IGJlIGRvbmUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleHRlbmRzIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNlYXJjaFwiOiB7XCJzZWFyY2hcIjogXCJJbml0aWFsIHNlYXJjaFwifVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9IClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvU2VhcmNoXCI6ICQuZXh0ZW5kKHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gpLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eSBgZGF0YWAgKG9yIGBhYURhdGFgIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY29tcGF0aWJpbGl0eSB3aXRoIERhdGFUYWJsZXMgMS45LSkgd2hlbiBvYnRhaW5pbmcgZGF0YSBmcm9tIGFuIEFqYXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNvdXJjZSBvciBmb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHRoaXMgcGFyYW1ldGVyIGFsbG93cyB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkLiBZb3UgY2FuIHVzZSBKYXZhc2NyaXB0IGRvdHRlZCBvYmplY3Qgbm90YXRpb24gdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGdldCBhIGRhdGEgc291cmNlIGZvciBtdWx0aXBsZSBsZXZlbHMgb2YgbmVzdGluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhEYXRhUHJvcFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzQWpheERhdGFQcm9wXCI6IFwiZGF0YVwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFlvdSBjYW4gaW5zdHJ1Y3QgRGF0YVRhYmxlcyB0byBsb2FkIGRhdGEgZnJvbSBhbiBleHRlcm5hbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc291cmNlIHVzaW5nIHRoaXMgcGFyYW1ldGVyICh1c2UgYURhdGEgaWYgeW91IHdhbnQgdG8gcGFzcyBkYXRhIGluIHlvdVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWxyZWFkeSBoYXZlKS4gU2ltcGx5IHByb3ZpZGUgYSB1cmwgYSBKU09OIG9iamVjdCBjYW4gYmUgb2J0YWluZWQgZnJvbS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhTb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0FqYXhTb3VyY2VcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGluaXRpYWxpc2F0aW9uIHZhcmlhYmxlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBleGFjdGx5IHdoZXJlIGluIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRE9NIHlvdSB3YW50IERhdGFUYWJsZXMgdG8gaW5qZWN0IHRoZSB2YXJpb3VzIGNvbnRyb2xzIGl0IGFkZHMgdG8gdGhlIHBhZ2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIChmb3IgZXhhbXBsZSB5b3UgbWlnaHQgd2FudCB0aGUgcGFnaW5hdGlvbiBjb250cm9scyBhdCB0aGUgdG9wIG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGFibGUpLiBESVYgZWxlbWVudHMgKHdpdGggb3Igd2l0aG91dCBhIGN1c3RvbSBjbGFzcykgY2FuIGFsc28gYmUgYWRkZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFpZCBzdHlsaW5nLiBUaGUgZm9sbG93IHN5bnRheCBpcyB1c2VkOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICA8dWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYWxsb3dlZDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nZicgLSBGaWx0ZXJpbmcgaW5wdXQ8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICA8bGk+J3QnIC0gVGhlIHRhYmxlITwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4ncCcgLSBQYWdpbmF0aW9uPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPidyJyAtIHBSb2Nlc3Npbmc8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgPC91bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT5UaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgYWxsb3dlZDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPidIJyAtIGpRdWVyeVVJIHRoZW1lIFwiaGVhZGVyXCIgY2xhc3NlcyAoJ2ZnLXRvb2xiYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItdGwgdWktY29ybmVyLXRyIHVpLWhlbHBlci1jbGVhcmZpeCcpPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgPGxpPidGJyAtIGpRdWVyeVVJIHRoZW1lIFwiZm9vdGVyXCIgY2xhc3NlcyAoJ2ZnLXRvb2xiYXIgdWktd2lkZ2V0LWhlYWRlciB1aS1jb3JuZXItYmwgdWktY29ybmVyLWJyIHVpLWhlbHBlci1jbGVhcmZpeCcpPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIDwvdWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBzeW50YXggaXMgZXhwZWN0ZWQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICA8dWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nJmx0OycgYW5kICcmZ3Q7JyAtIGRpdiBlbGVtZW50czwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nJmx0O1wiY2xhc3NcIiBhbmQgJyZndDsnIC0gZGl2IHdpdGggYSBjbGFzczwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nJmx0O1wiI2lkXCIgYW5kICcmZ3Q7JyAtIGRpdiB3aXRoIGFuIElEPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIDwvdWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+RXhhbXBsZXM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICA8dWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nJmx0O1wid3JhcHBlclwiZmxpcHQmZ3Q7JzwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgIDxsaT4nJmx0O2xmJmx0O3QmZ3Q7aXAmZ3Q7JzwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICA8L3VsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDwvdWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbGZydGlwIDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgZmFsc2UpPC9pPiA8Yj5vcjwvYj5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIDxcIkhcImxmcj50PFwiRlwiaXA+IDxpPih3aGVuIGBqUXVlcnlVSWAgaXMgdHJ1ZSk8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRvbVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiZG9tXCI6ICcmbHQ7XCJ0b3BcImkmZ3Q7cnQmbHQ7XCJib3R0b21cImZscCZndDsmbHQ7XCJjbGVhclwiJmd0OydcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNEb21cIjogXCJsZnJ0aXBcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTZWFyY2ggZGVsYXkgb3B0aW9uLiBUaGlzIHdpbGwgdGhyb3R0bGUgZnVsbCB0YWJsZSBzZWFyY2hlcyB0aGF0IHVzZSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgcHJvdmlkZWQgc2VhcmNoIGlucHV0IGVsZW1lbnQgKGl0IGRvZXMgbm90IGVmZmVjdCBjYWxscyB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYGR0LWFwaSBzZWFyY2goKWAsIHByb3ZpZGluZyBhIGRlbGF5IGJlZm9yZSB0aGUgc2VhcmNoIGlzIG1hZGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50ZWdlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoRGVsYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNlYXJjaERlbGF5XCI6IDIwMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9IClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzZWFyY2hEZWxheVwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERhdGFUYWJsZXMgZmVhdHVyZXMgZm91ciBkaWZmZXJlbnQgYnVpbHQtaW4gb3B0aW9ucyBmb3IgdGhlIGJ1dHRvbnMgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRpc3BsYXkgZm9yIHBhZ2luYXRpb24gY29udHJvbDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBzaW1wbGVgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMgb25seVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiAnc2ltcGxlX251bWJlcnNgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBmdWxsYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGZ1bGxfbnVtYmVyc2AgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIHBhZ2UgbnVtYmVyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRnVydGhlciBtZXRob2RzIGNhbiBiZSBhZGRlZCB1c2luZyB7QGxpbmsgRGF0YVRhYmxlLmV4dC5vUGFnaW5hdGlvbn0uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgc2ltcGxlX251bWJlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucGFnaW5nVHlwZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwicGFnaW5nVHlwZVwiOiBcImZ1bGxfbnVtYmVyc1wiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNQYWdpbmF0aW9uVHlwZVwiOiBcInNpbXBsZV9udW1iZXJzXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIGhvcml6b250YWwgc2Nyb2xsaW5nLiBXaGVuIGEgdGFibGUgaXMgdG9vIHdpZGUgdG8gZml0IGludG8gYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2VydGFpbiBsYXlvdXQsIG9yIHlvdSBoYXZlIGEgbGFyZ2UgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRhYmxlLCB5b3VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNhbiBlbmFibGUgeC1zY3JvbGxpbmcgdG8gc2hvdyB0aGUgdGFibGUgaW4gYSB2aWV3cG9ydCwgd2hpY2ggY2FuIGJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzY3JvbGxlZC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYHRydWVgIHdoaWNoIHdpbGwgYWxsb3cgdGhlIHRhYmxlIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzY3JvbGwgaG9yaXpvbnRhbGx5IHdoZW4gbmVlZGVkLCBvciBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuIFNldHRpbmcgYXMgc2ltcGx5IGB0cnVlYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgcmVjb21tZW5kZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsWFwiOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbFhcIjogXCJcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGZvcmNlIGEgRGF0YVRhYmxlIHRvIHVzZSBtb3JlIHdpZHRoIHRoYW4gaXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG1pZ2h0IG90aGVyd2lzZSBkbyB3aGVuIHgtc2Nyb2xsaW5nIGlzIGVuYWJsZWQuIEZvciBleGFtcGxlIGlmIHlvdSBoYXZlIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRhYmxlIHdoaWNoIHJlcXVpcmVzIHRvIGJlIHdlbGwgc3BhY2VkLCB0aGlzIHBhcmFtZXRlciBpcyB1c2VmdWwgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcIm92ZXItc2l6aW5nXCIgdGhlIHRhYmxlLCBhbmQgdGh1cyBmb3JjaW5nIHNjcm9sbGluZy4gVGhpcyBwcm9wZXJ0eSBjYW4gYnlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG1lYXN1cmVtZW50KS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxYSW5uZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFhcIjogXCIxMDAlXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxYSW5uZXJcIjogXCIxMTAlXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTY3JvbGxYSW5uZXJcIjogXCJcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgdmVydGljYWwgc2Nyb2xsaW5nLiBWZXJ0aWNhbCBzY3JvbGxpbmcgd2lsbCBjb25zdHJhaW4gdGhlIERhdGFUYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdG8gdGhlIGdpdmVuIGhlaWdodCwgYW5kIGVuYWJsZSBzY3JvbGxpbmcgZm9yIGFueSBkYXRhIHdoaWNoIG92ZXJmbG93cyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGN1cnJlbnQgdmlld3BvcnQuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYW4gYWx0ZXJuYXRpdmUgdG8gcGFnaW5nIHRvIGRpc3BsYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGEgbG90IG9mIGRhdGEgaW4gYSBzbWFsbCBhcmVhIChhbHRob3VnaCBwYWdpbmcgYW5kIHNjcm9sbGluZyBjYW4gYm90aCBiZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZW5hYmxlZCBhdCB0aGUgc2FtZSB0aW1lKS4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYW55IENTUyB1bml0LCBvciBhIG51bWJlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zY3JvbGxZXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwcHhcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcInBhZ2luYXRlXCI6IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU2Nyb2xsWVwiOiBcIlwiLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNldCB0aGUgSFRUUCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIG1ha2UgdGhlIEFqYXggY2FsbCBmb3Igc2VydmVyLXNpZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByb2Nlc3Npbmcgb3IgQWpheCBzb3VyY2VkIGRhdGEuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgR0VUXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlck1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU2VydmVyTWV0aG9kXCI6IFwiR0VUXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBtYWtlcyB1c2Ugb2YgcmVuZGVyZXJzIHdoZW4gZGlzcGxheWluZyBIVE1MIGVsZW1lbnRzIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYSB0YWJsZS4gVGhlc2UgcmVuZGVyZXJzIGNhbiBiZSBhZGRlZCBvciBtb2RpZmllZCBieSBwbHVnLWlucyB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZ2VuZXJhdGUgc3VpdGFibGUgbWFyay11cCBmb3IgYSBzaXRlLiBGb3IgZXhhbXBsZSB0aGUgQm9vdHN0cmFwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbnRlZ3JhdGlvbiBwbHVnLWluIGZvciBEYXRhVGFibGVzIHVzZXMgYSBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyIHRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkaXNwbGF5IHBhZ2luYXRpb24gYnV0dG9ucyBpbiB0aGUgbWFyay11cCByZXF1aXJlZCBieSBCb290c3RyYXAuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVycyBhdmFpbGFibGUgc2VlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGUuZXh0LnJlbmRlcmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nfG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJlbmRlcmVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInJlbmRlcmVyXCI6IG51bGxcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIF9mbkh1bmdhcmlhbk1hcChEYXRhVGFibGUuZGVmYXVsdHMpO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEZXZlbG9wZXIgbm90ZSAtIFNlZSBub3RlIGluIG1vZGVsLmRlZmF1bHRzLmpzIGFib3V0IHRoZSB1c2Ugb2YgSHVuZ2FyaWFuXHJcblx0ICAgICAgICAgICAgICAgICAqIG5vdGF0aW9uIGFuZCBjYW1lbCBjYXNlLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uID0ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEZWZpbmUgd2hpY2ggY29sdW1uKHMpIGFuIG9yZGVyIHdpbGwgb2NjdXIgb24gZm9yIHRoaXMgY29sdW1uLiBUaGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhbGxvd3MgYSBjb2x1bW4ncyBvcmRlcmluZyB0byB0YWtlIG11bHRpcGxlIGNvbHVtbnMgaW50byBhY2NvdW50IHdoZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRvaW5nIGEgc29ydCBvciB1c2UgdGhlIGRhdGEgZnJvbSBhIGRpZmZlcmVudCBjb2x1bW4uIEZvciBleGFtcGxlIGZpcnN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnMgbWFrZSBzZW5zZSB0byBkbyBhIG11bHRpLWNvbHVtbiBzb3J0IG92ZXIgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0d28gY29sdW1ucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheXxpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIDxpPlRha2VzIHRoZSB2YWx1ZSBvZiB0aGUgY29sdW1uIGluZGV4IGF1dG9tYXRpY2FsbHk8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IFsgMCwgMSBdLCBcInRhcmdldHNcIjogWyAwIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0sIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiAyLCBcInRhcmdldHNcIjogWyAyIF0gfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAwLCAxIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhRGF0YVNvcnRcIjogbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaURhdGFTb3J0XCI6IC0xLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFlvdSBjYW4gY29udHJvbCB0aGUgZGVmYXVsdCBvcmRlcmluZyBkaXJlY3Rpb24sIGFuZCBldmVuIGFsdGVyIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYmVoYXZpb3VyIG9mIHRoZSBzb3J0IGhhbmRsZXIgKGkuZS4gb25seSBhbGxvdyBhc2NlbmRpbmcgb3JkZXJpbmcgZXRjKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdXNpbmcgdGhpcyBwYXJhbWV0ZXIuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbICdhc2MnLCAnZGVzYycgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLm9yZGVyU2VxdWVuY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAxIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIsIFwiYXNjXCIsIFwiYXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMiBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDMgXSB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJhc2NcIiBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJTZXF1ZW5jZVwiOiBbIFwiZGVzY1wiLCBcImFzY1wiLCBcImFzY1wiIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFzU29ydGluZ1wiOiBbJ2FzYycsICdkZXNjJ10sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9uIHRoZSBkYXRhIGluIHRoaXMgY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uc2VhcmNoYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInNlYXJjaGFibGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInNlYXJjaGFibGVcIjogZmFsc2UgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU2VhcmNoYWJsZVwiOiB0cnVlLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIG9yZGVyaW5nIG9uIHRoaXMgY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF0gfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU29ydGFibGVcIjogdHJ1ZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiB0aGlzIGNvbHVtbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnZpc2libGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ2aXNpYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF0gfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ2aXNpYmxlXCI6IGZhbHNlIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlZpc2libGVcIjogdHJ1ZSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEZXZlbG9wZXIgZGVmaW5hYmxlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgY2VsbCBpcyBjcmVhdGVkIChBamF4IHNvdXJjZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGV0Yykgb3IgcHJvY2Vzc2VkIGZvciBpbnB1dCAoRE9NIHNvdXJjZSkuIFRoaXMgY2FuIGJlIHVzZWQgYXMgYSBjb21wbGltZW50IHRvIG1SZW5kZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFsbG93aW5nIHlvdSB0byBtb2RpZnkgdGhlIERPTSBlbGVtZW50IChhZGQgYmFja2dyb3VuZCBjb2xvdXIgZm9yIGV4YW1wbGUpIHdoZW4gdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50IGlzIGF2YWlsYWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZWxlbWVudH0gdGQgVGhlIFREIG5vZGUgdGhhdCBoYXMgYmVlbiBjcmVhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSBjZWxsRGF0YSBUaGUgRGF0YSBmb3IgdGhlIGNlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fG9iamVjdH0gcm93RGF0YSBUaGUgZGF0YSBmb3IgdGhlIHdob2xlIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSByb3cgVGhlIHJvdyBpbmRleCBmb3IgdGhlIGFvRGF0YSBkYXRhIHN0b3JlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbCBUaGUgY29sdW1uIGluZGV4IGZvciBhb0NvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jcmVhdGVkQ2VsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFszXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiY3JlYXRlZENlbGxcIjogZnVuY3Rpb24gKHRkLCBjZWxsRGF0YSwgcm93RGF0YSwgcm93LCBjb2wpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgaWYgKCBjZWxsRGF0YSA9PSBcIjEuN1wiICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgICQodGQpLmNzcygnY29sb3InLCAnYmx1ZScpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IGBkYXRhYCBpbiBEYXRhVGFibGVzIHRvIGVuc3VyZSBuYW1pbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNvbnNpc3RlbmN5LiBgZGF0YVByb3BgIGNhbiBzdGlsbCBiZSB1c2VkLCBhcyB0aGVyZSBpcyBiYWNrd2FyZHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNvbXBhdGliaWxpdHkgaW4gRGF0YVRhYmxlcyBmb3IgdGhpcyBvcHRpb24sIGJ1dCBpdCBpcyBzdHJvbmdseVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIGBkYXRhYCBpbiBwcmVmZXJlbmNlIHRvIGBkYXRhUHJvcGAuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhUHJvcFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byByZWFkIGRhdGEgZnJvbSBhbnkgZGF0YSBzb3VyY2UgcHJvcGVydHksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbmNsdWRpbmcgZGVlcGx5IG5lc3RlZCBvYmplY3RzIC8gcHJvcGVydGllcy4gYGRhdGFgIGNhbiBiZSBnaXZlbiBpbiBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBudW1iZXIgb2YgZGlmZmVyZW50IHdheXMgd2hpY2ggZWZmZWN0IGl0cyBiZWhhdmlvdXI6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgcmV0dXJuZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC4gTm90ZSB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGZ1bmN0aW9uIG5vdGF0aW9uIGlzIHJlY29tbWVuZGVkIGZvciB1c2UgaW4gYHJlbmRlcmAgcmF0aGVyIHRoYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYGRhdGFgIGFzIGl0IGlzIG11Y2ggc2ltcGxlciB0byB1c2UgYXMgYSByZW5kZXJlci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYG51bGxgIC0gdXNlIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyByYXRoZXIgdGhhbiBwbHVja2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBkYXRhIGRpcmVjdGx5IGZyb20gaXQuIFRoaXMgYWN0aW9uIGhhcyBlZmZlY3RzIG9uIHR3byBvdGhlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBpbml0aWFsaXNhdGlvbiBvcHRpb25zOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBgZGVmYXVsdENvbnRlbnRgIC0gV2hlbiBudWxsIGlzIGdpdmVuIGFzIHRoZSBgZGF0YWAgb3B0aW9uIGFuZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBgZGVmYXVsdENvbnRlbnRgIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHZhbHVlIGRlZmluZWQgYnlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYGRlZmF1bHRDb250ZW50YCB3aWxsIGJlIHVzZWQgZm9yIHRoZSBjZWxsLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBgcmVuZGVyYCAtIFdoZW4gbnVsbCBpcyB1c2VkIGZvciB0aGUgYGRhdGFgIG9wdGlvbiBhbmQgdGhlIGByZW5kZXJgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9wdGlvbiBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB3aG9sZSBkYXRhIHNvdXJjZSBmb3IgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIHJvdyBpcyB1c2VkIGZvciB0aGUgcmVuZGVyZXIuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgdGFrZXMgdGhyZWUgcGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICogUGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgKiBge2FycmF5fG9iamVjdH1gIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvd1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAqIGB7c3RyaW5nfWAgVGhlIHR5cGUgY2FsbCBkYXRhIHJlcXVlc3RlZCAtIHRoaXMgd2lsbCBiZSAnc2V0JyB3aGVuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgc2V0dGluZyBkYXRhIG9yICdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJywgJ3NvcnQnIG9yIHVuZGVmaW5lZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHdoZW4gZ2F0aGVyaW5nIGRhdGEuIE5vdGUgdGhhdCB3aGVuIGB1bmRlZmluZWRgIGlzIGdpdmVuIGZvciB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB0eXBlIERhdGFUYWJsZXMgZXhwZWN0cyB0byBnZXQgdGhlIHJhdyBkYXRhIGZvciB0aGUgb2JqZWN0IGJhY2s8XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICogYHsqfWAgRGF0YSB0byBzZXQgd2hlbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyAnc2V0Jy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICogUmV0dXJuOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gaXMgbm90IHJlcXVpcmVkIHdoZW4gJ3NldCcgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB0aGUgdHlwZSBvZiBjYWxsLCBidXQgb3RoZXJ3aXNlIHRoZSByZXR1cm4gaXMgd2hhdCB3aWxsIGJlIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBmb3IgdGhlIGRhdGEgcmVxdWVzdGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCBgZGF0YWAgaXMgYSBnZXR0ZXIgYW5kIHNldHRlciBvcHRpb24uIElmIHlvdSBqdXN0IHJlcXVpcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGZvcm1hdHRpbmcgb2YgZGF0YSBmb3Igb3V0cHV0LCB5b3Ugd2lsbCBsaWtlbHkgd2FudCB0byB1c2UgYHJlbmRlcmAgd2hpY2hcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIHNpbXBseSBhIGdldHRlciBhbmQgdGh1cyBzaW1wbGVyIHRvIHVzZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgcHJpb3IgdG8gRGF0YVRhYmxlcyAxLjkuMiBgZGF0YWAgd2FzIGNhbGxlZCBgbURhdGFQcm9wYC4gVGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBuYW1lIGNoYW5nZSByZWZsZWN0cyB0aGUgZmxleGliaWxpdHkgb2YgdGhpcyBwcm9wZXJ0eSBhbmQgaXMgY29uc2lzdGVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2l0aCB0aGUgbmFtaW5nIG9mIG1SZW5kZXIuIElmICdtRGF0YVByb3AnIGlzIGdpdmVuLCB0aGVuIGl0IHdpbGwgc3RpbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJlIHVzZWQgYnkgRGF0YVRhYmxlcywgYXMgaXQgYXV0b21hdGljYWxseSBtYXBzIHRoZSBvbGQgbmFtZSB0byB0aGUgbmV3XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpZiByZXF1aXJlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nfGludHxmdW5jdGlvbnxudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5Vc2UgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGNvbHVtbiBpbmRleDwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFJlYWQgdGFibGUgZGF0YSBmcm9tIG9iamVjdHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIEpTT04gc3RydWN0dXJlIGZvciBlYWNoIHJvdzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICAgICBcImVuZ2luZVwiOiB7dmFsdWV9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICAgICBcImJyb3dzZXJcIjoge3ZhbHVlfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJwbGF0Zm9ybVwiOiB7dmFsdWV9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICAgICBcInZlcnNpb25cIjoge3ZhbHVlfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJncmFkZVwiOiB7dmFsdWV9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL29iamVjdHMudHh0XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwidmVyc2lvblwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImdyYWRlXCIgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gUmVhZCBpbmZvcm1hdGlvbiBmcm9tIGRlZXBseSBuZXN0ZWQgb2JqZWN0c1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gSlNPTiBzdHJ1Y3R1cmUgZm9yIGVhY2ggcm93OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgIFwiYnJvd3NlclwiOiB7dmFsdWV9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgICAgXCJpbm5lclwiOiB7dmFsdWV9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgIFwiZGV0YWlsc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyAgICAgICAgIHt2YWx1ZX0sIHt2YWx1ZX1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImVuZ2luZVwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJwbGF0Zm9ybS5pbm5lclwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtLmRldGFpbHMuMFwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtLmRldGFpbHMuMVwiIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBkYXRhYCBhcyBhIGZ1bmN0aW9uIHRvIHByb3ZpZGUgZGlmZmVyZW50IGluZm9ybWF0aW9uIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gc29ydGluZywgZmlsdGVyaW5nIGFuZCBkaXNwbGF5LiBJbiB0aGlzIGNhc2UsIGN1cnJlbmN5IChwcmljZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImRhdGFcIjogZnVuY3Rpb24gKCBzb3VyY2UsIHR5cGUsIHZhbCApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzZXQnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgc291cmNlLnByaWNlID0gdmFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjb21wdXRlZCBkaXNsYXkgYW5kIGZpbHRlciB2YWx1ZXMgZm9yIGVmZmljaWVuY3lcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2VfZGlzcGxheSA9IHZhbD09XCJcIiA/IFwiXCIgOiBcIiRcIitudW1iZXJGb3JtYXQodmFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2VfZmlsdGVyICA9IHZhbD09XCJcIiA/IFwiXCIgOiBcIiRcIitudW1iZXJGb3JtYXQodmFsKStcIiBcIit2YWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdkaXNwbGF5Jykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2VfZGlzcGxheTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZmlsdGVyJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2VfZmlsdGVyO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIC8vICdzb3J0JywgJ3R5cGUnIGFuZCB1bmRlZmluZWQgYWxsIGp1c3QgdXNlIHRoZSBpbnRlZ2VyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIHJldHVybiBzb3VyY2UucHJpY2U7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfSBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGRlZmF1bHQgY29udGVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkNsaWNrIHRvIGVkaXRcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH0gXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBhcnJheSBub3RhdGlvbiAtIG91dHB1dHRpbmcgYSBsaXN0IGZyb20gYW4gYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImRhdGFcIjogXCJuYW1lWywgXVwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfSBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwibURhdGFcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGlzIHRoZSByZW5kZXJpbmcgcGFydG5lciB0byBgZGF0YWAgYW5kIGl0IGlzIHN1Z2dlc3RlZCB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIHlvdSB3YW50IHRvIG1hbmlwdWxhdGUgZGF0YSBmb3IgZGlzcGxheSAoaW5jbHVkaW5nIGZpbHRlcmluZyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNvcnRpbmcgZXRjKSB3aXRob3V0IGFsdGVyaW5nIHRoZSB1bmRlcmx5aW5nIGRhdGEgZm9yIHRoZSB0YWJsZSwgdXNlIHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByb3BlcnR5LiBgcmVuZGVyYCBjYW4gYmUgY29uc2lkZXJlZCB0byBiZSB0aGUgdGhlIHJlYWQgb25seSBjb21wYW5pb24gdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGBkYXRhYCB3aGljaCBpcyByZWFkIC8gd3JpdGUgKHRoZW4gYXMgc3VjaCBtb3JlIGNvbXBsZXgpLiBMaWtlIGBkYXRhYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhpcyBvcHRpb24gY2FuIGJlIGdpdmVuIGluIGEgbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHRvIGVmZmVjdCBpdHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJlaGF2aW91cjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICByZXR1cm5lZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgb2JqZWN0YCAtIHVzZSBkaWZmZXJlbnQgZGF0YSBmb3IgdGhlIGRpZmZlcmVudCBkYXRhIHR5cGVzIHJlcXVlc3RlZCBieVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBEYXRhVGFibGVzICgnZmlsdGVyJywgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnKS4gVGhlIHByb3BlcnR5IG5hbWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIG9mIHRoZSBvYmplY3QgaXMgdGhlIGRhdGEgdHlwZSB0aGUgcHJvcGVydHkgcmVmZXJzIHRvIGFuZCB0aGUgdmFsdWUgY2FuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGRlZmluZWQgdXNpbmcgYW4gaW50ZWdlciwgc3RyaW5nIG9yIGZ1bmN0aW9uIHVzaW5nIHRoZSBzYW1lIHJ1bGVzIGFzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGByZW5kZXJgIG5vcm1hbGx5IGRvZXMuIE5vdGUgdGhhdCBhbiBgX2Agb3B0aW9uIF9tdXN0XyBiZSBzcGVjaWZpZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIFRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIHlvdSBoYXZlbid0IHNwZWNpZmllZCBhIHZhbHVlIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICB0aGUgZGF0YSB0eXBlIHJlcXVlc3RlZCBieSBEYXRhVGFibGVzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgZnVuY3Rpb25gIC0gdGhlIGZ1bmN0aW9uIGdpdmVuIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbmV2ZXIgRGF0YVRhYmxlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBuZWVkcyB0byBzZXQgb3IgZ2V0IHRoZSBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gVGhlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAqIFBhcmFtZXRlcnM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChiYXNlZCBvbiBgZGF0YWApXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICoge3N0cmluZ30gVGhlIHR5cGUgY2FsbCBkYXRhIHJlcXVlc3RlZCAtIHRoaXMgd2lsbCBiZSAnZmlsdGVyJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAnZGlzcGxheScsICd0eXBlJyBvciAnc29ydCcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICoge2FycmF5fG9iamVjdH0gVGhlIGZ1bGwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgKG5vdCBiYXNlZCBvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGBkYXRhYClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICogUmV0dXJuOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAqIFRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24gaXMgd2hhdCB3aWxsIGJlIHVzZWQgZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIGRhdGEgcmVxdWVzdGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG9iamVjdHxudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCBVc2UgdGhlIGRhdGEgc291cmNlIHZhbHVlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnJlbmRlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBDcmVhdGUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwicmVuZGVyXCI6IFwiWywgXS5uYW1lXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIEV4ZWN1dGUgYSBmdW5jdGlvbiB0byBvYnRhaW4gZGF0YVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLCAvLyBVc2UgdGhlIGZ1bGwgZGF0YSBzb3VyY2Ugb2JqZWN0IGZvciB0aGUgcmVuZGVyZXIncyBzb3VyY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicmVuZGVyXCI6IFwiYnJvd3Nlck5hbWUoKVwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfSBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIEFzIGFuIG9iamVjdCwgZXh0cmFjdGluZyBkaWZmZXJlbnQgZGF0YSBmb3IgdGhlIGRpZmZlcmVudCB0eXBlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVGhpcyB3b3VsZCBiZSB1c2VkIHdpdGggYSBkYXRhIHNvdXJjZSBzdWNoIGFzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gICB7IFwicGhvbmVcIjogNTU1MjM2OCwgXCJwaG9uZV9maWx0ZXJcIjogXCI1NTUyMzY4IDU1NS0yMzY4XCIsIFwicGhvbmVfZGlzcGxheVwiOiBcIjU1NS0yMzY4XCIgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gSGVyZSB0aGUgYHBob25lYCBpbnRlZ2VyIGlzIHVzZWQgZm9yIHNvcnRpbmcgYW5kIHR5cGUgZGV0ZWN0aW9uLCB3aGlsZSBgcGhvbmVfZmlsdGVyYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gKHdoaWNoIGhhcyBib3RoIGZvcm1zKSBpcyB1c2VkIGZvciBmaWx0ZXJpbmcgZm9yIGlmIGEgdXNlciBpbnB1dHMgZWl0aGVyIGZvcm1hdCwgd2hpbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIHRoZSBmb3JtYXR0ZWQgcGhvbmUgbnVtYmVyIGlzIHRoZSBvbmUgdGhhdCBpcyBzaG93biBpbiB0aGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsIC8vIFVzZSB0aGUgZnVsbCBkYXRhIHNvdXJjZSBvYmplY3QgZm9yIHRoZSByZW5kZXJlcidzIHNvdXJjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJyZW5kZXJcIjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcIl9cIjogXCJwaG9uZVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImZpbHRlclwiOiBcInBob25lX2ZpbHRlclwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImRpc3BsYXlcIjogXCJwaG9uZV9kaXNwbGF5XCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNlIGFzIGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgbGluayBmcm9tIHRoZSBkYXRhIHNvdXJjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBcImRvd25sb2FkX2xpbmtcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicmVuZGVyXCI6IGZ1bmN0aW9uICggZGF0YSwgdHlwZSwgZnVsbCApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgcmV0dXJuICc8YSBocmVmPVwiJytkYXRhKydcIj5Eb3dubG9hZDwvYT4nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH0gXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwibVJlbmRlclwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENoYW5nZSB0aGUgY2VsbCB0eXBlIGNyZWF0ZWQgZm9yIHRoZSBjb2x1bW4gLSBlaXRoZXIgVEQgY2VsbHMgb3IgVEggY2VsbHMuIFRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNhbiBiZSB1c2VmdWwgYXMgVEggY2VsbHMgaGF2ZSBzZW1hbnRpYyBtZWFuaW5nIGluIHRoZSB0YWJsZSBib2R5LCBhbGxvd2luZyB0aGVtXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0byBhY3QgYXMgYSBoZWFkZXIgZm9yIGEgcm93ICh5b3UgbWF5IHdpc2ggdG8gYWRkIHNjb3BlPSdyb3cnIHRvIHRoZSBUSCBlbGVtZW50cykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdGRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jZWxsVHlwZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBNYWtlIHRoZSBmaXJzdCBjb2x1bW4gdXNlIFRIIGNlbGxzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJjZWxsVHlwZVwiOiBcInRoXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9IF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNDZWxsVHlwZVwiOiBcInRkXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2xhc3MgdG8gZ2l2ZSB0byBlYWNoIGNlbGwgaW4gdGhpcyBjb2x1bW4uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmNsYXNzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwiY2xhc3NcIjogXCJteV9jbGFzc1wiLCBcInRhcmdldHNcIjogWyAwIF0gfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzQ2xhc3NcIjogXCJcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBHZW5lcmFsbHkgeW91IHNob3VsZG4ndCBuZWVkIHRoaXMhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY29udGVudFBhZGRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJjb250ZW50UGFkZGluZ1wiOiBcIm1tbVwiXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0NvbnRlbnRQYWRkaW5nXCI6IFwiXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aGVuZXZlciBhIG51bGwgZGF0YSBzb3VyY2UgaXMgZW5jb3VudGVyZWQgKHRoaXMgY2FuIGJlIGJlY2F1c2UgYGRhdGFgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpcyBzZXQgdG8gbnVsbCwgb3IgYmVjYXVzZSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmIGlzIG51bGwpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kZWZhdWx0Q29udGVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFcIjogbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgLTEgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkYXRhXCI6IG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGVmYXVsdENvbnRlbnRcIjogXCJFZGl0XCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzRGVmYXVsdENvbnRlbnRcIjogbnVsbCxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBpcyBvbmx5IHVzZWQgaW4gRGF0YVRhYmxlcycgc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gSXQgY2FuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBiZSBleGNlcHRpb25hbGx5IHVzZWZ1bCB0byBrbm93IHdoYXQgY29sdW1ucyBhcmUgYmVpbmcgZGlzcGxheWVkIG9uIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2xpZW50IHNpZGUsIGFuZCB0byBtYXAgdGhlc2UgdG8gZGF0YWJhc2UgZmllbGRzLiBXaGVuIGRlZmluZWQsIHRoZSBuYW1lc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYWxzbyBhbGxvdyBEYXRhVGFibGVzIHRvIHJlb3JkZXIgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyIGlmIGl0IGNvbWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBiYWNrIGluIGFuIHVuZXhwZWN0ZWQgb3JkZXIgKGkuZS4gaWYgeW91IHN3aXRjaCB5b3VyIGNvbHVtbnMgYXJvdW5kIG9uIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2xpZW50LXNpZGUsIHlvdXIgc2VydmVyLXNpZGUgY29kZSBkb2VzIG5vdCBhbHNvIG5lZWQgdXBkYXRpbmcpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5uYW1lXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImVuZ2luZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYnJvd3NlclwiLCBcInRhcmdldHNcIjogWyAxIF0gfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwicGxhdGZvcm1cIiwgXCJ0YXJnZXRzXCI6IFsgMiBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlcnNpb25cIiwgXCJ0YXJnZXRzXCI6IFsgMyBdIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImdyYWRlXCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJlbmdpbmVcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJicm93c2VyXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwicGxhdGZvcm1cIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJ2ZXJzaW9uXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZ3JhZGVcIiB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic05hbWVcIjogXCJcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEZWZpbmVzIGEgZGF0YSBzb3VyY2UgdHlwZSBmb3IgdGhlIG9yZGVyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlYWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHJlYWwtdGltZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0YWJsZSAodXBkYXRpbmcgdGhlIGludGVybmFsbHkgY2FjaGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB2ZXJzaW9uKSBwcmlvciB0byBvcmRlcmluZy4gVGhpcyBhbGxvd3Mgb3JkZXJpbmcgdG8gb2NjdXIgb24gdXNlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZWRpdGFibGUgZWxlbWVudHMgc3VjaCBhcyBmb3JtIGlucHV0cy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBzdGRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlckRhdGFUeXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIsIFwidGFyZ2V0c1wiOiBbIDIsIDMgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcInR5cGVcIjogXCJudW1lcmljXCIsIFwidGFyZ2V0c1wiOiBbIDMgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tY2hlY2tib3hcIiwgXCJ0YXJnZXRzXCI6IFsgNSBdIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiLCBcInR5cGVcIjogXCJudW1lcmljXCIgfSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXNlbGVjdFwiIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1jaGVja2JveFwiIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydERhdGFUeXBlXCI6IFwic3RkXCIsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIHRpdGxlIG9mIHRoaXMgY29sdW1uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGwgPGk+RGVyaXZlZCBmcm9tIHRoZSAnVEgnIHZhbHVlIGZvciB0aGlzIGNvbHVtbiBpbiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIG9yaWdpbmFsIEhUTUwgdGFibGUuPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnRpdGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJNeSBjb2x1bW4gdGl0bGVcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNUaXRsZVwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSB0eXBlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBob3cgdGhlIGRhdGEgZm9yIHRoaXMgY29sdW1uIHdpbGwgYmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9yZGVyZWQuIEZvdXIgdHlwZXMgKHN0cmluZywgbnVtZXJpYywgZGF0ZSBhbmQgaHRtbCAod2hpY2ggd2lsbCBzdHJpcFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSFRNTCB0YWdzIGJlZm9yZSBvcmRlcmluZykpIGFyZSBjdXJyZW50bHkgYXZhaWxhYmxlLiBOb3RlIHRoYXQgb25seSBkYXRlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmb3JtYXRzIHVuZGVyc3Rvb2QgYnkgSmF2YXNjcmlwdCdzIERhdGUoKSBvYmplY3Qgd2lsbCBiZSBhY2NlcHRlZCBhcyB0eXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkYXRlLiBGb3IgZXhhbXBsZTogXCJNYXIgMjYsIDIwMDggNTowMyBQTVwiLiBNYXkgdGFrZSB0aGUgdmFsdWVzOiAnc3RyaW5nJyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICdudW1lcmljJywgJ2RhdGUnIG9yICdodG1sJyAoYnkgZGVmYXVsdCkuIEZ1cnRoZXIgdHlwZXMgY2FuIGJlIGFkZGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhyb3VnaCBwbHVnLWlucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIDxpPkF1dG8tZGV0ZWN0ZWQgZnJvbSByYXcgZGF0YTwvaT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi50eXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwidHlwZVwiOiBcImh0bWxcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNUeXBlXCI6IG51bGwsXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRGVmaW5pbmcgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4sIHRoaXMgcGFyYW1ldGVyIG1heSB0YWtlIGFueSBDU1MgdmFsdWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICgzZW0sIDIwcHggZXRjKS4gRGF0YVRhYmxlcyBhcHBsaWVzICdzbWFydCcgd2lkdGhzIHRvIGNvbHVtbnMgd2hpY2ggaGF2ZSBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJlZW4gZ2l2ZW4gYSBzcGVjaWZpYyB3aWR0aCB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlIGVuc3VyaW5nIHRoYXQgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByZW1haW5zIHJlYWRhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGwgPGk+QXV0b21hdGljPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLndpZHRoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiB9LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIF1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNXaWR0aFwiOiBudWxsXHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICBfZm5IdW5nYXJpYW5NYXAoRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbik7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCAtIHRoaXMgaG9sZHMgYWxsIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQgZm9yIGFcclxuXHQgICAgICAgICAgICAgICAgICogZ2l2ZW4gdGFibGUsIGluY2x1ZGluZyBjb25maWd1cmF0aW9uLCBkYXRhIGFuZCBjdXJyZW50IGFwcGxpY2F0aW9uIG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiB0YWJsZSBvcHRpb25zLiBEYXRhVGFibGVzIGRvZXMgbm90IGhhdmUgYSBzaW5nbGUgaW5zdGFuY2UgZm9yIGVhY2ggRGF0YVRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAqIHdpdGggdGhlIHNldHRpbmdzIGF0dGFjaGVkIHRvIHRoYXQgaW5zdGFuY2UsIGJ1dCByYXRoZXIgaW5zdGFuY2VzIG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGUgXCJjbGFzc1wiIGFyZSBjcmVhdGVkIG9uLXRoZS1mbHkgYXMgbmVlZGVkICh0eXBpY2FsbHkgYnkgYVxyXG5cdCAgICAgICAgICAgICAgICAgKiAkKCkuZGF0YVRhYmxlKCkgY2FsbCkgYW5kIHRoZSBzZXR0aW5ncyBvYmplY3QgaXMgdGhlbiBhcHBsaWVkIHRvIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICogaW5zdGFuY2UuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBpcyByZWxhdGVkIHRvIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9IGJ1dCB0aGlzXHJcblx0ICAgICAgICAgICAgICAgICAqIG9uZSBpcyB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBmb3IgRGF0YVRhYmxlcydzIGNhY2hlIG9mIGNvbHVtbnMuIEl0IHNob3VsZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBOT1QgYmUgbWFuaXB1bGF0ZWQgb3V0c2lkZSBvZiBEYXRhVGFibGVzLiBBbnkgY29uZmlndXJhdGlvbiBzaG91bGQgYmUgZG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgKiB0aHJvdWdoIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHRvZG8gUmVhbGx5IHNob3VsZCBhdHRhY2ggdGhlIHNldHRpbmdzIG9iamVjdCB0byBpbmRpdmlkdWFsIGluc3RhbmNlcyBzbyB3ZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBkb24ndCBuZWVkIHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9uIGVhY2ggJCgpLmRhdGFUYWJsZSgpIGNhbGwgKGlmIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICB0YWJsZSBhbHJlYWR5IGV4aXN0cykuIEl0IHdvdWxkIGFsc28gc2F2ZSBwYXNzaW5nIG9TZXR0aW5ncyBhcm91bmQgYW5kXHJcblx0ICAgICAgICAgICAgICAgICAqICAgIGludG8gZXZlcnkgc2luZ2xlIGZ1bmN0aW9uLiBIb3dldmVyLCB0aGlzIGlzIGEgdmVyeSBzaWduaWZpY2FudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICBhcmNoaXRlY3R1cmUgY2hhbmdlIGZvciBEYXRhVGFibGVzIGFuZCB3aWxsIGFsbW9zdCBjZXJ0YWlubHkgYnJlYWtcclxuXHQgICAgICAgICAgICAgICAgICogICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBpbnN0YWxsYXRpb25zLiBUaGlzIGlzIHNvbWV0aGluZyB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAqICAgIHdpbGwgYmUgZG9uZSBpbiAyLjAuXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncyA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUHJpbWFyeSBmZWF0dXJlcyBvZiBEYXRhVGFibGVzIGFuZCB0aGVpciBlbmFibGVtZW50IHN0YXRlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvRmVhdHVyZXNcIjoge1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBGbGFnIHRvIHNheSBpZiBEYXRhVGFibGVzIHNob3VsZCBhdXRvbWF0aWNhbGx5IHRyeSB0byBjYWxjdWxhdGUgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogb3B0aW11bSB0YWJsZSBhbmQgY29sdW1ucyB3aWR0aHMgKHRydWUpIG9yIG5vdCAoZmFsc2UpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYkF1dG9XaWR0aFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWxheSB0aGUgY3JlYXRpb24gb2YgVFIgYW5kIFREIGVsZW1lbnRzIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogbmVlZGVkIGJ5IGEgZHJpdmVuIHBhZ2UgZHJhdy4gVGhpcyBjYW4gZ2l2ZSBhIHNpZ25pZmljYW50IHNwZWVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogaW5jcmVhc2UgZm9yIEFqYXggc291cmNlIGFuZCBKYXZhc2NyaXB0IHNvdXJjZSBkYXRhLCBidXQgbWFrZXMgbm9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBkaWZmZXJlbmNlIGF0IGFsbCBmcm8gRE9NIGFuZCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJEZWZlclJlbmRlclwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBFbmFibGUgZmlsdGVyaW5nIG9uIHRoZSB0YWJsZSBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlbiB0aGVyZSBpcyBubyBmaWx0ZXJpbmcgYXQgYWxsIG9uIHRoZSB0YWJsZSwgaW5jbHVkaW5nIGZuRmlsdGVyLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRvIGp1c3QgcmVtb3ZlIHRoZSBmaWx0ZXJpbmcgaW5wdXQgdXNlIHNEb20gYW5kIHJlbW92ZSB0aGUgJ2YnIG9wdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJGaWx0ZXJcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVGFibGUgaW5mb3JtYXRpb24gZWxlbWVudCAodGhlICdTaG93aW5nIHggb2YgeSByZWNvcmRzJyBkaXYpIGVuYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZsYWcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJiSW5mb1wiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcmVzZW50IGEgdXNlciBjb250cm9sIGFsbG93aW5nIHRoZSBlbmQgdXNlciB0byBjaGFuZ2UgdGhlIHBhZ2Ugc2l6ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYkxlbmd0aENoYW5nZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBQYWdpbmF0aW9uIGVuYWJsZWQgb3Igbm90LiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBkaXNhYmxlZCB0aGVuIGxlbmd0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGNoYW5naW5nIG11c3QgYWxzbyBiZSBkaXNhYmxlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJQYWdpbmF0ZVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9jZXNzaW5nIGluZGljYXRvciBlbmFibGUgZmxhZyB3aGVuZXZlciBEYXRhVGFibGVzIGlzIGVuYWN0aW5nIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB1c2VyIHJlcXVlc3QgLSB0eXBpY2FsbHkgYW4gQWpheCByZXF1ZXN0IGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlByb2Nlc3NpbmdcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBlbmFibGVkIGZsYWcgLSB3aGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZ2V0IGFsbCBkYXRhIGZyb20gdGhlIHNlcnZlciBmb3IgZXZlcnkgZHJhdyAtIHRoZXJlIGlzIG5vIGZpbHRlcmluZyxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzb3J0aW5nIG9yIHBhZ2luZyBkb25lIG9uIHRoZSBjbGllbnQtc2lkZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJTZXJ2ZXJTaWRlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFNvcnRpbmcgZW5hYmxlbWVudCBmbGFnLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTXVsdGktY29sdW1uIHNvcnRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJTb3J0TXVsdGlcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQXBwbHkgYSBjbGFzcyB0byB0aGUgY29sdW1ucyB3aGljaCBhcmUgYmVpbmcgc29ydGVkIHRvIHByb3ZpZGUgYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHZpc3VhbCBoaWdobGlnaHQgb3Igbm90LiBUaGlzIGNhbiBzbG93IHRoaW5ncyBkb3duIHdoZW4gZW5hYmxlZCBzaW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZXJlIGlzIGEgbG90IG9mIERPTSBpbnRlcmFjdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJTb3J0Q2xhc3Nlc1wiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBTdGF0ZSBzYXZpbmcgZW5hYmxlbWVudCBmbGFnLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlN0YXRlU2F2ZVwiOiBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNjcm9sbGluZyBzZXR0aW5ncyBmb3IgYSB0YWJsZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwib1Njcm9sbFwiOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogV2hlbiB0aGUgdGFibGUgaXMgc2hvcnRlciBpbiBoZWlnaHQgdGhhbiBzU2Nyb2xsWSwgY29sbGFwc2UgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdGFibGUgY29udGFpbmVyIGRvd24gdG8gdGhlIGhlaWdodCBvZiB0aGUgdGFibGUgKHdoZW4gdHJ1ZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJiQ29sbGFwc2VcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogV2lkdGggb2YgdGhlIHNjcm9sbGJhciBmb3IgdGhlIHdlYi1icm93c2VyJ3MgcGxhdGZvcm0uIENhbGN1bGF0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBkdXJpbmcgdGFibGUgaW5pdGlhbGlzYXRpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJpQmFyV2lkdGhcIjogMCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVmlld3BvcnQgd2lkdGggZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nLiBIb3Jpem9udGFsIHNjcm9sbGluZyBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGRpc2FibGVkIGlmIGFuIGVtcHR5IHN0cmluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1hcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogV2lkdGggdG8gZXhwYW5kIHRoZSB0YWJsZSB0byB3aGVuIHVzaW5nIHgtc2Nyb2xsaW5nLiBUeXBpY2FsbHkgeW91XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGlzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzWElubmVyXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFZpZXdwb3J0IGhlaWdodCBmb3IgdmVydGljYWwgc2Nyb2xsaW5nLiBWZXJ0aWNhbCBzY3JvbGxpbmcgaXMgZGlzYWJsZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBpZiBhbiBlbXB0eSBzdHJpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNZXCI6IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBMYW5ndWFnZSBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXh0ZW5kcyBEYXRhVGFibGUuZGVmYXVsdHMub0xhbmd1YWdlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwib0xhbmd1YWdlXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBJbmZvcm1hdGlvbiBjYWxsYmFjayBmdW5jdGlvbi4gU2VlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5mbkluZm9DYWxsYmFja31cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiZm5JbmZvQ2FsbGJhY2tcIjogbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEJyb3dzZXIgc3VwcG9ydCBwYXJhbWV0ZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9Ccm93c2VyXCI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBJbmRpY2F0ZSBpZiB0aGUgYnJvd3NlciBpbmNvcnJlY3RseSBjYWxjdWxhdGVzIHdpZHRoOjEwMCUgaW5zaWRlIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBzY3JvbGxpbmcgZWxlbWVudCAoSUU2LzcpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcImJTY3JvbGxPdmVyc2l6ZVwiOiBmYWxzZSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgb24gdGhlIHJpZ2h0IG9yIGxlZnQgb2YgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogc2Nyb2xsaW5nIGNvbnRhaW5lciAtIG5lZWRlZCBmb3IgcnRsIGxhbmd1YWdlIGxheW91dCwgYWx0aG91Z2ggbm90XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYWxsIGJyb3dzZXJzIG1vdmUgdGhlIHNjcm9sbGJhciAoU2FmYXJpKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYlNjcm9sbGJhckxlZnRcIjogZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYWpheFwiOiBudWxsLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFycmF5IHJlZmVyZW5jaW5nIHRoZSBub2RlcyB3aGljaCBhcmUgdXNlZCBmb3IgdGhlIGZlYXR1cmVzLiBUaGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHBhcmFtZXRlcnMgb2YgdGhpcyBvYmplY3QgbWF0Y2ggd2hhdCBpcyBhbGxvd2VkIGJ5IHNEb20gLSBpLmUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDx1bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+J2wnIC0gTGVuZ3RoIGNoYW5naW5nPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+J3QnIC0gVGhlIHRhYmxlITwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPGxpPidpJyAtIEluZm9ybWF0aW9uPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPGxpPidyJyAtIHBSb2Nlc3Npbmc8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICA8L3VsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhYW5GZWF0dXJlc1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0b3JlIGRhdGEgaW5mb3JtYXRpb24gLSBzZWUge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1Jvd30gZm9yIGRldGFpbGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBpbmZvcm1hdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9EYXRhXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXJyYXkgb2YgaW5kZXhlcyB3aGljaCBhcmUgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSAoYWZ0ZXIgZmlsdGVyaW5nIGV0YylcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYWlEaXNwbGF5XCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXJyYXkgb2YgaW5kZXhlcyBmb3IgZGlzcGxheSAtIG5vIGZpbHRlcmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhaURpc3BsYXlNYXN0ZXJcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIGNvbHVtbiB0aGF0IGlzIGluIHVzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb0NvbHVtbnNcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBoZWFkZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9IZWFkZXJcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUncyBmb290ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9Gb290ZXJcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTdG9yZSB0aGUgYXBwbGllZCBnbG9iYWwgc2VhcmNoIGluZm9ybWF0aW9uIGluIGNhc2Ugd2Ugd2FudCB0byBmb3JjZSBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByZXNlYXJjaCBvciBjb21wYXJlIHRoZSBvbGQgc2VhcmNoIHRvIGEgbmV3IG9uZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvUHJldmlvdXNTZWFyY2hcIjoge30sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTdG9yZSB0aGUgYXBwbGllZCBzZWFyY2ggZm9yIGVhY2ggY29sdW1uIC0gc2VlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNofSBmb3IgdGhlIGZvcm1hdCB0aGF0IGlzIHVzZWQgZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZmlsdGVyaW5nIGluZm9ybWF0aW9uIGZvciBlYWNoIGNvbHVtbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9QcmVTZWFyY2hDb2xzXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU29ydGluZyB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlLiBOb3RlIHRoYXQgdGhlIGlubmVyIGFycmF5cyBhcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHVzZWQgaW4gdGhlIGZvbGxvd2luZyBtYW5uZXI6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiA8dWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDxsaT5JbmRleCAwIC0gY29sdW1uIG51bWJlcjwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDxsaT5JbmRleCAxIC0gY3VycmVudCBzb3J0aW5nIGRpcmVjdGlvbjwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiA8L3VsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdG9kbyBUaGVzZSBpbm5lciBhcnJheXMgc2hvdWxkIHJlYWxseSBiZSBvYmplY3RzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYWFTb3J0aW5nXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTb3J0aW5nIHRoYXQgaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIChpLmUuIHByZWZpeGVkIGluIGZyb250IG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhYVNvcnRpbmcpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2xhc3NlcyB0byB1c2UgZm9yIHRoZSBzdHJpcGluZyBvZiBhIHRhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFzU3RyaXBlQ2xhc3Nlc1wiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSWYgcmVzdG9yaW5nIGEgdGFibGUgLSB3ZSBzaG91bGQgcmVzdG9yZSBpdHMgc3RyaXBpbmcgY2xhc3NlcyBhcyB3ZWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFzRGVzdHJveVN0cmlwZXNcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyB3aWR0aFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzRGVzdHJveVdpZHRoXCI6IDAsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbnMgYXJyYXkgZm9yIGV2ZXJ5IHRpbWUgYSByb3cgaXMgaW5zZXJ0ZWQgKGkuZS4gb24gYSBkcmF3KS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9Sb3dDYWxsYmFja1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGhlYWRlciBvbiBlYWNoIGRyYXcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvSGVhZGVyQ2FsbGJhY2tcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGZvb3RlciBvbiBlYWNoIGRyYXcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvRm9vdGVyQ2FsbGJhY2tcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIGRyYXcgY2FsbGJhY2sgZnVuY3Rpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvRHJhd0NhbGxiYWNrXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciByb3cgY3JlYXRlZCBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1Jvd0NyZWF0ZWRDYWxsYmFja1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IganVzdCBiZWZvcmUgdGhlIHRhYmxlIGlzIHJlZHJhd24uIEEgcmV0dXJuIG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmYWxzZSB3aWxsIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1ByZURyYXdDYWxsYmFja1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvSW5pdENvbXBsZXRlXCI6IFtdLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0byBiZSBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZywgcHJpb3IgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNhdmluZyBzdGF0ZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9TdGF0ZVNhdmVQYXJhbXNcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWxsYmFja3MgZm9yIG1vZGlmeWluZyB0aGUgc2V0dGluZ3MgdGhhdCBoYXZlIGJlZW4gc3RvcmVkIGZvciBzdGF0ZSBzYXZpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHByaW9yIHRvIHVzaW5nIHRoZSBzdG9yZWQgdmFsdWVzIHRvIHJlc3RvcmUgdGhlIHN0YXRlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1N0YXRlTG9hZFBhcmFtc1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIENhbGxiYWNrcyBmb3Igb3BlcmF0aW5nIG9uIHRoZSBzZXR0aW5ncyBvYmplY3Qgb25jZSB0aGUgc2F2ZWQgc3RhdGUgaGFzIGJlZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGxvYWRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1N0YXRlTG9hZGVkXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQ2FjaGUgdGhlIHRhYmxlIElEIGZvciBxdWljayBhY2Nlc3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1RhYmxlSWRcIjogXCJcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBUQUJMRSBub2RlIGZvciB0aGUgbWFpbiB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiblRhYmxlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0aGVhZCBlbGVtZW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgbm9kZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJuVEhlYWRcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRmb290IGVsZW1lbnQgLSBpZiBpdCBleGlzdHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBub2RlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm5URm9vdFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUGVybWFuZW50IHJlZiB0byB0aGUgdGJvZHkgZWxlbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiblRCb2R5XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDYWNoZSB0aGUgd3JhcHBlciBub2RlIChjb250YWlucyBhbGwgRGF0YVRhYmxlcyBjb250cm9sbGVkIGVsZW1lbnRzKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG5vZGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiblRhYmxlV3JhcHBlclwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSW5kaWNhdGUgaWYgd2hlbiB1c2luZyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZSBsb2FkaW5nIG9mIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgc2Vjb25kIGRyYXcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiRGVmZXJMb2FkaW5nXCI6IGZhbHNlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSW5kaWNhdGUgaWYgYWxsIHJlcXVpcmVkIGluZm9ybWF0aW9uIGhhcyBiZWVuIHJlYWQgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiSW5pdGlhbGlzZWRcIjogZmFsc2UsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJbmZvcm1hdGlvbiBhYm91dCBvcGVuIHJvd3MuIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheSBoYXMgdGhlIHBhcmFtZXRlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICduVHInIGFuZCAnblBhcmVudCdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9PcGVuUm93c1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERpY3RhdGUgdGhlIHBvc2l0aW9uaW5nIG9mIERhdGFUYWJsZXMnIGNvbnRyb2wgZWxlbWVudHMgLSBzZWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUubW9kZWwub0luaXQuc0RvbX0uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0RvbVwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU2VhcmNoIGRlbGF5IChpbiBtUylcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRlZ2VyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNlYXJjaERlbGF5XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBXaGljaCB0eXBlIG9mIHBhZ2luYXRpb24gc2hvdWxkIGJlIHVzZWQuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB0d29fYnV0dG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1BhZ2luYXRpb25UeXBlXCI6IFwidHdvX2J1dHRvblwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIHN0YXRlIGR1cmF0aW9uIChmb3IgYHN0YXRlU2F2ZWApIGluIHNlY29uZHMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaVN0YXRlRHVyYXRpb25cIjogMCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgc2F2aW5nLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPHVsPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT5mdW5jdGlvbjpmbiAtIGZ1bmN0aW9uIHRvIGNhbGwuIFRha2VzIHR3byBwYXJhbWV0ZXJzLCBvU2V0dGluZ3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIGFuZCB0aGUgSlNPTiBzdHJpbmcgdG8gc2F2ZSB0aGF0IGhhcyBiZWVuIHRodXMgZmFyIGNyZWF0ZWQuIFJldHVybnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgIGEgSlNPTiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgaW50byBhIGpzb24gb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAoaS5lLiAnXCJwYXJhbVwiOiBbIDAsIDEsIDJdJyk8L2xpPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgPC91bD5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYW9TdGF0ZVNhdmVcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIGxvYWRpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICA8dWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgYW5kIHRoZSBvYmplY3Qgc3RvcmVkLiBNYXkgcmV0dXJuIGZhbHNlIHRvIGNhbmNlbCBzdGF0ZSBsb2FkaW5nPC9saT5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIDwvdWw+XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvU3RhdGVMb2FkXCI6IFtdLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU3RhdGUgdGhhdCB3YXMgc2F2ZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwib1NhdmVkU3RhdGVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFN0YXRlIHRoYXQgd2FzIGxvYWRlZC4gVXNlZnVsIGZvciBiYWNrIHJlZmVyZW5jZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvTG9hZGVkU3RhdGVcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNvdXJjZSB1cmwgZm9yIEFKQVggZGF0YSBmb3IgdGhlIHRhYmxlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNBamF4U291cmNlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0eSBmcm9tIGEgZ2l2ZW4gb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVhZCB0aGUgdGFibGUgZGF0YSBmcm9tLiBUaGlzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjYW4gYmUgYW4gZW1wdHkgc3RyaW5nICh3aGVuIG5vdCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nKSwgaW4gd2hpY2ggY2FzZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaXQgaXMgIGFzc3VtZWQgYW4gYW4gYXJyYXkgaXMgZ2l2ZW4gZGlyZWN0bHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzQWpheERhdGFQcm9wXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIGlmIGRyYXcgc2hvdWxkIGJlIGJsb2NrZWQgd2hpbGUgZ2V0dGluZyBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiQWpheERhdGFHZXRcIjogdHJ1ZSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBsYXN0IGpRdWVyeSBYSFIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgZm9yIHNlcnZlci1zaWRlIGRhdGEgZ2F0aGVyaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBjYW4gYmUgdXNlZCBmb3Igd29ya2luZyB3aXRoIHRoZSBYSFIgaW5mb3JtYXRpb24gaW4gb25lIG9mIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2FsbGJhY2tzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImpxWEhSXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJqc29uXCI6IHVuZGVmaW5lZCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERhdGEgc3VibWl0dGVkIGFzIHBhcnQgb2YgdGhlIGxhc3QgQWpheCByZXF1ZXN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwib0FqYXhEYXRhXCI6IHVuZGVmaW5lZCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZ1bmN0aW9uIHRvIGdldCB0aGUgc2VydmVyLXNpZGUgZGF0YS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5TZXJ2ZXJEYXRhXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGdW5jdGlvbnMgd2hpY2ggYXJlIGNhbGxlZCBwcmlvciB0byBzZW5kaW5nIGFuIEFqYXggcmVxdWVzdCBzbyBleHRyYVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogcGFyYW1ldGVycyBjYW4gZWFzaWx5IGJlIHNlbnQgdG8gdGhlIHNlcnZlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhb1NlcnZlclBhcmFtc1wiOiBbXSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNlbmQgdGhlIFhIUiBIVFRQIG1ldGhvZCAtIEdFVCBvciBQT1NUIChjb3VsZCBiZSBQVVQgb3IgREVMRVRFIGlmXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiByZXF1aXJlZCkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU2VydmVyTWV0aG9kXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGb3JtYXQgbnVtYmVycyBmb3IgZGlzcGxheS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5Gb3JtYXROdW1iZXJcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIExpc3Qgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGZvciB0aGUgdXNlciBzZWxlY3RhYmxlIGxlbmd0aCBtZW51LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFMZW5ndGhNZW51XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBDb3VudGVyIGZvciB0aGUgZHJhd3MgdGhhdCB0aGUgdGFibGUgZG9lcy4gQWxzbyB1c2VkIGFzIGEgdHJhY2tlciBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHNlcnZlci1zaWRlIHByb2Nlc3NpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiaURyYXdcIjogMCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEluZGljYXRlIGlmIGEgcmVkcmF3IGlzIGJlaW5nIGRvbmUgLSB1c2VmdWwgZm9yIEFqYXhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiRHJhd2luZ1wiOiBmYWxzZSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERyYXcgaW5kZXggKGlEcmF3KSBvZiB0aGUgbGFzdCBlcnJvciB3aGVuIHBhcnNpbmcgdGhlIHJldHVybmVkIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAtMVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImlEcmF3RXJyb3JcIjogLTEsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQYWdpbmcgZGlzcGxheSBsZW5ndGhcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAxMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9pRGlzcGxheUxlbmd0aFwiOiAxMCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFBhZ2luZyBzdGFydCBwb2ludCAtIGFpRGlzcGxheSBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJfaURpc3BsYXlTdGFydFwiOiAwLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSByZXN1bHQgc2V0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAoaS5lLiBiZWZvcmUgZmlsdGVyaW5nKSwgVXNlIGZuUmVjb3Jkc1RvdGFsIHJhdGhlciB0aGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBzZXR0aW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGludFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIl9pUmVjb3Jkc1RvdGFsXCI6IDAsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIC0gbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSBzZXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIChpLmUuIGFmdGVyIGZpbHRlcmluZykuIFVzZSBmblJlY29yZHNEaXNwbGF5IHJhdGhlciB0aGFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBzZXR0aW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHByaXZhdGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJfaVJlY29yZHNEaXNwbGF5XCI6IDAsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIGpRdWVyeSBVSSBtYXJraW5nIGFuZCBjbGFzc2VzIHNob3VsZCBiZSB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJKVUlcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBjbGFzc2VzIHRvIHVzZSBmb3IgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvQ2xhc3Nlc1wiOiB7fSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZsYWcgYXR0YWNoZWQgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBzbyB5b3UgY2FuIGNoZWNrIGluIHRoZSBkcmF3XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjYWxsYmFjayBpZiBmaWx0ZXJpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2ZcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGV2ZW50cy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImJGaWx0ZXJlZFwiOiBmYWxzZSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEZsYWcgYXR0YWNoZWQgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBzbyB5b3UgY2FuIGNoZWNrIGluIHRoZSBkcmF3XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBjYWxsYmFjayBpZiBzb3J0aW5nIGhhcyBiZWVuIGRvbmUgaW4gdGhlIGRyYXcuIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBldmVudHMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJiU29ydGVkXCI6IGZhbHNlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSW5kaWNhdGUgdGhhdCBpZiBtdWx0aXBsZSByb3dzIGFyZSBpbiB0aGUgaGVhZGVyIGFuZCB0aGVyZSBpcyBtb3JlIHRoYW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9uZSB1bmlxdWUgY2VsbCBwZXIgY29sdW1uLCBpZiB0aGUgdG9wIG9uZSAodHJ1ZSkgb3IgYm90dG9tIG9uZSAoZmFsc2UpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzaG91bGQgYmUgdXNlZCBmb3Igc29ydGluZyAvIHRpdGxlIGJ5IERhdGFUYWJsZXMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiYlNvcnRDZWxsc1RvcFwiOiBudWxsLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSW5pdGlhbGlzYXRpb24gb2JqZWN0IHRoYXQgaXMgdXNlZCBmb3IgdGhlIHRhYmxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9Jbml0XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBEZXN0cm95IGNhbGxiYWNrIGZ1bmN0aW9ucyAtIGZvciBwbHVnLWlucyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0byB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRlc3Ryb3kgc28gdGhleSBjYW4gY2xlYW4gdXAgbWFya3VwIGFuZCBldmVudHMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImFvRGVzdHJveUNhbGxiYWNrXCI6IFtdLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgcmVjb3JkIHNldCwgYmVmb3JlIGZpbHRlcmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiZm5SZWNvcmRzVG90YWxcIjogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5EYXRhU291cmNlKHRoaXMpID09ICdzc3AnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faVJlY29yZHNUb3RhbCAqIDEgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGg7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogR2V0IHRoZSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgY3VycmVudCByZWNvcmQgc2V0LCBhZnRlciBmaWx0ZXJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImZuUmVjb3Jkc0Rpc3BsYXlcIjogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5EYXRhU291cmNlKHRoaXMpID09ICdzc3AnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faVJlY29yZHNEaXNwbGF5ICogMSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWlEaXNwbGF5Lmxlbmd0aDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBHZXQgdGhlIGRpc3BsYXkgZW5kIHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJmbkRpc3BsYXlFbmRcIjogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLl9pRGlzcGxheUxlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9pRGlzcGxheVN0YXJ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjID0gc3RhcnQgKyBsZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHMgPSB0aGlzLmFpRGlzcGxheS5sZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gdGhpcy5vRmVhdHVyZXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2luYXRlID0gZmVhdHVyZXMuYlBhZ2luYXRlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMuYlNlcnZlclNpZGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhZ2luYXRlID09PSBmYWxzZSB8fCBsZW4gPT09IC0xID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgcmVjb3JkcyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihzdGFydCArIGxlbiwgdGhpcy5faVJlY29yZHNEaXNwbGF5KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhcGFnaW5hdGUgfHwgY2FsYyA+IHJlY29yZHMgfHwgbGVuID09PSAtMSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBEYXRhVGFibGVzIG9iamVjdCBmb3IgdGhpcyB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJvSW5zdGFuY2VcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIGluc3RhbmNlIG9mIHRoZSBEYXRhVGFibGVzIG9iamVjdC4gSWYgdGhlcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIGFuIElEIG9uIHRoZSB0YWJsZSBub2RlLCB0aGVuIGl0IHRha2VzIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBhblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogaW5jcmVtZW50aW5nIGludGVybmFsIGNvdW50ZXIgaXMgdXNlZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0luc3RhbmNlXCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0YWJpbmRleCBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyBhZGRlZCB0byBEYXRhVGFibGVzIGNvbnRyb2wgZWxlbWVudHMsIGFsbG93aW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSB0YWJsZSBhbmQgaXRzIGNvbnRyb2xzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImlUYWJJbmRleFwiOiAwLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRElWIGNvbnRhaW5lciBmb3IgdGhlIGZvb3RlciBzY3JvbGxpbmcgdGFibGUgaWYgc2Nyb2xsaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwiblNjcm9sbEhlYWRcIjogbnVsbCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm5TY3JvbGxGb290XCI6IG51bGwsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBMYXN0IGFwcGxpZWQgc29ydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJhTGFzdFNvcnRcIjogW10sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTdG9yZWQgcGx1Zy1pbiBpbnN0YW5jZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcIm9QbHVnaW5zXCI6IHt9XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRXh0ZW5zaW9uIG9iamVjdCBmb3IgRGF0YVRhYmxlcyB0aGF0IGlzIHVzZWQgdG8gcHJvdmlkZSBhbGwgZXh0ZW5zaW9uXHJcblx0ICAgICAgICAgICAgICAgICAqIG9wdGlvbnMuXHJcblx0ICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5leHRgIG9iamVjdCBpcyBhdmFpbGFibGUgdGhyb3VnaFxyXG5cdCAgICAgICAgICAgICAgICAgKiBgalF1ZXJ5LmZuLmRhdGFUYWJsZS5leHRgIHdoZXJlIGl0IG1heSBiZSBhY2Nlc3NlZCBhbmQgbWFuaXB1bGF0ZWQuIEl0IGlzXHJcblx0ICAgICAgICAgICAgICAgICAqIGFsc28gYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGhpc3RvcmljIHJlYXNvbnMuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLmV4dFxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBleHRlbnNpb25zXHJcblx0ICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgKiBUaGlzIG5hbWVzcGFjZSBhY3RzIGFzIGEgY29sbGVjdGlvbiBhcmVhIGZvciBwbHVnLWlucyB0aGF0IGNhbiBiZSB1c2VkIHRvXHJcblx0ICAgICAgICAgICAgICAgICAqIGV4dGVuZCBEYXRhVGFibGVzIGNhcGFiaWxpdGllcy4gSW5kZWVkIG1hbnkgb2YgdGhlIGJ1aWxkIGluIG1ldGhvZHNcclxuXHQgICAgICAgICAgICAgICAgICogdXNlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgdGhlaXIgb3duIGNhcGFiaWxpdGllcyAoc29ydGluZyBtZXRob2RzIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgKiBleGFtcGxlKS5cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgbmFtZXNwYWNlIGlzIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBsZWdhY3lcclxuXHQgICAgICAgICAgICAgICAgICogcmVhc29uc1xyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLmV4dCA9IF9leHQgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEJ1dHRvbnMuIEZvciB1c2Ugd2l0aCB0aGUgQnV0dG9ucyBleHRlbnNpb24gZm9yIERhdGFUYWJsZXMuIFRoaXMgaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRlZmluZWQgaGVyZSBzbyBvdGhlciBleHRlbnNpb25zIGNhbiBkZWZpbmUgYnV0dG9ucyByZWdhcmRsZXNzIG9mIGxvYWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9yZGVyLiBJdCBpcyBfbm90XyB1c2VkIGJ5IERhdGFUYWJsZXMgY29yZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYnV0dG9uczoge30sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRWxlbWVudCBjbGFzcyBuYW1lc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBjbGFzc2VzOiB7fSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFcnJvciByZXBvcnRpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEhvdyBzaG91bGQgRGF0YVRhYmxlcyByZXBvcnQgYW4gZXJyb3IuIENhbiB0YWtlIHRoZSB2YWx1ZSAnYWxlcnQnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ3xmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGFsZXJ0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGVyck1vZGU6IFwiYWxlcnRcIixcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBGZWF0dXJlIHBsdWctaW5zLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggZGVzY3JpYmUgdGhlIGZlYXR1cmUgcGx1Zy1pbnMgdGhhdCBhcmVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGF2YWlsYWJsZSB0byBEYXRhVGFibGVzLiBUaGVzZSBmZWF0dXJlIHBsdWctaW5zIGFyZSB0aGVuIGF2YWlsYWJsZSBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIHVzZSB0aHJvdWdoIHRoZSBgZG9tYCBpbml0aWFsaXNhdGlvbiBvcHRpb24uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVhY2ggZmVhdHVyZSBwbHVnLWluIGlzIGRlc2NyaWJlZCBieSBhbiBvYmplY3Qgd2hpY2ggbXVzdCBoYXZlIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGZuSW5pdGAgLSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gaW5pdGlhbGlzZSB0aGUgcGx1Zy1pbixcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYGNGZWF0dXJlYCAtIGEgY2hhcmFjdGVyIHNvIHRoZSBmZWF0dXJlIGNhbiBiZSBlbmFibGVkIGJ5IHRoZSBgZG9tYFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBpbnN0aWxsYXRpb24gb3B0aW9uLiBUaGlzIGlzIGNhc2Ugc2Vuc2l0aXZlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBgZm5Jbml0YCBmdW5jdGlvbiBoYXMgdGhlIGZvbGxvd2luZyBpbnB1dCBwYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEFuZCB0aGUgZm9sbG93aW5nIHJldHVybiBpcyBleHBlY3RlZDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiB7bm9kZXxudWxsfSBUaGUgZWxlbWVudCB3aGljaCBjb250YWlucyB5b3VyIGZlYXR1cmUuIE5vdGUgdGhhdCB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgcmV0dXJuIG1heSBhbHNvIGJlIHZvaWQgaWYgeW91ciBwbHVnLWluIGRvZXMgbm90IHJlcXVpcmUgdG8gaW5qZWN0IGFueVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICBET00gZWxlbWVudHMgaW50byBEYXRhVGFibGVzIGNvbnRyb2wgKGBkb21gKSAtIGZvciBleGFtcGxlIHRoaXMgbWlnaHRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgYmUgdXNlZnVsIHdoZW4gZGV2ZWxvcGluZyBhIHBsdWctaW4gd2hpY2ggYWxsb3dzIHRhYmxlIGNvbnRyb2wgdmlhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgIGtleWJvYXJkIGVudHJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQuZmVhdHVyZXMucHVzaCgge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICBcImZuSW5pdFwiOiBmdW5jdGlvbiggb1NldHRpbmdzICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiBuZXcgVGFibGVUb29scyggeyBcIm9EVFNldHRpbmdzXCI6IG9TZXR0aW5ncyB9ICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgIFwiY0ZlYXR1cmVcIjogXCJUXCJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZmVhdHVyZTogW10sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUm93IHNlYXJjaGluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2Qgb2Ygc2VhcmNoaW5nIGlzIGNvbXBsaW1lbnRhcnkgdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2VhcmNoaW5nLCBhbmQgYSBsb3QgbW9yZSBjb21wcmVoZW5zaXZlIGFzIGl0IGFsbG93cyB5b3UgY29tcGxldGUgY29udHJvbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3ZlciB0aGUgc2VhcmNoaW5nIGxvZ2ljLiBFYWNoIGVsZW1lbnQgaW4gdGhpcyBhcnJheSBpcyBhIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAocGFyYW1ldGVycyBkZXNjcmliZWQgYmVsb3cpIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSByb3cgaW4gdGhlIHRhYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW5kIHlvdXIgbG9naWMgZGVjaWRlcyBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHNlYXJjaGluZyBkYXRhIHNldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3Igbm90LlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFNlYXJjaGluZyBmdW5jdGlvbnMgaGF2ZSB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMS4gYHtvYmplY3R9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdDogc2VlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAyLiBge2FycmF5fG9iamVjdH1gIERhdGEgZm9yIHRoZSByb3cgdG8gYmUgcHJvY2Vzc2VkIChzYW1lIGFzIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgb3JpZ2luYWwgZm9ybWF0IHRoYXQgd2FzIHBhc3NlZCBpbiBhcyB0aGUgZGF0YSBzb3VyY2UsIG9yIGFuIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICBmcm9tIGEgRE9NIGRhdGEgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAzLiBge2ludH1gIFJvdyBpbmRleCAoe0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzLmFvRGF0YX0pLCB3aGljaFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgY2FuIGJlIHVzZWZ1bCB0byByZXRyaWV2ZSB0aGUgYFRSYCBlbGVtZW50IGlmIHlvdSBuZWVkIERPTSBpbnRlcmFjdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBBbmQgdGhlIGZvbGxvd2luZyByZXR1cm4gaXMgZXhwZWN0ZWQ6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiB7Ym9vbGVhbn0gSW5jbHVkZSB0aGUgcm93IGluIHRoZSBzZWFyY2hlZCByZXN1bHQgc2V0ICh0cnVlKSBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgKGZhbHNlKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCBhcyB3aXRoIHRoZSBtYWluIHNlYXJjaCBhYmlsaXR5IGluIERhdGFUYWJsZXMsIHRlY2huaWNhbGx5IHRoaXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGlzIFwiZmlsdGVyaW5nXCIsIHNpbmNlIGl0IGlzIHN1YnRyYWN0aXZlLiBIb3dldmVyLCBmb3IgY29uc2lzdGVuY3kgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG5hbWluZyB3ZSBjYWxsIGl0IHNlYXJjaGluZyBoZXJlLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgY3VzdG9tIHNlYXJjaCBiZWluZyBhcHBsaWVkIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gZm91cnRoIGNvbHVtbiAoaS5lLiB0aGUgZGF0YVszXSBpbmRleCkgYmFzZWQgb24gdHdvIGlucHV0IHZhbHVlc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgLy8gZnJvbSB0aGUgZW5kLXVzZXIsIG1hdGNoaW5nIHRoZSBkYXRhIGluIGEgY2VydGFpbiByYW5nZS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC5zZWFyY2gucHVzaChcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24oIHNldHRpbmdzLCBkYXRhLCBkYXRhSW5kZXggKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgdmFyIG1pbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaW4nKS52YWx1ZSAqIDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgdmFyIG1heCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXgnKS52YWx1ZSAqIDE7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgdmFyIHZlcnNpb24gPSBkYXRhWzNdID09IFwiLVwiID8gMCA6IGRhdGFbM10qMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgaWYgKCBtaW4gPT0gXCJcIiAmJiBtYXggPT0gXCJcIiApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBlbHNlIGlmICggbWluID09IFwiXCIgJiYgdmVyc2lvbiA8IG1heCApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBlbHNlIGlmICggbWluIDwgdmVyc2lvbiAmJiBcIlwiID09IG1heCApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBlbHNlIGlmICggbWluIDwgdmVyc2lvbiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2VhcmNoOiBbXSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBTZWxlY3RvciBleHRlbnNpb25zXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIGBzZWxlY3RvcmAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGV4dGVuZCB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogc2VsZWN0b3IgbW9kaWZpZXIgb3B0aW9ucyAoYHNlbGVjdG9yLW1vZGlmaWVyYCBvYmplY3QgZGF0YSB0eXBlKSB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBlYWNoIG9mIHRoZSB0aHJlZSBidWlsdCBpbiBzZWxlY3RvciB0eXBlcyBvZmZlciAocm93LCBjb2x1bW4gYW5kIGNlbGwgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGhlaXIgcGx1cmFsIGNvdW50ZXJwYXJ0cykuIEZvciBleGFtcGxlIHRoZSBTZWxlY3QgZXh0ZW5zaW9uIHVzZXMgdGhpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogbWVjaGFuaXNtIHRvIHByb3ZpZGUgYW4gb3B0aW9uIHRvIHNlbGVjdCBvbmx5IHJvd3MsIGNvbHVtbnMgYW5kIGNlbGxzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IGhhdmUgYmVlbiBtYXJrZWQgYXMgc2VsZWN0ZWQgYnkgdGhlIGVuZCB1c2VyIChge3NlbGVjdGVkOiB0cnVlfWApLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2hpY2ggY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgZXhpc3RpbmcgYnVpbHQgaW4gc2VsZWN0b3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9wdGlvbnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRWFjaCBwcm9wZXJ0eSBpcyBhbiBhcnJheSB0byB3aGljaCBmdW5jdGlvbnMgY2FuIGJlIHB1c2hlZC4gVGhlIGZ1bmN0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogdGFrZSB0aHJlZSBhdHRyaWJ1dGVzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogU2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgaG9zdCB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBPcHRpb25zIG9iamVjdCAoYHNlbGVjdG9yLW1vZGlmaWVyYCBvYmplY3QgdHlwZSlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogQXJyYXkgb2Ygc2VsZWN0ZWQgaXRlbSBpbmRleGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhlIHJldHVybiBpcyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0aW5nIGl0ZW0gaW5kZXhlcyBhZnRlciB0aGUgY3VzdG9tXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBzZWxlY3RvciBoYXMgYmVlbiBhcHBsaWVkLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjZWxsOiBbXSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogW11cclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogSW50ZXJuYWwgZnVuY3Rpb25zLCBleHBvc2VkIGZvciB1c2VkIGluIHBsdWctaW5zLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHlvdSBzaG91bGQgbm90IG5lZWQgdG8gdXNlIHRoZSBpbnRlcm5hbCBtZXRob2RzIGZvclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW55dGhpbmcgb3RoZXIgdGhhbiBhIHBsdWctaW4gKGFuZCBldmVuIHRoZW4sIHRyeSB0byBhdm9pZCBpZiBwb3NzaWJsZSkuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgaW50ZXJuYWwgZnVuY3Rpb24gbWF5IGNoYW5nZSBiZXR3ZWVuIHJlbGVhc2VzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbDoge30sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogTGVnYWN5IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gRW5hYmxlIGFuZCBkaXNhYmxlIGxlZ2FjeSBvcHRpb25zIHRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFyZSBhdmFpbGFibGUgaW4gRGF0YVRhYmxlcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIGxlZ2FjeToge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEVuYWJsZSAvIGRpc2FibGUgRGF0YVRhYmxlcyAxLjkgY29tcGF0aWJsZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogcmVxdWVzdHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhamF4OiBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFBhZ2luYXRpb24gcGx1Zy1pbiBtZXRob2RzLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFYWNoIGVudHJ5IGluIHRoaXMgb2JqZWN0IGlzIGEgZnVuY3Rpb24gYW5kIGRlZmluZXMgd2hpY2ggYnV0dG9ucyBzaG91bGRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGJlIHNob3duIGJ5IHRoZSBwYWdpbmF0aW9uIHJlbmRlcmluZyBtZXRob2QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGU6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLmV4dC5yZW5kZXJlci5wYWdlQnV0dG9ufS4gVGhlIHJlbmRlcmVyIGFkZHJlc3NlcyBob3cgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBidXR0b25zIGFyZSBkaXNwbGF5ZWQgaW4gdGhlIGRvY3VtZW50LCB3aGlsZSB0aGUgZnVuY3Rpb25zIGhlcmUgdGVsbCBpdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogd2hhdCBidXR0b25zIHRvIGRpc3BsYXkuIFRoaXMgaXMgZG9uZSBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYnV0dG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBkZXNjcmlwdGlvbnMgKHdoYXQgZWFjaCBidXR0b24gd2lsbCBkbykuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogUGFnaW5hdGlvbiB0eXBlcyAodGhlIGZvdXIgYnVpbHQgaW4gb3B0aW9ucyBhbmQgYW55IGFkZGl0aW9uYWwgcGx1Zy1pblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogb3B0aW9ucyBkZWZpbmVkIGhlcmUpIGNhbiBiZSB1c2VkIHRocm91Z2ggdGhlIGBwYWdpbmF0aW9uVHlwZWBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAxLiBge2ludH0gcGFnZWAgVGhlIGN1cnJlbnQgcGFnZSBpbmRleFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMi4gYHtpbnR9IHBhZ2VzYCBUaGUgbnVtYmVyIG9mIHBhZ2VzIGluIHRoZSB0YWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCBvZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFycmF5IGNhbiBiZSBvbmUgb2Y6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBgZmlyc3RgIC0gSnVtcCB0byBmaXJzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBsYXN0YCAtIEp1bXAgdG8gbGFzdCBwYWdlIHdoZW4gYWN0aXZhdGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAqIGBwcmV2aW91c2AgLSBTaG93IHByZXZpb3VzIHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYG5leHRgIC0gU2hvdyBuZXh0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYHtpbnR9YCAtIFNob3cgcGFnZSBvZiB0aGUgaW5kZXggZ2l2ZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqICogYHthcnJheX1gIC0gQSBuZXN0ZWQgYXJyYXkgY29udGFpbmluZyB0aGUgYWJvdmUgZWxlbWVudHMgdG8gYWRkIGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgY29udGFpbmluZyAnRElWJyBlbGVtZW50IChtaWdodCBiZSB1c2VmdWwgZm9yIHN0eWxpbmcpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCBEYXRhVGFibGVzIHYxLjktIHVzZWQgdGhpcyBvYmplY3Qgc2xpZ2h0bHkgZGlmZmVyZW50bHkgd2hlcmVieVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogYW4gb2JqZWN0IHdpdGggdHdvIGZ1bmN0aW9ucyB3b3VsZCBiZSBkZWZpbmVkIGZvciBlYWNoIHBsdWctaW4uIFRoYXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFiaWxpdHkgaXMgc3RpbGwgc3VwcG9ydGVkIGJ5IERhdGFUYWJsZXMgMS4xMCsgdG8gcHJvdmlkZSBiYWNrd2FyZHNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGNvbXBhdGliaWxpdHksIGJ1dCB0aGlzIG9wdGlvbiBvZiB1c2UgaXMgbm93IGRlY3JlbWVudGVkIGFuZCBubyBsb25nZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRvY3VtZW50ZWQgaW4gRGF0YVRhYmxlcyAxLjEwKy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIC8vIFNob3cgcHJldmlvdXMsIG5leHQgYW5kIGN1cnJlbnQgcGFnZSBidXR0b25zIG9ubHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlRXh0Lm9QYWdpbmF0aW9uLmN1cnJlbnQgPSBmdW5jdGlvbiAoIHBhZ2UsIHBhZ2VzICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICByZXR1cm4gWyAncHJldmlvdXMnLCBwYWdlLCAnbmV4dCcgXTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIH07XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHBhZ2VyOiB7fSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYWdlQnV0dG9uOiB7fSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIE9yZGVyaW5nIHBsdWctaW5zIC0gY3VzdG9tIGRhdGEgc291cmNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBleHRlbnNpb24gb3B0aW9ucyBmb3Igb3JkZXJpbmcgb2YgZGF0YSBhdmFpbGFibGUgaGVyZSBpcyBjb21wbGltZW50YXJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkIG9yZGVyaW5nIHRoYXQgRGF0YVRhYmxlcyB0eXBpY2FsbHkgdXNlcy4gSXRcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGFsbG93cyBtdWNoIGdyZWF0ZXIgY29udHJvbCBvdmVyIHRoZSB0aGUgZGF0YSB0aGF0IGlzIGJlaW5nIHVzZWQgdG9cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIG9yZGVyIGEgY29sdW1uLCBidXQgaXMgbmVjZXNzYXJpbHkgdGhlcmVmb3JlIG1vcmUgY29tcGxleC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVGhpcyB0eXBlIG9mIG9yZGVyaW5nIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBkbyBvcmRlcmluZyBiYXNlZCBvbiBkYXRhXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBsaXZlIGZyb20gdGhlIERPTSAoZm9yIGV4YW1wbGUgdGhlIGNvbnRlbnRzIG9mIGFuICdpbnB1dCcgZWxlbWVudCkgcmF0aGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGFuIGp1c3QgdGhlIHN0YXRpYyBzdHJpbmcgdGhhdCBEYXRhVGFibGVzIGtub3dzIG9mLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB3aXNoIHRvIGJlIG9yZGVyaW5nIGZvciB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIGFuZCB0aGVuIHJldHVybiB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBhcnJheS4gVGhlIGRhdGEgaW4gdGhlIGFycmF5IG11Y2ggYmUgaW4gdGhlIGluZGV4IG9yZGVyIG9mIHRoZSByb3dzIGluXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbiBpcyBydW4gaGVyZSBkZXBlbmRzIG9uIHRoZSBgZHQtaW5pdCBjb2x1bW5zLm9yZGVyRGF0YVR5cGVgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBwYXJhbWV0ZXIgdGhhdCBpcyB1c2VkIGZvciB0aGUgY29sdW1uIChpZiBhbnkpLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogMi4gYHtpbnR9YCBUYXJnZXQgY29sdW1uIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYW4gYXJyYXk6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBPcmRlcmluZyB1c2luZyBgaW5wdXRgIG5vZGUgdmFsdWVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgcmV0dXJuIHRoaXMuYXBpKCkuY29sdW1uKCBjb2wsIHtvcmRlcjonaW5kZXgnfSApLm5vZGVzKCkubWFwKCBmdW5jdGlvbiAoIHRkLCBpICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBvcmRlcjoge30sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogVHlwZSBiYXNlZCBwbHVnLWlucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBFYWNoIGNvbHVtbiBpbiBEYXRhVGFibGVzIGhhcyBhIHR5cGUgYXNzaWduZWQgdG8gaXQsIGVpdGhlciBieSBhdXRvbWF0aWNcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGRldGVjdGlvbiBvciBieSBkaXJlY3QgYXNzaWdubWVudCB1c2luZyB0aGUgYHR5cGVgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbi5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqIFRoZSB0eXBlIG9mIGEgY29sdW1uIHdpbGwgZWZmZWN0IGhvdyBpdCBpcyBvcmRlcmluZyBhbmQgc2VhcmNoIChwbHVnLWluc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogY2FuIGFsc28gbWFrZSB1c2Ugb2YgdGhlIGNvbHVtbiB0eXBlIGlmIHJlcXVpcmVkKS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZXNwYWNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUeXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgaW4gdGhpcyBvYmplY3QgYXJlIHVzZWQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBhIGNvbHVtbidzIHR5cGUsIG1ha2luZyBpbml0aWFsaXNhdGlvbiBvZiBEYXRhVGFibGVzIHN1cGVyIGVhc3ksIGV2ZW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIGNvbXBsZXggZGF0YSBpcyBpbiB0aGUgdGFibGUuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb25zIGRlZmluZWQgdGFrZSB0d28gcGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAxLiBgeyp9YCBEYXRhIGZyb20gdGhlIGNvbHVtbiBjZWxsIHRvIGJlIGFuYWx5c2VkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIDIuIGB7c2V0dGluZ3N9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdC4gVGhpcyBjYW4gYmUgdXNlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICBwZXJmb3JtIGNvbnRleHQgc3BlY2lmaWMgdHlwZSBkZXRlY3Rpb24gLSBmb3IgZXhhbXBsZSBkZXRlY3Rpb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgYmFzZWQgb24gbGFuZ3VhZ2Ugc2V0dGluZ3Mgc3VjaCBhcyB1c2luZyBhIGNvbW1hIGZvciBhIGRlY2ltYWxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgcGxhY2UuIEdlbmVyYWxseSBzcGVha2luZyB0aGUgb3B0aW9ucyBmcm9tIHRoZSBzZXR0aW5ncyB3aWxsIG5vdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICBiZSByZXF1aXJlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGB7c3RyaW5nfG51bGx9YCBEYXRhIHR5cGUgZGV0ZWN0ZWQsIG9yIG51bGwgaWYgdW5rbm93biAoYW5kIHRodXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIHBhc3MgaXQgb24gdG8gdGhlIG90aGVyIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgLy8gQ3VycmVuY3kgdHlwZSBkZXRlY3Rpb24gcGx1Zy1pbjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5kZXRlY3QucHVzaChcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGZ1bmN0aW9uICggZGF0YSwgc2V0dGluZ3MgKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIC8vIENoZWNrIHRoZSBudW1lcmljIHBhcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgaWYgKCAhICQuaXNOdW1lcmljKCBkYXRhLnN1YnN0cmluZygxKSApICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgLy8gQ2hlY2sgcHJlZml4ZWQgYnkgY3VycmVuY3lcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgaWYgKCBkYXRhLmNoYXJBdCgwKSA9PSAnJCcgfHwgZGF0YS5jaGFyQXQoMCkgPT0gJyZwb3VuZDsnICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiAnY3VycmVuY3knO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0OiBbXSxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFR5cGUgYmFzZWQgc2VhcmNoIGZvcm1hdHRpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgdHlwZSBiYXNlZCBzZWFyY2hpbmcgZnVuY3Rpb25zIGNhbiBiZSB1c2VkIHRvIHByZS1mb3JtYXQgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZGF0YSB0byBiZSBzZWFyY2ggb24uIEZvciBleGFtcGxlLCBpdCBjYW4gYmUgdXNlZCB0byBzdHJpcCBIVE1MXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogdGFncyBvciB0byBkZS1mb3JtYXQgdGVsZXBob25lIG51bWJlcnMgZm9yIG51bWVyaWMgb25seSBzZWFyY2hpbmcuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgaXMgYSBzZWFyY2ggaXMgbm90IGRlZmluZWQgZm9yIGEgY29sdW1uIG9mIGEgZ2l2ZW4gdHlwZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBubyBzZWFyY2ggZm9ybWF0dGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcmUtcHJvY2Vzc2luZyBvZiBzZWFyY2hpbmcgZGF0YSBwbHVnLWlucyAtIFdoZW4geW91IGFzc2lnbiB0aGUgc1R5cGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBmb3IgYSBjb2x1bW4gKG9yIGhhdmUgaXQgYXV0b21hdGljYWxseSBkZXRlY3RlZCBmb3IgeW91IGJ5IERhdGFUYWJsZXNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBvciBhIHR5cGUgZGV0ZWN0aW9uIHBsdWctaW4pLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYmUgdXNpbmcgdGhpcyBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBjdXN0b20gc29ydGluZywgYnV0IGl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZSBjdXN0b20gc2VhcmNoaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYnkgYWxsb3dpbmcgeW91IHRvIHByZS1wcm9jZXNzaW5nIHRoZSBkYXRhIGFuZCByZXR1cm5pbmcgdGhlIGRhdGEgaW5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgZm9ybWF0IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIHVwb24uIFRoaXMgaXMgZG9uZSBieSBhZGRpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbnMgdGhpcyBvYmplY3Qgd2l0aCBhIHBhcmFtZXRlciBuYW1lIHdoaWNoIG1hdGNoZXMgdGhlIHNUeXBlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogZm9yIHRoYXQgdGFyZ2V0IGNvbHVtbi4gVGhpcyBpcyB0aGUgY29yb2xsYXJ5IG9mIDxpPmFmblNvcnREYXRhPC9pPlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIGZvciBzZWFyY2hpbmcgZGF0YS5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIGEgc2luZ2xlIHBhcmFtZXRlcjpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAxLiBgeyp9YCBEYXRhIGZyb20gdGhlIGNvbHVtbiBjZWxsIHRvIGJlIHByZXBhcmVkIGZvciBzZWFyY2hpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgcmV0dXJuIGQucmVwbGFjZSgvXFxuL2csXCIgXCIpLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaDoge30sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBUeXBlIGJhc2VkIG9yZGVyaW5nLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGNvbHVtbiB0eXBlIHRlbGxzIERhdGFUYWJsZXMgd2hhdCBvcmRlcmluZyB0byBhcHBseSB0byB0aGUgdGFibGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB3aGVuIGEgY29sdW1uIGlzIHNvcnRlZCB1cG9uLiBUaGUgb3JkZXIgZm9yIGVhY2ggdHlwZSB0aGF0IGlzIGRlZmluZWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogaXMgZGVmaW5lZCBieSB0aGUgZnVuY3Rpb25zIGF2YWlsYWJsZSBpbiB0aGlzIG9iamVjdC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEVhY2ggb3JkZXJpbmcgb3B0aW9uIGNhbiBiZSBkZXNjcmliZWQgYnkgdGhyZWUgcHJvcGVydGllcyBhZGRlZCB0b1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoaXMgb2JqZWN0OlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBge3R5cGV9LXByZWAgLSBQcmUtZm9ybWF0dGluZyBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICogYHt0eXBlfS1hc2NgIC0gQXNjZW5kaW5nIG9yZGVyIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBge3R5cGV9LWRlc2NgIC0gRGVzY2VuZGluZyBvcmRlciBmdW5jdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogQWxsIHRocmVlIGNhbiBiZSB1c2VkIHRvZ2V0aGVyLCBvbmx5IGB7dHlwZX0tcHJlYCBvciBvbmx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogYHt0eXBlfS1hc2NgIGFuZCBge3R5cGV9LWRlc2NgIHRvZ2V0aGVyLiBJdCBpcyBnZW5lcmFsbHkgcmVjb21tZW5kZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IG9ubHkgYHt0eXBlfS1wcmVgIGlzIHVzZWQsIGFzIHRoaXMgcHJvdmlkZXMgdGhlIG9wdGltYWxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbXBsZW1lbnRhdGlvbiBpbiB0ZXJtcyBvZiBzcGVlZCwgYWx0aG91Z2ggdGhlIG90aGVycyBhcmUgcHJvdmlkZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIEphdmFzY3JpcHQgc29ydCBmdW5jdGlvbnMuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBge3R5cGV9LXByZWA6IEZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgYSBzaW5nbGUgcGFyYW1ldGVyOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgcHJlcGFyZWQgZm9yIG9yZGVyaW5nXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBBbmQgcmV0dXJuOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogKiBgeyp9YCBEYXRhIHRvIGJlIHNvcnRlZCB1cG9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBge3R5cGV9LWFzY2AgYW5kIGB7dHlwZX0tZGVzY2A6IEZ1bmN0aW9ucyBhcmUgdHlwaWNhbCBKYXZhc2NyaXB0IHNvcnRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbnMsIHRha2luZyB0d28gcGFyYW1ldGVyczpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAxLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIHNlY29uZCBwYXJhbWV0ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgMi4gYHsqfWAgRGF0YSB0byBjb21wYXJlIHRvIHRoZSBmaXJzdCBwYXJhbWV0ZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqIEFuZCByZXR1cm5pbmc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAqIGB7Kn1gIE9yZGVyaW5nIG1hdGNoOiA8MCBpZiBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGJlIHNvcnRlZCBsb3dlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgdGhhbiB0aGUgc2Vjb25kIHBhcmFtZXRlciwgPT09MCBpZiB0aGUgdHdvIHBhcmFtZXRlcnMgYXJlIGVxdWFsIGFuZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgPjAgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgc29ydGVkIGhlaWdodCB0aGFuIHRoZSBzZWNvbmRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgIHBhcmFtZXRlci5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiBcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAvLyBOdW1lcmljIG9yZGVyaW5nIG9mIGZvcm1hdHRlZCBudW1iZXJzIHdpdGggYSBwcmUtZm9ybWF0dGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgJC5leHRlbmQoICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICBcInN0cmluZy1wcmVcIjogZnVuY3Rpb24oeCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICBhID0gKGEgPT09IFwiLVwiIHx8IGEgPT09IFwiXCIpID8gMCA6IGEucmVwbGFjZSggL1teXFxkXFwtXFwuXS9nLCBcIlwiICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiBwYXJzZUZsb2F0KCBhICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgLy8gQ2FzZS1zZW5zaXRpdmUgc3RyaW5nIG9yZGVyaW5nLCB3aXRoIG5vIHByZS1mb3JtYXR0aW5nIG1ldGhvZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXIsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIFwic3RyaW5nLWNhc2UtYXNjXCI6IGZ1bmN0aW9uKHgseSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICBcInN0cmluZy1jYXNlLWRlc2NcIjogZnVuY3Rpb24oeCx5KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICogICAgICAgIHJldHVybiAoKHggPCB5KSA/IDEgOiAoKHggPiB5KSA/IC0xIDogMCkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjoge31cclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBVbmlxdWUgRGF0YVRhYmxlcyBpbnN0YW5jZSBjb3VudGVyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogQHR5cGUgaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBfdW5pcXVlOiAwLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRGVwcmVjaWF0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmxpdHkgb25seS5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzaG91bGQgbm90IGJlIHVzZWQgaW4gbmV3IHByb2plY3RzIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHZlcnNpb25cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBWZXJzaW9uIGNoZWNrIGZ1bmN0aW9uLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2lhdGVkIFNpbmNlIDEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm5WZXJzaW9uQ2hlY2s6IERhdGFUYWJsZS5mblZlcnNpb25DaGVjayxcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiBJbmRleCBmb3Igd2hhdCAndGhpcycgaW5kZXggQVBJIGZ1bmN0aW9ucyBzaG91bGQgdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgaW50XHJcblx0ICAgICAgICAgICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcclxuXHQgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaUFwaUluZGV4OiAwLFxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICAgICAqIGpRdWVyeSBVSSBjbGFzcyBjb250YWluZXJcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBvSlVJQ2xhc3Nlczoge30sXHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogU29mdHdhcmUgdmVyc2lvblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXHJcblx0ICAgICAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIHNWZXJzaW9uOiBEYXRhVGFibGUudmVyc2lvblxyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vXHJcblx0ICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBBbGlhcyB0byBwcmUgMS4xMCBIdW5nYXJpYW4gbm90YXRpb24gY291bnRlciBwYXJ0c1xyXG5cdCAgICAgICAgICAgICAgICAvL1xyXG5cdCAgICAgICAgICAgICAgICAkLmV4dGVuZChfZXh0LCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBhZm5GaWx0ZXJpbmc6IF9leHQuc2VhcmNoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgYVR5cGVzOiBfZXh0LnR5cGUuZGV0ZWN0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb2ZuU2VhcmNoOiBfZXh0LnR5cGUuc2VhcmNoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb1NvcnQ6IF9leHQudHlwZS5vcmRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIGFmblNvcnREYXRhOiBfZXh0Lm9yZGVyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgYW9GZWF0dXJlczogX2V4dC5mZWF0dXJlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgb0FwaTogX2V4dC5pbnRlcm5hbCxcclxuXHQgICAgICAgICAgICAgICAgICAgIG9TdGRDbGFzc2VzOiBfZXh0LmNsYXNzZXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICBvUGFnaW5hdGlvbjogX2V4dC5wYWdlclxyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0LmNsYXNzZXMsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1RhYmxlXCI6IFwiZGF0YVRhYmxlXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNOb0Zvb3RlclwiOiBcIm5vLWZvb3RlclwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFBhZ2luZyBidXR0b25zICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNQYWdlQnV0dG9uXCI6IFwicGFnaW5hdGVfYnV0dG9uXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNQYWdlQnV0dG9uQWN0aXZlXCI6IFwiY3VycmVudFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzUGFnZUJ1dHRvbkRpc2FibGVkXCI6IFwiZGlzYWJsZWRcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBTdHJpcGluZyBjbGFzc2VzICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTdHJpcGVPZGRcIjogXCJvZGRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1N0cmlwZUV2ZW5cIjogXCJldmVuXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogRW1wdHkgcm93ICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNSb3dFbXB0eVwiOiBcImRhdGFUYWJsZXNfZW1wdHlcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBGZWF0dXJlcyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzV3JhcHBlclwiOiBcImRhdGFUYWJsZXNfd3JhcHBlclwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzRmlsdGVyXCI6IFwiZGF0YVRhYmxlc19maWx0ZXJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0luZm9cIjogXCJkYXRhVGFibGVzX2luZm9cIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1BhZ2luZ1wiOiBcImRhdGFUYWJsZXNfcGFnaW5hdGUgcGFnaW5nX1wiLCAvKiBOb3RlIHRoYXQgdGhlIHR5cGUgaXMgcG9zdGZpeGVkICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNMZW5ndGhcIjogXCJkYXRhVGFibGVzX2xlbmd0aFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzUHJvY2Vzc2luZ1wiOiBcImRhdGFUYWJsZXNfcHJvY2Vzc2luZ1wiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIFNvcnRpbmcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRBc2NcIjogXCJzb3J0aW5nX2FzY1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydERlc2NcIjogXCJzb3J0aW5nX2Rlc2NcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRhYmxlXCI6IFwic29ydGluZ1wiLCAvKiBTb3J0YWJsZSBpbiBib3RoIGRpcmVjdGlvbnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRhYmxlQXNjXCI6IFwic29ydGluZ19hc2NfZGlzYWJsZWRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRhYmxlRGVzY1wiOiBcInNvcnRpbmdfZGVzY19kaXNhYmxlZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydGFibGVOb25lXCI6IFwic29ydGluZ19kaXNhYmxlZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydENvbHVtblwiOiBcInNvcnRpbmdfXCIsIC8qIE5vdGUgdGhhdCBhbiBpbnQgaXMgcG9zdGZpeGVkIGZvciB0aGUgc29ydGluZyBvcmRlciAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIEZpbHRlcmluZyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzRmlsdGVySW5wdXRcIjogXCJcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvKiBQYWdlIGxlbmd0aCAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzTGVuZ3RoU2VsZWN0XCI6IFwiXCIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLyogU2Nyb2xsaW5nICovXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTY3JvbGxXcmFwcGVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbEhlYWRcIjogXCJkYXRhVGFibGVzX3Njcm9sbEhlYWRcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1Njcm9sbEhlYWRJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZElubmVyXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTY3JvbGxCb2R5XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxCb2R5XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTY3JvbGxGb290XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxGb290XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTY3JvbGxGb290SW5uZXJcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3RJbm5lclwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8qIE1pc2MgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0hlYWRlclRIXCI6IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNGb290ZXJUSFwiOiBcIlwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIERlcHJlY2F0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRKVUlBc2NcIjogXCJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic1NvcnRKVUlEZXNjXCI6IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJXCI6IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJQXNjQWxsb3dlZFwiOiBcIlwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydEpVSURlc2NBbGxvd2VkXCI6IFwiXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJV3JhcHBlclwiOiBcIlwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzU29ydEljb25cIjogXCJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic0pVSUhlYWRlclwiOiBcIlwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzSlVJRm9vdGVyXCI6IFwiXCJcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBSZXVzZWQgc3RyaW5ncyBmb3IgYmV0dGVyIGNvbXByZXNzaW9uLiBDbG9zdXJlIGNvbXBpbGVyIGFwcGVhcnMgdG8gaGF2ZSBhXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB3ZWlyZCBlZGdlIGNhc2Ugd2hlcmUgaXQgaXMgdHJ5aW5nIHRvIGV4cGFuZCBzdHJpbmdzIHJhdGhlciB0aGFuIHVzZSB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHZhcmlhYmxlIHZlcnNpb24uIFRoaXMgcmVzdWx0cyBpbiBhYm91dCAyMDAgYnl0ZXMgYmVpbmcgYWRkZWQsIGZvciB2ZXJ5XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBsaXR0bGUgcHJlZmVyZW5jZSBiZW5lZml0IHNpbmNlIGl0IHRoaXMgcnVuIG9uIHNjcmlwdCBsb2FkIG9ubHkuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2VtcHR5ID0gJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICBfZW1wdHkgPSAnJztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX3N0YXRlRGVmYXVsdCA9IF9lbXB0eSArICd1aS1zdGF0ZS1kZWZhdWx0JztcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfc29ydEljb24gPSBfZW1wdHkgKyAnY3NzX3JpZ2h0IHVpLWljb24gdWktaWNvbi0nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9oZWFkZXJGb290ZXIgPSBfZW1wdHkgKyAnZmctdG9vbGJhciB1aS10b29sYmFyIHVpLXdpZGdldC1oZWFkZXIgdWktaGVscGVyLWNsZWFyZml4JztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0Lm9KVUlDbGFzc2VzLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBGdWxsIG51bWJlcnMgcGFnaW5nIGJ1dHRvbnMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNQYWdlQnV0dG9uXCI6IFwiZmctYnV0dG9uIHVpLWJ1dHRvbiBcIiArIF9zdGF0ZURlZmF1bHQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzUGFnZUJ1dHRvbkFjdGl2ZVwiOiBcInVpLXN0YXRlLWRpc2FibGVkXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzUGFnZUJ1dHRvbkRpc2FibGVkXCI6IFwidWktc3RhdGUtZGlzYWJsZWRcIixcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogRmVhdHVyZXMgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNQYWdpbmdcIjogXCJkYXRhVGFibGVzX3BhZ2luYXRlIGZnLWJ1dHRvbnNldCB1aS1idXR0b25zZXQgZmctYnV0dG9uc2V0LW11bHRpIFwiICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1aS1idXR0b25zZXQtbXVsdGkgcGFnaW5nX1wiLCAvKiBOb3RlIHRoYXQgdGhlIHR5cGUgaXMgcG9zdGZpeGVkICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8qIFNvcnRpbmcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0QXNjXCI6IF9zdGF0ZURlZmF1bHQgKyBcIiBzb3J0aW5nX2FzY1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnREZXNjXCI6IF9zdGF0ZURlZmF1bHQgKyBcIiBzb3J0aW5nX2Rlc2NcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0YWJsZVwiOiBfc3RhdGVEZWZhdWx0ICsgXCIgc29ydGluZ1wiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnRhYmxlQXNjXCI6IF9zdGF0ZURlZmF1bHQgKyBcIiBzb3J0aW5nX2FzY19kaXNhYmxlZFwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnRhYmxlRGVzY1wiOiBfc3RhdGVEZWZhdWx0ICsgXCIgc29ydGluZ19kZXNjX2Rpc2FibGVkXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydGFibGVOb25lXCI6IF9zdGF0ZURlZmF1bHQgKyBcIiBzb3J0aW5nX2Rpc2FibGVkXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydEpVSUFzY1wiOiBfc29ydEljb24gKyBcInRyaWFuZ2xlLTEtblwiLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic1NvcnRKVUlEZXNjXCI6IF9zb3J0SWNvbiArIFwidHJpYW5nbGUtMS1zXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydEpVSVwiOiBfc29ydEljb24gKyBcImNhcmF0LTItbi1zXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydEpVSUFzY0FsbG93ZWRcIjogX3NvcnRJY29uICsgXCJjYXJhdC0xLW5cIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJRGVzY0FsbG93ZWRcIjogX3NvcnRJY29uICsgXCJjYXJhdC0xLXNcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTb3J0SlVJV3JhcHBlclwiOiBcIkRhdGFUYWJsZXNfc29ydF93cmFwcGVyXCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzU29ydEljb25cIjogXCJEYXRhVGFibGVzX3NvcnRfaWNvblwiLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvKiBTY3JvbGxpbmcgKi9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTY3JvbGxIZWFkXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkIFwiICsgX3N0YXRlRGVmYXVsdCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNTY3JvbGxGb290XCI6IFwiZGF0YVRhYmxlc19zY3JvbGxGb290IFwiICsgX3N0YXRlRGVmYXVsdCxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLyogTWlzYyAqL1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwic0hlYWRlclRIXCI6IF9zdGF0ZURlZmF1bHQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJzRm9vdGVyVEhcIjogX3N0YXRlRGVmYXVsdCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNKVUlIZWFkZXJcIjogX2hlYWRlckZvb3RlciArIFwiIHVpLWNvcm5lci10bCB1aS1jb3JuZXItdHJcIixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcInNKVUlGb290ZXJcIjogX2hlYWRlckZvb3RlciArIFwiIHVpLWNvcm5lci1ibCB1aS1jb3JuZXItYnJcIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB9KCkpO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgZXh0UGFnaW5hdGlvbiA9IERhdGFUYWJsZS5leHQucGFnZXI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfbnVtYmVycyhwYWdlLCBwYWdlcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycyA9IFtdLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSBleHRQYWdpbmF0aW9uLm51bWJlcnNfbGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhbGYgPSBNYXRoLmZsb29yKGJ1dHRvbnMgLyAyKSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpID0gMTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFnZXMgPD0gYnV0dG9ucykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMgPSBfcmFuZ2UoMCwgcGFnZXMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFnZSA8PSBoYWxmKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycyA9IF9yYW5nZSgwLCBidXR0b25zIC0gMik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKCdlbGxpcHNpcycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMucHVzaChwYWdlcyAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFnZSA+PSBwYWdlcyAtIDEgLSBoYWxmKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVycyA9IF9yYW5nZShwYWdlcyAtIChidXR0b25zIC0gMiksIHBhZ2VzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAnZWxsaXBzaXMnKTsgLy8gbm8gdW5zaGlmdCBpbiBpZTZcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMgPSBfcmFuZ2UocGFnZSAtIGhhbGYgKyAyLCBwYWdlICsgaGFsZiAtIDEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnMucHVzaCgnZWxsaXBzaXMnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzLnB1c2gocGFnZXMgLSAxKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAnZWxsaXBzaXMnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAwKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBudW1iZXJzLkRUX2VsID0gJ3NwYW4nO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcnM7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAkLmV4dGVuZChleHRQYWdpbmF0aW9uLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBzaW1wbGU6IGZ1bmN0aW9uIChwYWdlLCBwYWdlcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ3ByZXZpb3VzJywgJ25leHQnXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZnVsbDogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnZmlyc3QnLCAncHJldmlvdXMnLCAnbmV4dCcsICdsYXN0J107XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHNpbXBsZV9udW1iZXJzOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnXTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZnVsbF9udW1iZXJzOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydmaXJzdCcsICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnLCAnbGFzdCddO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGVzdGluZyBhbmQgcGx1Zy1pbnMgdG8gdXNlXHJcblx0ICAgICAgICAgICAgICAgICAgICBfbnVtYmVyczogX251bWJlcnMsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gTnVtYmVyIG9mIG51bWJlciBidXR0b25zIChpbmNsdWRpbmcgZWxsaXBzaXMpIHRvIHNob3cuIF9NdXN0IGJlIG9kZCFfXHJcblx0ICAgICAgICAgICAgICAgICAgICBudW1iZXJzX2xlbmd0aDogN1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBwYWdlQnV0dG9uOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXzogZnVuY3Rpb24gKHNldHRpbmdzLCBob3N0LCBpZHgsIGJ1dHRvbnMsIHBhZ2UsIHBhZ2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5nID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9QYWdpbmF0ZTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyID0gMDtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRhY2ggPSBmdW5jdGlvbiAoY29udGFpbmVyLCBidXR0b25zKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaWVuLCBub2RlLCBidXR0b247XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5QYWdlQ2hhbmdlKHNldHRpbmdzLCBlLmRhdGEuYWN0aW9uLCB0cnVlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gYnV0dG9ucy5sZW5ndGggOyBpIDwgaWVuIDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uc1tpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQuaXNBcnJheShidXR0b24pKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbm5lciA9ICQoJzwnICsgKGJ1dHRvbi5EVF9lbCB8fCAnZGl2JykgKyAnLz4nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbnRhaW5lcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaChpbm5lciwgYnV0dG9uKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuQ2xhc3MgPSAnJztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYnV0dG9uKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbGxpcHNpcyc6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJlbGxpcHNpc1wiPiYjeDIwMjY7PC9zcGFuPicpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpcnN0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5EaXNwbGF5ID0gbGFuZy5zRmlyc3Q7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA+IDAgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyA6ICcgJyArIGNsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJldmlvdXMnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBsYW5nLnNQcmV2aW91cztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlID4gMCA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnIDogJyAnICsgY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduZXh0JzpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5EaXNwbGF5ID0gbGFuZy5zTmV4dDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlIDwgcGFnZXMgLSAxID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgOiAnICcgKyBjbGFzc2VzLnNQYWdlQnV0dG9uRGlzYWJsZWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xhc3QnOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBsYW5nLnNMYXN0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPCBwYWdlcyAtIDEgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyA6ICcgJyArIGNsYXNzZXMuc1BhZ2VCdXR0b25EaXNhYmxlZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5EaXNwbGF5ID0gYnV0dG9uICsgMTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9IHBhZ2UgPT09IGJ1dHRvbiA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1BhZ2VCdXR0b25BY3RpdmUgOiAnJztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ0bkRpc3BsYXkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSAkKCc8YT4nLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3Nlcy5zUGFnZUJ1dHRvbiArICcgJyArIGJ0bkNsYXNzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogc2V0dGluZ3Muc1RhYmxlSWQsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEtZHQtaWR4JzogY291bnRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiBzZXR0aW5ncy5pVGFiSW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWR4ID09PSAwICYmIHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc1RhYmxlSWQgKyAnXycgKyBidXR0b24gOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKGJ0bkRpc3BsYXkpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbnRhaW5lcik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQmluZEFjdGlvbihcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLCB7IGFjdGlvbjogYnV0dG9uIH0sIGNsaWNrSGFuZGxlclxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyKys7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTkgdGhyb3dzIGFuICd1bmtub3duIGVycm9yJyBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVzZWRcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4gVHJ5IC8gY2F0Y2ggdGhlIGVycm9yLiBOb3QgZ29vZCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzaWJpbGl0eSwgYnV0IG5laXRoZXIgYXJlIGZyYW1lcy5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUVsO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhpcyBhcHByb2FjaCBpcyBkZXN0cm95aW5nIGFuZCByZWNyZWF0aW5nIHRoZSBwYWdpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRzLCBmb2N1cyBpcyBsb3N0IG9uIHRoZSBzZWxlY3QgYnV0dG9uIHdoaWNoIGlzIGJhZCBmb3JcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY2Vzc2liaWxpdHkuIFNvIHdlIHdhbnQgdG8gcmVzdG9yZSBmb2N1cyBvbmNlIHRoZSBkcmF3IGhhc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcGxldGVkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbCA9ICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoKCQoaG9zdCkuZW1wdHkoKSwgYnV0dG9ucyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoaG9zdCkuZmluZCgnW2RhdGEtZHQtaWR4PScgKyBhY3RpdmVFbCArICddJykuZm9jdXMoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIEJ1aWx0IGluIHR5cGUgZGV0ZWN0aW9uLiBTZWUgbW9kZWwuZXh0LmFUeXBlcyBmb3IgaW5mb3JtYXRpb24gYWJvdXRcclxuXHQgICAgICAgICAgICAgICAgLy8gd2hhdCBpcyByZXF1aXJlZCBmcm9tIHRoaXMgbWV0aG9kcy5cclxuXHQgICAgICAgICAgICAgICAgJC5leHRlbmQoRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdCwgW1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGxhaW4gbnVtYmVycyAtIGZpcnN0IHNpbmNlIFY4IGRldGVjdHMgc29tZSBwbGFpbiBudW1iZXJzIGFzIGRhdGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIERhdGUucGFyc2UoJzU1JykgKGJ1dCBub3QgYWxsLCBlLmcuIERhdGUucGFyc2UoJzIyJykuLi4pLlxyXG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9pc051bWJlcihkLCBkZWNpbWFsKSA/ICdudW0nICsgZGVjaW1hbCA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIERhdGVzIChvbmx5IHRob3NlIHJlY29nbmlzZWQgYnkgdGhlIGJyb3dzZXIncyBEYXRlLnBhcnNlKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVjggd2lsbCByZW1vdmUgYW55IHVua25vd24gY2hhcmFjdGVycyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGVcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uLCBsZWFkaW5nIHRvIGZhbHNlIG1hdGNoZXMgc3VjaCBhcyBgJDI0NS4xMmAgb3IgYDEwJWAgYmVpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHZhbGlkIGRhdGUuIFNlZSBmb3J1bSB0aHJlYWQgMTg5NDEgZm9yIGRldGFpbC5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCAmJiAhKGQgaW5zdGFuY2VvZiBEYXRlKSAmJiAoIV9yZV9kYXRlX3N0YXJ0LnRlc3QoZCkgfHwgIV9yZV9kYXRlX2VuZC50ZXN0KGQpKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IERhdGUucGFyc2UoZCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZWQgIT09IG51bGwgJiYgIWlzTmFOKHBhcnNlZCkpIHx8IF9lbXB0eShkKSA/ICdkYXRlJyA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdHRlZCBudW1iZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2lzTnVtYmVyKGQsIGRlY2ltYWwsIHRydWUpID8gJ251bS1mbXQnICsgZGVjaW1hbCA6IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEhUTUwgbnVtZXJpY1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9odG1sTnVtZXJpYyhkLCBkZWNpbWFsKSA/ICdodG1sLW51bScgKyBkZWNpbWFsIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSFRNTCBudW1lcmljLCBmb3JtYXR0ZWRcclxuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfaHRtbE51bWVyaWMoZCwgZGVjaW1hbCwgdHJ1ZSkgPyAnaHRtbC1udW0tZm10JyArIGRlY2ltYWwgOiBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBIVE1MICh0aGlzIGlzIHN0cmljdCBjaGVja2luZyAtIHRoZXJlIG11c3QgYmUgaHRtbClcclxuXHQgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoZCkgfHwgKHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJiBkLmluZGV4T2YoJzwnKSAhPT0gLTEpID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0bWwnIDogbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgXSk7XHJcblxyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIEZpbHRlciBmb3JtYXR0aW5nIGZ1bmN0aW9ucy4gU2VlIG1vZGVsLmV4dC5vZm5TZWFyY2ggZm9yIGluZm9ybWF0aW9uIGFib3V0XHJcblx0ICAgICAgICAgICAgICAgIC8vIHdoYXQgaXMgcmVxdWlyZWQgZnJvbSB0aGVzZSBtZXRob2RzLlxyXG5cdCAgICAgICAgICAgICAgICAvLyBcclxuXHQgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGFkZGl0aW9uYWwgc2VhcmNoIG1ldGhvZHMgYXJlIGFkZGVkIGZvciB0aGUgaHRtbCBudW1iZXJzIGFuZFxyXG5cdCAgICAgICAgICAgICAgICAvLyBodG1sIGZvcm1hdHRlZCBudW1iZXJzIGJ5IGBfYWRkTnVtZXJpY1NvcnQoKWAgd2hlbiB3ZSBrbm93IHdoYXQgdGhlIGRlY2ltYWxcclxuXHQgICAgICAgICAgICAgICAgLy8gcGxhY2UgaXNcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoLCB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBodG1sOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoZGF0YSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShfcmVfbmV3X2xpbmVzLCBcIiBcIilcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShfcmVfaHRtbCwgXCJcIikgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHN0cmluZzogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VtcHR5KGRhdGEpID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJlcGxhY2UoX3JlX25ld19saW5lcywgXCIgXCIpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgX19udW1lcmljUmVwbGFjZSA9IGZ1bmN0aW9uIChkLCBkZWNpbWFsUGxhY2UsIHJlMSwgcmUyKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZCAhPT0gMCAmJiAoIWQgfHwgZCA9PT0gJy0nKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBkZWNpbWFsIHBsYWNlIG90aGVyIHRoYW4gYC5gIGlzIHVzZWQsIGl0IG5lZWRzIHRvIGJlIGdpdmVuIHRvIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gc28gd2UgY2FuIGRldGVjdCBpdCBhbmQgcmVwbGFjZSB3aXRoIGEgYC5gIHdoaWNoIGlzIHRoZSBvbmx5XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBsYWNlIEphdmFzY3JpcHQgcmVjb2duaXNlcyAtIGl0IGlzIG5vdCBsb2NhbGUgYXdhcmUuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbFBsYWNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZCA9IF9udW1Ub0RlY2ltYWwoZCwgZGVjaW1hbFBsYWNlKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZC5yZXBsYWNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gZC5yZXBsYWNlKHJlMSwgJycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlMikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gZC5yZXBsYWNlKHJlMiwgJycpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZCAqIDE7XHJcblx0ICAgICAgICAgICAgICAgIH07XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBudW1lcmljICdkZWZvcm1hdHRpbmcnIGZ1bmN0aW9ucyBmb3Igc29ydGluZyBhbmQgc2VhcmNoLiBUaGlzIGlzIGRvbmVcclxuXHQgICAgICAgICAgICAgICAgLy8gaW4gYSBmdW5jdGlvbiB0byBwcm92aWRlIGFuIGVhc3kgYWJpbGl0eSBmb3IgdGhlIGxhbmd1YWdlIG9wdGlvbnMgdG8gYWRkXHJcblx0ICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgbWV0aG9kcyBpZiBhIG5vbi1wZXJpb2QgZGVjaW1hbCBwbGFjZSBpcyB1c2VkLlxyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfYWRkTnVtZXJpY1NvcnQoZGVjaW1hbFBsYWNlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAkLmVhY2goXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFpbiBudW1iZXJzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibnVtXCI6IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19udW1lcmljUmVwbGFjZShkLCBkZWNpbWFsUGxhY2UpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0dGVkIG51bWJlcnNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJudW0tZm10XCI6IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19udW1lcmljUmVwbGFjZShkLCBkZWNpbWFsUGxhY2UsIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIVE1MIG51bWVyaWNcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJodG1sLW51bVwiOiBmdW5jdGlvbiAoZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIVE1MIG51bWVyaWMsIGZvcm1hdHRlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImh0bWwtbnVtLWZtdFwiOiBmdW5jdGlvbiAoZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCwgX3JlX2Zvcm1hdHRlZF9udW1lcmljKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGtleSwgZm4pIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBvcmRlcmluZyBtZXRob2RcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4dC50eXBlLm9yZGVyW2tleSArIGRlY2ltYWxQbGFjZSArICctcHJlJ10gPSBmbjtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBIVE1MIHR5cGVzIGFkZCBhIHNlYXJjaCBmb3JtYXR0ZXIgdGhhdCB3aWxsIHN0cmlwIHRoZSBIVE1MXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkubWF0Y2goL15odG1sXFwtLykpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leHQudHlwZS5zZWFyY2hba2V5ICsgZGVjaW1hbFBsYWNlXSA9IF9leHQudHlwZS5zZWFyY2guaHRtbDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHNvcnQgbWV0aG9kc1xyXG5cdCAgICAgICAgICAgICAgICAkLmV4dGVuZChfZXh0LnR5cGUub3JkZXIsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIERhdGVzXHJcblx0ICAgICAgICAgICAgICAgICAgICBcImRhdGUtcHJlXCI6IGZ1bmN0aW9uIChkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERhdGUucGFyc2UoZCkgfHwgMDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaHRtbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJodG1sLXByZVwiOiBmdW5jdGlvbiAoYSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoYSkgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucmVwbGFjZSA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnJlcGxhY2UoLzwuKj8+L2csIFwiXCIpLnRvTG93ZXJDYXNlKCkgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmdcclxuXHQgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nLXByZVwiOiBmdW5jdGlvbiAoYSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBsaXR0bGUgY29tcGxleCwgYnV0IGZhc3RlciB0aGFuIGFsd2F5cyBjYWxsaW5nIHRvU3RyaW5nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rvc3RyaW5nLXYtY2hlY2tcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VtcHR5KGEpID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYSA9PT0gJ3N0cmluZycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50b0xvd2VyQ2FzZSgpIDpcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFhLnRvU3RyaW5nID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS50b1N0cmluZygpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmctYXNjIGFuZCAtZGVzYyBhcmUgcmV0YWluZWQgb25seSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBvbGRcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIHNvcnQgbWV0aG9kc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmctYXNjXCI6IGZ1bmN0aW9uICh4LCB5KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nLWRlc2NcIjogZnVuY3Rpb24gKHgsIHkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gTnVtZXJpYyBzb3J0aW5nIHR5cGVzIC0gb3JkZXIgZG9lc24ndCBtYXR0ZXIgaGVyZVxyXG5cdCAgICAgICAgICAgICAgICBfYWRkTnVtZXJpY1NvcnQoJycpO1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhlYWRlcjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF86IGZ1bmN0aW9uIChzZXR0aW5ncywgY2VsbCwgY29sdW1uLCBjbGFzc2VzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGFkZGl0aW9uYWwgbWFyay11cCByZXF1aXJlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIHVwZGF0ZSBvbiBzb3J0IC0gbm90ZSB0aGF0IHVzaW5nIHRoZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBgRFRgIG5hbWVzcGFjZSB3aWxsIGFsbG93IHRoZSBldmVudCB0byBiZSByZW1vdmVkIGF1dG9tYXRpY2FsbHlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gZGVzdHJveSwgd2hpbGUgdGhlIGBkdGAgbmFtZXNwYWNlZCBldmVudCBpcyB0aGUgb25lIHdlIGFyZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgZm9yXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS5vbignb3JkZXIuZHQuRFQnLCBmdW5jdGlvbiAoZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkgeyAvLyBuZWVkIHRvIGNoZWNrIHRoaXMgdGhpcyBpcyB0aGUgaG9zdFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAvLyB0YWJsZSwgbm90IGEgbmVzdGVkIG9uZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xJZHggPSBjb2x1bW4uaWR4O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zU29ydGluZ0NsYXNzICsgJyAnICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEFzYyArICcgJyArXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnREZXNjXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjb2x1bW5zW2NvbElkeF0gPT0gJ2FzYycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1tjb2xJZHhdID09ICdkZXNjJyA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0RGVzYyA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1NvcnRpbmdDbGFzc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGpxdWVyeXVpOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGNlbGwsIGNvbHVtbiwgY2xhc3Nlcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKCc8ZGl2Lz4nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGNsYXNzZXMuc1NvcnRKVUlXcmFwcGVyKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChjZWxsLmNvbnRlbnRzKCkpXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxzcGFuLz4nKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjbGFzc2VzLnNTb3J0SWNvbiArICcgJyArIGNvbHVtbi5zU29ydGluZ0NsYXNzSlVJKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNlbGwpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkub24oJ29yZGVyLmR0LkRUJywgZnVuY3Rpb24gKGUsIGN0eCwgc29ydGluZywgY29sdW1ucykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzICE9PSBjdHgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbElkeCA9IGNvbHVtbi5pZHg7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhjbGFzc2VzLnNTb3J0QXNjICsgXCIgXCIgKyBjbGFzc2VzLnNTb3J0RGVzYylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoY29sdW1uc1tjb2xJZHhdID09ICdhc2MnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEFzYyA6IGNvbHVtbnNbY29sSWR4XSA9PSAnZGVzYycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydERlc2MgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNTb3J0aW5nQ2xhc3NcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZCgnc3Bhbi4nICsgY2xhc3Nlcy5zU29ydEljb24pXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJQXNjICsgXCIgXCIgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJRGVzYyArIFwiIFwiICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSSArIFwiIFwiICtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSUFzY0FsbG93ZWQgKyBcIiBcIiArXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRKVUlEZXNjQWxsb3dlZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoY29sdW1uc1tjb2xJZHhdID09ICdhc2MnID9cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSUFzYyA6IGNvbHVtbnNbY29sSWR4XSA9PSAnZGVzYycgP1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSURlc2MgOlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLnNTb3J0aW5nQ2xhc3NKVUlcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLypcclxuXHQgICAgICAgICAgICAgICAgICogUHVibGljIGhlbHBlciBmdW5jdGlvbnMuIFRoZXNlIGFyZW4ndCB1c2VkIGludGVybmFsbHkgYnkgRGF0YVRhYmxlcywgb3JcclxuXHQgICAgICAgICAgICAgICAgICogY2FsbGVkIGJ5IGFueSBvZiB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byBEYXRhVGFibGVzLCBidXQgdGhleSBjYW4gYmUgdXNlZFxyXG5cdCAgICAgICAgICAgICAgICAgKiBleHRlcm5hbGx5IGJ5IGRldmVsb3BlcnMgd29ya2luZyB3aXRoIERhdGFUYWJsZXMuIFRoZXkgYXJlIGhlbHBlciBmdW5jdGlvbnNcclxuXHQgICAgICAgICAgICAgICAgICogdG8gbWFrZSB3b3JraW5nIHdpdGggRGF0YVRhYmxlcyBhIGxpdHRsZSBiaXQgZWFzaWVyLlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBIZWxwZXJzIGZvciBgY29sdW1ucy5yZW5kZXJgLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUaGUgb3B0aW9ucyBkZWZpbmVkIGhlcmUgY2FuIGJlIHVzZWQgd2l0aCB0aGUgYGNvbHVtbnMucmVuZGVyYCBpbml0aWFsaXNhdGlvblxyXG5cdCAgICAgICAgICAgICAgICAgKiBvcHRpb24gdG8gcHJvdmlkZSBhIGRpc3BsYXkgcmVuZGVyZXIuIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSBkZWZpbmVkOlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAqIGBudW1iZXJgIC0gV2lsbCBmb3JtYXQgbnVtZXJpYyBkYXRhIChkZWZpbmVkIGJ5IGBjb2x1bW5zLmRhdGFgKSBmb3JcclxuXHQgICAgICAgICAgICAgICAgICogICBkaXNwbGF5LCByZXRhaW5pbmcgdGhlIG9yaWdpbmFsIHVuZm9ybWF0dGVkIGRhdGEgZm9yIHNvcnRpbmcgYW5kIGZpbHRlcmluZy5cclxuXHQgICAgICAgICAgICAgICAgICogICBJdCB0YWtlcyA0IHBhcmFtZXRlcnM6XHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgc3RyaW5nYCAtIFRob3VzYW5kcyBncm91cGluZyBzZXBhcmF0b3JcclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBzdHJpbmdgIC0gRGVjaW1hbCBwb2ludCBpbmRpY2F0b3JcclxuXHQgICAgICAgICAgICAgICAgICogICAqIGBpbnRlZ2VyYCAtIE51bWJlciBvZiBkZWNpbWFsIHBvaW50cyB0byBzaG93XHJcblx0ICAgICAgICAgICAgICAgICAqICAgKiBgc3RyaW5nYCAob3B0aW9uYWwpIC0gUHJlZml4LlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIC8vIENvbHVtbiBkZWZpbml0aW9uIHVzaW5nIHRoZSBudW1iZXIgcmVuZGVyZXJcclxuXHQgICAgICAgICAgICAgICAgICogICB7XHJcblx0ICAgICAgICAgICAgICAgICAqICAgICBkYXRhOiBcInNhbGFyeVwiLFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgcmVuZGVyOiAkLmZuLmRhdGFUYWJsZS5yZW5kZXIubnVtYmVyKCAnXFwnJywgJy4nLCAwLCAnJCcgKVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgIH1cclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgRGF0YVRhYmxlLnJlbmRlciA9IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIG51bWJlcjogZnVuY3Rpb24gKHRob3VzYW5kcywgZGVjaW1hbCwgcHJlY2lzaW9uLCBwcmVmaXgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbiAoZCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZCAhPT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBkIDwgMCA/ICctJyA6ICcnO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCA9IE1hdGguYWJzKHBhcnNlRmxvYXQoZCkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnRQYXJ0ID0gcGFyc2VJbnQoZCwgMTApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsb2F0UGFydCA9IHByZWNpc2lvbiA/XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbCArIChkIC0gaW50UGFydCkudG9GaXhlZChwcmVjaXNpb24pLnN1YnN0cmluZygyKSA6XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5lZ2F0aXZlICsgKHByZWZpeCB8fCAnJykgK1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFBhcnQudG9TdHJpbmcoKS5yZXBsYWNlKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgdGhvdXNhbmRzXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXRQYXJ0O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIHJlYWxseSBhIGdvb2QgYml0IHJ1YmJpc2ggdGhpcyBtZXRob2Qgb2YgZXhwb3NpbmcgdGhlIGludGVybmFsIG1ldGhvZHNcclxuXHQgICAgICAgICAgICAgICAgICogcHVibGljbHkuLi4gLSBUbyBiZSBmaXhlZCBpbiAyLjAgdXNpbmcgbWV0aG9kcyBvbiB0aGUgcHJvdG90eXBlXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDcmVhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBleHBvcnRpbmcgYW4gaW50ZXJuYWwgZnVuY3Rpb25zIHRvIGFuIGV4dGVybmFsIEFQSS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBmbiBBUEkgZnVuY3Rpb24gbmFtZVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHJldHVybnMge2Z1bmN0aW9ufSB3cmFwcGVkIGZ1bmN0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI2ludGVybmFsXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbiBfZm5FeHRlcm5BcGlGdW5jKGZuKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW19mblNldHRpbmdzRnJvbU5vZGUodGhpc1tEYXRhVGFibGUuZXh0LmlBcGlJbmRleF0pXS5jb25jYXQoXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXRhVGFibGUuZXh0LmludGVybmFsW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIGludGVybmFsIGZ1bmN0aW9ucyBmb3IgdXNlIGJ5IHBsdWctaW4gZGV2ZWxvcGVycy4gTm90ZSB0aGF0XHJcblx0ICAgICAgICAgICAgICAgICAqIHRoZXNlIG1ldGhvZHMgYXJlIHJlZmVyZW5jZXMgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGFuZCBhcmUgY29uc2lkZXJlZCB0byBiZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBwcml2YXRlLiBJZiB5b3UgdXNlIHRoZXNlIG1ldGhvZHMsIGJlIGF3YXJlIHRoYXQgdGhleSBhcmUgbGlhYmxlIHRvIGNoYW5nZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBiZXR3ZWVuIHZlcnNpb25zLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICAgICAgJC5leHRlbmQoRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRXh0ZXJuQXBpRnVuYzogX2ZuRXh0ZXJuQXBpRnVuYyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkJ1aWxkQWpheDogX2ZuQnVpbGRBamF4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWpheFVwZGF0ZTogX2ZuQWpheFVwZGF0ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFqYXhQYXJhbWV0ZXJzOiBfZm5BamF4UGFyYW1ldGVycyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFqYXhVcGRhdGVEcmF3OiBfZm5BamF4VXBkYXRlRHJhdyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFqYXhEYXRhU3JjOiBfZm5BamF4RGF0YVNyYyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFkZENvbHVtbjogX2ZuQWRkQ29sdW1uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uT3B0aW9uczogX2ZuQ29sdW1uT3B0aW9ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZzogX2ZuQWRqdXN0Q29sdW1uU2l6aW5nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXg6IF9mblZpc2libGVUb0NvbHVtbkluZGV4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGU6IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuVmlzYmxlQ29sdW1uczogX2ZuVmlzYmxlQ29sdW1ucyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkdldENvbHVtbnM6IF9mbkdldENvbHVtbnMsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5UeXBlczogX2ZuQ29sdW1uVHlwZXMsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5BcHBseUNvbHVtbkRlZnM6IF9mbkFwcGx5Q29sdW1uRGVmcyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkh1bmdhcmlhbk1hcDogX2ZuSHVuZ2FyaWFuTWFwLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbjogX2ZuQ2FtZWxUb0h1bmdhcmlhbixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkxhbmd1YWdlQ29tcGF0OiBfZm5MYW5ndWFnZUNvbXBhdCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkJyb3dzZXJEZXRlY3Q6IF9mbkJyb3dzZXJEZXRlY3QsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5BZGREYXRhOiBfZm5BZGREYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWRkVHI6IF9mbkFkZFRyLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuTm9kZVRvRGF0YUluZGV4OiBfZm5Ob2RlVG9EYXRhSW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Ob2RlVG9Db2x1bW5JbmRleDogX2ZuTm9kZVRvQ29sdW1uSW5kZXgsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5HZXRDZWxsRGF0YTogX2ZuR2V0Q2VsbERhdGEsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5TZXRDZWxsRGF0YTogX2ZuU2V0Q2VsbERhdGEsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5TcGxpdE9iak5vdGF0aW9uOiBfZm5TcGxpdE9iak5vdGF0aW9uLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuR2V0T2JqZWN0RGF0YUZuOiBfZm5HZXRPYmplY3REYXRhRm4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5TZXRPYmplY3REYXRhRm46IF9mblNldE9iamVjdERhdGFGbixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkdldERhdGFNYXN0ZXI6IF9mbkdldERhdGFNYXN0ZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DbGVhclRhYmxlOiBfZm5DbGVhclRhYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRGVsZXRlSW5kZXg6IF9mbkRlbGV0ZUluZGV4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuSW52YWxpZGF0ZTogX2ZuSW52YWxpZGF0ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkdldFJvd0VsZW1lbnRzOiBfZm5HZXRSb3dFbGVtZW50cyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkNyZWF0ZVRyOiBfZm5DcmVhdGVUcixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkJ1aWxkSGVhZDogX2ZuQnVpbGRIZWFkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRHJhd0hlYWQ6IF9mbkRyYXdIZWFkLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRHJhdzogX2ZuRHJhdyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblJlRHJhdzogX2ZuUmVEcmF3LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQWRkT3B0aW9uc0h0bWw6IF9mbkFkZE9wdGlvbnNIdG1sLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRGV0ZWN0SGVhZGVyOiBfZm5EZXRlY3RIZWFkZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5HZXRVbmlxdWVUaHM6IF9mbkdldFVuaXF1ZVRocyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sRmlsdGVyOiBfZm5GZWF0dXJlSHRtbEZpbHRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckNvbXBsZXRlOiBfZm5GaWx0ZXJDb21wbGV0ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckN1c3RvbTogX2ZuRmlsdGVyQ3VzdG9tLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ29sdW1uOiBfZm5GaWx0ZXJDb2x1bW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXI6IF9mbkZpbHRlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckNyZWF0ZVNlYXJjaDogX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRXNjYXBlUmVnZXg6IF9mbkVzY2FwZVJlZ2V4LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmlsdGVyRGF0YTogX2ZuRmlsdGVyRGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sSW5mbzogX2ZuRmVhdHVyZUh0bWxJbmZvLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuVXBkYXRlSW5mbzogX2ZuVXBkYXRlSW5mbyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkluZm9NYWNyb3M6IF9mbkluZm9NYWNyb3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Jbml0aWFsaXNlOiBfZm5Jbml0aWFsaXNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdENvbXBsZXRlOiBfZm5Jbml0Q29tcGxldGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5MZW5ndGhDaGFuZ2U6IF9mbkxlbmd0aENoYW5nZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sTGVuZ3RoOiBfZm5GZWF0dXJlSHRtbExlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sUGFnaW5hdGU6IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5QYWdlQ2hhbmdlOiBfZm5QYWdlQ2hhbmdlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxQcm9jZXNzaW5nOiBfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheTogX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5GZWF0dXJlSHRtbFRhYmxlOiBfZm5GZWF0dXJlSHRtbFRhYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuU2Nyb2xsRHJhdzogX2ZuU2Nyb2xsRHJhdyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbjogX2ZuQXBwbHlUb0NoaWxkcmVuLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsY3VsYXRlQ29sdW1uV2lkdGhzOiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5UaHJvdHRsZTogX2ZuVGhyb3R0bGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Db252ZXJ0VG9XaWR0aDogX2ZuQ29udmVydFRvV2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5TY3JvbGxpbmdXaWR0aEFkanVzdDogX2ZuU2Nyb2xsaW5nV2lkdGhBZGp1c3QsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5HZXRXaWRlc3ROb2RlOiBfZm5HZXRXaWRlc3ROb2RlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuR2V0TWF4TGVuU3RyaW5nOiBfZm5HZXRNYXhMZW5TdHJpbmcsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5TdHJpbmdUb0NzczogX2ZuU3RyaW5nVG9Dc3MsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5TY3JvbGxCYXJXaWR0aDogX2ZuU2Nyb2xsQmFyV2lkdGgsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0RmxhdHRlbjogX2ZuU29ydEZsYXR0ZW4sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0OiBfZm5Tb3J0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuU29ydEFyaWE6IF9mblNvcnRBcmlhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuU29ydExpc3RlbmVyOiBfZm5Tb3J0TGlzdGVuZXIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0QXR0YWNoTGlzdGVuZXI6IF9mblNvcnRBdHRhY2hMaXN0ZW5lcixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNvcnRpbmdDbGFzc2VzOiBfZm5Tb3J0aW5nQ2xhc3NlcyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNvcnREYXRhOiBfZm5Tb3J0RGF0YSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblNhdmVTdGF0ZTogX2ZuU2F2ZVN0YXRlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuTG9hZFN0YXRlOiBfZm5Mb2FkU3RhdGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5TZXR0aW5nc0Zyb21Ob2RlOiBfZm5TZXR0aW5nc0Zyb21Ob2RlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuTG9nOiBfZm5Mb2csXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5NYXA6IF9mbk1hcCxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkJpbmRBY3Rpb246IF9mbkJpbmRBY3Rpb24sXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZzogX2ZuQ2FsbGJhY2tSZWcsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmU6IF9mbkNhbGxiYWNrRmlyZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkxlbmd0aE92ZXJmbG93OiBfZm5MZW5ndGhPdmVyZmxvdyxcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mblJlbmRlcmVyOiBfZm5SZW5kZXJlcixcclxuXHQgICAgICAgICAgICAgICAgICAgIF9mbkRhdGFTb3VyY2U6IF9mbkRhdGFTb3VyY2UsXHJcblx0ICAgICAgICAgICAgICAgICAgICBfZm5Sb3dBdHRyaWJ1dGVzOiBfZm5Sb3dBdHRyaWJ1dGVzLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsY3VsYXRlRW5kOiBmdW5jdGlvbiAoKSB7IH0gLy8gVXNlZCBieSBhIGxvdCBvZiBwbHVnLWlucywgYnV0IHJlZHVuZGFudFxyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gaW4gMS4xMCwgc28gdGhpcyBkZWFkLWVuZCBmdW5jdGlvbiBpc1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gYWRkZWQgdG8gcHJldmVudCBlcnJvcnNcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8galF1ZXJ5IGFjY2Vzc1xyXG5cdCAgICAgICAgICAgICAgICAkLmZuLmRhdGFUYWJsZSA9IERhdGFUYWJsZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBhbGlhc2VzXHJcblx0ICAgICAgICAgICAgICAgICQuZm4uZGF0YVRhYmxlU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XHJcblx0ICAgICAgICAgICAgICAgICQuZm4uZGF0YVRhYmxlRXh0ID0gRGF0YVRhYmxlLmV4dDtcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIFdpdGggYSBjYXBpdGFsIGBEYCB3ZSByZXR1cm4gYSBEYXRhVGFibGVzIEFQSSBpbnN0YW5jZSByYXRoZXIgdGhhbiBhXHJcblx0ICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgJC5mbi5EYXRhVGFibGUgPSBmdW5jdGlvbiAob3B0cykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZGF0YVRhYmxlKG9wdHMpLmFwaSgpO1xyXG5cdCAgICAgICAgICAgICAgICB9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gQWxsIHByb3BlcnRpZXMgdGhhdCBhcmUgYXZhaWxhYmxlIHRvICQuZm4uZGF0YVRhYmxlIHNob3VsZCBhbHNvIGJlXHJcblx0ICAgICAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBvbiAkLmZuLkRhdGFUYWJsZVxyXG5cdCAgICAgICAgICAgICAgICAkLmVhY2goRGF0YVRhYmxlLCBmdW5jdGlvbiAocHJvcCwgdmFsKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAkLmZuLkRhdGFUYWJsZVtwcm9wXSA9IHZhbDtcclxuXHQgICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgZXZlbnRzIGZpcmVkIGJ5IERhdGFUYWJsZXMgLSBmb3IgZG9jdW1lbnRhdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIERyYXcgZXZlbnQsIGZpcmVkIHdoZW5ldmVyIHRoZSB0YWJsZSBpcyByZWRyYXduIG9uIHRoZSBwYWdlLCBhdCB0aGUgc2FtZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBwb2ludCBhcyBmbkRyYXdDYWxsYmFjay4gVGhpcyBtYXkgYmUgdXNlZnVsIGZvciBiaW5kaW5nIGV2ZW50cyBvclxyXG5cdCAgICAgICAgICAgICAgICAgKiBwZXJmb3JtaW5nIGNhbGN1bGF0aW9ucyB3aGVuIHRoZSB0YWJsZSBpcyBhbHRlcmVkIGF0IGFsbC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNkcmF3LmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBTZWFyY2ggZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHNlYXJjaGluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAodXNpbmcgdGhlXHJcblx0ICAgICAgICAgICAgICAgICAqIGJ1aWx0LWluIGdsb2JhbCBzZWFyY2gsIG9yIGNvbHVtbiBmaWx0ZXJzKSBpcyBhbHRlcmVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI3NlYXJjaC5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUGFnZSBjaGFuZ2UgZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHBhZ2luZyBvZiB0aGUgdGFibGUgaXMgYWx0ZXJlZC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNwYWdlLmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBPcmRlciBldmVudCwgZmlyZWQgd2hlbiB0aGUgb3JkZXJpbmcgYXBwbGllZCB0byB0aGUgdGFibGUgaXMgYWx0ZXJlZC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNvcmRlci5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvbiBjb21wbGV0ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgZnVsbHlcclxuXHQgICAgICAgICAgICAgICAgICogZHJhd24sIGluY2x1ZGluZyBBamF4IGRhdGEgbG9hZGVkLCBpZiBBamF4IGRhdGEgaXMgcmVxdWlyZWQuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjaW5pdC5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcclxuXHQgICAgICAgICAgICAgICAgICogICAgcHJlc2VudCBpZiBjbGllbnQtc2lkZSBBamF4IHNvdXJjZWQgZGF0YSBpcyB1c2VkPC9saT48L29sPlxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBTdGF0ZSBzYXZlIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBoYXMgY2hhbmdlZCBzdGF0ZSBhIG5ldyBzdGF0ZSBzYXZlXHJcblx0ICAgICAgICAgICAgICAgICAqIGlzIHJlcXVpcmVkLiBUaGlzIGV2ZW50IGFsbG93cyBtb2RpZmljYXRpb24gb2YgdGhlIHN0YXRlIHNhdmluZyBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogcHJpb3IgdG8gYWN0dWFsbHkgZG9pbmcgdGhlIHNhdmUsIGluY2x1ZGluZyBhZGRpdGlvbiBvciBvdGhlciBzdGF0ZVxyXG5cdCAgICAgICAgICAgICAgICAgKiBwcm9wZXJ0aWVzIChmb3IgcGx1Zy1pbnMpIG9yIG1vZGlmaWNhdGlvbiBvZiBhIERhdGFUYWJsZXMgY29yZSBwcm9wZXJ0eS5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZVNhdmVQYXJhbXMuZHRcclxuXHQgICAgICAgICAgICAgICAgICogIEBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc3RhdGUgaW5mb3JtYXRpb24gdG8gYmUgc2F2ZWRcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogU3RhdGUgbG9hZCBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgbG9hZGluZyBzdGF0ZSBmcm9tIHRoZSBzdG9yZWRcclxuXHQgICAgICAgICAgICAgICAgICogZGF0YSwgYnV0IHByaW9yIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgYmVpbmcgbW9kaWZpZWQgYnkgdGhlIHNhdmVkIHN0YXRlXHJcblx0ICAgICAgICAgICAgICAgICAqIC0gYWxsb3dpbmcgbW9kaWZpY2F0aW9uIG9mIHRoZSBzYXZlZCBzdGF0ZSBpcyByZXF1aXJlZCBvciBsb2FkaW5nIG9mXHJcblx0ICAgICAgICAgICAgICAgICAqIHN0YXRlIGZvciBhIHBsdWctaW4uXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVMb2FkUGFyYW1zLmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uXHJcblx0ICAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICAgICAqIFN0YXRlIGxvYWRlZCBldmVudCwgZmlyZWQgd2hlbiBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSBzdG9yZWQgZGF0YSBhbmRcclxuXHQgICAgICAgICAgICAgICAgICogdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBieSB0aGUgbG9hZGVkIGRhdGEuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVMb2FkZWQuZHRcclxuXHQgICAgICAgICAgICAgICAgICogIEBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUHJvY2Vzc2luZyBldmVudCwgZmlyZWQgd2hlbiBEYXRhVGFibGVzIGlzIGRvaW5nIHNvbWUga2luZCBvZiBwcm9jZXNzaW5nXHJcblx0ICAgICAgICAgICAgICAgICAqIChiZSBpdCwgb3JkZXIsIHNlYXJjZyBvciBhbnl0aGluZyBlbHNlKS4gSXQgY2FuIGJlIHVzZWQgdG8gaW5kaWNhdGUgdG9cclxuXHQgICAgICAgICAgICAgICAgICogdGhlIGVuZCB1c2VyIHRoYXQgdGhlcmUgaXMgc29tZXRoaW5nIGhhcHBlbmluZywgb3IgdGhhdCBzb21ldGhpbmcgaGFzXHJcblx0ICAgICAgICAgICAgICAgICAqIGZpbmlzaGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI3Byb2Nlc3NpbmcuZHRcclxuXHQgICAgICAgICAgICAgICAgICogIEBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IGJTaG93IEZsYWcgZm9yIGlmIERhdGFUYWJsZXMgaXMgZG9pbmcgcHJvY2Vzc2luZyBvciBub3RcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQWpheCAoWEhSKSBldmVudCwgZmlyZWQgd2hlbmV2ZXIgYW4gQWpheCByZXF1ZXN0IGlzIGNvbXBsZXRlZCBmcm9tIGFcclxuXHQgICAgICAgICAgICAgICAgICogcmVxdWVzdCB0byBtYWRlIHRvIHRoZSBzZXJ2ZXIgZm9yIG5ldyBkYXRhLiBUaGlzIGV2ZW50IGlzIGNhbGxlZCBiZWZvcmVcclxuXHQgICAgICAgICAgICAgICAgICogRGF0YVRhYmxlcyBwcm9jZXNzZWQgdGhlIHJldHVybmVkIGRhdGEsIHNvIGl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJlLVxyXG5cdCAgICAgICAgICAgICAgICAgKiBwcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciwgaWYgbmVlZGVkLlxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyB0cmlnZ2VyIGlzIGNhbGxlZCBpbiBgZm5TZXJ2ZXJEYXRhYCwgaWYgeW91IG92ZXJyaWRlXHJcblx0ICAgICAgICAgICAgICAgICAqIGBmblNlcnZlckRhdGFgIGFuZCB3aGljaCB0byB1c2UgdGhpcyBldmVudCwgeW91IG5lZWQgdG8gdHJpZ2dlciBpdCBpbiB5b3VcclxuXHQgICAgICAgICAgICAgICAgICogc3VjY2VzcyBmdW5jdGlvbi5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSN4aHIuZHRcclxuXHQgICAgICAgICAgICAgICAgICogIEBldmVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxyXG5cdCAgICAgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgICAgICogICAgIC8vIFVzZSBhIGN1c3RvbSBwcm9wZXJ0eSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgaW4gYW5vdGhlciBET00gZWxlbWVudFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgJCgnI3RhYmxlJykuZGF0YVRhYmxlKCkub24oJ3hoci5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAkKCcjc3RhdHVzJykuaHRtbCgganNvbi5zdGF0dXMgKTtcclxuXHQgICAgICAgICAgICAgICAgICogICAgIH0gKTtcclxuXHQgICAgICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICAgICAqICAgICAvLyBQcmUtcHJvY2VzcyB0aGUgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcclxuXHQgICAgICAgICAgICAgICAgICogICAgICQoJyN0YWJsZScpLmRhdGFUYWJsZSgpLm9uKCd4aHIuZHQnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGpzb24pIHtcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgZm9yICggdmFyIGk9MCwgaWVuPWpzb24uYWFEYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAgIGpzb24uYWFEYXRhW2ldLnN1bSA9IGpzb24uYWFEYXRhW2ldLm9uZSArIGpzb24uYWFEYXRhW2ldLnR3bztcclxuXHQgICAgICAgICAgICAgICAgICogICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgICAvLyBOb3RlIG5vIHJldHVybiAtIG1hbmlwdWxhdGUgdGhlIGRhdGEgZGlyZWN0bHkgaW4gdGhlIEpTT04gb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgICAgfSApO1xyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBEZXN0cm95IGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBEYXRhVGFibGUgaXMgZGVzdHJveWVkIGJ5IGNhbGxpbmcgZm5EZXN0cm95XHJcblx0ICAgICAgICAgICAgICAgICAqIG9yIHBhc3NpbmcgdGhlIGJEZXN0cm95OnRydWUgcGFyYW1ldGVyIGluIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QuIFRoaXNcclxuXHQgICAgICAgICAgICAgICAgICogY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIGJvdW5kIGV2ZW50cywgYWRkZWQgRE9NIG5vZGVzLCBldGMuXHJcblx0ICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjZGVzdHJveS5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogUGFnZSBsZW5ndGggY2hhbmdlIGV2ZW50LCBmaXJlZCB3aGVuIG51bWJlciBvZiByZWNvcmRzIHRvIHNob3cgb24gZWFjaFxyXG5cdCAgICAgICAgICAgICAgICAgKiBwYWdlICh0aGUgbGVuZ3RoKSBpcyBjaGFuZ2VkLlxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI2xlbmd0aC5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50ZWdlcn0gbGVuIE5ldyBsZW5ndGhcclxuXHQgICAgICAgICAgICAgICAgICovXHJcblxyXG5cdCAgICAgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgICAgICogQ29sdW1uIHNpemluZyBoYXMgY2hhbmdlZC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNjb2x1bW4tc2l6aW5nLmR0XHJcblx0ICAgICAgICAgICAgICAgICAqICBAZXZlbnRcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAgICAgKiBDb2x1bW4gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZC5cclxuXHQgICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNjb2x1bW4tdmlzaWJpbGl0eS5kdFxyXG5cdCAgICAgICAgICAgICAgICAgKiAgQGV2ZW50XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cclxuXHQgICAgICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2x1bW4gQ29sdW1uIGluZGV4XHJcblx0ICAgICAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IHZpcyBgZmFsc2VgIGlmIGNvbHVtbiBub3cgaGlkZGVuLCBvciBgdHJ1ZWAgaWYgdmlzaWJsZVxyXG5cdCAgICAgICAgICAgICAgICAgKi9cclxuXHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiAkLmZuLmRhdGFUYWJsZTtcclxuXHQgICAgICAgICAgICB9KSk7XHJcblxyXG5cdCAgICAgICAgfSh3aW5kb3csIGRvY3VtZW50KSk7XHJcblx0ICAgICAgICAgICAgICAgXHJcblx0ICAgIH0sXHJcblx0ICAgIFJ1bkRhdGFUYWJsZTogZnVuY3Rpb24gKENTU2lkc2VsZWN0b3IpIHtcclxuXHJcblx0ICAgICAgICB0aGlzLmpxdWVyeVRhYmxlSW5pdCgpO1xyXG5cclxuXHQgICAgICAgICQoQ1NTaWRzZWxlY3RvcikuRGF0YVRhYmxlKHtcclxuXHQgICAgICAgICAgICBcImxhbmd1YWdlXCI6IHN2bGFuZ3VhZ2VTZXR0aW5nc1xyXG5cdCAgICAgICAgfSk7XHJcblxyXG5cdCAgICB9XHJcblx0fVxyXG5cclxuXHRsZXQgc3ZsYW5ndWFnZVNldHRpbmdzID0ge1xyXG5cdCAgICBcInNFbXB0eVRhYmxlXCI6IFwiVGFiZWxsZW4gaW5uZWhcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjI5KSArIFwibGxlciBpbmdlbiBkYXRhXCIsXHJcblx0ICAgIFwic0luZm9cIjogXCJWaXNhciBfU1RBUlRfIHRpbGwgX0VORF8gYXYgdG90YWx0IF9UT1RBTF8gcmFkZXJcIixcclxuXHQgICAgXCJzSW5mb0VtcHR5XCI6IFwiVmlzYXIgMCB0aWxsIDAgYXYgdG90YWx0IDAgcmFkZXJcIixcclxuXHQgICAgXCJzSW5mb0ZpbHRlcmVkXCI6IFwiKGZpbHRyZXJhZGUgZnJcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjI5KSArIFwibiB0b3RhbHQgX01BWF8gcmFkZXIpXCIsXHJcblx0ICAgIFwic0luZm9Qb3N0Rml4XCI6IFwiXCIsXHJcblx0ICAgIFwic0luZm9UaG91c2FuZHNcIjogXCIgXCIsXHJcblx0ICAgIFwic0xlbmd0aE1lbnVcIjogXCJWaXNhIF9NRU5VXyByYWRlclwiLFxyXG5cdCAgICBcInNMb2FkaW5nUmVjb3Jkc1wiOiBcIkxhZGRhci4uLlwiLFxyXG5cdCAgICBcInNQcm9jZXNzaW5nXCI6IFwiQmVhcmJldGFyLi4uXCIsXHJcblx0ICAgIFwic1NlYXJjaFwiOiBcIlNcIiArIFN0cmluZy5mcm9tQ2hhckNvZGUoMjQ2KSArIFwiazpcIixcclxuXHQgICAgXCJzWmVyb1JlY29yZHNcIjogXCJIaXR0YWRlIGluZ2EgbWF0Y2hhbmRlIHJlc3VsdGF0XCIsXHJcblx0ICAgIFwib1BhZ2luYXRlXCI6IHtcclxuXHQgICAgICAgIFwic0ZpcnN0XCI6IFwiRlwiICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNDYpICsgXCJyc3RhXCIsXHJcblx0ICAgICAgICBcInNMYXN0XCI6IFwiU2lzdGFcIixcclxuXHQgICAgICAgIFwic05leHRcIjogXCJOXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDIyOCkgKyBcInN0YVwiLFxyXG5cdCAgICAgICAgXCJzUHJldmlvdXNcIjogXCJGXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI0NikgKyBcInJlZ1wiICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyMjkpICsgXCJlbmRlXCJcclxuXHQgICAgfSxcclxuXHQgICAgXCJvQXJpYVwiOiB7XHJcblx0ICAgICAgICBcInNTb3J0QXNjZW5kaW5nXCI6IFwiOiBha3RpdmVyYSBmXCIgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKDI0NikgKyBcInIgYXR0IHNvcnRlcmEga29sdW1uZW4gaSBzdGlnYW5kZSBvcmRuaW5nXCIsXHJcblx0ICAgICAgICBcInNTb3J0RGVzY2VuZGluZ1wiOiBcIjogYWt0aXZlcmEgZlwiICsgU3RyaW5nLmZyb21DaGFyQ29kZSgyNDYpICsgXCJyIGF0dCBzb3J0ZXJhIGtvbHVtbmVuIGkgZmFsbGFuZGUgb3JkbmluZ1wiXHJcblx0ICAgIH1cclxuXHR9O1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRsZXQgZmlsbG9iaiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblx0bGV0IGF1dG9jb21wbGV0ZW9iajIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cdGxldCBzZXJ2aWNlY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG5cdGxldCAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuY2FjaGVEb20oKTtcclxuXHQgICAgICAgIHRoaXMuYmluZEV2ZW50KCk7XHJcblx0ICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG5cdCAgICAgICAgLy9hdXRvY29tcGxldGVvYmoyLmluaXQoJyNiYl9hal9jdXJfdGl0bGUnKTtcclxuXHQgICAgfSxcclxuXHQgICAgY2FjaGVEb206IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuJGJvZHkgPSAkKCdib2R5Jyk7XHJcblx0ICAgICAgICB0aGlzLiRiYl9hal9hcHByb3ZlID0gJChcIi5iYl9hal9hcHByb3ZlXCIpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfbW9kYWxDb250YWluZXIgPSAkKFwiI2JiX2FqX21vZGFsQ29udGFpbmVyXCIpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfYm9rdGlwZm9ybXNhdmVkYXRhID0gJCgnI2JiX2FqX2Jva3RpcGZvcm1zYXZlZGF0YScpO1xyXG5cdCAgICAgICAgdGhpcy4kYmJfYWpfY3VyX3RpdGxlPSAkKFwiI2JiX2FqX2N1cl90aXRsZVwiKTtcclxuXHQgICAgfSxcclxuXHQgICAgYmluZEV2ZW50OiBmdW5jdGlvbiAodXNlcmlkKSB7XHJcblx0ICAgICAgICBsZXQgdGhhdCA9IHRoaXM7ICAgICAgICBcclxuXHJcblx0ICAgICAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsICcuYmJfYWpfYXBwcm92ZScsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgbGV0IGlkID0gJCh0aGlzKS5hdHRyKCdkYXRhLXRpcGlkJyk7ICAgICAgICAgICAgXHJcblxyXG5cdCAgICAgICAgICAgIGZpbGxvYmouZ2V0Q3VycmVudEl0ZW0oaWQsIGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhhdC4kYmJfYWpfbW9kYWxDb250YWluZXIuc2hvdygpO1xyXG5cdCAgICAgICAgICAgICAgICBhdXRvY29tcGxldGVvYmoyLmluaXQoJyNiYl9hal9jdXJfdGl0bGUnKTtcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICB0aGlzLiRib2R5Lm9uKCdjbGljaycsICcuYmJfYWpfZGVsZXRlJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgaWQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtdGlwaWQnKTtcclxuXHQgICAgICAgICAgICBmaWxsb2JqLmRlbGV0ZWl0ZW1Cb3goaWQpO1xyXG5cdCAgICAgICAgICAgIHRoYXQuJGJiX2FqX21vZGFsQ29udGFpbmVyLnNob3coKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgICAgXHJcblx0ICAgICAgICB0aGlzLiRib2R5Lm9uKCdjaGFuZ2UnLCAnLmJiX2FqX3ZhbHRib2t0aXBzJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgaWQgPSAkKHRoaXMpLmF0dHIoJ2RhdGEtdGlwaWQnKTtcclxuXHQgICAgICAgICAgICBsZXQgdmFsID0gMDtcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBpZiAodGhpcy5jaGVja2VkKSB7XHJcblx0ICAgICAgICAgICAgICAgdmFsID0gMTsgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaWYgKHNlcnZpY2VjYWxsLmFwcHJvdmV0aXAoaWQsIHZhbCkpIHtcclxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhcHByb3ZlZCBqc29uXCIpO1xyXG5cdCAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICQodGhpcykudmFsKHRoaXMuY2hlY2tlZCk7IFxyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrJywgJyNiYl9hal9TYXZlRWRpdFRvU2VydmVyJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBsZXQgYmJfYWpfYm9rdGlwZm9ybXNhdmVkYXRhID0gJCgnI2JiX2FqX2Jva3RpcGZvcm1zYXZlZGF0YScpO1xyXG5cdCAgICAgICAgICAgIGxldCBiYl9hal9jdXJfdGl0bGUgPSAkKFwiI2JiX2FqX2N1cl90aXRsZVwiKTtcclxuXHJcblx0ICAgICAgICAgICAgbGV0IHNhdmVkYXRhID0ge1xyXG5cdCAgICAgICAgICAgICAgICBUaXBJRDogJCh0aGlzKS5hdHRyKCdkYXRhLXRpcGlkJyksXHJcblx0ICAgICAgICAgICAgICAgIFRpdGxlOiBiYl9hal9jdXJfdGl0bGUudmFsKCksXHJcblx0ICAgICAgICAgICAgICAgIExvd0FnZTogYmJfYWpfYm9rdGlwZm9ybXNhdmVkYXRhLmF0dHIoXCJkYXRhLWxvd1wiKSxcclxuXHQgICAgICAgICAgICAgICAgSGlnaEFnZTogYmJfYWpfYm9rdGlwZm9ybXNhdmVkYXRhLmF0dHIoXCJkYXRhLWhpZ2hcIiksXHJcblx0ICAgICAgICAgICAgICAgIENhdGVnb3J5OiBiYl9hal9ib2t0aXBmb3Jtc2F2ZWRhdGEuYXR0cihcImRhdGEtY2F0XCIpLFxyXG5cdCAgICAgICAgICAgICAgICBVc2VyaWQ6IGJiX2FqX2Jva3RpcGZvcm1zYXZlZGF0YS5hdHRyKFwiZGF0YS11c2VyaWRcIiksXHJcblx0ICAgICAgICAgICAgICAgIEJvb2tpZDogYmJfYWpfYm9rdGlwZm9ybXNhdmVkYXRhLmF0dHIoXCJkYXRhLWJvb2tpZFwiKSxcclxuXHQgICAgICAgICAgICAgICAgUmV2aWV3OiB0aW55TUNFLmFjdGl2ZUVkaXRvci5nZXRDb250ZW50KClcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChzYXZlZGF0YS5UaXRsZSAmJiBzYXZlZGF0YS5UaXBJRCA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgZmlsbG9iai5zYXZlaXRlbUJveChzYXZlZGF0YSk7XHJcblx0ICAgICAgICAgICAgICAgIHRoYXQuJGJiX2FqX21vZGFsQ29udGFpbmVyLnNob3coKTtcclxuXHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgYWxlcnQoXCJBbmdlIHRpdGVsIVwiKTtcclxuXHQgICAgICAgICAgICAgICAgYmJfYWpfY3VyX3RpdGxlLmZvY3VzKCk7XHJcblx0ICAgICAgICAgICAgfTsgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgdGhpcy4kYm9keS5vbignY2xpY2snLCAnLmJiX2FqX2Nsb3NlTW9kYWwnLCBmdW5jdGlvbiAoZSkge1xyXG5cdCAgICAgICAgICAgIHRoYXQuJGJiX2FqX21vZGFsQ29udGFpbmVyLmhpZGUoKTtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICB0aGlzLiRib2R5Lm9uKCdjaGFuZ2UnLCAnI2RycEJva3RpcFN1aXRhYmxlQWdlTWluJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgbWluYWdlID0gJCh0aGlzKS52YWwoKTtcclxuXHQgICAgICAgICAgICBsZXQgYmJfYWpfYm9rdGlwZm9ybXNhdmVkYXRhID0gJCgnI2JiX2FqX2Jva3RpcGZvcm1zYXZlZGF0YScpO1xyXG5cdCAgICAgICAgICAgIGJiX2FqX2Jva3RpcGZvcm1zYXZlZGF0YS5hdHRyKFwiZGF0YS1sb3dcIiwgbWluYWdlKTtcclxuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhtaW5hZ2UpO1xyXG5cdCAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgdGhpcy4kYm9keS5vbignY2hhbmdlJywgJyNkcnBCb2t0aXBTdWl0YWJsZUFnZU1heCcsIGZ1bmN0aW9uIChlKSB7XHJcblx0ICAgICAgICAgICAgbGV0IG1heGFnZSA9ICQodGhpcykudmFsKCk7XHJcblx0ICAgICAgICAgICAgbGV0IGJiX2FqX2Jva3RpcGZvcm1zYXZlZGF0YSA9ICQoJyNiYl9hal9ib2t0aXBmb3Jtc2F2ZWRhdGEnKTtcclxuXHQgICAgICAgICAgICBiYl9hal9ib2t0aXBmb3Jtc2F2ZWRhdGEuYXR0cihcImRhdGEtaGlnaFwiLCBtYXhhZ2UpO1xyXG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKG1heGFnZSk7XHJcblx0ICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICB0aGlzLiRib2R5Lm9uKCdjaGFuZ2UnLCAnI2RycEJva3RpcEFtbmVuJywgZnVuY3Rpb24gKGUpIHtcclxuXHQgICAgICAgICAgICBsZXQgY2F0ID0gJCh0aGlzKS52YWwoKTtcclxuXHQgICAgICAgICAgICBsZXQgYmJfYWpfYm9rdGlwZm9ybXNhdmVkYXRhID0gJCgnI2JiX2FqX2Jva3RpcGZvcm1zYXZlZGF0YScpO1xyXG5cdCAgICAgICAgICAgIGJiX2FqX2Jva3RpcGZvcm1zYXZlZGF0YS5hdHRyKFwiZGF0YS1jYXRcIiwgY2F0KTtcclxuXHQgICAgICAgICAgICBjb25zb2xlLmxvZyhjYXQpO1xyXG5cdCAgICAgICAgfSk7XHJcblx0ICAgICAgIFxyXG5cdCAgICB9LFxyXG5cdCAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0ICAgIH1cclxuXHR9XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGxldCBfaGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpXHJcblx0bGV0IGVkdCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcblx0bGV0IGFwcHNldHRpbmdzb2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHRsZXQgYXBwc2V0dGluZ3MgPSBhcHBzZXR0aW5nc29iamVjdC5jb25maWc7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBcclxuXHQgICAgZ2V0Q3VycmVudEl0ZW06IGZ1bmN0aW9uIChpZCxjYWxsYmFjaykge1xyXG5cdCAgICAgICAgbGV0IF9jdXJyZW50b2JqID0gYXBwc2V0dGluZ3MuZGF0YXNldC5jdXJyZW50ZGF0YWxpc3Q7XHJcblxyXG5cdCAgICAgICAgbGV0IGN1cnJvYmogPSBfY3VycmVudG9iai5Cb2t0aXBzLmZpbHRlcihpdGVtID0+IGl0ZW0uVGlwSUQgPT0gaWQpO1xyXG5cdCAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgIF9oaC5pbmplY3RodG1sdGVtcGxhdGUoXCIjYmJfYWpfbW9kYWxDb250YWluZXJcIiwgYXBwc2V0dGluZ3MuaGFuZGxlYmFydGVtcGxhdGUuaGJfZWRpdG9yX3RtcCwgY3Vycm9iaiwgZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIGVkdC5yZW1vdmUoKTtcclxuXHQgICAgICAgICAgICBlZHQuaW5pdChcIiNiYl9hal9tb2RhbGJvZHlcIik7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG5cdCAgICAgICAgfSk7ICAgICAgICAgICAgIFxyXG5cdCAgICB9LFxyXG5cdCAgICBzYXZlaXRlbUJveDogZnVuY3Rpb24gKHNhdmVPYmopIHsgICAgICAgIFxyXG5cdCAgICAgICAgYXBwc2V0dGluZ3MuZGF0YXNldC5zYXZlYm9rdGlwT2JqID0gc2F2ZU9iajtcclxuXHJcblx0ICAgICAgICBfaGguaW5qZWN0aHRtbHRlbXBsYXRlKFwiI2JiX2FqX21vZGFsQ29udGFpbmVyXCIsIGFwcHNldHRpbmdzLmhhbmRsZWJhcnRlbXBsYXRlLmhiX3NhdmVib3hfdG1wLCBzYXZlT2JqLCBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfSxcclxuXHQgICAgZGVsZXRlaXRlbUJveDogZnVuY3Rpb24gKHRpcGlkKSB7XHJcblx0ICAgICAgICBsZXQgb2JqID0geyBcIlRpcElEXCI6IHRpcGlkIH07XHJcblxyXG5cdCAgICAgICAgX2hoLmluamVjdGh0bWx0ZW1wbGF0ZShcIiNiYl9hal9tb2RhbENvbnRhaW5lclwiLCBhcHBzZXR0aW5ncy5oYW5kbGViYXJ0ZW1wbGF0ZS5oYl9kZWxib3hfdG1wLCBvYmosIGZ1bmN0aW9uICgpIHsgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH0pOyAgICBcclxuXHQgICAgfSxcclxuXHQgICAgZWRpdGNvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8vZWR0LmFjdGl2ZUVkaXRvci5nZXRDb250ZW50KCcnKTtcclxuXHQgICAgfSxcclxuXHJcblx0fSAvL2VuZCBtb2R1bGVleHBvcnRcclxuXG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGluamVjdGh0bWx0ZW1wbGF0ZTogZnVuY3Rpb24gKHRhcmdldENsYXNzLCB1c2V0ZW1wbGF0ZU5hbWUsIGN1cnJlbnRkYXRhLCBjYWxsYmFjaykge1xyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICAkLmdldCh1c2V0ZW1wbGF0ZU5hbWUsIGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRlbXB0cGwgPSBIYW5kbGViYXJzLmNvbXBpbGUoZGF0YSk7XHJcblx0ICAgICAgICAgICAgJCh0YXJnZXRDbGFzcykuaHRtbCh0ZW1wdHBsKGN1cnJlbnRkYXRhKSk7XHJcblx0ICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuXHQgICAgICAgIH0sICdodG1sJyk7XHJcblx0ICAgIH1cclxuXHR9XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBfZWRpdG9ybjogdGlueU1DRSxcclxuXHQgICAgaW5pdDogZnVuY3Rpb24gKENTU2lkc2VsZWN0b3IpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICB0aGlzLl9lZGl0b3JuLmluaXQoe1xyXG5cdCAgICAgICAgICAgIHNlbGVjdG9yOiBDU1NpZHNlbGVjdG9yLFxyXG5cdCAgICAgICAgICAgIG1lbnViYXI6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgIHRvb2xiYXI6ICd1bmRvIHJlZG8gfCBzdHlsZXNlbGVjdCB8IGJvbGQgaXRhbGljIHwgbGluayBpbWFnZSdcclxuXHQgICAgICAgIH0pO1xyXG5cclxuXHQgICAgfSwvL2VuZCBpbml0XHJcblx0ICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgdGhpcy5fZWRpdG9ybi5yZW1vdmUoKTtcclxuXHQgICAgfSxcclxuXHQgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIHRoaXMuX2VkaXRvcm4uYWN0aXZlRWRpdG9yLnNldENvbnRlbnQoJycpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBzZXRjb250ZW50OiBmdW5jdGlvbiAoY29udGVudCkge1xyXG5cdCAgICAgICAgdGhpcy5fZWRpdG9ybi5hY3RpdmVFZGl0b3Iuc2V0Q29udGVudChjb250ZW50KTtcclxuXHQgICAgfVxyXG5cdH0gLy9lbmQgbW9kdWxlZXhwb3J0XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBjb25maWc6IChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBsZXQgX2FwaXNlcnZlciA9IFwiaHR0cDovL2xvY2FsaG9zdDo1OTAxNVwiO1xyXG5cdCAgICAgICAgbGV0IF9kbm5VUkwgPSBcImh0dHA6Ly9sb2NhbGRldi5raXZkZXYuc2VcIjtcclxuXHQgICAgICAgIC8vbGV0IF9hcGlzZXJ2ZXIgPSBcImh0dHA6Ly9kZXYxLmJhcm5lbnNiaWJsaW90ZWsuc2U6ODA4MFwiO1xyXG5cdCAgICAgICAgLy9sZXQgX2RublVSTCA9IFwiaHR0cDovL2RldjEuYmFybmVuc2JpYmxpb3Rlay5zZVwiO1xyXG5cdCAgICAgICAgLy9sZXQgX2FwaXNlcnZlciA9IFwiaHR0cDovL2RldjEuYmFybmVuc2JpYmxpb3Rlay5zZTo4MDgwXCI7XHJcblx0ICAgICAgICAvL2xldCBfZG5uVVJMID0gXCJodHRwOi8vbnl0dC5iYXJuZW5zYmlibGlvdGVrLnNlXCI7XHJcblx0ICAgICAgICAvL2xldCBfYXBpc2VydmVyID0gXCJodHRwczovL3d3dzIuYmFybmVuc2JpYmxpb3Rlay5zZVwiO1xyXG5cdCAgICAgICAgLy9sZXQgX2RublVSTCA9IFwiaHR0cHM6Ly93d3cuYmFybmVuc2JpYmxpb3Rlay5zZVwiO1xyXG5cdCAgICAgICAgbGV0IF9kZXZrZXkgPSBcImFsZlwiO1xyXG5cdCAgICAgICAgbGV0IF9hcGlkZXZrZXllbmQgPSBcIi9kZXZrZXkvXCIgKyBfZGV2a2V5ICsgXCIvP3R5cGU9anNvbnAmY2FsbGJhY2s9P1wiO1xyXG5cdCAgICAgICAgbGV0IF9odG1sdGVtcGxhdGVVUkwgPSBcIi9EZXNrdG9wTW9kdWxlcy9iYl9hal9Cb2t0aXBzX0FkbWluL3RlbXBsYXRlL1wiOyAgICAgICAgXHJcblx0ICAgICAgICBsZXQgX2N1cnJlbnRkYXRhbGlzdDtcclxuXHQgICAgICAgIC8vLy8gdGVtcGxhdGVcclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgbGV0IF9oYl9ib29rdGlwTGlzdF90ZW1wbGF0ZSA9IF9odG1sdGVtcGxhdGVVUkwgKyBcInRlbXBsYXRlX2RhdGF0YWJsZVJvdy50eHRcIjsgICBcclxuXHQgICAgICAgIGxldCBfaGJfZWRpdG9yX3RlbXBsYXRlID0gX2h0bWx0ZW1wbGF0ZVVSTCArIFwidGVtcGxhdGVfZWRpdG9yLnR4dFwiOyBcclxuXHQgICAgICAgIGxldCBfaGJfc2F2ZWJveF90ZW1wbGF0ZSA9IF9odG1sdGVtcGxhdGVVUkwgKyBcInRlbXBsYXRlX3NhdmUudHh0XCI7XHJcblx0ICAgICAgICBsZXQgX2hiX2RlbGV0ZWJveF90ZW1wbGF0ZSA9IF9odG1sdGVtcGxhdGVVUkwgKyBcInRlbXBsYXRlX3RhYm9ydC50eHRcIjtcclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgLy8gYW52w6RuZGFyZW5zIHNlbmFzdGUgYm9rdGlwc1xyXG5cdCAgICAgICAgbGV0IF9mbl9ib29rdGlwTGlzdCA9IGZ1bmN0aW9uICh1c2VyaWQpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gX2FwaXNlcnZlciArIFwiL0FwaV92MS9ib2t0aXBzL2J5bGF0ZXN0LzEvZGV2a2V5L1wiICsgX2RldmtleSArIFwiLz90eXBlPWpzb25cIjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGxldCBfZm5fYm9va3RpcFNhdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIF9hcGlzZXJ2ZXIgKyBcIi9BcGlfdjMuMS9ib2t0aXBzL3R5cC9lZGl0Ym9rdGlwcy9kZXZrZXkvXCIgKyBfZGV2a2V5ICsgXCIvP3R5cGU9anNvbnBcIjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGxldCBfZm5fYm9va3RpcERlbGV0ZSA9IGZ1bmN0aW9uICgpIHsgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICByZXR1cm4gX2FwaXNlcnZlciArIFwiL0FwaV92My4xL2Jva3RpcHMvdHlwL2RlbGV0ZWJva3RpcHMvZGV2a2V5L1wiICsgX2RldmtleSArIFwiLz90eXBlPWpzb25cIjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGxldCBfZm5fYm9va3RpcEFwcHJvdmUgPSBmdW5jdGlvbiAodGlwaWQsIHZhbCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBfYXBpc2VydmVyICsgXCIvQXBpX3YzLjEvYm9rdGlwcy90eXAvYXBwcm92ZS92YWwvXCIgKyB0aXBpZCArIFwiL3R4dHZhbC9cIiArIHZhbCArIFwiL2RldmtleS9cIiArIF9kZXZrZXkgKyBcIi8/dHlwZT1qc29uXCI7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBsZXQgX2ZuX2Jvb2t0aXBMaXN0VG9BcHJvdmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIF9hcGlzZXJ2ZXIgKyBcIi9BcGlfdjMuMS9ib2t0aXBzL3R5cC90b2FwcHJvdmUvdmFsLzAvdHh0dmFsLzAvZGV2a2V5L1wiICsgX2RldmtleSArIFwiLz90eXBlPWpzb25cIjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGxldCBfZm5fYm9va3RpcExpc3RBbGwgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIF9hcGlzZXJ2ZXIgKyBcIi9BcGlfdjMuMS9ib2t0aXBzL3R5cC9nZXRhbGwvdmFsLzAvdHh0dmFsLzAvZGV2a2V5L1wiICsgX2RldmtleSArIFwiLz90eXBlPWpzb25cIjtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIC8vIGF1dG9jb21wbGV0ZVVSTFxyXG5cdCAgICAgICAgbGV0IF9mbl9hdXRvY29tcGxldGVVUkwgPSBmdW5jdGlvbiAoYW50YWwpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gX2FwaXNlcnZlciArIFwiL0FwaV92My4xL2thdGFsb2dlbi9jbWR0eXAvYXV0b2NvbXBsZXRlL2FudGFsL1wiICsgYW50YWwgKyBcIi9kZXZrZXkvXCIgKyBfZGV2a2V5ICsgXCIvP3R5cGU9anNvblwiO1xyXG5cdCAgICAgICAgfTtcclxuXHQgICAgICAgICAgIFxyXG5cdCAgICAgICAgcmV0dXJuIHtcclxuXHQgICAgICAgICAgICBhcGlzZXJ2ZXI6IF9hcGlzZXJ2ZXIsXHJcblx0ICAgICAgICAgICAgZG5uVVJMOiBfZG5uVVJMLFxyXG5cdCAgICAgICAgICAgIGh0bWx0ZW1wbGF0ZXVybDogX2RublVSTCArIF9odG1sdGVtcGxhdGVVUkwsXHJcblx0ICAgICAgICAgICAgZGV2a2V5OiBfZGV2a2V5LFxyXG5cdCAgICAgICAgICAgIGhhbmRsZWJhcnRlbXBsYXRlOiB7XHJcblx0ICAgICAgICAgICAgICAgIGhiX2Jvb2t0aXBMaXN0X3RtcDogX2hiX2Jvb2t0aXBMaXN0X3RlbXBsYXRlLFxyXG5cdCAgICAgICAgICAgICAgICBoYl9lZGl0b3JfdG1wOiBfaGJfZWRpdG9yX3RlbXBsYXRlLFxyXG5cdCAgICAgICAgICAgICAgICBoYl9zYXZlYm94X3RtcDogX2hiX3NhdmVib3hfdGVtcGxhdGUsXHJcblx0ICAgICAgICAgICAgICAgIGhiX2RlbGJveF90bXA6IF9oYl9kZWxldGVib3hfdGVtcGxhdGVcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGFwaTogeyAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICAgICAgYm9rdGlwc2xpc3Rvcjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0Ym9rdGlwc2xpc3RUb0FwcHJvdmU6IF9mbl9ib29rdGlwTGlzdFRvQXByb3ZlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0Ym9rdGlwc2xpc3RBbGw6IF9mbl9ib29rdGlwTGlzdEFsbFxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBhcHByb3ZlOiBfZm5fYm9va3RpcEFwcHJvdmUsXHJcblx0ICAgICAgICAgICAgICAgIHNhdmU6IF9mbl9ib29rdGlwU2F2ZSxcclxuXHQgICAgICAgICAgICAgICAgZGVsZXRlOiBfZm5fYm9va3RpcERlbGV0ZSxcclxuXHQgICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBnZXR1cmw6IF9mbl9hdXRvY29tcGxldGVVUkxcclxuXHQgICAgICAgICAgICAgICAgfSwgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgICAgIGRldmtleWVuZDogX2FwaWRldmtleWVuZFxyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgZGF0YXNldDoge1xyXG5cdCAgICAgICAgICAgICAgICBjdXJyZW50ZGF0YWxpc3Q6IF9jdXJyZW50ZGF0YWxpc3QsXHJcblx0ICAgICAgICAgICAgICAgIHNhdmVib2t0aXBPYmo6IHt9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgZGVidWc6IFwiZmFsc2VcIlxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KSgpLFxyXG5cdCAgICBcclxuXHR9XHJcblxyXG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cdHZhciBhcHBzZXR0aW5nc29iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcblx0dmFyIGFwcHNldHRpbmdzID0gYXBwc2V0dGluZ3NvYmplY3QuY29uZmlnO1xyXG5cclxuXHRtb2R1bGUuZXhwb3J0cyA9IHtcclxuXHQgICAgaW5pdDogZnVuY3Rpb24gKENvbnRyb2xJRCkge1xyXG5cdCAgICAgICAgbGV0IGF1dG9jb21wID0gbmV3IGF1dG9Db21wbGV0ZSh7XHJcblx0ICAgICAgICAgICAgc2VsZWN0b3I6IENvbnRyb2xJRCxcclxuXHQgICAgICAgICAgICBtaW5DaGFyczogMixcclxuXHQgICAgICAgICAgICBzb3VyY2U6IGZ1bmN0aW9uICh0ZXJtLCByZXNwb25zZSkge1xyXG5cdCAgICAgICAgICAgICAgICBsZXQgdXJsID0gYXBwc2V0dGluZ3MuYXBpLmF1dG9jb21wbGV0ZS5nZXR1cmw7XHJcblx0ICAgICAgICAgICAgICAgIGxldCB0ZXN0ID0gdXJsKDEwKTtcclxuXHQgICAgICAgICAgICAgICAgbGV0IHNlYXJjaGRhdGEgPSB7IFwiU2VhcmNoc3RyXCI6IHRlcm0gfTtcclxuXHQgICAgICAgICAgICAgICAgJC5hamF4KHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0XCIsXHJcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YTpzZWFyY2hkYXRhLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwoMTApLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3VnZ2VzdGlvbnMgPSBbXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEuQm9va0xpc3QsIGZ1bmN0aW9uIChpdGVtLCB2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goW3ZhbC5UaXRsZSx2YWwuQm9va2lkXSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlKHN1Z2dlc3Rpb25zKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgYWpheE9wdGlvbnMsIHRocm93bkVycm9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJOw6V0dCBibGV2IGZlbCB2aWQgaMOkbXRuaW5nIGF2IGFycmFuZ2VtYW5nIVwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfSlcclxuXHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICByZW5kZXJJdGVtOiBmdW5jdGlvbiAoaXRlbSwgc2VhcmNoKXtcclxuXHQgICAgICAgICAgICAgICAgLy9zZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XHJcblx0ICAgICAgICAgICAgICAgIC8vdmFyIHJlID0gbmV3IFJlZ0V4cChcIihcIiArIHNlYXJjaC5zcGxpdCgnICcpLmpvaW4oJ3wnKSArIFwiKVwiLCBcImdpXCIpO1xyXG5cdCAgICAgICAgICAgICAgICAvLyByZXR1cm4gJzxkaXYgY2xhc3M9XCJhdXRvY29tcGxldGUtc3VnZ2VzdGlvblwiIGRhdGEtYm9va2lkPVwiJyArIGl0ZW1bMV0gKyAnXCI+JyArIGl0ZW1bMF0ucmVwbGFjZShyZSwgXCI8Yj4kMTwvYj5cIikgKyAnPC9kaXY+JztcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwiYXV0b2NvbXBsZXRlLXN1Z2dlc3Rpb25cIiBkYXRhLWJvb2tpZD1cIicgKyBpdGVtWzFdICsgJ1wiPicgKyBpdGVtWzBdICsgJzwvZGl2Pic7XHJcblxyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIChlLCB0ZXJtLCBpdGVtKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICAgICAgJCgnI2JiX2FqX2N1cl90aXRsZScpLnZhbChpdGVtLmlubmVySFRNTCk7XHJcblx0ICAgICAgICAgICAgICAgICQoJy5iYl9hal9ib29raWQnKS5odG1sKGl0ZW0uZGF0YXNldC5ib29raWQpO1xyXG5cdCAgICAgICAgICAgICAgICAkKCcjYmJfYWpfYm9rdGlwZm9ybXNhdmVkYXRhJykuYXR0cihcImRhdGEtYm9va2lkXCIsIGl0ZW0uZGF0YXNldC5ib29raWQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9KTtcclxuXHQgICAgfVxyXG5cdH07XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRsZXQgX3NlcnZpY2Vfb2xkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblx0bGV0IF9zZXJ2aWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcblx0bGV0IGFwcHNldHRpbmdzb2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuXHRsZXQgYXBwc2V0dGluZ3MgPSBhcHBzZXR0aW5nc29iamVjdC5jb25maWc7XHJcblxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBhcHByb3ZldGlwOiBmdW5jdGlvbiAodGlwaWQsIHZhbCkge1xyXG5cdCAgICAgICAgbGV0IGpzb25kYXRhcHJvbWlzZSA9IF9zZXJ2aWNlLmdldGpzb25kYXRhKGFwcHNldHRpbmdzLmFwaS5hcHByb3ZlKHRpcGlkLCB2YWwpKTtcclxuXHJcblx0ICAgICAgICBqc29uZGF0YXByb21pc2VcclxuXHQgICAgICAgICAgICAudGhlbihqc29uZGF0YSA9PiB7IHJldHVybiB0cnVlOyB9KVxyXG5cdCAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gZmFsc2UpO1xyXG5cdCAgICB9LFxyXG5cdCAgICBkZWxldGV0aXA6IGZ1bmN0aW9uICh0aXBpZCwgY2FsbGJhY2spIHtcclxuXHQgICAgICAgIGxldCBkYXRhb3B0ID0geyAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgXCJUaXBJRFwiOiB0aXBpZFxyXG5cdCAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIF9zZXJ2aWNlX29sZC5wb3N0anNvbmRhdGEoYXBwc2V0dGluZ3MuYXBpLmRlbGV0ZSgpLCBkYXRhb3B0LCBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xyXG5cdCAgICAgICAgfSk7ICAgICAgXHJcblxyXG5cdCAgICB9LFxyXG5cdCAgICBzYXZldGlwOiBmdW5jdGlvbiAodGlwaWQsIHJ1YnJpaywgY29udGVudCwgY2FsbGJhY2spIHtcclxuXHQgICAgICAgIGxldCBkYXRhb3B0ID0gYXBwc2V0dGluZ3MuZGF0YXNldC5zYXZlYm9rdGlwT2JqO1xyXG5cclxuXHQgICAgICAgIGlmICh0aXBpZCA9PT0gZGF0YW9wdC5UaXBJRCkge1xyXG5cdCAgICAgICAgICAgIF9zZXJ2aWNlX29sZC5wb3N0anNvbmRhdGEoYXBwc2V0dGluZ3MuYXBpLnNhdmUoKSwgZGF0YW9wdCwgZnVuY3Rpb24gKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfVxyXG5cdH1cblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGdldGpzb25kYXRhOiBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaykge1xyXG5cdCAgICAgICAgaWYgKCF1cmwpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTZWFyY2hzZXJ2aWNlbiBow6RtdGFyIEFycmFuZ2VtYW5nZGF0YVwiKTtcclxuXHQgICAgICAgICAgICAkLmFqYXgoe1xyXG5cdCAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIixcclxuXHQgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29ucCcsXHJcblx0ICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG5cdCAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTZWFyY2ggRGV0YWxqIGFycmFuZ2VtYW5nIGjDpG10YXQ6IFwiKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKHhociwgYWpheE9wdGlvbnMsIHRocm93bkVycm9yKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBhbGVydChcIk7DpXR0IGJsZXYgZmVsIHZpZCBow6RtdG5pbmcgYXYgYXJyYW5nZW1hbmchXCIpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSlcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0sXHJcblx0ICAgIHBvc3Rqc29uZGF0YTogZnVuY3Rpb24gKHVybCwgcG9zdGRhdGEsIGNhbGxiYWNrKSB7XHJcblx0ICAgICAgICBpZiAoIXVybCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNlYXJjaHNlcnZpY2VuIGjDpG10YXIgQXJyYW5nZW1hbmdkYXRhXCIpO1xyXG5cdCAgICAgICAgICAgICQuYWpheCh7XHJcblx0ICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0XCIsXHJcblx0ICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG5cdCAgICAgICAgICAgICAgICBkYXRhOiBwb3N0ZGF0YSxcclxuXHQgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSMOkbXRhciBEYXRhOiBcIik7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIGFqYXhPcHRpb25zLCB0aHJvd25FcnJvcikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJOw6V0dCBibGV2IGZlbCB2aWQgaMOkbXRuaW5nIGF2IFBPU1QganNvbiFcIik7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9KVxyXG5cdCAgICAgICAgfTtcclxuXHQgICAgfVxyXG5cdH1cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdFxyXG5cdG1vZHVsZS5leHBvcnRzID0ge1xyXG5cdCAgICBnZXRqc29uZGF0YTogZnVuY3Rpb24gKHVybCkge1xyXG5cdCAgICAgICAgcmV0dXJuIGZldGNoKHVybClcclxuXHQgICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcclxuXHQgICAgICAgICAgICAudGhlbihqc29uZGF0YSA9PiBqc29uZGF0YSlcclxuXHQgICAgICAgICAgICBcclxuXHQgICAgfSxcclxuXHQgICAgcG9zdGpzb25kYXRhOiBmdW5jdGlvbiAodXJsLCBwb3N0ZGF0YSkge1xyXG5cclxuXHQgICAgICAgIGNvbnN0IG9wdGlvbiA9IHtcclxuXHQgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJywgXHJcblx0ICAgICAgICAgICAgbW9kZTpcIm5vLWNvcnNcIixcclxuXHQgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwb3N0ZGF0YSksXHJcblx0ICAgICAgICAgICAgaGVhZGVyczoge1xyXG5cdCAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb24pXHJcblx0ICAgICAgICAgICAgLnRoZW4ocmVzID0+IHJlcy5qc29uKCkpXHJcblx0ICAgICAgICAgICAgLnRoZW4oanNvbmRhdGEgPT4ganNvbmRhdGEpXHJcblxyXG5cdCAgICB9LFxyXG5cdCAgICBmZXRjaGpzb25wZGF0YTogZnVuY3Rpb24gKHVybCwgcG9zdGRhdGEpIHtcclxuXHQgICAgICAgIC8vcG9zdGRhdGE9IHsgZGF0YTogbWVkc2tpY2ssIG1lcmRhdGE6IG1lcmEgfVxyXG5cdCAgICAgICAgY29uc3Qgb3B0aW9uID0ge1xyXG5cdCAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG5cdCAgICAgICAgICAgIGhlYWRlcjogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG5cdCAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBvc3RkYXRhKVxyXG5cclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbilcclxuXHQgICAgICAgICAgICAudGhlbihyZXMgPT4gcmVzLnJlc3BvbnNlVGV4dCgpKVxyXG5cdCAgICAgICAgICAgIC50aGVuKGpzb25UZXh0ID0+IEpTT04ucGFyc2UoanNvblRleHQpKVxyXG5cclxuXHQgICAgfVxyXG5cdH1cclxuXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcclxuXHRsZXQgYXBwc2V0dGluZ3NvYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cdGxldCBhcHBzZXR0aW5ncyA9IGFwcHNldHRpbmdzb2JqZWN0LmNvbmZpZztcclxuXHJcblx0bW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0ICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0ICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdjaGVja2FwcHJvdmVkJywgZnVuY3Rpb24gKEFwcHJvdmUpIHsgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHQgICAgICAgICAgICBpZiAoQXBwcm92ZT09MSkge1xyXG5cdCAgICAgICAgICAgICAgIHJldHVybiAgXCJjaGVja2VkXCI7XHJcblx0ICAgICAgICAgICAgfTsgICAgICAgICAgICBcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcignZmlsbG9wdGlvbnMnLCBmdW5jdGlvbiAoc2VsKSB7XHJcblx0ICAgICAgICAgICAgbGV0IHJldG9wdCxpO1xyXG5cclxuXHQgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgMjA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoaSA9PSBzZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldG9wdCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiIHNlbGVjdGVkID4nICsgaSArICc8L29wdGlvbj4nO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0b3B0ICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCI+JyArIGkgKyAnPC9vcHRpb24+JztcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHJldG9wdDtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcignZmlsbGNhdCcsIGZ1bmN0aW9uIChzZWwpIHtcclxuXHQgICAgICAgICAgICBsZXQgcmV0b3B0LCBpO1xyXG5cclxuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMjM7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoaSA9PSBzZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJldG9wdCArPSAnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiIHNlbGVjdGVkID4nICsgaSArICc8L29wdGlvbj4nO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0b3B0ICs9ICc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCI+JyArIGkgKyAnPC9vcHRpb24+JztcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHJldG9wdDtcclxuXHQgICAgICAgIH0pO1xyXG5cdCAgICAgICBcclxuXHQgICAgfVxyXG5cdH1cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pOyJdfQ==
